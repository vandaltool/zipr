#---------------------------------------------------------------------
 2011 Canonical Ltd.
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  # Add jobs->event links to jobs which emit events that current job
    # Add links to events emitted by all jobs which current job
    # add those jobs which are referenced by existing jobs, but which
# a Graphviz DOT language (".dot") file for procesing with dot(1), etc.
#   all nodes be defined before being referenced.
# Author: James Hunt <james.hunt@canonical.com>
  'bang').replace(':', '_').replace('*', 'star').replace('?', 'question')
# but WITHOUT ANY WARRANTY; without even the implied warranty of
cmd = "initctl --system show-config -e"
      (cmd, os.uname()[1])
# -*- coding: utf-8 -*-
  color_bg=default_color_bg,
  color_event=default_color_event,
  color_event_text=default_color_text,
  color_job=default_color_job,
  color_job_text=default_color_text,
  color_start_on=default_color_start_on,
  color_stop_on=default_color_stop_on,
  color_text=default_color_text,
# contain dashes. Also remove dollars and colons
      continue
        continue
# Convert a dollar in @name to a unique-ish new name, based on @job and
# Copyright 
  # Create links from jobs (which advertise they emits a class of
      default_color_bg)
default_color_bg       = 'white'
      default_color_emits)
default_color_emits    = 'green'
      default_color_event)
default_color_event    = 'thistle'
      default_color_job)
default_color_job      = '#DCDCDC' # "Gainsboro"
      default_color_start_on)
default_color_start_on = 'blue'
      default_color_stop_on)
default_color_stop_on  = 'red'
      default_color_text)
default_color_text     = 'black'
default_outfile        = 'upstart.dot'
def encode_dollar(job, name):
def footer(ofh):
def header(ofh):
def main():
def mk_event_node_name(name):
def mk_job_node_name(name):
def mk_node_name(name):
def read_data():
def sanitise(s):
def show_edge(ofh, from_node, to_node, color):
def show_edges(ofh):
def show_event(ofh, name):
def show_events(ofh):
def show_job_emits_edge(ofh, from_job, to_event):
def show_job(ofh, name):
def show_jobs(ofh):
def show_start_on_event_edge(ofh, from_job, to_event):
def show_start_on_job_edge(ofh, from_job, to_job):
def show_stop_on_event_edge(ofh, from_job, to_event):
def show_stop_on_job_edge(ofh, from_job, to_job):
  description = "Convert initctl(8) output to GraphViz dot(1) format."
      dest="color_bg",
      dest="color_emits",
      dest="color_event",
      dest="color_event_text",
      dest="color_job",
      dest="color_job_text",
      dest="color_start_on",
      dest="color_stop_on",
      dest="color_text",
      dest="infile",
      dest="outfile",
      dest="restrictions",
# - dot(1).
#   dot -Tpng -o upstart.png upstart.dot
        else:
      else:
    else:
        emits           = {}
      # emmitted by those jobs in the restrictions_list that we
    epilog += "("
  epilog = \
  epilog += "Boxes of color %s denote jobs.\\n" % options.color_job
  epilog += "Dotted diamonds denote 'glob' events.\\n"
  epilog += "Emits denoted by %s lines.\\n" % options.color_emits
    epilog += "from file data).\\n"
    epilog += "from '%s' on host %s).\\n" % \
  epilog += "label=\"Generated on %s by %s\\n" % \
  epilog += "}\n"
  epilog += "\";\n"
  epilog = "overlap=false;\n"
  epilog += "Solid diamonds of color %s denote events.\\n" % options.color_event
  epilog += "Start on denoted by %s lines.\\n" % options.color_start_on
  epilog += "Stop on denoted by %s lines.\\n" % options.color_stop_on
    epilog += "(subset, "
        event = encode_dollar(job, event)
        _event = encode_dollar(job, result.group(1))
        event = (line.lstrip().split())[1]
events = {}
          events[_event] = 1
        events[event] = 1
  events_to_show = []
    events_to_show = events
          events_to_show += jobs[j]['emits']
      events_to_show += jobs[job]['emits']
      events_to_show += jobs[job]['start on']['event']
      events_to_show += jobs[job]['stop on']['event']
  # events, via the glob syntax) to all the events they create.
    except:
  # Finally, show all jobs which emit events that jobs in the
  footer(ofh)
        for _e in events:
  for e in events_to_show:
      for e in jobs[j]['emits']:
    for e in jobs[job]['emits']:
    for e in jobs[j]['start on']['event']:
    for e in jobs[j]['stop on']['event']:
    for ge in glob_jobs[g]:
  for g in glob_jobs:
      for j in jobs[job]['start on']['job']:
    for j in jobs[job]['start on']['job']:
      for j in jobs[job]['stop on']['job']:
    for j in jobs[job]['stop on']['job']:
  for j in jobs_to_show:
  for j in restrictions_list:
    for job in jobs[j]['start on']['job']:
    for job in jobs[j]['stop on']['job']:
  for job in jobs_list:
    for job in restrictions_list:
  for job in restrictions_list:
      for k in jobs:
  for line in ifh.readlines():
    for s in jobs[job]['start on']['event']:
    for s in jobs[job]['start on']['job']:
    for s in jobs[job]['stop on']['event']:
    for s in jobs[job]['stop on']['job']:
    for s in jobs[j]['start on']['job']:
    for s in jobs[j]['stop on']['job']:
from optparse import OptionParser
from string import split
from subprocess import (Popen, PIPE)
  global cmd
  global default_color_bg
  global default_color_emits
  global default_color_event
  global default_color_job
  global default_color_start_on
  global default_color_stop_on
  global default_color_text
  global events
  global job_events
  global jobs
    global options
  global options
  global restrictions_list
        glob_events = []
            glob_events.append(_e)
  glob_jobs = {}
        glob_jobs[job] = glob_events
# GNU General Public License for more details.
        # handle glob patterns in 'emits'
  # Having displayed the jobs in restrictions_list,
  header(ofh)
      help="File to read '%s' output from. If not specified, " \
      help="File to write output to (default=%s)" % default_outfile)
      help="Limit display of 'start on' and 'stop on' conditions to " +
      help="Specify background color for diagram (default=%s)." %
      help="Specify color for 'emits' lines (default=%s)." %
      help="Specify color for event boxes (default=%s)." %
      help="Specify color for job boxes (default=%s)." %
      help="Specify color for 'start on' lines (default=%s)." %
      help="Specify color for 'stop on' lines (default=%s)." %
      help="Specify color for summary text (default=%s)." %
      help="Specify color for text in event boxes (default=%s)." %
      help="Specify color for text in job boxes (default=%s)." %
# - http://www.graphviz.org.
          if e != _e and fnmatch.fnmatch(_e, e):
        if e in jobs[k]['emits']:
        if e in jobs[k]['emits'] and e not in restrictions_list:
      ifh = open(options.infile, 'r')
      ifh = Popen(split(cmd), stdout=PIPE).stdout
      if '*' in e:
    if '*' in name:
        if _job:
        if jobs.has_key(j) and jobs[j].has_key('emits'):
        if len(tokens) != 1:
  if name[0] == '$':
if __name__ == "__main__":
    if not job in jobs:
      if not jobs.has_key(j):
    if not restrictions_list:
  if not restrictions_list:
  if options.infile:
  if options.outfile == '-':
  if options.restrictions:
      if re.match('^\s+emits', line):
  if restrictions_list:
      if result:
      if s not in jobs_to_show:
import datetime
import fnmatch
import os
import re
import sys
#   initctl2dot -f initctl.out -o upstart.dot
#  initctl2dot -o - | dot -Tpng -o upstart.png
# - initctl(8).
#   initctl show-config -e > initctl.out
      "initctl will be run automatically." % cmd)
    # installed.
# it under the terms of the GNU General Public License version 2, as
job_events = [ 'starting', 'started', 'stopping', 'stopped' ]
        job_record      = {}
        job_record['emits']    = emits
        job_record['start on'] = start_on
        job_record['stop on']  = stop_on
        _job   = result.group(2)
jobs   = {}
# Jobs and events can have identical names, so prefix them to namespace
        jobs[job]['emits'][event] = 1
        jobs[job] = job_record
          jobs[job]['start on']['event'][_event] = 1
          jobs[job]['start on']['job'][_job] = 1
          jobs[job]['stop on']['event'][_event] = 1
          jobs[job]['stop on']['job'][_job] = 1
    jobs_list = jobs
    jobs_list = restrictions_list
    jobs_to_show = jobs
    jobs_to_show = restrictions_list
        job = (tokens)[0]
  'lbracket').replace(']', 'rbracket').replace('!', \
      line = line.rstrip()
# list of jobs to restict output to
  main()
  # make the default node an event to simplify glob code
# Map dash to underscore since graphviz node names cannot
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # might not be available as .conf files. For example, plymouth.conf
      (mk_event_node_name(name), name, options.color_event_text, options.color_event)
    mk_event_node_name(to_event), options.color_emits)
    mk_event_node_name(to_event), options.color_start_on)
    mk_event_node_name(to_event), options.color_stop_on)
    """ % (mk_job_node_name(name), name, options.color_job_text, options.color_job))
    name = job + ':' + name
# Notes:
      ofh = open(options.outfile, "w")
    ofh = sys.stdout
  ofh.write("""
  ofh.write(epilog)
  ofh.write("%s -> %s [color=\"%s\"];\n" % (from_node, to_node, color))
    ofh.write(str)
  ofh.write(str)
      # on.
  (options, args) = parser.parse_args()
    % (options.color_event_text, options.color_event)
# Or more simply:
  outfile=default_outfile)
  parser.add_option("--color-bg",
  parser.add_option("--color-emits",
  parser.add_option("--color-event",
  parser.add_option("--color-event-text",
  parser.add_option("--color-job",
  parser.add_option("--color-job-text",
  parser.add_option("--color-start-on",
  parser.add_option("--color-stop-on",
  parser.add_option("--color-text",
  parser.add_option("-f", "--infile",
  parser.add_option("-o", "--outfile",
  parser.add_option("-r", "--restrict-to-jobs",
  parser = OptionParser(description=description, epilog=epilog)
  parser.set_defaults(color_emits=default_color_emits,
# published by the Free Software Foundation.
  read_data()
      record = {}
    # references gdm *or* kdm, but you are unlikely to have both
restrictions_list = []
  # restrictions_list care about.
    restrictions_list = options.restrictions.split(",")
      # restrictions_list start/stop on. Finally, we want all events
      result = re.match('^\s+start on ([^,]+) \(job:\s*([^,]*), env:', line)
      result = re.match('^\s+stop on ([^,]+) \(job:\s*([^,]*), env:', line)
    return
# return it. Used for very rudimentary instance handling.
  return mk_node_name('event_' + name)
  return mk_node_name('job_' + name)
  return name
  return sanitise(name)
  return s.replace('-', '_').replace('$', 'dollar_').replace('[', \
script_name =  os.path.basename(sys.argv[0])
# Script to take output of "initctl show-config -e" and convert it into
# See also:
    "See http://www.graphviz.org/doc/info/colors.html for available colours."
  show_edge(ofh, "%s:job" % mk_job_node_name(from_job),
  show_edge(ofh, "%s:start" % mk_job_node_name(from_job),
  show_edge(ofh, "%s:stop" % mk_job_node_name(from_job),
  show_edges(ofh)
    show_event(ofh, e)
  show_events(ofh)
      show_job_emits_edge(ofh, g, ge)
        show_job_emits_edge(ofh, j, e)
      show_job_emits_edge(ofh, job, e)
          show_job_emits_edge(ofh, k, e)
    show_job(ofh, j)
      show_job(ofh, job)
          show_job(ofh, k)
        show_job(ofh, s)
  show_jobs(ofh)
      show_start_on_event_edge(ofh, job, s)
      show_start_on_job_edge(ofh, job, s)
      show_stop_on_event_edge(ofh, job, s)
      show_stop_on_job_edge(ofh, job, s)
    "%s:job" % mk_job_node_name(to_job), options.color_start_on)
    "%s:job" % mk_job_node_name(to_job), options.color_stop_on)
# - Slightly laborious logic used to satisfy graphviz requirement that
      "specified jobs (comma-separated list).")
    %s [shape=\"record\", label=\"<job> %s | { <start> start on | <stop> stop on }\", fontcolor=\"%s\", style=\"filled\", fillcolor=\"%s\"];
        start_on        = {}
        start_on_events = {}
        start_on['event']  = start_on_events
        start_on_jobs   = {}
        start_on['job']    = start_on_jobs
  # start on/stop on.
      # start/stop on.
    # start/stops on
  # start/stops on.
        stop_on         = {}
        stop_on_events  = {}
        stop_on['event']   = stop_on_events
        stop_on_jobs    = {}
        stop_on['job']     = stop_on_jobs
  str += "  bgcolor=\"%s\";\n" % options.color_bg
    (str(datetime.datetime.now()), script_name)
  str  = "digraph upstart {\n"
  str += "  fontcolor=\"%s\";\n" % options.color_text
    str += "];\n"
  str += "  node [shape=\"diamond\", fontcolor=\"%s\", fillcolor=\"%s\", style=\"filled\"];\n" \
  str += "  overlap=false;\n"
  str += "  rankdir=LR;\n"
    str = "%s [label=\"%s\", shape=diamond, fontcolor=\"%s\", fillcolor=\"%s\"," % \
      str += " style=\"dotted\""
      str += " style=\"filled\""
      sys.exit("ERROR: cannot open file %s for writing" % options.outfile)
      sys.exit("ERROR: cannot read file '%s'" % options.infile)
      sys.exit("ERROR: cannot run '%s'" % cmd)
          sys.exit("ERROR: invalid line: %s" % line.lstrip())
      sys.exit("ERROR: unknown job %s" % job)
# them off.
# This program is distributed in the hope that it will be useful,
# This program is free software; you can redistribute it and/or modify
        tokens = (line.lstrip().split())
    try:
# Usage:
#!/usr/bin/python
      # We also want all events emitted by all jobs that jobs in the
      # We also want all events that jobs in restrictions_list start/stop
  # we now need to display all jobs that *those* jobs
      # We want all events emitted by the jobs in the restrictions_list.
# with this program; if not, write to the Free Software Foundation, Inc.,
# You should have received a copy of the GNU General Public License along
