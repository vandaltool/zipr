                }
            }
        }
    $a = ($ckern * $ckern) + 1;
    #   Add masked image and shadow to obtain result, which this
#   adds attractive shadows to images, as often seen in titles
    $a =~ m/.*\sP[BGP]M\s.*,\s*(\d*)\sby\s(\d*)/;
    $a = `pnmfile $ifile`;
    #   Apply defaults for arguments not specified
        $arg = shift;
#            by John Walker  --  http://www.fourmilab.ch/
#  Change the path name in the line above to wherever Perl lives
            $ckern++;
    $ckern = $convolve <= 11 ? $convolve : 11;
    close(OF);
    $convolve = 11;                   # Default blur convolution kernel size
                    $convolve++;      # Round up even kernel specification
        #   Convolve the input colour image with the kernel
        #   Convolve the positive mask with the kernel to create shadow
    #   Create a blank background bitmap the size of the source bitmap
    #   Create convolution kernel file to generate shadow
    #   Create inverse mask
    #   Create offset shadow image
    #   Create positive mask file from input image
    #   Cut an offset rectangle from the shadow image
    #   Determine the size of the source image
                    die("Argument missing after -b option\n");
                    die("Argument missing after -x option\n");
    || die "Cant create tmpdir"; #219019
                die("Duplicate input file specification.");
#   *do* any image processing--it simply invokes components of
        } else {
    } else {
            } elsif ($opt eq 'k') {   # -K  --  Keep temporary files
            } elsif ($opt eq 't') {   # -T  --  Translucent image
            } elsif ($opt eq 'u' || $opt eq '?') {
            } elsif ($opt eq 'x') {   # -X n  --  X offset
            } elsif ($opt eq 'y') {   # -Y n  --  Y offset
                exit(0);
    for ($i = 0; $i < $ckern; $i++) {
        for ($j = 0; $j < $ckern; $j++) {
                if (($convolve < 11) && (($convolve & 1) == 0)) {
                if (!defined($convolve = shift)) {
            if (defined $ifile) {
    if ((!(defined $ifile)) || ($ifile eq '-')) {
                if (defined $version) {
    if (!(defined $xoffset)) {
                if (!defined($xoffset = shift)) {
    if (!(defined $yoffset)) {
                if (!defined($yoffset = shift)) {
            $ifile = $arg;            # Input file name
        $ifile = "$fname/0.ppm";
            if ($opt eq 'b') {        # -B n  --  Blur size
        if ((substr($arg, 0, 1) eq '-') && (length($arg) > 1)) {
    if ($translucent) {
                if ($xoffset < 0) {
                if ($yoffset < 0) {
#   image into a plausible result.
        #   Input default to standard input
    $i = $xsize - $xoffset;
#   Jef Poskanzer's PBMplus package (which must be present on
    $j = $ysize - $yoffset;
    #   last call on pnmarith sends to standard output.
#  level 36.
    #   Multiply original image by inverse mask
    #   Multiply shadow by mask
        #   Multiply the shadow by the background colour
my $fname = tempdir("PPMshadow.XXXXXXX", CLEANUP => $purge)
#   of World-Wide Web pages.  This program does not actually
#  on your system.  This script was tested with Perl 4.0, patch
    open(OF, ">$fname/2.ppm");
            $opt = substr($arg, 1, 1);
            $opt =~ tr/A-Z/a-z/;
#   Pnmshadow is a brutal sledgehammer implemented in Perl which
#                         P P M S H A D O W
            printf(OF "%d%s", $a, ($j < ($ckern - 1)) ? " " : "\n");
    printf(OF "P2\n$ckern $ckern\n%d\n", $ckern * $ckern * 2);
                print(STDERR "    -B n       Set blur size to n pixels\n");
                print(STDERR "    -K         Keep intermediate temporary files from run\n");
                print(STDERR "Options:\n");
                print(STDERR "ppmshadow  --  Add simulated shadow to anymap.\n");
                print(STDERR "    -T         Cast shadows of translucent objects\n");
                print(STDERR "    -U         Print this message\n");
                print(STDERR "Usage: ppmshadow [options] [pnmfile] \n");
                    print(STDERR "               Version $version.\n"); 
                print(STDERR "    -X n       Shift shadow n pixels to the right\n");
                print(STDERR "    -Y n       Shift shadow n pixels down\n");
    #   Process command line options
                $purge = 0;
    $purge = 1;                       # Set to 0 to preserve intermediate files
    $stdin = 0;
        $stdin = 1;
        system("cat >$fname/0.ppm");
            system("mv $fname/10a.ppm $fname/10.ppm");
            system("mv $fname/3a.ppm $fname/3.ppm");
    system("pnmarith -add $fname/8.ppm $fname/9.ppm");
    system("pnmarith -difference $ifile $fname/5.ppm | pnminvert | ppmtopgm | pgmtopbm -thresh -value 1.0 >$fname/1.ppm");
        system("pnmarith -multiply $fname/3.ppm $fname/5.ppm >$fname/10.ppm");
    system("pnmarith -multiply $fname/6.ppm $fname/1.ppm >$fname/9.ppm");
    system("pnmarith -multiply $ifile $fname/7.ppm >$fname/8.ppm");
        system("pnmconvol $fname/2.ppm $fname/1.ppm >$fname/3.ppm");
        system("pnmconvol $fname/2.ppm $ifile >$fname/10.ppm");
    system("pnmcut 0 0 1 1 $ifile | pnmscale -xsize $xsize -ysize $ysize >$fname/5.ppm");
    system("pnmcut 0 0 $i $j $fname/10.ppm >$fname/4.ppm");
    system("pnminvert $fname/1.ppm >$fname/7.ppm");
    system("pnmpaste -replace $fname/4.ppm $xoffset $yoffset $fname/5.ppm >$fname/6.ppm");
            system("pnmsmooth $fname/10.ppm >$fname/10a.ppm");
            system("pnmsmooth $fname/3.ppm >$fname/3a.ppm");
    # temporary files are automatically removed by tempdir
#   the path when this script is run) to bludgeon the source
#   the real John Walker work, named pnmshadow.
#               This program is in the public domain.
        #   to create a translucent shadow image.
    $translucent = 0;                 # Default not translucent
                $translucent = 1;
use File::Temp "tempdir";
#!/usr/bin/perl
                           $version = 1.2;
    while (@ARGV) {
        while ($ckern < $convolve) {
#   --> with minor changes by Bryan Henderson.  See above web site for
        #   Xoffset defaults to half the blur distance
        $xoffset = int($convolve / 2);
                    $xoffset = -$xoffset;
    $xsize = $1;
        #   Yoffset defaults to Xoffset, however specified
                    $yoffset = -$xoffset;
        $yoffset = $xoffset;
    $ysize = $2;
