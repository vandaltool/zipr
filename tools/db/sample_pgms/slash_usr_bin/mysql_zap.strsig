# along with this program; if not, write to the Free Software
	$ans = "n";
$ans = "y";
$BSD = -f '/vmunix' || $ENV{"OS"} eq "SunOS4";
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# Catch any errors with eval.  A bad pattern, for instance.
    chop($cand);
&cleanup;
# Configuration parameters.
# Copyright (c) 2000-2002, 2004, 2006 MySQL AB, 2009 Sun Microsystems, Inc.
    else
    else {
    elsif ($ARGV[0] eq "-a")
    elsif ($ARGV[0] eq "-?" || $ARGV[0] eq "-I" || $ARGV[0] eq "--help")
    } elsif ($ARGV[0] eq "-f") {
    } elsif ($ARGV[0] eq "-t") {
eval <<'EOF';
    exit;
    exit(1);
	for (1..5) {
    foreach $pat (@ARGV)
	    $found = 1 if $cand =~ $pat;
    $found = !@ARGV;
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
# GNU General Public License for more details.
    if ($ans =~ /^q/i) { last; }
    if ($ans =~ /^y/i) { &killpid($sig, $pid); }
    if ($ARGV[0] =~ /(ZERO|HUP|INT|QUIT|ILL|TRAP|ABRT|EMT|FPE|KILL|BUS|SEGV|SYS|PIPE|ALRM|TERM|URG|STOP|TSTP|CONT|CLD|TTIN|TTOU|IO|XCPU|XFSZ|VTALRM|PROF|WINCH|LOST|USR1|USR2)/ || $ARGV[0] =~ /-(\d+)$/) {
    if ($BSD) {
	    if (! ($cand =~ $pat))
If -f isn't given, ask user for confirmation for each process to kill.
	if ($opt_a)
    if ($opt_a) { $found = 1; }
if (!$opt_f)
    if (! $opt_f && ! $opt_t)
    if ($signal)
If signal isn't given, try first with signal 15, then with signal 9.
If -t is given, the processes are only shown on stdout.
# it under the terms of the GNU General Public License as published by
	kill 15, $pid;
	kill 9, $pid;
Kill processes that match the pattern.
	kill $signal,$pid;
$LINUX = $^O eq 'linux' || $^O eq 'darwin';
    local($signal,$pid) = @_;
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    next if (!$found);
    next if $pid == $$;
		next process;
# of MySQL.
open(PS, "$pscmd|") || die "can't run $pscmd: $!";
open(TTYIN, "</dev/tty") || die "can't read /dev/tty: $!";
open(TTYOUT, ">/dev/tty") || die "can't write /dev/tty: $!";
$opt_a = "";
	$opt_a = 1;
$opt_f= 0;
	$opt_f=1;
Options: -I or -? "info"  -f "force" -t "test".
$opt_t= 0;
	$opt_t=1;
    print <<EOF;
	print "kill -15\n";
	print "kill -9\n";
    print "\n";
	print "$pid will not die!\n";
	print STDERR "$0: illegal argument $ARGV[0] ignored\n";
	print TTYOUT "$cand? ";
	print TTYOUT "$cand\n";
	print TTYOUT "\n" if ($ans ne "\n");
print TTYOUT $title;
process: while ($cand = <PS>)
$pscmd = $BSD ? "/bin/ps -auxww" : $LINUX ? "/bin/ps axuw" : "/bin/ps -ef";
	read(TTYIN, $ans, 1);
	    return if kill(0, $pid) == 0;
select(STDOUT);
select(TTYOUT);
    shift;
	$sig = $1;
$sig = "";			# Default to try all signals
$SIG{'INT'} = 'cleanup';
	    sleep 2;
sub cleanup {
sub killpid {
sub usage {
	system "stty", 'cbreak',
	system "stty -cbreak </dev/tty >/dev/tty 2>&1";
	system "stty cbreak </dev/tty >/dev/tty 2>&1";
	system "stty", 'eol', '^@';
	system "stty", 'eol', '^A';
	system "stty", 'icanon';
# the Free Software Foundation; version 2 of the License.
# This is a utility for MySQL. It is not needed by any standard part
# This program is distributed in the hope that it will be useful,
# This program is free software; you can redistribute it and/or modify
$title = <PS>;
	&usage;
Usage:   $0 [-signal] [-?Ift] [--help] pattern
&usage if $#ARGV < 0;
# Usage: mysql_zap [-signal] [-f] [-t] pattern
# Use is subject to license terms.
    ($user, $pid) = split(' ', $cand);
#!/usr/bin/perl
Version 1.0
while ($#ARGV >= $[ && $ARGV[0] =~ /^-/) {
# You should have received a copy of the GNU General Public License
