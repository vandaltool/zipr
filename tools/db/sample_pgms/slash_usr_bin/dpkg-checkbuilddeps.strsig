 2001 Joey Hess <joeyh@debian.org>
# Additional parameters that must be passed:
  --admindir=<directory>
                'admindir=s' => \$admindir)) {
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# an list of the unsatisfied depends is returned.
# architecture.
# * A reference to a hash of all "ok installed" the packages on the system,
# * A reference to a hash, where the keys are package names, and the
# (at your option) any later version.
  -B             binary-only, ignore -Indep.
    $bc_value = $fields->{"Build-Conflicts"} if defined $fields->{"Build-Conflicts"};
	    $bc_value = $fields->{"Build-Conflicts-Indep"};
	    $bc_value .= ", " . $fields->{"Build-Conflicts-Indep"};
    $bd_value = 'build-essential';
    $bd_value .= ", " . $fields->{"Build-Depends"} if defined $fields->{"Build-Depends"};
	$bd_value .= ", " . $fields->{"Build-Depends-Indep"};
# but WITHOUT ANY WARRANTY; without even the implied warranty of
  -c build-conf  use given string for build conflicts instead of
                 change the administrative directory.
# checks for build conflicts, and returns a list of the packages
	chomp $host_arch;
	close STATUS;
"<control-file> is the control file to process (default: debian/control).")
# Copyright 
                'c=s' => \$bc_value,
  -d build-deps  use given string as build dependencies instead of
		$dep_list->simplify_deps($facts);
# deps, and 0 to check build conflicts.
		deps_parse($bc_value, reduce_arch => 1, union => 1), $facts);
		deps_parse($bd_value, reduce_arch => 1), $facts);
# dpkg-checkbuilddeps
                'd=s' => \$bd_value,
	} else {
		} else {
	} else { # Build-Conflicts
	    error(_g("error occurred while parsing %s"), $fieldname);
	exit(0);
exit 1 if @unmet || @conflicts;
	exit(2);
		$facts->add_installed_package($package, $version, $arch,
				$facts->add_provided_package($_->{package},
			foreach (grep { $_->isa('Dpkg::Deps::Simple') }
		foreach my $dep ($dep_list->get_deps()) {
# GNU General Public License for more details.
                'help|h' => sub { usage(); exit(0); },
  -h, --help     show this help message.
	if ($bc_value) {
if ($bc_value) {
if ($bd_value) {
	if ($build_depends) {
if (@conflicts) {
			if ($dep->get_evaluation($facts)) {
		if ($dep_list->is_empty()) {
if (!GetOptions('B' => \$binary_only,
    if (not $binary_only and defined $fields->{"Build-Conflicts-Indep"}) {
    if (not $binary_only and defined $fields->{"Build-Depends-Indep"}) {
		if (/^Provides: (.*)$/m) {
if (@unmet) {
# in as the 4th parameter. If not set, dpkg will be queried for the build
#   installed version.
# it under the terms of the GNU General Public License as published by
	local $/ = '';
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
		                              $multiarch);
		my ($arch) = /^Architecture: (.*)$/m;
my ($bd_value, $bc_value);
my $binary_only=0;
	my $build_depends=shift;
		my @conflicts = ();
my $control = Dpkg::Control::Info->new($controlfile);
my $controlfile = shift || "debian/control";
	my $dep_list=shift;
	my $facts = Dpkg::Deps::KnownFacts->new();
my $facts = parse_status("$admindir/status");
	my $facts=shift;
	my $fieldname=shift;
my $fields = $control->get_source();
	my $host_arch = shift || get_host_arch();
		my ($multiarch) = /^Multi-Arch: (.*)$/m;
		my ($package) = /^Package: (.*)$/m;
			my $provides = deps_parse($1, reduce_arch => 1, union => 1);
	my $status = shift;
	my @unmet=();
my (@unmet, @conflicts);
		my ($version) = /^Version: (.*)$/m;
			next if not defined $provides;
		next unless /^Status: .*ok installed$/m;
	. "\n\n" . _g(
	. "\n", $progname;
	open(STATUS, "<$status") || die "$status: $!\n";
# Optionally, the architecture the package is to be built for can be passed
"Options:
                                    $package);
# parameter. If they are satisfied, returns false. If they are unsatisfied,
	printf _g(
	printf(_g("Debian %s version %s.\n"), $progname, $version);
	printf STDERR _g("%s: Build conflicts: "), $progname;
	printf STDERR _g("%s: Unmet build dependencies: "), $progname;
	print STDERR join(" ", map { $_->output() } @conflicts), "\n";
	print STDERR join(" ", map { $_->output() } @unmet), "\n";
                                 $provides->get_deps())
	push @conflicts, build_conflicts('Build-Conflicts/Build-Conflicts-Indep',
				push @conflicts, $dep;
	push @unmet, build_depends('Build-Depends/Build-Depends-Indep)',
                                    $_->{relation}, $_->{version},
                 retrieving them from control file
			return ();
	return check_line(0, @_);
	return check_line(1, @_);
		return @conflicts;
			return $dep_list->get_deps();
	return $facts;
# Silly little status file parser that returns a Dpkg::Deps::KnownFacts
sub build_conflicts {
sub build_depends {
sub check_line {
sub parse_status {
sub usage {
sub version()
textdomain("dpkg-dev");
# that are installed and are conflicted with.
#   that package (all installed packages provide themselves)
# the Free Software Foundation; either version 2 of the License, or
# This function checks the build dependencies passed in as the first
# This function does all the work. The first parameter is 1 to check build
# This function is exactly like unmet_build_depends, except it
# This program is distributed in the hope that it will be useful,
# This program is free software; you can redistribute it and/or modify
unless (defined($bd_value) or defined($bc_value)) {
	unless(defined($dep_list)) {
	usage();
"Usage: %s [<option>...] [<control-file>]")
use Dpkg;
use Dpkg::Arch qw(get_host_arch);
use Dpkg::Control::Info;
use Dpkg::Deps;
use Dpkg::ErrorHandling;
use Dpkg::Gettext;
use Getopt::Long qw(:config posix_default bundling no_ignorecase);
use strict;
use warnings;
#!/usr/bin/perl
#   value is a true value iff some package installed on the system provides
      --version  show the version.")
                'version' => \&version,
	while (<STATUS>) {
#   with the hash key being the package name, and the value being the 
# You should have received a copy of the GNU General Public License
