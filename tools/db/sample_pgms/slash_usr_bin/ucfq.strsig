          }
        }
@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< @<<<<<<<<<<<<<<<<<< @|||   @|||
additional diagnostics from the script.
All class methods mediate access to class variables.  All class
along with this program; if not, write to the Free Software
#         already determined), if any
and remove objects, as well as an option to list all elements in the
an optional value argument. The value is returned.
any, if the file exists on disk, and whether it has been modfied by te
# arch-tag: 1390e09f-ee31-4d7f-a968-bd539ea061a0
#         arg)
arguments, and queries the on disk databases, determines of the files
associated with configuration files.
associated with the given package.  Takes the package name as a
associations registry.  It parses the data in the registry, and
(at your option) any later version.
Author: $main::Author <$main::AuthorMail>
# Author           : Manoj Srivastava ( srivasta@glaurung.internal.golden-gryphon.com ) 
  bless $self => $class;
B<StateDir>, and based on that, proceeds toparse the registry and
but WITHOUT ANY WARRANTY; without even the implied warranty of
          chomp;
      chomp;
        close NEWHASH;
      "Colons"   => 0,
compact colon-separated machine friendly format.
configuration file as a required parameter.
configuration file object names.  It provides methods to add, access,
Configuration file                            Package             Exists Changed
configuration files with B<ucf> using C<ucfr>.
Copyright (c) 2006 Manoj Srivastava <srivasta\@debian.org>
# Created On Node  : glaurung.internal.golden-gryphon.com
# Created On       : Wed Apr 12 14:51:16 2006
C<value> is present, updates the value of the attribute.  It also
C</var/lib/ucf>.  Used mostly for testing.
    *$datum = sub {
      "DEBUG"    => 0,
      'debug|d'        => sub {$::ConfOpts{"DEBUG"}+= "$_[1]";},
 --debug               Turn on debugging mode.
  # defaults.
     Defaults => 
                       default /var/lib/ucf.
  delete $this->{"List"}->{$name}
# Description      : 
developers version of the given file.  Takes the path of the
      die "Can't read registry file $params{StateDir}/hashfile:$!";
      die "Can't read registry file $params{StateDir}/registry:$!";
        die "Could not find /usr/bin/md5sum .\n";
          die "Could not run md5sum: $!";
  die "Missing required parameter Name"
  die "Missing required parameter StateDir"
dividers, headers, or footer.
    # Don't die for etch
during purge to query the system for configuration files that may
          else {
      else {
    else {
  else {
  # Ensure that if default parameters have not been set on the comman
exist, and have been modified.
    exit 0 unless m,^/,;
  for (keys %{$this->{configs}}) {
  for (keys %{$this->{Con_Ref}}) {
  for (keys %{$this->{packages}} ) {
format STDOUT =
format STDOUT_TOP =
  for my $datum (keys %Ucf ) {
  for my $default (keys %$defaults) {
    for my $file (@$pkg_files) {
  for my $file (sort $this->{file_list}->list) {
  for my $file ($this->{file_list}->list) {
  for my $option (keys %params) {
  for my $package ($this->{pkg_list}->list) {
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
given file.  Takes the path of the configuration file as a required
GNU General Public License for more details.
    hashfile->new("StateDir" => $this->{Con_Ref}->{StateDir});
hash of the configuration file.
=head1 AUTHOR
=head1 BUGS
=head1 CAVEATS
=head1 class conffile
=head1 Class hashfile
=head1 CLASS object_list
=head1 CLASS PKG
=head1 Class registry
=head1 Class ucf
=head1 COPYRIGHT AND LICENSE
=head1 DESCRIPTION
=head1 INTERNALS
=head1 NAME
=head1 OPTIONS
=head1 SYNOPSIS
=head2 Class Methods
=head2 conffile_exists
=head2 conffile_hash
=head2 conffile_modified
=head2 conffile_package
=head2 dump_config 
=head2 element
=head2 find_pkg
=head2 get_config_ref
=head2 hash
=head2 list
=head2 list_files
=head2 new
=head2 process
=head2 remove
=head2 report
=head2 validate
      'help|h'         => sub {print ucf->Usage();     exit 0;},
 --help                This message.
# HISTORY          : 
holds package name associated with the file.  If an optional C<value>
holds the hash for the developers version of the file.  If an optional
holds the information whether the file exists on disk or not.
holds the information whether the file exists on disk or not.  If an
    if (! defined $this->{Con_Ref}->{"$default"}) {
      if (! defined $this->{file_list}->element($file)) {
    if (! defined $this->{file_list}->element($file)->conffile_package) {
    if (-e "$name") {
  if (-e "$params{StateDir}/hashfile") {
  if (-e "$params{StateDir}/registry") {
      if (exists $self->{List}->{$pkg}) {
  if (exists $this->{Exists}) {
  if (exists $this->{Hash}) {
    if (exists $this->{"List"}->{$name} );
  if (exists $this->{"List"}->{$name}) {
  if (exists $this->{List}->{$pkg}) {
  if (exists $this->{Modified}) {
  if (exists $this->{Package}) {
  if (exists $this->{Packages}->{$file}) {
          if ("$hash" ne "$value") {
    if $params{Package};
    if (! -r "$params{StateDir}/hashfile") {
    if (! -r "$params{StateDir}/registry") {
    if ($this->{Con_Ref}->{Colons}) {
  if ($value ) {
  if ($value) {
      if (-x "/usr/bin/md5sum") {
information gathered during the processing. There are two kinds of
is present, updates the value of the attribute.
=item B<--debug> B<-d> Turn on debugging mode.
=item B<--help> B<h> Print out a usage message.
=item B<--state-dr> dir
=item B<--verbose> B<-v> Make the script more verbose..
=item B<--with-colons> B<-w>
it under the terms of the GNU General Public License as published by
# Last Machine Used: glaurung.internal.golden-gryphon.com
# Last Modified By : Manoj Srivastava
# Last Modified On : Fri Apr 14 19:30:45 2006
  # line on in the configuration file, if any, we use the built in
$main::AuthorMail  = "srivasta\@debian.org";
$main::Author      = "Manoj Srivastava";
($main::MYNAME     = $main::0) =~ s|.*/||;
  # Make sure runtime options override what we get from the config file
Manoj Srivastava <srivasta\@debian.org>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
methods can be invoked with zero or one parameters. When invoked with
#                              -*- Mode: Cperl -*- 
modified by the user -- assuming that the package registered all the
    my $class   = ref($obclass) || $obclass;
  my $class = ref($this) || $this;
  my $defaults = $this->Defaults();
    my $file = conffile->new('Name' => "$_");
  my $file      = shift;
          my ($hash, $dummy) = m/^(\S+)\s+(\S+)$/;
      my ($hash, $file) = m/^(\S+)\s+(\S+)$/;
  my $name      = shift;
    my $obclass = shift || __PACKAGE__;
  my $optdesc = ucf->Optdesc();
    my $package = pkg->new('Name' => "$_");
  my %params = @_;
  my %params   = @_;
  my $parser  = new Getopt::Long::Parser;
      my ($pkg, $file) = m/^(\S+)\s+(\S+)$/;
    my $pkg_files = $this->{registry_proxy}->list_files($package);
  my $pkg       = shift;
  my $query = ucf->new(%::ConfOpts);
        my $ret = conffile->new('Name' => "$file");
  my $self = {};
      my ($self, $newvalue) = @_;
  my $this = shift;
  my $this   = shift;
  my $this     = shift;
  my $this      = shift;
  my %Ucf = 
  my $value     = shift;
None Known so far.
Normally, the script presents the information in a human readable
    no strict "refs";
    no strict "refs";   # to convert sym ref to real one
notes whether or not the file is modified from the developers version.
    open (HASH, "$params{StateDir}/hashfile") || 
        open (NEWHASH, "/usr/bin/md5sum $name |") || 
    open (REG, "$params{StateDir}/registry") || 
     Optdesc  => 
optional C<value> is present, updates the value of the attribute.
options.
or the full path of the configuration file.
our ($out_pkg, $out_file, $there, $mod);
$out_file,                                    $out_pkg,           $there,$mod
    ($out_pkg, $out_file, $there, $mod) =
package conffile;
package hashfile;
package main;
package object_list;
package pkg;
package registry;
package ucf;
parameter.
parameters. If the parameter B<Colons> is present, then the output
  $parser->configure("bundling");
  $parser->getoptions (%$optdesc);
parses the data in the database, and provides methods to query the
path to a configuration file, and outputs the associated package, if
populate internal data structures.
(presumably from the command line) are given preference. 
      print "$out_file:$out_pkg:$there:$mod\n";
    print  "$_ = [${$this->{Con_Ref}}{$_}]\n"
provides methods to query the registry based either on package name,
        push @{$self->{List}->{$pkg}}, $file;
  $query->process;
  $query->report;
    registry->new("StateDir" => $this->{Con_Ref}->{StateDir});
Removes elements from the list.  Take in an required name, which is
reports, the first being a user friendly tabular form, the second
required parameter.
    return [];
  return [];
    return \%$class;
  return keys %{$this->{"List"}};
  return $self;
  return $this->{Con_Ref};
    return $this->{Exists};
  return $this->{$file};
    return $this->{Hash};
    return $this->{"List"}->{$name};
    return [ @{$this->{List}->{$pkg}} ];
    return $this->{Modified};
    return $this->{Package};
    return $this->{Packages}->{$file};
  return $this->{Package} ? $this->{Package} : "",
      return $Ucf{$datum};
    return undef;
{  # scope for ultra-private meta-object for class attributes
  $self->{Exists}  = 'Yes' if -e $self->{Name};
      $self->{$file} = $hash
  $self->{"List"} = ();
        $self->{List}->{$pkg} = [ $file ];
  $self->{Name} = $params{Name};
  $self->{Name}    = $params{Name};
  $self->{Package} = $params{Package}
      $self->{Packages}->{$file} = $pkg;
  $self->validate(%params);
Set the state directory to C</path/to/dir> instead of the default
# set the version and revision
 --state-dir </path/>  Set the state directory to /path/ instead of the
      'state-dir=s'    => sub {$::ConfOpts{"StateDir"}= "$_[1]";},
      "StateDir" => '/var/lib/ucf'
# Status           : Unknown, Use with caution!
# Step 1: Process all arguments in sequence.
# Step 2: determine if the arument given is a package name (no / in
# Step 3: If so, gather all files associated with the package
# Step 4: for all configuration files, determine package (unless
# Step 5: For each configuration file, check if it exists
# Step 6: For each existing file, see if it has been changed
still exist on the system, and whether these files have been locally
  sub _classobj {
sub conffile_exists {
sub conffile_hash {
sub conffile_modified {
sub conffile_package {
sub conffile_report {
sub dump_config {
sub element {
sub find_pkg {
sub get_config_ref {
sub hash {
sub list {
sub list_files {
sub main {
sub new {
sub process {
sub remove {
sub report {
sub validate{
tabular format, but that may be harder for a machine to parse. With
the Free Software Foundation; either version 2 of the License, or
the optional parameter, the class method sets the value of the
the user and the internal model classes.
  %{$this->{configs}}     = map { +"$_" => 1} grep {  m,/,} @ARGV;
      $this->{Con_Ref}->{"$default"} = $defaults->{"$default"};
    $this->{Con_Ref}->{"$option"} = $params{"$option"};
    $this->{file_list}->element($_, $file);
    $this->{file_list}->element($file)->conffile_hash($file, $this->{hashfile_proxy}->hash($file));
      $this->{file_list}->element($file)->conffile_package($package);
      $this->{file_list}->element($file)->conffile_package($this->{registry_proxy}->find_pkg($file));
      $this->{file_list}->element($file)->conffile_report;
        $this->{file_list}->element($file, $ret);
  $this->{file_list}      = object_list->new;
    $this->{$file} = $value;
  $this->{hashfile_proxy} = 
    $this->{Hash} = $value;
This is a clas which holds lists of object names, either packages or
This is a combination view and controller class that mediates between
This is an accessor method for elements of the list. If an optional
This is an encapsulation of package metadata.  Packages may be
This is the constructor for the class. It takes a number of optional
This is the constructor for the class.  It takes a required parameter
This is the constructor for the class. It takes no arguments.
This is the encapsulation of a configuration file metadata.
This is very inchoate, at the moment, and needs testing.
    $this->{"List"}->{$name} =  $value;
            $this->{Modified} = 'No';
      $this->{Modified}? $this->{Modified} : "";
    $this->{Modified} = $value;
            $this->{Modified} = 'Yes';
This moel class encapsulates the configuration file hash database.  It
This moel class encapsulates the package-configuration file
    $this->{Name}, $this->{Exists} ? $this->{Exists} : "",
this option, the output is a compact, colon separated line, with no
  %{$this->{packages}}    = map { +"$_" => 1} grep {! m,/,} @ARGV;
    $this->{Package} = $value;
    $this->{pkg_list}->element($_, $package);
  $this->{pkg_list}       = object_list->new;
This program is distributed in the hope that it will be useful,
This program is free software; you can redistribute it and / or modify
  $this->{registry_proxy} = 
This routine generates a nicely formatted report based on the
This routine is responsible for ensuring that the parameters passed in
This routine is the accessor method of the internal attribute that
This routine is the work horse routine -- it parses the command line
This routine lists all the elements in the list.  It does not take any
This routine queries the database for the hash associated with the
This routine queries the registry and lists all configuration files
This routine queries the registry for the package associated with the
This routine returns a C<Data::Dumper> for debugging purposes
This routine returns a reference to the configuration hash
This script can potentially be used in package C<postinst> scripts
This script is a part of the Ucf package, and is 
This script takes a set of arguments, each of which is a package or a
  # tri-natured: function, class method, or object method
(turned on by the C<-w> option) a easily parseable colon separated
      $Ucf{$datum} = $newvalue if @_ > 1;
# ucfq --- 
ucfq - query ucf registry and hashfile about configuration file details.
underlying class data.  In either case, the value of the underlying
      unless m,^/,;
    unless $name;
    unless $params{Name};
    unless $params{StateDir};
# Update Count     : 81
     Usage => qq(Usage: $main::MYNAME [options]
 usage: ucfq [options] (file|package)[file|package  ...]
used as the key for the element to delete.
use Getopt::Long;
user.  The output is either a human readable tabular form, or a
use strict;
      use strict "refs";
#!/usr/bin/perl
  # validate and sanitize the settings
value argument exists, it creates or updates the element associtated
variable is returned.
      "VERBOSE"  => 0,
 --verbose             Make the script more verbose.
      'verbose|v'      => sub {$::ConfOpts{"VERBOSE"}+= "$_[1]";}
    warn "Need a fully qualified path name for config file \"$_\"\n"
  where options are:
    while (<HASH>) {
        while (<NEWHASH>) {
    while (<REG>) {
will be compact. The parameters B<DEBUG> and B<VERBOSE> turn on
 --with-colons         A compact, machine readable version of the output.
      'with-colons|w!' => sub {$::ConfOpts{"Colons"}= "$_[1]";},
with the vaslue. Takes in a required name, which is used as a kay, and
      write;
You should have received a copy of the GNU General Public License
