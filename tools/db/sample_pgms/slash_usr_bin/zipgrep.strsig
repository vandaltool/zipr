     ) 3>&1 `
# and "-l" options internally.
# are specified explicitly.  The script attempts to handle egrep's "-h"
#!/bin/sh
             break;
  case "$1" in
case "$opt" in
  echo usage: `basename "$0"` "[egrep_options] pattern zipfile [members...]"
  echo Uses unzip and egrep to search the zip members for a string or pattern.
  -e | -f) opt="$opt $1"; shift; pat="$1";;
     egrep $opt "$pat"
     egrep $opt "$pat" 1>&4 ; echo $? >&3 ) 4>&1 | \
     egrep $opt "$pat" > /dev/null && echo "$i"
  elif test $silent -eq 1; then
           else
# Else, when "sts" is bad, exit with the worst status we can find.
    # Escape (or re-escape) shell-special characters in the archive
# Escape shell-special characters in "pat".
    exec 4>&1
  exit 1
    exit "$status_grep"
  exit $status_grep_global
    exit $sts
           fi;;
for i in `unzip -Z1 "$zipfile" ${1+"$@"} | sed -e 's/\\\\/\\\\\\\\/g' `; do
    # Globally, send fd 4 to stdout.  In the pipeline, send normal
    # "-h": Show only the matching line(s), not the archive member name.
  *h*) silent=1
    i=` echo "$i" | \
# If "sts" is good (0), then exit with the global grep status.
if test $# = 0; then
  if test $list -eq 1; then
if test -n "$opt"; then
  if test "$status_grep" -gt 1 ; then
if test $sts -eq 0 ; then
   *)      if test -z "$pat"; then
  # If this grep status was not zero or one, exit now.
  # If this grep status was zero, set the global grep status to zero.
  *l*) list=1; opt=`echo $opt | sed s/l//`
    # "-l": Show only the archive member name, not the matching line(s).
    # member name, "i".
opt=`echo "$opt" | sed -e 's/ //g' -e 's/-//g'`
  opt="-$opt"
  -*)      opt="$opt $1";;
             pat="$1"
pat=` echo "$pat" | \
# programs are on the user's PATH.
  # Save the primary command status.  (May be the grep status.)
     sed -e 's/\\\\/\\\\\\\\/g' -e 's/|/\\\|/g' -e 's/&/\\\&/g' `
 sed -e 's/\\\\/\\\\\\\\/g' -e 's/|/\\\|/g' -e 's/&/\\\&/g' `
     sed "s|^|${i}:|" 1>&4 \
silent=0
    # ("-s" in "opt" will silence "egrep", stopping all output.)
# specified archive.  Escape any backslashes in a file name.
    status_grep=` ( \
    status_grep=$?
status_grep_global=1
    # stdout to fd 4, and send grep status to fd 3.  Collect fd 3
  sts=$?
  test "$status_grep" -eq 0 && status_grep_global=0
  test "$status_grep" -gt 1 && exit "$status_grep"
# This script assumes that the desired "unzip" and "egrep" (and "sed")
     ( unzip -p-L "$zipfile" "$i" | \
    unzip -p-L "$zipfile" "$i" | \
# Use "unzip -Z1" to get a listing of the specified members from the
while test $# -ne 0; do
    # with ``.
# Zip archive for a string or pattern.  Search all members if no members
zipfile="$1"; shift
#    zipgrep: Use unzip and egrep to search the specified members of a
