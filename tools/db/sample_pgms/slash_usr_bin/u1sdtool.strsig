"""A command-line utility to interact with ubuntuone-syncdaemon."""
                      action='store_true',
                      action="store_true",
                      action='store_true', help="Disconnect the syncdaemon")
    bus = dbus.SessionBus(mainloop=loop)
    bus = None
# by the Free Software Foundation.
                        category=DeprecationWarning)
# Copyright 2009-2011 Canonical Ltd.
        d.addBoth(shutdown_check)
        d.addCallback(lambda info: show_public_file_info(info, out))
        d.addCallback(lambda r: show_dirty_nodes(r, out))
        d.addCallback(lambda r: show_downloads(r, out))
        d.addCallback(lambda r: show_folders(r, out))
        d.addCallback(lambda r: show_free_space(r, out))
        d.addCallback(lambda r: show_path_info(r, path, out))
        d.addCallback(lambda r: show_shared(r, out))
        d.addCallback(lambda r: show_shares(r, out))
        d.addCallback(lambda r: show_state(r, out))
        d.addCallback(lambda r: show_uploads(r, out))
        d.addCallback(lambda r: show_waiting_content(r, out))
        d.addCallback(lambda r: show_waiting_metadata(r, out))
        d.addCallback(lambda r: show_waiting(r, out))
        d.addCallback(lambda _: sync_daemon_tool.get_current_downloads())
        d.addCallbacks(callback)
        d.addErrback(lambda failure: show_error(failure, out))
        d.addErrback(lambda r: show_error(r, out))
        d = defer.succeed(None)
        def callback(result):
        @defer.inlineCallbacks
@defer.inlineCallbacks
def main(options, args, stdout):
def run(options, sync_daemon_tool, out):
        def shutdown_check(result):
    # disable the dbus warnings
# do not wish to do so, delete this exception statement from your
        d = sync_daemon_tool.accept_share(options.accept_share)
        d = sync_daemon_tool.change_public_access(path, False)
        d = sync_daemon_tool.change_public_access(path, True)
        d = sync_daemon_tool.connect()
        d = sync_daemon_tool.create_folder(path)
        d = sync_daemon_tool.delete_folder(options.delete_folder)
        d = sync_daemon_tool.disconnect()
        d = sync_daemon_tool.free_space(options.free_space)
        d = sync_daemon_tool.get_current_uploads()
        d = sync_daemon_tool.get_dirty_nodes()
        d = sync_daemon_tool.get_folders()
        d = sync_daemon_tool.get_metadata(path)
        d = sync_daemon_tool.get_shares()
        d = sync_daemon_tool.get_status()
        d = sync_daemon_tool.list_shared()
        d = sync_daemon_tool.offer_share(path, username, name, access_level)
        d = sync_daemon_tool.quit()
        d = sync_daemon_tool.refresh_shares()
        d = sync_daemon_tool.refresh_volumes()
        d = sync_daemon_tool.reject_share(options.reject_share)
        d = sync_daemon_tool.rescan_from_scratch(options.rescan_from_scratch)
        d = sync_daemon_tool.start()
        d = sync_daemon_tool.subscribe_folder(options.subscribe_folder)
        d = sync_daemon_tool.subscribe_share(options.subscribe_share)
        d = sync_daemon_tool.unsubscribe_folder(options.unsubscribe_folder)
        d = sync_daemon_tool.unsubscribe_share(options.unsubscribe_share)
        d = sync_daemon_tool.wait_for_nirvana(verbose=True)
        d = sync_daemon_tool.waiting()
        d = sync_daemon_tool.waiting_content()
        d = sync_daemon_tool.waiting_metadata()
    elif options.accept_share:
    elif options.connect:
    elif options.create_folder:
    elif options.current_transfers:
    elif options.delete_folder:
    elif options.dirty_nodes:
    elif options.disconnect:
    elif options.free_space is not None:
    elif options.list_folders:
    elif options.list_shared:
    elif options.list_shares:
    elif options.offer_share:
    elif options.path_info:
    elif options.publish_file:
    elif options.quit:
    elif options.refresh_shares:
    elif options.refresh_volumes:
    elif options.reject_share:
    elif options.rescan_from_scratch is not None:
    elif options.start:
    elif options.status:
    elif options.subscribe_folder:
    elif options.subscribe_share:
    elif options.unpublish_file:
    elif options.unsubscribe_folder:
    elif options.unsubscribe_share:
    elif options.version:
    elif options.waiting:
    elif options.waiting_content:
    elif options.waiting_metadata:
            else:
    else:
                         'encoding %r.' % (
                      "enlightened Buddha!\n")
    """Entry point."""
    except Exception, e:
    except ImportError:
        except (UnicodeDecodeError, UnicodeEncodeError):
# files in the program, then also delete it here.
# file(s) with this exception, you may extend this exception to your
    finally:
# for all of the code used other than OpenSSL.  If you modify
    from dbus.mainloop.glib import DBusGMainLoop
from optparse import OptionParser
        from twisted.internet import gireactor
        from twisted.internet import glib2reactor
from twisted.internet import reactor, defer
from ubuntuone.clientdefs import VERSION
from ubuntuone.platform.tools import (
    # get the encoding of the output stream, defaults to UTF-8
        gireactor.install()
        glib2reactor.install()
                      help="Accept the share with the specified id")
                      help="Connect the syncdaemon")
                      help="Create user defined folder in the specified path")
                      help="Delete user defined folder in the specified path")
                      help="Get the current status of syncdaemon")
                      help="Get the free space for the volume")
                      help="Get the list of operations being executed")
                      help="Get the list of shares")
                      help="Get the waiting content list - Warning: this "
                      help="Get the waiting metadata list - Warning: this "
                      help="List all the user defined folders")
                      help="List the shared paths/shares offered. ")
                      help="Print the version number and exit")
                      help="Reject the share with the specified id")
                      help="Request a refresh of the list of shares to"
                      help="Request a refresh of the list of volumes to"
                      help="Request a rescan from scratch for a volume.")
                      help="Share PATH to USER. ")
                      help=" show the current uploads and downloads")
                      help="Show the list of nodes marked as 'dirty'")
                      help="Shutdown the syncdaemon")
                      help="Start syncdaemon if it's not running")
                      help="Subscribe to a share specified by id")
                      help="Subscribe to the folder specified by id")
                      help="Unsubscribe from a share specified by id")
                      help="Unsubscribe from the folder specified by id")
                      help="Wait until ubuntuone-syncdaemon reaches nirvana")
if __name__ == '__main__':
        if not os.path.exists(path):
    if options.wait:
    if out_encoding is None:
        if reactor.running:
            if result is None and not running:
        if should_start:
if sys.platform != 'win32':
import codecs
    import dbus
import os
import sys
import warnings
# In addition, as a special exception, the copyright holders give
# including the two.
# individual source file, and distribute linked combinations
    is_already_running,
    loop = DBusGMainLoop(set_as_default=True)
# make configglue be quiet about itself using deprecated stuff
# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
                      metavar="FOLDER_ID",
                      metavar="PATH",
                      metavar="PATH", help="Publish file publicly.")
                      metavar="PATH", help="Request the metadata of PATH")
                      metavar="PATH", help="Stop publishing file publicly.")
                      metavar="SHARE_ID",
                      metavar="VOLUME_ID",
                      nargs=4, metavar="PATH USER SHARE_NAME ACCESS_LEVEL",
# OpenSSL library under certain conditions as described in each
                      "option is deprecated, use '--waiting' instead")
    (options, args) = parser.parse_args(sys.argv)
                             options.path_info, sys.getfilesystemencoding()))
    out = codecs.getwriter(out_encoding)(stdout, errors='replace')
    out_encoding = getattr(stdout, 'encoding', 'utf-8')
        out_encoding = 'utf-8'
        out.write("\nOops, an error ocurred:\n%s\n" % e)
            out.write("\nubuntuone-syncdaemon became a fully "
                out.write("ubuntuone-syncdaemon still running.\n")
                out.write("ubuntuone-syncdaemon stopped.\n")
    parser.add_option("", "--accept-share", dest="accept_share",
    parser.add_option("-c", "--connect", dest="connect", action='store_true',
    parser.add_option("", "--create-folder", dest="create_folder",
    parser.add_option("", "--current-transfers", dest="current_transfers",
    parser.add_option("-d", "--disconnect", dest="disconnect",
    parser.add_option("", "--delete-folder", dest="delete_folder",
    parser.add_option("", "--free-space", dest="free_space",
    parser.add_option("", "--info", dest="path_info",
    parser.add_option("", "--list-dirty-nodes", dest="dirty_nodes",
    parser.add_option("", "--list-folders", dest="list_folders",
    parser.add_option("", "--list-shared", dest="list_shared",
    parser.add_option("", "--list-shares", dest="list_shares",
    parser.add_option("", "--offer-share", dest="offer_share", type="string",
    parser.add_option("", "--publish-file", dest="publish_file",
    parser.add_option("-q", "--quit", dest="quit", action='store_true',
    parser.add_option("", "--refresh-shares", dest="refresh_shares",
    parser.add_option("", "--refresh-volumes", dest="refresh_volumes",
    parser.add_option("", "--reject-share", dest="reject_share",
    parser.add_option("", "--rescan-from-scratch", dest="rescan_from_scratch",
    parser.add_option("-s", "--status", dest="status", action='store_true',
    parser.add_option("", "--start", dest="start", action='store_true',
    parser.add_option("", "--subscribe-folder", dest="subscribe_folder",
    parser.add_option("", "--subscribe-share", dest="subscribe_share",
    parser.add_option("", "--unpublish-file", dest="unpublish_file",
    parser.add_option("", "--unsubscribe-folder", dest="unsubscribe_folder",
    parser.add_option("", "--unsubscribe-share", dest="unsubscribe_share",
    parser.add_option("", "--version", dest="version", action='store_true',
    parser.add_option("", "--waiting-content", dest="waiting_content",
    parser.add_option("", "--waiting", dest="waiting",
    parser.add_option("", "--waiting-metadata", dest="waiting_metadata",
    parser.add_option("-w", "--wait", dest="wait", action="store_true",
            parser.error('PATH %r could not be decoded using the filesystem '
            parser.error("PATH: '%s' don't exists" % path)
    parser = OptionParser(usage=usage)
        parser.print_help()
            path = options.path_info.decode(sys.getfilesystemencoding())
        path = os.path.abspath(options.create_folder)
        path = os.path.abspath(options.publish_file)
        path = os.path.abspath(options.unpublish_file)
        path = os.path.abspath(path)
        path, username, name, access_level = options.offer_share
# permission to link the code of portions of this program with the
        print '%s - Version %s' % (os.path.basename(sys.argv[0]), VERSION)
# PURPOSE.  See the GNU General Public License for more details.
    reactor.callWhenRunning(main, options, args, sys.stdout)
    reactor.run()
            reactor.stop()
    return d
            running = yield is_already_running()
    running = yield is_already_running()
    should_start = not running and not options.quit and not options.start
    show_dirty_nodes,
    show_downloads,
    show_error,
    show_folders,
    show_free_space,
    show_path_info,
    show_public_file_info,
    show_shared,
    show_shares,
    show_state,
    show_uploads,
    show_waiting,
    show_waiting_content,
    show_waiting_metadata,
            """Shutdown and check if really stopped."""
    # start syncdaemon if it's required
    SyncDaemonTool,
    sync_daemon_tool = SyncDaemonTool(bus)
                      " the server")
# This program is distributed in the hope that it will be useful, but
# This program is free software: you can redistribute it and/or modify it
        try:
    try:
# under the terms of the GNU General Public License version 3, as published
    usage = "Usage: %prog [option]"
#! /usr/bin/env python
# version.  If you delete this exception statement from all source
# version of the file(s), but you are not obligated to do so.  If you
            """ wait_for_nirvana callback (stop the reactor and exit)"""
warnings.filterwarnings('ignore', message='.*Config(Option|Section).*',
    warnings.filterwarnings('ignore', module='dbus')
# WITHOUT ANY WARRANTY; without even the implied warranties of
# with this program.  If not, see <http://www.gnu.org/licenses/>.
        yield run(options, sync_daemon_tool, out)
            yield sync_daemon_tool.start()
# You must obey the GNU General Public License in all respects
# You should have received a copy of the GNU General Public License along
