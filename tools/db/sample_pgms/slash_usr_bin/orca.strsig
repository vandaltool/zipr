            }
    # Allow a --replace to kill other orca processes.
ARGS="$*"
#!/bin/sh
# Boston MA  02110-1301 USA.
                break
# but WITHOUT ANY WARRANTY; without even the implied warranty of
        CAPSLOCKSETTING=`xmodmap | grep Caps_Lock | cut -f1`
    # Check if we should force orca to quit, or just ask it nicely.
# Cleans up any orca-related processes that might be running,
    cleanup
cleanup()
    cleanup "-f"
# Copyright 2006-2008 Sun Microsystems Inc.
# __copyright__ = "Copyright (c) 2006-2008 Sun Microsystems Inc."
# __date__      = "$Date: 2006/12/08 16:21:25 $"
        DBUSSENDCMD=
                DBUSSENDCMD="$dir/dbus-send"
            $DBUSSENDCMD --reply-timeout=5000 --print-reply \
                --dest=org.gnome.Orca / org.freedesktop.DBus.Peer.Ping \
                > /dev/null 2>&1
    done
        done
    # Do not run if another Orca is already running.
                echo "Another Orca process is already running for this session."
                echo "process with a new one."
                echo "Run \"orca --replace\" if you want to replace the current"
elif [ `echo $ARGS | egrep -c " \-f|^\-f|\-\-forcequit"` -gt 0 ] ; then
    else
    # erroneously types an illegal command line argument, the help
    exec_prefix=/usr
    # existing orca process to quit.  So, we just do a cleanup.
                exit
export PATH
    export PYTHONPATH
        fi
            fi
        for dir in $PATH:/usr/sfw/bin:/usr/local/bin; do
# Free Software Foundation, Inc., Franklin Street, Fifth Floor,
# __id__        = "$Id: orca.in,v 1.22 2006/12/08 16:21:25 wwalker Exp $"
    if [ "$1" = "-f" ];then
if [ `echo $ARGS | grep -c "\-q"` -gt 0 ] ; then
    if [ `echo $ARGS | grep -c "\-\-replace"` -gt 0 ] ; then
            if [ "$?" -eq 0 ] ; then
if pidof speech-dispatcher >/dev/null; then
        IFS=:
    # If the user has done -f or --forcequit, that means 
    # If the user has done -q or --quit, that means to tell any
    # If the user passed in a flag that results in orca only
    if [ "x$ARGS" = "x" ] ; then
    if [ "x$CAPSLOCKSETTING" != "x" ] ; then
        if [ "x$DBUSSENDCMD" != "x" ] ; then
    if [ "x$DBUS_SESSION_BUS_ADDRESS" != "x" ] && [ $WONT_EXIT -gt 0 ] ; then
    if [ "x$DISPLAY" != "x" ] ; then
    if [ "x$INSERTSETTING" != "x" ] ; then
    if [ "x$KPINSERTSETTING" != "x" ] ; then
    # in a cleanup (i.e., every legal command except -?, --help, -v,
        INSERTSETTING=`xmodmap -pke | grep Insert | grep -v KP_`
    # kill -15, will give orca time to shutdown gracefully
    # kill -9 will terminate immediately
        KILLARG="-KILL"
        KILLARG="-TERM"
	kill $(pidof speech-dispatcher)
    # KP_Insert and KP_0 by default).  See the use of xmodmap in
        KPINSERTSETTING=`xmodmap -pke | grep KP_Insert`
# Lesser General Public License for more details.
# License along with this library; if not, write to the
# License as published by the Free Software Foundation; either
# __license__   = "LGPL"
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# modify it under the terms of the GNU Lesser General Public
# orca itself, any speech synthesis drivers, and festival processes
    # orca.py:loadUserSettings for the other part of what's going on.
    # outputting data to the console, don't kill any other orca
PATH="${PATH}:/usr/bin:/usr/sbin:/bin"
    PATTERN="orca[.]orca|festival [-][-]server"
    pkill $KILLARG -U $USERID -f "$PATTERN"
    # process.  We do this by looking for flags that *should* result
    PYTHONPATH=${PYTHONPATH}:${exec_prefix}/lib/python2.7/dist-packages
# rerun Orca if it detects that Orca died an unnatural death.
    restoreXmodmap
restoreXmodmap()
# Restore XMODMAP settings we may have changed.
# restricting it to those processes owned by the user. These include
# running in server mode.
    # running.  That can be done using the 'xset' utility, though
    runOrca
runOrca()
# Runs orca.
# Save away XMODMAP settings we might change.
# Save the arguments away.
    saveXmodmap
saveXmodmap() 
# Set the user's $PATH for this script.
        sleep 0.5
    # straightforward.]]]
    # sure it only produces the keysyms we expect (it produces
            test -x "$dir/dbus-send" && {
    # text is emitted and the other orca is not killed.
    # that Orca has probably hung badly, and needs to be killed with force.
    # the Orca modifier key and turn the autorepeat off when Orca is
    # the user is using the Caps_Lock as the Orca modifier key.  We
# This library is distributed in the hope that it will be useful,
# This library is free software; you can redistribute it and/or
# This script performs some clean up and will run Orca.  It will also
trap cleanup HUP QUIT TERM INT ABRT
    # turning it on/off is easy, but getting the current state is not
    USERID=$(id -u)
    /usr/bin/python -c "import orca.orca; orca.orca.main()" "$ARGS"
# version 2.1 of the License, or (at your option) any later version.
    # --version, -l, and --list-apps).  This way, if the user
# __version__   = "$Revision: 1.22 $"
        waitForCleanup
waitForCleanup()
    # [[[WDW: we probably should save/restore the autorepeat value of
    # We'll save and restore the Caps_Lock as a modifier just in case
    while $(cleanup) ; do
    # will also do so with the KP_Insert key since we want to make
        WONT_EXIT=1
        WONT_EXIT=`echo $ARGS | egrep -c "\-s|\-t|\-n|\-u|\-e|\-d"`
        xmodmap -e "add $CAPSLOCKSETTING = Caps_Lock" > /dev/null 2>&1
        xmodmap -e "$INSERTSETTING" > /dev/null 2>&1
        xmodmap -e "$KPINSERTSETTING" > /dev/null 2>&1
# You should have received a copy of the GNU Lesser General Public
