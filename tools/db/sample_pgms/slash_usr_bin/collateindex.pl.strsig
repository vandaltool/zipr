    # 1. the primary, secondary, and tertiary entries are the same
    # 2. They occur in the same titled section
    # 3. They point to the same place
    $A = $a->{$sterm} || $a->{$term};
	     && ($a->{'href'} eq $b->{'href'}));
# all of the fields from the indexterm with the id specified by STARTREF
    # AND
    $aP =~ s/^\s*//; $aP =~ s/\s*$//; $aP = uc($aP);
	     && ($aS eq $bS)
    $A =~ s/^\s*//; $A =~ s/\s*$//; $A = uc($A);
    $aS =~ s/^\s*//; $aS =~ s/\s*$//; $aS = uc($aS);
	     && ($aT eq $bT)
	     && ($a->{'title'} eq $b->{'title'})
    $aT =~ s/^\s*//; $aT =~ s/\s*$//; $aT = uc($aT);
      backends, it is impossible to suppress duplicate pages or coalesce
      back to the appropriate place in the output produced by the HTML
    $B = $b->{$sterm} || $b->{$term};
B<collateindex.pl> [B<-f>] [B<-g>] [B<-i> I<id>] [B<-I> I<scope>] [B<-N>]
B<collateindex.pl> B<-o> F<index.sgml> F<HTML.index>
B<collateindex.pl> creates index data for DocBook XML or SGML files.
                [B<-o> F<file>] [B<-p>] [B<-P> F<file>] [B<-q>] [B<-s> I<name>]
    $bP =~ s/^\s*//; $bP =~ s/\s*$//; $bP = uc($bP);
                [B<-S> I<scope>] [B<-t> I<name>] [B<-x>] F<file>
    $B =~ s/^\s*//; $B =~ s/\s*$//; $B = uc($B);
    $bS =~ s/^\s*//; $bS =~ s/\s*$//; $bS = uc($bS);
    $bT =~ s/^\s*//; $bT =~ s/\s*$//; $bT = uc($bT);
    chop;
    chop if /\r$/;
		        'class', 'scope') {
	    close(F);
close (F);
	    close (OUT);
close (OUT);
collateindex.pl - generate DocBook index files
containing section.
	# Copy the preamble
$dat = shift @ARGV || die $usage;
$debug        = $opt_D;
die "$me: file \"$dat\" does not exist\n" if ! -f $dat;
    die "$me: invalid implied scope: $impliedscope\n";
    die "$me: invalid scope: $scope\n";
	die "$me: invalid zone: $_\n" if !/^title (.*)$/i;
    die "$me: unrecognized tag in input: $_\n";
die $usage if ! getopts('Dfgi:NpP:s:o:S:I:t:xqV');
    # (do we do the right thing in that case?)
      Duplicates may be removed in the HTML backend, but in the print
edited by hand.
    } else {
} else {
	    } else {
	} else {
	    } elsif (($group eq '') || ($group ne $letter)) {
    } elsif (!&tsame($last, $idx, 'secondary')) {
    } elsif (!&tsame($last, $idx, 'tertiary')) {
    # End any open elements...
&end_entry();
	&end_entry() if not $first;
    exit 0;
	    exit 1;
	$first = 0; # there can only be on first ;-)
$first = 1;     # this is the first one
# Fixup the startrefs...
$forceoutput  = $opt_f;
Force the output file to be written, even if it appears to have been
    #          for comparing duplicates.
	foreach $field ('primary', 'secondary', 'tertiary', 'see', 'seealso',
    foreach $idx (@term) {
foreach $idx (@term) {
	foreach $key (keys %{$idx->{'zone'}}) {
    foreach (@seealsos) {
	foreach (@seealsos) {
		    || (($group ge 'A') && ($group le 'Z'))) {
		    $group = $letter;
		$group = $letter;
Group terms with IndexDiv based on the first letter of the term (or
$group = "";    # we're not in a group yet
	    $handedit = 0;
		    $handedit = 0;
=head1 AUTHOR
=head1 DESCRIPTION
=head1 EXAMPLE
=head1 EXIT STATUS
=head1 NAME
=head1 OPTIONS
=head1 SYNOPSIS
	$href{$idx->{'href'}} = $idx->{'title'};
	    $href{$key} = $idx->{'zone'}->{$key};
    @hrefs = keys %href;
HTML stylesheet (usually called F<HTML.index>).
%id   = ();
	$id{$1} = $idx;
# $Id: collateindex.pl,v 1.10 2004/10/24 17:05:41 petere78 Exp $
	$ididx = $id{$idx->{'startref'}};
	$idx = {};
	$idx->{'class'} = &escape($1);
	$idx->{'count'} = $termcount;
	    $idx->{$field} = $ididx->{$field};
	$idx->{'href'} = $1;
	$idx->{'hrefpoint'} = $1;
	$idx->{'id'} = $1;
	    $idx->{'primary'} = &escape($1);
	    $idx->{'primary'} = &escape($2);
	    $idx->{'psortas'} = &escape($1);
	$idx->{'scope'} = &escape(uc($1));
	$idx->{'scope'} = $impliedscope;
	    $idx->{'secondary'} = &escape($1);
	    $idx->{'secondary'} = &escape($2);
	$idx->{'seealso'} = &escape($1);
	$idx->{'see'} = &escape($1);
	$idx->{'significance'} = &escape($1);
	    $idx->{'ssortas'} = &escape($1);
	$idx->{'startref'} = $1;
	    $idx->{'tertiary'} = &escape($1);
	    $idx->{'tertiary'} = &escape($2);
	$idx->{'title'} = $1;
	    $idx->{'tsortas'} = &escape($1);
	$idx->{'zone'} = {};
	$idx->{'zone'}->{$href} = $1;
    if ($aP eq $bP) {
	if ($aS eq $bS) {
	    if ($aT eq $bT) {
    if (/^class (.*)$/i) {
		# if everything else is the same, keep these elements
		if (($group eq '')
	if ($handedit) {
    if (/^id (.*)$/i) {
 	if ($idx->{'secondary'}) {
    if ($idx->{'see'}) {
    if ($idx->{'seealso'}) {
    if ($idx->{'startref'}) {
	if ($idx->{'tertiary'}) {
if ($impliedscope && !$legal_scopes{$impliedscope}) {
    if ($indexid) {
if ($indexid) {
    if (/^indexpoint (.*)$/i) {
    if (/^\/indexterm/i) {
    if (/^indexterm (.*)$/i) {
    if (keys %{$idx->{'zone'}}) {
	if ($lastout) {
	if ($lettergroups) {
	    if (($letter lt 'A') || ($letter gt 'Z')) {
	if (($letter lt 'A') || ($letter gt 'Z')) {
	if ($linkpoints) {
	if $linkpoints;
if ($newindex) {
	if (open(F, $preamble)) {
	if (open (OUT, $outfile)) {
if ( $opt_V ) {
    if (($outfile ne '-') && (!$forceoutput)) {
    if ($preamble) {
    # If primary changes, output a whole new index term, otherwise just
    if (/^primary[\[ ](.*)$/i) {
	if (/^primary\[(.*?)\] (.*)$/i) {
		if (/<!-- Remove this comment if you edit this file by hand! -->/){
    if ($same) {
    if (/^scope (.*)$/i) {
if ($scope && !$legal_scopes{$scope}) {
    if (/^secondary[\[ ](.*)$/i) {
	if (/^secondary\[(.*?)\] (.*)$/i) {
    if (/^seealso (.*)$/i) {
    if (/^see (.*)$/i) {
    if (/^significance (.*)$/i) {
    if (/^startref (.*)$/i) {
    if (/^tertiary[\[ ](.*)$/i) {
	if (/^tertiary\[(.*?)\] (.*)$/i) {
    if (/^title (.*)$/i) {
    if (!&tsame($last, $idx, 'primary')) {
	    # If we're grouping, make the right indexdivs
    # If we're linking to points, they're only the same if they link
    if (/^zone (.*)$/i) {
$impliedscope = uc($opt_I) || 'ALL';
    $indent = "    ";
$indexid      = $opt_i;
$indextag     = $setindex ? 'setindex' : 'index';
# indexterm
# In DocBook, STARTREF is a #CONREF attribute; support this by copying
		# in document order (so the index links are in the right
inserted before the E<lt>indexE<gt> tag.
    #        Interpretation of "the same place" depends on whether or
	    # it'd be nice to make this a link...
	# it'd be nice to make this a link...
=item B<0>
=item B<1>
=item B<-f>
=item B<-g>
=item B<-i> I<id>
=item B<-I> I<scope>
=item B<-N>
=item B<-o> F<file>
=item B<-p>
=item B<-P> F<file>
=item B<-q>
=item B<-s> I<name>
=item B<-S> I<scope>
=item B<-t> I<name>
=item B<-V>
=item B<-x>
=item F<file>
its SortAs attribute).  (This might not handle all language environments.)
	$key = shift @hrefs;
		    last;
    $last = $idx;
    $lastout = "";
	    $lastout = "";
	$lastout = "primaryie";
	    $lastout = "secondaryie";
	$lastout = "secondaryie";
	    $lastout = "tertiaryie";
$lastout = "";  # we've not put anything out yet
$last = {};     # the last indexterm we processed
%legal_scopes = ('ALL' => 1, 'LOCAL' => 1, 'GLOBAL' => 1);
$lettergroups = $opt_g;
	    $letter = $idx->{'primary'} if !$letter;
	$letter = $idx->{'primary'} if !$letter;
	    $letter = $idx->{'psortas'};
	$letter = $idx->{'psortas'};
	    $letter = uc(substr($letter, 0, 1));
	$letter = uc(substr($letter, 0, 1));
	    $linkend = $key;
	    $linkend = $phref{$key};
$linkpoints   = $opt_p;
Link to points in the document.  The default is to link to the closest
    local(*F, $_);
    local(*OUT) = shift;
    local $_ = shift;
Make a SetIndex.
    # make sure & and < don't show up in the index
		# make sure seealso's always sort to the bottom
Meaningless if B<-g> is not used.
$me = basename($0);
Minor updates by Adam Di Carlo E<lt>adam@onshore.comE<gt> and Peter Eisentraut E<lt>peter_e@gmx.netE<gt>
# Move all of the non-alphabetic entries to the front of the index.
    # Move the non-letter things to the front.  Should digits be thier
    my($A, $B);
    my($ap) = $a->{'count'};
    my($aP) = $a->{'psortas'} || $a->{'primary'};
    my($aS) = $a->{'ssortas'} || $a->{'secondary'};
    my($a) = shift;
    my($aT) = $a->{'tsortas'} || $a->{'tertiary'};
    my($bp) = $b->{'count'};
    my($bP) = $b->{'psortas'} || $b->{'primary'};
    my($bS) = $b->{'ssortas'} || $b->{'secondary'};
    my($b) = shift;
    my($bT) = $b->{'tsortas'} || $b->{'tertiary'};
	my($handedit) = 1;
    my(%href) = ();
	my($href) = $1;
    my($ididx, $field);
    my($idx);
    my($idx) = shift;
    my($key, $indent, @hrefs);
    my($letter);
	my($linkend) = "";
    my(@new) = ();
    my(%phref) = ();
	my($role) = "";
    my($same);
    my($sterm) = substr($term, 0, 1) . "sortas";
    my(@sym) = ();
    my(@term) = @_;
    my($term) = shift;
Name the IndexDiv that contains symbols.  The default is C<Symbols>.
New index (generates an empty index file).
$newindex     = $opt_N;
    next if ($idx->{'scope'} eq 'GLOBAL') && ($scope eq 'LOCAL');
    next if ($idx->{'scope'} eq 'LOCAL') && ($scope eq 'GLOBAL');
    next if $idx->{'startref'}; # no way to represent spans...
    next if &same($idx, $last); # suppress duplicates
-->\n\n";
Norm Walsh E<lt>ndw@nwalsh.comE<gt>
    # Notes: Scope is used to suppress some entries, but can't be used
    #          not $linkpoints is true.
    # one if the term has a ZONE that points to more than one place.
open (F, $dat);
    open (OUT, ">$outfile") || die "$me: could not open file \"$outfile\": $!\n";
		# order)
    #    (or have the same SORTAS)
    # original source (and, in fact, it might not have one).
$outfile      = $opt_o || '-';
    # output another secondary or tertiary, as appropriate.  We know from
Output to F<file>. Defaults to F<stdout>.
    # own group?  Maybe...
      pass.)
	$phref{$idx->{'href'}} = $idx->{'hrefpoint'};
	    $phref{$key} = $key;
$preamble     = $opt_P;
#    print "[$aP]=[$bP]\n";
#    print "[$aS]=[$bS]\n";
#    print "[$aT]=[$bT]\n";
    print "collateindex.pl $version\n";
	print "DIFF PRIM\n" if $debug;
	print "DIFF SEC\n" if $debug;
	print "DIFF TERT\n" if $debug;
		print OUT $_;
	print OUT "</emphasis>" if ($idx->{'significance'} eq 'PREFERRED');
	print OUT "<emphasis>" if ($idx->{'significance'} eq 'PREFERRED');
	print OUT &escape($href{$key});
	print OUT $indent;
	    print OUT $indent, "  <seealsoie>", &escape($_), "</seealsoie>\n";
	print OUT $indent, "  <seealsoie>", &escape($_), "</seealsoie>\n";
	print OUT $indent, "<seeie>", &escape($idx->{'see'}), "</seeie>\n";
		    print OUT "</indexdiv>\n" if !$first;
		print OUT "</indexdiv>\n" if !$first;
print OUT "</indexdiv>\n" if $lettergroups;
		print OUT "<indexdiv><title>$letter</title>\n\n";
		    print OUT "<indexdiv><title>$symbolsname</title>\n\n";
	print OUT "<indexentry>\n";
    print OUT "</indexentry>\n\n";
    print OUT "<$indextag id='$indexid'>\n\n";
	print OUT "<$indextag id='$indexid'>\n\n";
    print OUT "</$indextag>\n";
print OUT "</$indextag>\n";
    print OUT "<$indextag>\n\n";
	print OUT "<$indextag>\n\n";
    print OUT ",\n";
	    print OUT "\n  </$lastout>\n";
    print OUT "\n  </$lastout>\n" if $lastout;
	print OUT "\n  </$lastout>\n" if $lastout;
	    print OUT "\n  </primaryie>\n";
	    print OUT "\n  </secondaryie>\n";
	print OUT "  <primaryie>", $idx->{'primary'};
    print OUT "<!-- Remove this comment if you edit this file by hand! -->\n";
print OUT "<!-- Remove this comment if you edit this file by hand! -->\n";
	    print OUT "  <secondaryie>", $idx->{'secondary'};
	print OUT "  <secondaryie>", $idx->{'secondary'};
	    print OUT "  <tertiaryie>", $idx->{'tertiary'};
    # Print out the links for an indexterm.  There can be more than
    print OUT "<!-- This file was produced by collateindex.pl.         -->\n";
print OUT "<!-- This file was produced by collateindex.pl.         -->\n";
print OUT "<title>$title</title>\n\n" if $title;
	print OUT "</ulink>";
print OUT "<!-- ULINK is abused here.
	print OUT "<ulink url=\"$linkend\" role=\"$role\">";
	    print STDERR "$me: file \"$outfile\" appears to have been edited by hand\n";
	    print STDERR "Use the -f option or specify a different output file name.\n";
    &print_term($idx);
Print version number and exit.
		        'psortas', 'ssortas', 'tsortas', 'significance',
	    push (@new, $idx);
	push @seealsos, $idx->{'seealso'};
	    push (@sym, $idx);
	push (@term, $idx);
$quiet        = $opt_q;
$quiet || print STDERR "Done.\n";
$quiet || print STDERR "Processing $dat...\n";
$quiet || print STDERR "$termcount entries ignored...\n";
$quiet || print STDERR "$termcount entries loaded...\n";
Read a preamble from F<file>.  The contents of F<file> will be
# Read the index file, creating an array of objects.  Each object
# represents and indexterm and has fields for the content of the
    return $_;
	return;
		return 1 if ($a->{'seealso'});
		return -1  if ($b->{'seealso'});
    return $A eq $B;
		return $ap <=> $bp;
	return $aP cmp $bP;
	    return $aS cmp $bS;
		return $aT cmp $bT;
    return (@sym, @new);
	$role = $1 if $role =~ /(.*)\./;
	$role = $1 if $role =~ /\#(.*)$/;
	$role = $phref{$key};
Run quietly.
    safe_open(*OUT, $outfile);
safe_open(*OUT, $outfile);
    $same;
    $same = (($aP eq $bP)
    $same = $same && ($a->{'hrefpoint'} eq $b->{'hrefpoint'})
    s/&/&amp;/sg;
	$_ = scalar(<F>);
Scope of the index, must be C<all>, C<local>, or C<global>.  If
$scope        = uc($opt_S) || 'ALL';
    @seealsos = ();
	@seealsos = ();
@seealsos = (); # See also stack.
      sequences of pages into a range.
$setindex     = $opt_x;
    s/>/&gt;/sg; # what the heck
    s/</&lt;/sg;
    # sorting that the terms will always be in the right order.
# Sort the index terms
      stylesheet. (It's much easier to calculate this URL in the first
sub end_entry {
sub escape {
sub print_term {
sub safe_open {
sub same {
sub sortsymbols {
sub termsort {
sub tsame {
	    # symbols are a special case
$symbolsname  = $opt_s || "Symbols";
@term = ();
    $termcount--;
	$termcount++;
$termcount = 0;
# Termcount is > 0 iff some entries were skipped.
@term = sortsymbols(@term);
@term = sort termsort @term;
      the corresponding INDEXTERM.  This is used by the print backends
      The entries below are sorted and collated into the correct order.
The file containing index data generated with the DocBook DSSSL
The ID to use for the E<lt>indexE<gt> tag.
The implied scope, must be C<all>, C<local>, or C<global>.  IndexTerms
      The Role attribute holds the ID (either real or manufactured) of
      The URL attribute holds the URL that points from the index entry
Title for the index.
$title        = $opt_t;
    # to exactly the same spot.
      to produce page numbers.
# to the indexterm that has the STARTREF.
Try \"perldoc $me\" for documentation.\n";
    # Two index terms are the same if:
    # Unlike same(), tsame only compares a single term
unspecified, C<all> is assumed.
$usage = "Usage: $0 [options] file
use File::Basename;
use Getopt::Std;
#!/usr/bin/perl -- # -*- Perl -*-
( $version = '$Revision: 1.10 $' ) =~ s/^\$[R]evision:\s*([^ ]*)\s*\$$/$1/;
	    warn "$me: could not open preamble file \"$preamble\": $!\n";
       warn "$me: duplicated index entry found: $aP $aS $aT\n";
    # We can't use <LINK> because we don't know the ID of the term in the
which do not specify a scope will have the implied scope.  If
	    while (<F>) {
while (<F>) {
    while (@hrefs) {
	    while (<OUT>) {
# Write the index...
