and static (F<lib*.a>) and debugging libraries (F<lib*_g.a>, F<debug/*.so>), and
as independent files in the package build directory of the specified debugging
 		attach_debug($_, $debug_path) if defined $debug_path;
		attach_debug($_, $debug_path) if defined $debug_path;
B<dh_strip> is a debhelper program that is responsible for stripping
B<dh_strip> [S<I<debhelper options>>] [B<-X>I<item>] [B<--dbg-package=>I<package>] [B<--keep-debug>]
"Binaries").
Causes B<dh_strip> to save debug symbols stripped from the packages it acts on
# Check if a file is an elf binary, shared library, or static library,
	close FILE;
	# (*.cmxs are OCaml native code shared libraries)
compatibility levels 4 and below. Instead of specifying the name of a debug
currently deal with stripping binary modules such as F<.o> files.
Debian policy, version 3.0.1
debugging.
		$debug_path=$desttmp."/usr/lib/debug/".$base_file;
		$debug_path=$desttmp."/usr/lib/debug/.build-id/$1/$2.debug"
Debug symbols will be retained, but split into an independent
			$debugtmp=tmpdir($debugpackage);
			$debugtmp=tmpdir($package."-dbg");
dh_strip - strip executables, shared libraries, and some static libraries
		|| die "can't exec file: $!";
	# Does its filename look like a shared library?
	doit("chmod", 644, $debug_path);
		doit("install", "-d", $debug_dir);
	doit($objcopy, "--add-gnu-debuglink", $debug_path, $file);
		doit($objcopy, "--only-keep-debug", "--compress-debug-sections", $file, $debug_path);
		doit($objcopy, "--only-keep-debug", $file, $debug_path);
		doit($strip,"--remove-section=.comment",
		doit($strip,"--strip-debug",$_);
	# Don't try to copy debug symbols out if the file is already
				error("debug package $debugpackage is not listed in the control file");
Exclude files that contain I<item> anywhere in their filename from being
		|| exec('file', $file)
executables, shared libraries, and static libraries that are not used for
file in F<usr/lib/debug/> in the package build directory. B<--dbg-package>
		# file returns a variety of things on static libraries.
	find(\&testfile,$tmp);
	foreach (@executables) {
	foreach my $f (@{$dh{EXCLUDE}}) {
foreach my $package (@{$dh{DOPACKAGES}}) {
	foreach (@shared_libs) {
	foreach (@static_libs) {
For example, if your packages are libfoo and foo and you want to include a
# for use by File::Find. It'll fill the following 3 arrays with anything
			# for v5 only one value is used.
=head1 AUTHOR
=head1 CONFORMS TO
=head1 DESCRIPTION
=head1 NAME
=head1 NOTES
=head1 OPTIONS
=head1 SEE ALSO
=head1 SYNOPSIS
# I could just use `file $_[0]`, but this is safer
		if (-B $_) {
	if (! compat(4)) {
	if (! compat(8) && 
	if (compat(8)) {
	if (! -d $debug_dir) {
if (get_buildoption('nostrip')) {
			if (! grep { $_ eq $debugpackage } getpackages()) {
	if (m/lib.*\.a$/ && ! m/.*_g\.a$/) {
	if ($mode & 0111) {
	if (m/.*\.(so.*?|cmxs$)/) {
I<foo-dbg> package with debugging symbols, use B<dh_strip --dbg-package=>I<foo-dbg>.
		if (ref $dh{DEBUGPACKAGES}) {
		if (ref $dh{DEBUGPACKAGES} && grep { $_ eq $package } @{$dh{DEBUGPACKAGES}}) {
If the B<DEB_BUILD_OPTIONS> environment variable contains B<nostrip>, nothing
		if ($type=~m/.*ELF.*(executable|shared).*/) {
		if ($type=~m/.*ELF.*shared.*/) {
init(options => {
in packages with B<-dbg> added to their name.
is easier to use than this option, but this option is more flexible.
		# Is it a binary file, or something else (maybe a liner
	# Is it a debug library in a debug subdir?
	# Is it a static library, and not a debug library?
	# Is it executable? -x isn't good enough, so we need to use stat.
=item B<--dbg-package=>I<package>
=item B<-k>, B<--keep-debug>
=item B<-X>I<item>, B<--exclude=>I<item>
# it finds:
Joey Hess <joeyh@debian.org>
			$keep_debug=1;
	"keep-debug" => \$dh{K_FLAG},
L<debhelper(7)>
libraries.) In general it seems to make very good guesses, and will do the
module, and hard to determine how to strip a module, B<dh_strip> does not
		# *must* inclde the --strip-unneeded.
	my ($base_file)=$file=~/^\Q$tmp\E(.*)/;
	my $debug_dir=dirname($debug_path);
			my $debugpackage=@{$dh{DEBUGPACKAGES}}[0];
	my $debug_path;
		my $debug_path = make_debug($_, $tmp, $debugtmp) if $keep_debug;
	my $debug_path=shift;
	my $debugtmp=$tmp;
	my $desttmp=shift;
	my $file=shift;
	my $fn="$File::Find::dir/$_";
	my $keep_debug=$dh{K_FLAG};
my $objcopy = cross_command("objcopy");
my (@shared_libs, @executables, @static_libs);
my $strip = cross_command("strip");
	my $tmp=shift;
	my $tmp=tmpdir($package);
	my $type=<FILE>;
		my $type=get_file_type($_);
	my (undef,undef,$mode,undef)=stat(_);
	# No reason for this to be executable.
		# Note that all calls to strip on shared libs
			# Note that it's only an array for the v4 stuff;
Note that this option behaves significantly different in debhelper
	# Note that we have to test on the full filename, including directory.
		# Ok, do the expensive test.
		# Ok, expensive test.
	open (FILE, '-|') # handle all filenames safely
package.
package to put symbols in, it specifies a package (or packages) which
			push @executables, $fn;
			push @shared_libs, $fn;
			push @static_libs, $fn;
	    `readelf -n $file`=~ /^\s+Build ID: ([0-9a-f]{2})([0-9a-f]+)$/m) {
			"--remove-section=.note",$_);
			"--remove-section=.note","--strip-unneeded",$_);
			return;
	return $debug_path;
	return if $fn=~m/debug\/.*\.so/;
		return if ($fn=~m/\Q$f\E/);
	return if -l $_ or -d $_; # Skip directories and symlinks always.
	return $type;
	return unless get_file_type($file) =~ /not stripped/;
right thing in almost all cases.
		# script on Hurd, for example? I don't use file, because
	# See if we were asked to exclude this file.
	@shared_libs=@executables=@static_libs=();
should have separated debug symbols, and the separated symbols are placed
Since it is very hard to automatically guess if a file is a
	# stripped.
stripped. You may use this option multiple times to build up a list of
strips each as much as is possible. (Which is not at all for debugging
sub attach_debug {
sub get_file_type {
sub make_debug {
sub testfile {
	# Support for keeping the debugging symbols in a detached file.
things to exclude.
This program examines your package build directories and works out what
This program is a part of debhelper.
# This variable can be used to turn off stripping (see Policy).
to figure out what files are shared libraries (F<*.so>), executable binaries,
to strip on its own. It uses L<file(1)> and file permissions and filenames
use Debian::Debhelper::Dh_Lib;
use File::Find;
use strict;
#!/usr/bin/perl -w
will be stripped, in accordance with Debian policy (section 10.1
