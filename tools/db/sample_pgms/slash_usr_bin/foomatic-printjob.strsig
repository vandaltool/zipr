        }
$0 =~ m!/([^/]+)\s*$!;
    $action = 'control';
	$action = 'control';
$action = ($opt_C ? 'control' : $action);
$action = ($opt_Q ? 'query' : $action);
$action = ($opt_R ? 'remove' : $action);
    $action = 'print';
	$action = 'print';
    $action = 'query';
	$action = 'query';
    $action = 'remove';
	$action = 'remove';
    # Add the driver-specific options supplied by the user, if any
    # Add the printer queue argument
    # Add the remaining command line arguments, they are the control command
    # Add the remaining command line arguments, they are the names of
    # Add the remaining command line arguments, they are the numbers
	    $alljobs = " all";
	# already finished, cancelled, or aborted
 -a              Query the jobs in all queues
		($ARGV[$i+1] =~ m!^\s*([0-9]+)\s*$!)) {
    # as of LPD and CUPS.
    # Auto-detect whether the "lpr" executable is the VA-Linux version or not
	# Avoid spaces in the status field, so that frontends can separate the
		# but there can be enumerated options with numbers as choices,
# Call proper proc
 -C              Execute control commands for queue/job manipulation
	chomp $line;
	    chomp $queue;
	chomp $s;
	# Clean up the command
	close DEFAULTFILE;
	close JOBSTATUSFILE;
	    close LINES;
    close LPQOUTPUT;
    close PDQHELP;
		close PIPE;
    close PJDIR;
	close QUEUELIST;
 command [ arguments ]  Control command for queue/job manipulation. The 
	$command = lc($command);
	    $commandline .= "\"";
	# command line
		$commandline .= "$_ ";
    $commandline .= $alljobs;
		$commandline .= " -aOPT_$1";
    $commandline .= " @ARGV";
    # command line do not make much sense, because under PDQ a user can
	    $commandline .= " -J\"";
	    $commandline .= " -o $_";
		$commandline .= " -o $_";
	    $commandline .= " -o$option";
	$commandline .= " -P $config->{'queue'}";
	    $commandline .= " -Z $_";
    # command "pdq". So we launch "pdq" once per copy. Thw command line
                 commands are the ones of the BSD "lpc" utility. Use
                 commands. Note: the amount of commands varies with the
	$config->{'queue'} = get_pdq_default_printer();
    # Control command
    # control command (standard commands of lpc for LPD/LPRng)
			 'control'  => \&control_cups },
		         'control'  => \&control_lpd },
			 'control'  => \&control_lpd },
			 'control'  => \&control_pdq } };
    # Control the printing system with the standard "lpc" command
	   "C"   => \$opt_C,         # Control job(s)/queue(s)
    # CUPS has no LPD/LPRng-compatible lpc command, so we must emulate
	      'cups' =>{ 'print'    => \&print_cups,
# Default action: Printing
		 (!(defined($joblist->{$jobnumbers[$i]}))));
		 (!(defined($userlist->{$owner}))));
# Determine the action by a command line option
# Determine the action by the name how we were called
    die "Advanced queue/job manipulation functionality is not supported under PDQ!\n";
	    die "Cannot write $ENV{'HOME'}/.defaultspooler!\n";
	    die "Cannot write $sysdeps->{'foo-etc'}/defaultspooler!\n";
	die "Command \"$command\" not recognized!\n";
	    die "$config->{'queue'}: unknown printer\n";
	die "$config->{'queue'}: unknown printer\n";
		    die "Could not launch printing command!\n";
	die "\n" if ($yn !~ m!^y!i);
	die "No default printer defined, you have to specify a printer with \"-P\" or \"-d\"!\n";
    die "Sorry, $action for your spooler is unimplemented...\n";
    die "Unable to identify spooler, please specify one with \"-s\"!\n"
	    die "Unknown option: $ARGV[$i]\n";
	    die "Usage of the \"$command\" control command:\n\n   $command queue [ jobID ] \n\n";
	    die "Usage of the \"move\" control command:\n\n   move oldqueue [ jobID ] newqueue\n\n";
	die "You must supply a control command with the \"-C\" option!\n";
    # Does the chosen printer exist
    # Do it!
	   "d=s" => \$opt_d,         # which queue (Destination)?
    } else {
	    } else {
	} else {
    # Else if /etc/printcap, some sort of lpd thing
    } else { # name does not determine the action
	} elsif ($ARGV[$i] =~ m!^\s*[^\-]+!) {
	} elsif ($ARGV[$i] =~ m!^\s*\-\#\s*$!) {
	} elsif ($ARGV[$i] =~ m!^\s*\-\s*$!) {
    } elsif (defined($ENV{PRINTER})) {
    } elsif (lc($command) eq "disable") { # Reject new jobs
    } elsif (lc($command) eq "down") { # Turn off queue (queueing/printing)
    } elsif (lc($command) eq "enable") { # Accept new jobs
    } elsif (lc($command) eq "help") { # List the available commands
    } elsif ((lc($command) eq "hold") ||    # Hold job
    } elsif (lc($command) eq "move") { # Move jobs
    } elsif (lc($command) eq "start") { # Turn on queue (printing)
    } elsif (lc($command) eq "status") { # Queue status listing
    } elsif (lc($command) eq "stop") { # Turn off queue (printing)
    } elsif (lc($command) eq "up") { # Turn on queue (queueing/printing)
	} elsif ($line =~ m!\s*Rank\s+Owner!) {
    } elsif ($progname =~ m!^lpq!) { # 'lpq*' ==> list jobs 
} elsif ($progname =~ m!^lpq!) { # 'lpq*' ==> list jobs 
    } elsif ($progname =~ m!^lprm!) { # 'lprm*' ==> remove jobs 
} elsif ($progname =~ m!^lprm!) { # 'lprm*' ==> remove jobs 
} elsif (($progname =~ m!^lpr!) || ($progname =~ m!^lp!)) { 
    } elsif (($progname =~ m!^lpr!) || ($progname =~ m!^lp!)) { # 'lpr*', 'lp*' ==> print 
	} elsif (-x $sysdeps->{'lpd-bin'}) {
	    # Enumerated and boolean options are PDQ options ("-o"),
	"< $ENV{'HOME'}/.printjobs/$jobnumbers[$i].status";
    eval `foomatic-configure -P -n $config->{'queue'} -s $config->{'spooler'}`;
# everything related to print queue static state: install, modify,
# Exception...
    exit 0;
	exit 0;
exit &{$procs->{$in_config->{'spooler'}}{$action}}($in_config);
	# Extract the important fields from the file
	# fields from the job list more easily.
	    $file = $1;
	       [ file1 file2 ... ]
 file1 file2 ... Files to be printed, when no file is given, standard input
	    $file_in_args = 1;
    # files in ~/.printjobs and setting the permissions of these files
	    # Fill up the number with zeros so that it has three digits
    # Filter the output
		$firstline = 0;
		# Foomatic treats numerical options as PDQ arguments ("-a"),
	    for (@{$config->{'options'}}) {
	for (@{$config->{'options'}}) {
    foreach my $arg (@{$QUEUES[0]->{'args'}}) {
        foreach my $val (@{$arg->{'vals'}}) {
    for ($i = 0; ($i <= $#ARGV); $i++) {
    for ($i = 0; $i <= $#jobnumbers; $i ++) {
	    for ($i = 0; $i < $num_copies; $i++) {
    for $line (@lpqoutput) {
	    for (@lines) {
	for (@queuelist) {
    for (split(':', $ENV{'PATH'})) {
    # For the VA-Linux implementation of "lpr" (gnulpr) options are passed
    # front ends
	# Get all printer queues
    GetOptions("a"   => \$opt_a,        # List jobs on all printers
    GetOptions("a"   => \$opt_a);        # List jobs on all printers
    GetOptions("l"   => \$opt_l);       # Long, more verbose output
GetOptions("P=s" => \$opt_P,         # which queue (Printer)?
    # Getopt::Long.
Getopt::Long::Configure("no_ignore_case", "pass_through");
    # given
		# headline
help() if ($opt_h && !$opt_P);
# Help on printer-specific options
help_options($in_config) if ($opt_h);
# here. With the sister program foomatic-configure, you can do
    # holding/releasing/moving jobs, etc.
	   "h"   => \$opt_h);        # Help!
 -h              Show this message
 -h              Show this message or show a list of available options if a 
	    $i--;
    if (($> != 0) && (-f "$ENV{'HOME'}/.defaultspooler")) {
    if ($> == 0) { # Program invoked as "root"?
    if ($action eq 'all') {
    if (($action eq 'control') || ($action eq 'all')) {
    if (($action eq 'print') || ($action eq 'all')) {
    if (($action eq 'query') || ($action eq 'all')) {
    if (($action eq 'remove') || ($action eq 'all')) {
    if ($action ne 'control') {
	if (($#ARGV < 0) or ($#ARGV > 1)) {
	if (($#ARGV < 1) or ($#ARGV > 2)) {
	if ($ARGV[$i] =~ m!^\s*([0-9]+)\s*$!) {
	if ($ARGV[$i] =~ m!^\s*\-\s*$!) {
	if ($ARGV[$i] =~ m!^\s*\-\#\s*([0-9]+)\s*$!) {
	if ($command eq "release") {$command = "resume";} 
	if ($command eq "topq") {$command = "immediate";} 
    if ($#{$config->{'options'}} >= 0) {
	if ($#{$config->{'options'}} >= 0) {
	    if ((defined $ARGV[$i+1]) && 
    if (!defined($command)) {
    if (!(defined($config->{'queue'}))) {
    if (defined($config->{'queue'})) {
	if (defined($config->{'queue'})) {
if (!(defined($in_config->{'queue'}))) {
if (!defined($in_config->{'spooler'})) {
	if (!defined($jobid)) {
    if (!(defined($opt_a))) {
    if (defined($opt_a)) {
    if ((!(defined($opt_a))) && (!(defined($config->{'queue'})))) {
    if (defined($opt_d)) {
    if (defined($opt_i)) {
	    if (!defined($opt_l)) {
	    if (defined($opt_l)) {
if (defined($opt_S)) {
    if (!defined($s)) {
    if ((!defined($s)) && (-f "$sysdeps->{'foo-etc'}/defaultspooler")) {
	if (!defined($toqueue)) {
	if (-f "$ENV{'HOME'}/.printjobs/$jobnumbers[$i].raw") {
	# If -f /etc/lpd.conf, lprng
	if ($file_in_args == 0) {
	if ($filename =~ m!^([0-9][0-9][0-9]).status$!) {
    if ($firstline == 1) {
	    if ($firstline == 1) {
    if (-f $sysdeps->{'lpd-pcap'}) {
	if (-f $sysdeps->{'lprng-conf'}) {
	if ($jobstatusdata =~ 
	if ($jobstatusdata =~ m!^\s*input_filename\s*\=\s*{([^{}]*)}\s*$!m) {
	if ($jobstatusdata =~ m!^\s*printer\s*\=\s*{([^{}]*)}\s*$!m) {
	if ($jobstatusdata =~ m!^\s*status\s*\=\s*{([^{}]*)}\s*$!m) {
	    if (length($file) > 37) {$file = substr($file, 0, 37);}
		if (length($file) > 37) {$file = substr($file, 0, 37)};
	    if (length($file) > 40) {$file = substr($file, 0, 40);}
		if (length($file) > 40) {$file = substr($file, 0, 40);}
	    if (length($owner) > 10) {$owner = substr($owner, 0, 10);}
		if (length($owner) > 8) {$owner = substr($owner, 0, 8)};
		if (length($owner_rank) > 40) {
	    if (length($owner_status) > 40) {
		if (length($rank) > 6) {$rank = substr($rank, 0, 6)};
	    if (length($status) > 6) {$status = substr($status, 0, 6);}
	if ($line =~ m!^\s*(\S+)\s+([^@\s]+)@[^@\+\s]+\+[0-9]+\s+\S+\s+([0-9]+)\s+(\S+)\s+([0-9]+)\s+[0-9:]+\s*$!) {
		if ($_ =~ m!^\s*\S+\s+\S+\s+([0-9]+)\s+!) {
	if ((($nojob == 0) && (defined($joblist->{$jobnumbers[$i]}))) || 
    if ($nothingremoved == 1) {
    if ($num_copies == 1) {
	    if ($option =~ m!^\s*([^=]+=[\+\-0-9\.]+)\s*$!) {
	if ($opt_l) {
    if ($page =~ m!Common UNIX Printing System!) {
    if (!pdq_check_printer($config->{'queue'})) {
	if (!pdq_check_printer($config->{'queue'})) {
    if ($pdqhelp =~ m!default\s+printer.*\s+(\S+)\s*$!mg) {
    if ($progname =~ m!^lpc!) { # 'lpc*' ==> control 
if ($progname =~ m!^lpc!) { # 'lpc*' ==> control 
	    if ($result != 0) {return $result};
		if ($result != 0) {return $result};
    # If tcp/localhost:631 opens, cups
    # If the user specified job numbers, list them. User names on the
    if ($valinuxlpr) {
	if (-x "$_/pdq") {
		# ignores non-existent options, the wrong form of the option
 -i              Interactive mode: You will be asked if $progname
	$in_config->{'queue'} = $ENV{PRINTER};
	$in_config->{'queue'} = $opt_d;
    $in_config->{'spooler'} = $s;
                 is in doubt about something. Otherwise $progname
    # is launched.
    # Is there an easier way to do this?
# It also comprises half of a programattic API for user tools: you can
	       [ jobid1 jobid2 ... ]
 jobid1 jobid2   IDs of the jobs to be removed
	    $joblist->{$job} = 1;
    @jobnumbers = sort {$b cmp $a} @jobnumbers;
# jobs with the same commands independent whether the spooler is CUPS,
	# Kill the job when it is in the scope of jobs defined by the
	     (lc($command) eq "release") || # Resume job
	     (lc($command) eq "topq")) {    # Bring job to the top of the
# learn and control everything about the properties of printing jobs
    # line.  So we read the *.status files in ~/.printjobs and generate
    # line.  "xpdq" cancels jobs by "touch"ing <job id>.cancelled
	    $listalljobs = 0;
	    $listallusers = 0;
    # listed at first
	# List the jobs on all the queues
    # List the jobs on the specified queue
	# List the jobs on the specified queue
	    # Long (3+ lines per job) mode
	       "l"   => \$opt_l);       # Long, more verbose output
# LPD, LPRng, or PDQ.
    # 'lpr*', 'lp*' ==> print 
    # lprng.
	      'lprng'=>{ 'print'    => \&print_lprng,
    # Make sure that a printer is specified when the "-a" option is not
    # many more commands. So we use the "control_lpd" function also for
	$mostrecent = 0;
	    (($mostrecent == 1) && ($nojob == 1) && ($nouser == 1) && 
	m!^\s*env_driver\s*\=\s*{.*\"LOGNAME\"\s*=\s*\"([^\"]*)\".*}\s*$!m) {
    my $action = 'all';
my $action = 'print';
    my $alljobs = "";
    my $commandline = "$sysdeps->{'cups-lpr'}";
    my $commandline = "$sysdeps->{'cups-lprm'}";
    my $commandline = "$sysdeps->{'lpd-lpc'}";
    my $commandline = "$sysdeps->{'lpd-lpr'}";
    my $commandline = "$sysdeps->{'lpd-lprm'}";
    my $commandline = "$sysdeps->{'pdq-print'}";
    my $command = shift (@ARGV);
    my ($config) = $_[0];
my $db = new Foomatic::DB;
	my $file;
    my $file_in_args = 0;
    my $firstline = 1;
	my $fromqueue = shift (@ARGV);
    my $i;
	    my $i;
my $in_config = {'queue'   => $opt_P,
	    my $job=$1;
	    my @job_contents = <STDIN>;
	my $jobid = shift (@ARGV);
    my $joblist = {};
    my @jobnumbers = ();
	my $jobstatusdata = join("", <JOBSTATUSFILE>);
	    my @lines = <LINES>;
    my $listalljobs = 1;
    my $listallusers = 1;
    my @lpqoutput = <LPQOUTPUT>;
    my $mostrecent = 1;
    my $nojob = 1;
    my $nothingremoved = 1;
    my $nouser = 1;
    my $num_copies = 1;
    my $opt_alljobs = 0;
	    my $option = $_;
	my $outputline;
	my $owner;
		my $owner_rank = "$owner: $rank";
	    my $owner_status = "$owner: $status";
    my $page = $db->getpage('http://localhost:631/', 1);
	my $printer;
    my $printer = $_[0];
my $procs = { 'lpd' => { 'print'    => \&print_lpd,
    my $queue = "";
	    my $queue = $_;
	my $queue = "";
	my @queuelist = <QUEUELIST>;
	my $queue = shift (@ARGV);
	    my ($rank, $owner, $jobid, $file, $size) = ($1, $2, $3, $4, $5);
	    my $result = 0;
	    my $result = (system "$sysdeps->{'lpd-lpq'} -P $queue @ARGV") >> 8;
	my $size;
	my $status = "";
	my $toqueue = shift (@ARGV);
	    my $user=$ARGV[$i];
    my $userlist = {};
    my $valinuxlpr = 
        my @vals = ();
	my $yn = <STDIN>;
        next if $arg->{'hidden'};
	next if ((!(defined($opt_a))) && ($printer ne $config->{'queue'}));
	next if (($listalljobs == 0) && 
	next if (($listallusers == 0) && 
	next if !open JOBSTATUSFILE, 
	next if (($status eq "") || ($status =~ m!aborted!) || 
	    $nojob = 0;
    # No job handling without knowing the name of the queue
	    # No job ID given, move all jobs in the given queue
	    # No job ID given, treat all jobs in the given queue
    # Note: '#' as option name is not supported by the Perl library
	    $nothingremoved = 0;
	# not the one of this job
	# not the owner of this job
	    $nouser = 0;
	    (($nouser == 0) && (defined($userlist->{$owner}))) ||
	# Now get the info nicely onto the screen
    # Now list the jobs
    # Now search the jobs to remove
 -\# n            Print n copies
	    $num_copies = $1;
		$num_copies = $1;
    # of the jobs to kill, the users whose jos to remove and also
	# Omit this job if job numbers are specified on the command line, but
	# Omit this job if user names are specified on the command line, but
	# Omit this job when it has no status field or when the job is
	# Omit this job when it is already finished, cancelled, or aborted
	# Omit this job when we are querying only the jobs of another printer
	# Omit this job when we want to remove jobs on another printer
    # only see ones own jobs, they are supported here to do not break
               [ -o option1=value1 -o option2 ... ] [ -i ] \
               [ -o option1=value1 -o option2 ... ] [ -i ] [ file1 file2 ... ]
 -o option       Set the switch option
 -o option=value Set option to value
	open DEFAULTFILE, "> $ENV{'HOME'}/.defaultspooler" ||
	open DEFAULTFILE, "> $sysdeps->{'foo-etc'}/defaultspooler" ||
    opendir PJDIR, "$ENV{'HOME'}/.printjobs" || 
	    open LINES, "$sysdeps->{'cups-lpq'} -P $fromqueue |";
	    open LINES, "$sysdeps->{'cups-lpq'} -P $queue |";
    open LPQOUTPUT, "$sysdeps->{'lpd-lpq'}$queue @ARGV |" || return 1;
    open PDQHELP, "pdq --help 2>&1 |";
		open PIPE, "| $commandline" || 
	open QUEUELIST, "$sysdeps->{'lpd-lpc'} status 2>&1 | grep \":\$\" | ";
	     ($opt_alljobs == 0))) {
	    $opt_alljobs = 1;
	    (($opt_alljobs == 1) && ($ENV{'LOGNAME'} eq $owner)) ||
	    (($opt_alljobs == 1) && ($ENV{'LOGNAME'} eq "root")) ||
    # option of the lprm command of BSD LPD
# option on one command line.
		 'options' => \@opt_o,
	    $option =~ s/=/_/;  # Replace only the first "="
    or $progname -C [ -s spooler ] [ -i ] command [ arguments ]
    or $progname -h
    or $progname -h [ -s spooler ] [ -P queuename ] [ -i ]
    or $progname -Q [ -s spooler ] [ -P queuename ] [ -i ] [ -a ] \
    or $progname -R [ -s spooler ] [ -P queuename ] [ - ] [ -i ] \
    or $progname -S [ -s spooler ] [ -i ]
	   "o=s" => \@opt_o,         # printing Options
	    $outputline = sprintf("%-6s %-10s % 3d  %-37s %d bytes\n",
	    $outputline = sprintf("\n%-40s [job %d]\n\t%-40s %d bytes\n",
	# Owner
	    $owner = $1;
			      $owner_rank, $jobid, $file, $size);
		    $owner_rank = substr($owner_rank, 0, 40);
				  $owner_status, $jobnumbers[$i], $file,
		$owner_status = substr($owner_status, 0, 40);
    # passe with '-J"option=value switch"'.
    # PDQ does not have functionality for enabling/disabling queues, 
    # pdq executable in our path somewhere?
    # PDQ has no possiblity to list the printing jobs from the command
    # PDQ has no possiblity to remove printing jobs from the command
    $pdqhelp = join ("", <PDQHELP>);
	    # PDQ-O-MATIC-generated configuration
	      'pdq'  =>{ 'print'    => \&print_pdq,
# -*- perl -*-
    # Personal default spooler
 -P queuename    Command should apply to this queue
        print "  $arg->{'name'} : < ";
    print "Available options for queue $config->{'queue'}:\n";
    #print "$commandline\n";
    #print "$commandline\n"; return 0;
	print "$config->{'queue'} is ready\n";
	print DEFAULTFILE "$in_config->{'spooler'}\n";
	print "   disable queue           : Make queue rejecting new jobs\n";
	print "   down queue              : Turn off queue (queueing/printing)\n";
	print "   enable queue            : Make queue accepting new jobs\n";
	# Printer
	    $printer = $1;
    # PRINTER environment variable
    # "<printer> is ready".
    # printer status at first. In PDQ the printer status cannot be
	print "   help                    : This help message\n\n";
	print "   hold queue [ jobid ]    : Hold job jobid or all jobs in queue\n";
    # Printing command
### Printing/Job manipulation functions for CUPS
### Printing/Job manipulation functions for LPD
### Printing/Job manipulation functions for LPRng
### Printing/Job manipulation functions for PDQ
        print join(' | ', @vals) . " >\n";
	    print("$line\n");
	print "       Move all jobs in oldqueue to newqueue when jobid not given\n";
	print "       Move job jobid in oldqueue to newqueue\n";
	print "   move oldqueue [ jobid ] newqueue : \n";
	print "no entries\n";
	print $outputline;
		print PIPE @job_contents;
	    print "$queue\n";
		print "Rank   Owner       Job File(s)                               Total Size\n";
		print "Rank   Owner      Job  File(s)                               Total Size\n";
	print "   release queue [ jobid ] : Release job jobid or all jobs in queue\n";
		print sprintf("%-6s %-8s % 6d %-37s %d bytes\n",
		print sprintf("\n%-40s [job %d]\n\t%-40s %d bytes\n",
	print "   start queue             : Turn on printing on queue\n";
	print "   status [ queue ]        : Status of queue or of all queues\n";
	    print STDERR "Cancel request for job $jobnumbers[$i] submitted!\n";
     print STDERR <<EOF;
    print STDERR <<EOF;
	print STDERR <<EOF;
	print STDERR <<EOF; 
	print STDERR "no cancel request sent\n";
	print STDERR "You appear to be using $s.  Correct? ";
	print "   stop queue              : Turn off printing on queue\n";
	print "The following control commands are available:\n\n";
	print "   topq queue jobid        : Print job jobid in queue immediately\n";
	print "   up queue                : Turn on queue (queueing/printing)\n";
    # (probably still waiting) jobs removed at first
$progname = $1;
	    push (@jobnumbers, $1);
            push @vals, $val->{'value'};
	   "Q"   => \$opt_Q,         # Query jobs in queue
 -Q              Query the jobs in a queue
			 'query'    => \&query_cups,
			 'query'    => \&query_lpd,
			 'query'    => \&query_lprng,
			 'query'    => \&query_pdq,
	                                    # queue
                 queue is specified
	    $queue = " -P $config->{'queue'}";
	$queue = " -P $config->{'queue'}";
	    $queue =~ s/:$//;
			      $rank, $owner, $jobid, $file, $size);
    # Read additional options
    # Read in the names of all job status files in ~/.printjobs/
# Read out the program name with which we were called, but discard the path
    # Read the help message of PDQ
	# Read the job status file
    # Remove a job with the standard "lprm" command
    # Remove a job with the standard "lprm" command and emulate the "-"
 -               Remove all your jobs
# remove queues, query queue, printer, and driver info.
			 'remove'   => \&remove_cups,
		         'remove'   => \&remove_lpd,
			 'remove'   => \&remove_lprng,
			 'remove'   => \&remove_pdq,
    # Removing command
    # Replace the "-" option by the "all" option
		$result = (system $commandline) >> 8;
    # retrived from the command line, so we put a dummy line
	    return;
	    return 0;
	return 0;  # No ~/.printjobs/ directory ==> no jobs
	return $1;
	return 'cups';
	    return 'lpd';
	    return 'lprng';
	    return 'pdq';
    return ($pdqhelp =~ m!^\s+$printer\s+\-\s+.*\s+\-\s*$!mg);
    return (system $commandline) >> 8;
	return (system $commandline) >> 8;
	return (system "$sysdeps->{'cups-accept'} @ARGV") >> 8;
	return (system "$sysdeps->{'cups-disable'} @ARGV") >> 8;
	return (system "$sysdeps->{'cups-disable'} @ARGV; $sysdeps->{'cups-reject'} @ARGV") >> 8;
	return (system "$sysdeps->{'cups-enable'} @ARGV") >> 8;
	return (system "$sysdeps->{'cups-enable'} @ARGV; $sysdeps->{'cups-accept'} @ARGV") >> 8;
	return (system "$sysdeps->{'cups-lpc'} status @ARGV") >> 8;
	    return (system "$sysdeps->{'cups-lp'} -i $queue-$jobid -H $command") >> 8;
	    return (system "$sysdeps->{'cups-lpmove'} $fromqueue-$jobid $toqueue") >> 8;
    return (system "$sysdeps->{'cups-lpq'}$queue @ARGV") >> 8;
	return (system "$sysdeps->{'cups-reject'} @ARGV") >> 8;
	return (system "$sysdeps->{'lpd-lpq'}$queue @ARGV") >> 8;
    return undef;
	   "R"   => \$opt_R,         # Remove job(s)
 -R              Remove a job from a queue
    # Say "No cancel request sent" if no job was killed
    # Say "no entries" if no job was listed
	$s = `cat $ENV{'HOME'}/.defaultspooler`;
	$s = `cat $sysdeps->{'foo-etc'}/defaultspooler`;
	$s = detect_spooler();
    # Search the appropriate printer entry
    # Search the "default" line
	# Set personal default spooler
	# Set system default spooler
# Set up the help message depending on how we were called
	    # Short (1 line per job) mode
				  $size);
	# Size of job input file
	    $size = (stat("$ENV{'HOME'}/.printjobs/$jobnumbers[$i].raw"))[7];
	   "S"   => \$opt_S,         # set default Spooler
    # Sort the filenames in descending order to get the most recent
    # Sort the filenames in descending order to get the most recent jobs
		# so we give the option in both styles. Since PDQ silently
	    splice(@ARGV,$i,1);
		splice(@ARGV,$i,2);
                 spooler, but the same commands given under different 
		 'spooler' => $opt_s};
                 spoolers do the same thing.
    # spooler-specific options
 -S              Save the chosen spooler as the default spooler
	   "s=s" => \$opt_s,         # which Spooler?
 -s spooler      Explicit spooler type (cups,lpd,lprng,pdq)
    # standard lpq, emulate -a of lpq-cups
	# Status:
	    $status = $1;
		 ($status =~ m!finished!) || ($status =~ m!cancelled!));
				  $status, $owner, $jobnumbers[$i], $file,
	$status =~ s/\s//g;
sub control_cups {
sub control_lpd {
sub control_lprng {
sub control_pdq {
sub detect_spooler {
sub get_pdq_default_printer {
sub help {
sub help_options {
sub pdq_check_printer {
sub print_cups {
sub print_lpd {
sub print_lprng {
sub print_pdq {
sub query_cups {
sub query_lpd {
sub query_lprng {
sub query_pdq {
sub remove_cups {
sub remove_lpd {
sub remove_lprng {
sub remove_pdq {
sub unimp {
    #sysdeps->{'lpd-lpr'} = "/home/test/lpr-0.71/lpr/lpr";
    # System default spooler
	!(system "strings $sysdeps->{'lpd-lpr'} | grep option > /dev/null");
		    system "$sysdeps->{'cups-lp'} -i $queue-$1 -H $command";
		    system "$sysdeps->{'cups-lpmove'} $fromqueue-$1 $toqueue";
	    system("touch $ENV{'HOME'}/.printjobs/$jobnumbers[$i].cancelled; chmod 0600 $ENV{'HOME'}/.printjobs/$jobnumbers[$i].cancelled");
		 the control command "help" to get a list of supported 
    # the files to print and also spooler-specific options
	# The first argument is always the queue
	# The first argument is always the source printer
    # The first command line argument (of the remaining ones) is the
	    # the "=" has to be replaced by "_" to work with the
    # the job entry lines from that information.
    # The lpc command of lprng is compatible to the one of LPD, it has only
        # (then it cannot be killed any more)
    # The "-#" option for multiple copies is not supported by the print
	    # There's a /usr/sbin/lpd
	# The second argument is the job ID
	# The second argument is the job ID or the destination
	# The third argument is the destination
    # this functionality with the command line tools of CUPS.
# This is foomatic-printjob, a program to print and manage printing
    # to 0600.
	    # to print multiple copies
	    $toqueue = $jobid;
	    # Treat the specified job
	unless $s;
Usage: $progname [ -s spooler ] [ -i ] command [ arguments ]
Usage: $progname [ -s spooler ] [ -P queuename ] \
Usage: $progname [ -s spooler ] [ -P queuename ] [ -i ] [ -a ] [ user1 user2 ... ]
Usage: $progname [ -s spooler ] [ -P queuename ] [ - ] [ -i ] [ jobid1 jobid2 ... ]
use Foomatic::DB;
use Foomatic::Defaults;
use Getopt::Long;
	       [ user1 user2 ... ]
 user1 user2 ... Users whose jobs should be listed
	    $userlist->{$user} = 1;
		 uses auto-detection or quits with an error.
	# Use spoolers default
#!/usr/bin/perl
	# VA-Linux/gnulpr
    # We filter the output of lpq and rearrange it to have the same format
	    # We print files
	    # We print from standard input, so we must buffer it to be able
# We use the library Getopt::Long here, so that we can have more than one "-o"
    # When we list only the jobs for a specific printer, display the
    while ($filename = readdir(PJDIR)) {
	    while (length($job) < 3) {$job = "0" . $job;}
		# will be ignored.
    # will be modified appropriately directly before the printing command
                 will be printed
    # with its arguments
    # with '-o option=value -o switch', for the BSD implementation they are
