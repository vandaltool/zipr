        }
            $< = $> = 0;
            $( = $) = 0;
0 on success, with 2 if the server is already running, and with 1 on other
1 on other failure conditions. This mode should only be used when the machine
$action = shift @ARGV;
%actions = ('start' => \&start, 'stop' => \&stop, 'reload' => \&reload,
A log file for this specific cluster is created if it does not exist yet (by
and a PostreSQL server process (L<postmaster(1)>) is started on it. Exits with
and data path and calls the right version of B<pg_ctl> with appropriate
# Arguments: <pid file path>
# Arguments: <version> <cluster> <port> <socket dir>
at the next start. If this still does not help, the B<postmaster> process is
#  (at your option) any later version.
B<pg_ctlcluster> [I<options>] I<cluster-version> I<cluster-name> I<action> B<--> [I<pg_ctl options>]
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
# (C) 2005-2009 Martin Pitt <mpitt@debian.org>
# (C) 2009 Cyril Bouthors <cyril@bouthors.org>
Causes the configuration files to be re-read without a full shutdown of the
            change_ugid $info{'owneruid'}, $info{'ownergid'};
    change_ugid $info{'owneruid'}, $info{'ownergid'};
    chdir ('/var/lib/postgresql');
    # check conflicting port
# Check for known broken configurations of this cluster
# check if a cluster reliably connects or fails
# Check if a pid file is not present or it is invalid. If so, clean up/abort.
# check that owner uig/gid is valid
    check_valid_config;
        # check whether /var/run/postgresql/ is writeable as the cluster owner
    chmod 0640, $info{'logfile'};
        chomp $pid;
    chown $info{'owneruid'}, $g, $info{'logfile'};
	    close F;
    close L;
	close PIDFILE;
            close STDOUT;
($cluster) = $cluster =~ /^([^'"\s]+)$/; # untaint
$cluster = shift @ARGV;
configuration parameters and paths.
# configuration parameters to 'start', and makes sure that a postmaster really
    $currlogsize = 0;
        $currlogsize = (stat $info{'logfile'})[7] if $info{'logfile'} && -r $info{'logfile'};
C</var/log/postgresql/postgresql->I<cluster-version>C<->I<cluster-name>C<.log>),
default,
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
description of valid options.
        dup2(POSIX::open('/dev/null', POSIX::O_WRONLY), 1);
        dup2(POSIX::open('/dev/null', POSIX::O_WRONLY), 2);
        } else {
    } else {
} else {
	} elsif (-w '/proc/self/oom_adj') {
$ENV{'PATH'} = '/sbin:/bin:/usr/sbin:/usr/bin';
    $ENV{'PGPASSWORD'} = 'foo'; # prevent hangs if superuser cannot connect withouth password
    %ENV = read_cluster_conf_file $version, $cluster, 'environment';
    error 'Cluster is disabled' if $info{'start'} eq 'disabled';
    error 'cluster_port_ready: could not find psql binary' unless $psql;
	error 'Could not create log file ' . $info{'logfile'};
        error "could not exec $pg_ctl @options: $!" if $?;
                error "Could not open log file " . $info{'logfile'};
    error 'Error: invalid action (must be one of: '. 
    error $info{'pgdata'} . ' is not accessible or does not exist';
	error 'invalid postgresql.conf: log_statement_stats and the other log_*_stats options are mutually exclusive';
	error 'pid file is invalid, please manually kill the stale server process.';
        error("Port conflict: another instance is already running on $sockdir with port $info{'port'}");
error 'specified cluster does not exist' unless $version && $cluster && cluster_exists $version, $cluster;
    error 'The cluster is owned by group id '.$info{'ownergid'}.' which does not exist any more'
    error 'The cluster is owned by user id '.$info{'owneruid'}.' which does not exist any more'
    error 'You must run this program as the cluster owner ('.
essentially wraps the L<pg_ctl(1)> command. It determines the cluster version
    exec $pg_ctl, '-D', $info{'pgdata'}, '-s', @pg_ctl_opts_from_cli, 'reload';
            exec $pg_ctl, '-D', $info{'pgdata'}, '-s', '-w', '-m', 'fast', @pg_ctl_opts_from_cli, 'stop';
            exec $pg_ctl, '-D', $info{'pgdata'}, '-s', '-w', @pg_ctl_opts_from_cli, 'stop'; 
        exec $pg_ctl @options or error "could not exec $pg_ctl @options: $!";
        exit 1;
    exit 1;
exit 1 unless GetOptions ('o|options=s' => \@postmaster_auxoptions,
        exit 2;
    exit 2;
    exit $actions{$action}->();
    # external_pid_file files are currently not removed by postmaster itself
failure conditions.
    'f|force' => \$force);
for a description of valid options.
foreach my $argv (@ARGV) {
    for (my $attempt = 0; $attempt < 60; $attempt++) {
        (getpwuid $info{'owneruid'})[0].')';
	$g = (getgrnam 'adm')[2];
	$g = $info{'ownergid'};
#  GNU General Public License for more details.
    # have the postmaster start with increased OOM killer protection; 9.1 and
=head1 ACTIONS
=head1 AUTHOR
=head1 DESCRIPTION
=head1 FILES
=head1 NAME
=head1 OPTIONS
=head1 SEE ALSO
=head1 SYNOPSIS
        if ($> == 0) {
if ($> == 0) {
    if ($action eq 'start' && $version ge '9.1') {
if ($actions{$action}) {
# If a pid file is already present, delete it if it is stale/invalid, or exit
if ($#ARGV < 2) {
        if (cluster_port_running $version, $cluster, $info{'port'}) {
    if (cluster_port_running $version, $cluster, $info{'port'}) {
	if defined $pg_ctl_opts_from_file{'pg_ctl_options'} and $pg_ctl_opts_from_file{'pg_ctl_options'} ne '';
    if ((-d '/var/run/postgresql') && !defined (PgCommon::get_conf_value $version, $cluster, 'postgresql.conf', 'external_pid_file')) {
    if (-e $pidfile) {
        if (-f $info{'pgdata'}.'/postmaster.pid') {
    if ($force) {
        if (!fork()) {
    if (fork) {
    if ($info{'logfile'}) {
if ($info{'logfile'} && ! -e $info{'logfile'}) {
if( $> != $info{'owneruid'} ) {
    if ($info{'owneruid'} < 500) {
    if ($info{'running'}) {
        if ($logsize) {
    if ($log_statement_stats && ($log_parser_stats || $log_planner_stats ||
    if (open PIDFILE, $_[0]) {
    if ($out =~ 'FATAL:') {
    if (PgCommon::check_pidfile_running $pidfile) {
    if (!(PgCommon::get_conf_value $version, $cluster, 'postgresql.conf', 'hba_file')) {
    if (!(PgCommon::get_conf_value $version, $cluster, 'postgresql.conf', 'ident_file')) {
    if (!(PgCommon::get_conf_value $version, $cluster, 'postgresql.conf', 'unix_socket_directory')) {
        if ($? == $result) {    
    if ($result == 0) {
    if (!$success) {
    if ($success) {
        # if that still not helps, use the big hammer
        # if the postmaster wrote something, but the process does not exist any
        if ($vrp_writable) {
        if (-w '/proc/self/oom_score_adj') {
%info = cluster_info ($version, $cluster);
is about to be shut down.
=item B<-o> I<option>
=item B<reload>
=item B<restart>
=item B<start>
=item B<stop>
=item C</etc/postgresql/>I<cluster-version>C</>I<cluster-name>C</pg_ctl.conf>
=item I<pg_ctl options>
#  it under the terms of the GNU General Public License as published by
        (join ', ', keys %actions);
            kill (9, $pid) if $pid;
killed.  Exits with 0 on success, with 2 if the server is not running, and with
            last;
        last if ($currlogsize > $logsize && !PgCommon::check_pidfile_running $pidfile);
    # later has builtin support for resetting the adjustment of child processes
leave the cluster in an inconsistent state and thus will lead to a recovery run
	$log_executor_stats)) {
    $logsize = 0;
        $logsize = (stat $info{'logfile'})[7];
L<pg_ctl(1)>.
L<pg_ctl(1)>, L<pg_wrapper(1)>, L<pg_lsclusters(1)>, L<postmaster(1)>
Martin Pitt L<E<lt>mpitt@debian.orgE<gt>>
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
mode is used, which waits until all clients disconnected.
        # more, there must be a problem and we can stop immediately
# multiversion/cluster aware pg_ctl wrapper; this also supplies the correct
    my $cdir = $info{'configdir'};
    my $g;
    my $log_executor_stats = config_bool $postgresql_conf{'log_executor_stats'};
    my $log_parser_stats = config_bool $postgresql_conf{'log_parser_stats'};
    my $log_planner_stats = config_bool $postgresql_conf{'log_planner_stats'};
    my $log_statement_stats = config_bool $postgresql_conf{'log_statement_stats'};
    my $n = 0;
    my $out;
    my %pg_ctl_opts_from_file = read_cluster_conf_file $version, $cluster, 'pg_ctl.conf';
    my $pidfile = $info{'pgdata'}.'/postmaster.pid';
    my $pid = get_running_pid $pidfile;
	my $pid = <PIDFILE>;
    my %postgresql_conf = read_cluster_conf_file $version, $cluster,
    my $postmaster_opts = '';
    my $psql = get_program_path 'psql', $v;
    my $result;
    my $result = 0;
    my $result = 1;
        my $sockdir = get_cluster_socketdir $version, $cluster;
    my ($v, $c, $p, $sd) = @_;
        my $vrp_writable;
            $n++;
            $n = 0;
    # OK, the server runs, now wait until it stabilized
    # only supply or default logfile path when none is given explicitly in
	    open F, '>/proc/self/oom_adj';
	    open F, '>/proc/self/oom_score_adj';
    open L, '>', $info{'logfile'} or 
            open LOG, $info{'logfile'} or 
    @options = ($pg_ctl, 'start', '-D', $info{'pgdata'});
        $out = `$psql -h '$sd' --port $p -l 2>&1 >/dev/null`;
Pass given I<option> as command line option to the C<postmaster> process. It is
Pass given I<pg_ctl options> as command line options to pg_ctl. See L<pg_ctl(1)>
pg_ctlcluster - start/stop/restart/reload a PostgreSQL cluster
$pg_ctl = get_program_path 'pg_ctl', $version;
@pg_ctl_opts_from_cli=();
            $pid = get_running_pid $info{'pgdata'}.'/postmaster.pid';
        ($pid) = $pid =~ /^(\d+)\s*$/; # untaint
possible to specify B<-o> multiple times. See L<postmaster(1)> for a
        'postgresql.conf';
    # postgresql.conf
    $postmaster_opts .= " -c config_file=\"$cdir/postgresql.conf\""; 
            $postmaster_opts .= " -c external_pid_file=\"/var/run/postgresql/$version-$cluster.pid\"";
        $postmaster_opts .= " -c hba_file=\"$cdir/pg_hba.conf\"";
        $postmaster_opts .= " -c ident_file=\"$cdir/pg_ident.conf\""; 
	$postmaster_opts .= '-c unix_socket_directory="' . $info{'socketdir'} . '"';
    $postmaster_opts .= ' ' . (join ' ', @postmaster_auxoptions);
    ($postmaster_opts) = $postmaster_opts =~ /(.*)/; # untaint
    # prepare environment
        print "Cluster is already running.\n";
    print "Cluster is not running.\n";
            print "(does not shutdown gracefully, now stopping immediately)\n";
            print "(does not shutdown, killing the process)";
	    print F "-16\n";
	    print F "-900\n";
	print "Removed stale pid file.\n";
            print STDERR "The PostgreSQL server failed to start. Please check the log output:\n";
            print STDERR "The PostgreSQL server failed to start. Please check the log output.\n";
	print STDERR "WARNING: connection to the database failed, disabling startup checks:\n$out\n";
            print STDERR $_ while <LOG>;
    print "Usage: $0 <version> <cluster> <action>\n";
    # probe until we get three successful or failed connections in a row
        push @options, ('-l', $info{'logfile'});
    push @options, @pg_ctl_opts_from_cli if @pg_ctl_opts_from_cli;
    push @options, ('-s', '-o', $postmaster_opts);
    push @options, split(' ', $pg_ctl_opts_from_file{'pg_ctl_options'})
    push @pg_ctl_opts_from_cli, $argv =~ /(.*)/; # untaint
# recreate missing log file
        # remember current size of the log
    # Remove invalid or stale PID file
            'restart' => \&restart);
        $result = $?;
	    $result = 0;
	    $result = $? >> 8;
	$result = stop;
	    $result = system $pg_ctl, '-D', $info{'pgdata'}, '-s', '-w', '-m', 'immediate', @pg_ctl_opts_from_cli, 'stop';
    return 0;
	return cluster_port_running $v, $c, $p;
    return if (defined $pid && PgCommon::check_pidfile_running $pidfile); 
	return $pid;
    return !$result;
    return $result;
	return $result if $result;
    return start;
# Return the PID from an existing PID file or undef if it does not exist.
	return undef;
    return undef unless -e $_[0];
            seek LOG, $logsize, SEEK_SET;
        select (undef, undef, undef, 0.5);
        select undef, undef, undef, 0.5;
        setsid or error "could not start session: $!";
    start_check_pid_file;
    # statement and other statistics are mutually exclusive
    stop_check_pid_file;
# stops on 'stop'.
Stops the L<postmaster(1)> server of the given cluster. By default, "smart"
Stops the server if it is running and starts it (again).
sub check_valid_config {
sub cluster_port_ready {
sub get_running_pid {
sub reload {
sub restart {
sub start {
sub start_check_pid_file {
sub stop {
sub stop_check_pid_file {
    $success = 0;
            $success = 1;
	$success = cluster_port_ready $version, $cluster, $info{'port'}, $info{'socketdir'};
that does not work, shutdown is attempted again in "immediate" mode, which can
#  the Free Software Foundation; either version 2 of the License, or
This configuration file contains cluster specific options to be passed to
This program controls the B<postmaster> server for a particular cluster. It
#  This program is distributed in the hope that it will be useful,
#  This program is free software; you can redistribute it and/or modify
transactions, disconnects clients immediately and thus shuts down cleanly. If
        # try harder if "fast" mode does not work
unless ($action eq 'stop') {
unless (-d $info{'pgdata'} && defined $info{'owneruid'}) {
unless (getgrgid $info{'ownergid'}) {
unless (getpwuid $info{'owneruid'}) {
	unlink $pidfile;
	unlink "/var/run/postgresql/$version-$cluster.pid";
# untaint environment
use Fcntl 'SEEK_SET';
use Getopt::Long;
use lib '/usr/share/postgresql-common';
use PgCommon;
use POSIX qw/setsid dup2 setlocale LC_ALL :sys_wait_h/;
#!/usr/bin/perl -wT
$version = shift @ARGV;
($version) = $version =~ /^(\d+\.\d+)$/; # untaint
            $vrp_writable = -w '/var/run/postgresql';
            wait;
        wait;
    # wait a bit until the socket exists
where I<action> = B<start>|B<stop>|B<restart>|B<reload>
    while ($n < ($result ? 10 : 3)) {
# with a notice if it belongs to an already running postmaster.
	# without this, you'll get zombies on startup
With the B<--force> option the "fast" mode is used which rolls back all active
You have to start this program as the user who owns the database cluster or as
