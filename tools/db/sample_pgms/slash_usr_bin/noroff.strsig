   $AWK '{
base="`basename $1 | sed '/\./s/\.[^.]*$//'`"
	 # BEGIN { str = "abc[[foo[i]]]]]]]]junk"
#!/bin/sh
		break;
	case $1 in
 cat "$@") |
	                                               chunkuse = chunkdefn = "" }
   cp $tagsfile $tagstemp
(echo ".so $macrodir/noweb.tmac"
  echo "Usage: noroff [groff-arguments] files" 1>&2
	     else if (sub(/^###BEGINCHUNKS###/, "")) printf ".de CLIST\n.CLISTBEGIN\n"
	     else if (sub(/^###BEGININDEX###/ , "")) printf ".de ILIST\n.ILISTBEGIN\n"
	     else if (sub(/^###CHUNKBEGIN### /, "")) { name = convquote($0)
	     else if (sub(/^###CHUNKDEFN### / , "")) chunkdefn = chunkdefn " " tag($0)
	     else if (sub(/^###CHUNKEND###/   , ""))
	     else if (sub(/^###CHUNKUSE### /  , "")) chunkuse = chunkuse " " tag($0)
	     else if (sub(/^###ENDCHUNKS###/  , "")) printf ".CLISTEND\n..\n"
	     else if (sub(/^###ENDINDEX###/   , "")) printf ".ILISTEND\n..\n" 
	     else if (sub(/^###ENTRYBEGIN### /, "")) { name = convquote($0)
	     else if (sub(/^###ENTRYDEFN### / , "")) entrydefn = entrydefn " " tag($0)
	     else if (sub(/^###ENTRYEND###/   , "")) {
	     else if (sub(/^###ENTRYUSE### /  , "")) entryuse = entryuse " " tag($0)
	*)	# end of options
	                                               entryuse = entrydefn = "" }
  exit 1
	         for (i = 1; i <= split(entrydefn, entryarray); i++)
	 		front = substr(s, 1, RSTART - 1)
	 		front = substr(s, 1, RSTART - 1 + RLENGTH - 2)
         function convquote(s,	out, front, mid, tail) {
	 function tag(s) { if (s in tags) return tags[s]; else return "???" }' $tagstemp
	# groff already defaults to -Tps
	     gsub(/\[\[/, "\\*[BEGINCONVQUOTE]", s)
	     # gsub(/\]\]/, "\\*[ENDCONVQUOTE]", s)
if [ $# -eq 0 ]; then
if [ "$opts" = "" ]
	 	if (RLENGTH == 2) # easy
if [ -r "$tagsfile" ]; then 
	     if      (sub(/^###TAG### /       , "")) tags[$1] = $2
macrodir=/usr/share/groff/tmac
	     mid = "\\*[ENDCONVQUOTE]"
	 # my test program for the revised function - ADR
	# no options, default to -mm
# noroff -- run troff using tags file trick
	opts="-mm"
	-*)	opts="$opts $1"
# otherwise assume user passed in all the arguments they want
	     out = ""
	 	out = out front mid
	     out = out s
	 #	print convquote(str)
	 #	print convquote(str2)
	 #	print convquote(str3)
	        printf ".CITEM \"%s\" \"%s\" \"%s\"\n", name, chunkdefn, chunkuse
	         printf ".IITEM \"%s\" \"%s\"\n", name, entryuse }
	 #	print str
	 #	print str2
	 #	print str3
	     return out }
	     	# RLENGTH is length of match, want to remove last two chars
   rm -f $tagstemp
ROFF="groff"
($ROFF $opts 2>$tagsfile)
	 	# RSTART is where sequence of ]s begins
sed '/^###[A-Z][A-Z]*###/d' $tagsfile >&2
	 	s = tail
	 #	str2 = "nothing here"
	 #	str3 = "abc[[foo[i]]]]]]]]junk[[bar[i]]more stuff[[baz]]"
	             sub(entryarray[i], "\\*[BEGINDEFN]&\\*[ENDDEFN]", entryuse)
tagsfile="$base.nwt"
   tagstemp=$(tempfile -p tags) || { echo "$0: Cannot create temporary file" >&2; exit 1;  }
	 	tail = substr(s, RSTART + RLENGTH)
while [ $# -gt 0 ]
	     while (match(s, /\]\]+/) != 0) {
