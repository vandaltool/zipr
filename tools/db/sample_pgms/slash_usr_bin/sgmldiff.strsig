#---------------------------------------------------------------------
#----------------------------------------------------------------------
	    }; 
		    };
	      -a, --attributes includes the attribute values in the diff
	    "a|attributes!" => \$opt_a,
# - add text occurrences to diff file, such that diff has a bit more
		    # -a includes the attribute values in the diff
# along with this program; if not, write to the Free Software
                  also be combined: -c nesting,attributes
                       # and show precise context position of error
an example (e.g. the input that caused this message)";
	    # as yet never printed out
	    @attributes = ();
		    @attributes = (@attributes, "$attr=\"$1\"");
# (at your option) any later version.
# but WITHOUT ANY WARRANTY; without even the implied warranty of
                    # -c add some context to improve the diff results
              -c, --context    adds more context to the diff, which may
	    "c|context=s" => \$opt_c);
		    $char = "";
		    $char = $c;
		    $char .= $c;
# Check number of arguments
    chomp $_;
	chomp $_;
chomp(my $progname = `basename $0`);
# Clean up
    close(DIFF);
    close(ESIS);
close(SDIFF);
	$command = $4;
	  ."$command$lines2[$start2]"
#   context; it might help in some cases (and perhaps ruin it in others).
# Copyright (C) 2000 Frederik Fouvry
	delete $statistics{files};
		die "State `$state' does not exist, stopped ";
		    die "Unrecognised construction"; 
# differences to the user (@full).  For more info: see SP
		# `\\%\d+;' is character number in document character set
		# `\\#\d+;' is character number in internal character set
# documentation, nsgmls output format.
# Do diff and rebuild the original input
	    # don't do anything
                    # don't print anything
		    @e_attributes = (@e_attributes, "$attr=\"$1\"");
	    } else {
	    } else { };
	} else {
		} else {
	    else { die "Wrong statistics value"};
		} else { # length == 2
	} else {               # normal case
	} elsif ($_ =~ /^-(.*)$/) {
	} elsif ($_ =~ /^{(.*)$/) {
	} elsif ($_ =~ /^}(.*)$/) {
	} elsif ($_ =~ /^\?(.*)$/) {
	} elsif ($_ =~ /^\)(.+)$/) {
	} elsif ($_ =~ /^\&(.*)$/) {
	} elsif ($_ =~ /^#(.*)$/) {
	} elsif ($_ =~ /^A(\S+)\s+(IMPLIED|CDATA (.*)|NOTATION (.*)|ENTITY (.*)|TOKEN (.*)|ID (.*))$/) {
	} elsif ($_ =~ /^a(\S+)\s+(\S+)\s+(.*)$/) {
	} elsif ($_ =~ /^C$/) {
		} elsif ($c =~ /^[0-7]$/) { # character
	} elsif ($c eq "\\") { # an escape starts
		} elsif ($c eq "%" || $c eq "#") { # character
		} elsif ($c eq "n") { # newline
		} elsif ($c eq "|") { # pipe
	} elsif ($_ =~ /^D(\S+)\s+(IMPLIED|CDATA (.*)|NOTATION (.*)|ENTITY (.*)|TOKEN (.*)|ID (.*))$/) {
	} elsif ($_ =~ /^e$/) {
	} elsif ($_ =~ /^E(\S+)\s+(CDATA|NDATA|SDATA)\s+(.*)$/) {
	} elsif ($_ =~ /^f(.*)$/) {
	} elsif ($_ =~ /^i$/) {
	} elsif ($_ =~ /^I(\S+)\s+(CDATA|SDATA|PI|TEXT)\s+(.*)$/) {
	    elsif ($k eq "notation") { $stat_text1 .= "<!NOTATION"; }
	    elsif ($k eq "subdocument") { $stat_text1 .= "<!SUBDOC"; }
	    elsif ($k eq "text") { $stat_text1 .= "Entity"; }
	} elsif ($_ =~ /^L((\d+)( (.+))?)$/) {
		    } elsif ($m eq "sysid" && defined($value)) {
	} elsif ($_ =~ /^N(.*)$/) {
	} elsif ($_ =~ /^p(.*)$/) {
	} elsif ($_ =~ /^s(.*)$/) {
	    } elsif ($state eq "decchar") { # reading a character code
	    } elsif ($state eq "octchar") { # reading a charactre code
	} elsif ($_ =~ /^T(.*)$/) {
	    } elsif ($typ =~ /^PI$/) {
	    } elsif ($typ =~ /^SDATA$/) {
	    } elsif ($typ =~ /^TEXT$/) {
		} elsif ($val =~ /^CDATA (.*)$/) {
		} elsif ($val =~ /^ENTITY (.*)$/) {
		} elsif ($val =~ /^ID (.*)$/) {
		} elsif ($val =~ /^NOTATION (.*)$/) {
		} elsif ($val =~ /^TOKEN (.*)$/) {
	    $empty = 0;
	    $empty = 1;
    $end1 = $start1+$d1; 
    $end2 = $start2+$d2;
$errorlog = "-f /dev/null";
$errors = "-E0 -e -g"; # allow any number of errors
    exit 0;
		      external_data => {},
		      files => {});
	    $f_info = "";
	    $f_info = "$1";
    foreach $c (@string) {
	foreach my $f (keys %{$statistics{files}}) {
	foreach my $k (keys %statistics) {
	    foreach my $l (keys %{$statistics{$k}}) {
		foreach my $m (keys %{$statistics{$k}->{$l}}) {
	    # for elements that are allowed by inclusion exception
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
# Frederik Fouvry <fouvry@sfs.nphil.uni-tuebingen.de>.
# Get file name
&GetOptions("h|help" => \$opt_h, 
# Get structure of the files
# GNU General Public License for more details.
              -h, --help       prints this usage information
                    # -h prints help
	if ($_ =~ /^\((.+)$/) {
		if (@attributes > 0 && defined($opt_a) && $opt_a == 1);
		if ($c eq "\\") { # slash
		if ($c ne ";") {
    if ($_ =~ /^(\d+)(,(\d+))?([acd])(\d+)(,(\d+))?$/) {
	if (defined $3) { $d1 = $3-$1; } else { $d1 = 0; }; 
	if (defined $7) { $d2 = $7-$5; } else { $d2 = 0; }; 
    if (defined $opt_s && $opt_s == 1) {
	if (defined $state) { # we're in an escape sequence
		if (defined($value) && $value ne "") {
	    if ($k eq "external_data") { $stat_text1 .= "<!ENTITY"; }
		if (length($char) < 2) {
		    if ($m eq "pubid" && defined($value)) {
		# (if not representable by output encoding)
	    if ($opt_a == 1) {
if ($opt_h == 1 || @ARGV != 2) {
if ($opt_v == 1) {
	    if ($state eq "escape") { # which just started
	if ($stat_text ne "") {
	    if ($typ =~ /^CDATA$/) {
		if ($val eq "IMPLIED") {
                  improve the results.  It takes \"attributes\", \"textpos\"
	    $indent .= " " if $opt_c =~ /nesting/;
	    $indent = substr($indent,0,-1) if $opt_c =~ /nesting/;
# Initialise
# it under the terms of the GNU General Public License as published by
	    $line = $2;
	    $line += $#a;
	  .($lines1[$end1] > $lines1[$start1] ? ",$lines1[$end1]" : "")
	  .($lines2[$end2] > $lines2[$start2] ? ",$lines2[$end2]" : "")
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    my ($a) = @_;
	    my @a = split(/\\n/, $data);
		my $attr = $1;
    my @attributes;
    my ($char,$state,$c);
	    my $data = $1;
my $diff1 = "$file1.difftmp$$";
my $diff2 = "$file2.difftmp$$";
    my @e_attributes;
my $file1 = $ARGV[0];
my $file2 = $ARGV[1];
    my($filename,$todiffname) = @_;
    my @full = ();
	    my $gi = $1;
my $indent = "";
    my $line = 0;
    my @line_numbered = ();
my ($lines1,@allfile1) = &prepare($file1, $diff1);
my @lines1 = split(/@/,$lines1);
my ($lines2,@allfile2) = &prepare($file2, $diff2);
my @lines2 = split(/@/,$lines2);
	    my $name = $1;
my $nsgmls;
my ($opt_a, $opt_s, $opt_h, $opt_v, $opt_c) = (0, 0, 0, 0, "");
    my $result = "$prefix";
    my ($start1, $start2, $command, $d1, $d2, $end1, $end2);
    my %statistics = (notation => {},
	my $stat_text = "";
	    my $stat_text1;
    my @string;
    my($string,$prefix) = @_;
    my ($system_identifier, $public_identifier, $f_info, $empty) = ("", "", "");
	    my $typ = $2;
		my $val = $2;
	    my $val = $3;
		my $value = $statistics{$k}->{$l}->{emsysid};
		    my $value = "$statistics{$k}->{$l}->{$m}";
	    my_warn($_);
		my_warn($typ);
	  ."\n";
    # New difference
# Normalise data text from nsgmls (i.e. don't print the escaped text).
# Note: the input file need not be valid, nor is it necessary to have 
$nsgmls = "/usr/bin/nsgmls";
		# (numeric char ref to non-SGML chars in fixed char set mode)
	    # only line is set; nothing else is done
	    # only output with the option -oempty
	    # only output with the option -oincluded
    open(DIFF, "> $todiffname");
    open(ESIS, "$nsgmls -l $errors $errorlog -onotation-sysid -oid -oempty $filename | ");  #-oentity generates strange output; ? -ononsgml
open(SDIFF,"diff $diff1 $diff2 |");
$opt_a = 1 if $opt_c =~ /attributes/; # -c attributes = -a
                  or \"nesting\" as an argument e.g. -c textpos, which can 
Please send a message to the maintainer (see source file) and include 
	    print DIFF "&$1;";
	    print DIFF "<?$1>\n";
	    # print DIFF "----------$4----------\n" if defined($4); 
	    print DIFF "$indent<$1";
	    print DIFF "$indent</$gi>\n" unless $empty;
	    print DIFF " ".join(" ",@attributes)
	    print DIFF ">\n";
	    print DIFF ($opt_c =~ /textpos/ ? "-" : "")."\n";
		print DIFF "$val";
    print "$lines1[$start1]"
    # Print lines of first file
    # Print lines of second file
    print "---\n";
	print &normalise_text($allfile1[$start1++],"< ");
	print &normalise_text($allfile2[$start2++],"> ");
    print STDERR "DocBook-utils version 0.6.14 (sgmldiff v$VERSION)
	    print STDERR "  $f\n";
	    print STDERR "====================\n";
	print STDERR "--------------------\n";
	    print STDERR "No SGML information for `$filename'\n"
	    print STDERR "SGML information for `$filename':\n$stat_text";
	    print STDERR "The file `$filename' is a valid document.\n";
	print STDERR "Used SGML text files:\n" 
    print STDOUT "DocBook-utils version 0.6.14 (sgmldiff v$VERSION)\n";
# Process nsgmls output: keep all stuff that is important for the
	    $public_identifier = "";
	    $public_identifier = "$1";
	    push @full, "&$1;";
	    push @full, "<?$1>\n";
	    push @full, "$data\n";
	    # push @full, (defined($4) ? "----------$4----------\n" : "")."L$line\n";
	    push @full, "$indent<$1".(@attributes > 0 ? " ".join(" ",@attributes) : "").">\n";
	    push @full, "$indent</$gi>\n" unless $empty;
		push @full, "$val";
	    # push @line_numbered, "$line";
	    push @line_numbered, "$line";	    
		push @line_numbered, "$line";	    
	    push @line_numbered, "$line" unless $empty;	    
	    $result .= $c;
		    $result .= $c;
		    $result .= $c; 
		    $result .= chr($char);
		    $result .= chr(oct($char.$c));
		    $result .= "\n$prefix";
    return (join("@",@line_numbered),@full);
    return $result;
    $_ = <SDIFF>;
$_ = <SDIFF>;
	$_ = <SDIFF>;
    $_ = <SDIFF> if defined($_) && $_ =~ /^---$/;
# Send bug reports, comments, suggestions, improvements etc. to
		    $si =~ s/^osfile$/FILE/io;
                    # -s prints external entity information at the end
	    "s|statistics!" => \$opt_s, 
	      -s, --statistics prints some SGML information at the end
	$start1 = $1-1;
	$start2 = $5-1;
		    $state = "decchar";
	    $state = "escape";
		    $state = "octchar";
	    $statistics{external_data}->{$1}->{emsysid} = "$f_info"
	    $statistics{external_data}->{$1}->{pubid} = "$public_identifier $2 $3"
	    $statistics{external_data}->{$1}->{sysid} = "$system_identifier $2 $3"
	    $statistics{files}->{$4} = 1 if defined $4;
	    $statistics{notation}->{$1}->{emsysid} = "$f_info"
	    $statistics{notation}->{$1}->{pubid} = "$public_identifier"
	    $statistics{notation}->{$1}->{sysid} = "$system_identifier"
	    $statistics{subdocument}->{$1}->{emsysid} = "$f_info"
	    $statistics{subdocument}->{$1}->{pubid} = "$public_identifier"
	    $statistics{subdocument}->{$1}->{sysid} = "$system_identifier"
	    $statistics{text}->{$1}->{emsysid} = "$f_info"
	    $statistics{text}->{$1}->{pubid} = "$public_identifier"
	    $statistics{text}->{$1}->{sysid} = "$system_identifier"
		    $stat_text .= "  Full name of system identifier ($si) actually referred to:\n  \"$value\"\n";
		    $stat_text .= "  No system identifier could be generated\n";
			$stat_text .= "PUBLIC \"$value\">\n";
		$stat_text .= "$stat_text1 $l ";
			$stat_text .= "SYSTEM \"$value\">\n";
    @string = split(//,$string);
# Structurally diffs two SGML/XML files.
# structure comparison.  Make two structures: one that is diffed
		      subdocument => {},
sub my_warn {
sub normalise_text {
sub prepare {
	    $system_identifier = "";
	    $system_identifier = "$1";
		      text => {},
# the DTDs.  nsgmls always returns a structure.
# the Free Software Foundation; either version 2 of the License, or
# This program is distributed in the hope that it will be useful,
# This program is free software; you can redistribute it and/or modify
		    undef $char;
    undef $start1;
    undef $start2;
		    undef $state;
		unless $f_info eq "";
	    unless keys(%{$statistics{files}}) == 0;
		unless $public_identifier eq "";
		unless $system_identifier eq "";
unlink $diff1;
unlink $diff2;
Usage: $progname [options] file1 file2
use Getopt::Long 2.01;
use integer;
use strict;
use vars qw($nsgmls $errors $errorlog $VERSION);
#!/usr/bin/perl -w
		    $value =~ s/^<(.*)>(.*)/$2/o, my $si = $1;
$VERSION = 1.03;
                    # -v prints version
	    "v|version" => \$opt_v, 
              -v, --version    prints the version on the standard output
# - Wait for suggestions ;-)
    warn "`$a' not implemented yet.
	    warn "Unrecognised construction `$_'";
		    warn "Unrecognised construction `$val'";
		    warn "Unresolved SDATA "; 
        where the options are:
    while (defined $_ && /^< /) {
    while (defined $_ && /^> /) {
while (defined($_)) {
    while (<ESIS>) {
# (without text) (DIFF) and one that is used to present the
# You should have received a copy of the GNU General Public License
