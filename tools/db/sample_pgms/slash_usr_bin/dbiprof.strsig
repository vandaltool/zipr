        } 
# all done, print it out
allows you to analyze the profile data file produced by
"all" then all results are shown.
And called dbiprof as in:
By default the exclude expression is matched case-insensitively, but
By default the match expression is matched case-insensitively, but
           'case-sensitive' => \$case_sensitive,
    -case_sensitive  for -match and -exclude
case-sensitively.  Defaults to off.
Consider only items where the specified key matches the given value.
Copyright (C) 2002 Sam Tregar
(C</>) then it will be treated as a regular expression.  For example,
    $Data::Dumper::Deparse   = 0;
    $Data::Dumper::Indent    = 1;
    $Data::Dumper::Terse     = 1;
    $Data::Dumper::Useqq     = 1;
dbiprof - command-line client for DBI::ProfileData
  dbiprof --exclude key2=prepare
    DBI::ProfileData->new(
DBI::ProfileDumper and produce various useful reports.
DBI::Profile Path of:
  [ DBIprofile_Statement, DBIprofile_Methodname ]
  dbiprof --match key1=/^SELECT/
  dbiprof --match key1=/^UPDATE/
  dbiprof --match key2=execute
dbiprof [options] [files]
 dbiprof prof1.out
  dbiprof --sort count
  dbiprof --sort count --number 15
  dbiprof --sort total --reverse
# default options
        DeleteFiles => $opt_delete,
           'delete!'        => \my $opt_delete,
    -delete          rename files before reading then delete afterwards
die "Unable to load profile data: $@\n" if $@;
           'dumpnodes!'     => \my $dumpnodes,
eval 'exec /usr/bin/perl  -S $0 ${1+"$@"}'
example, to exclude all prepare entries where key2 is the method name:
    -exclude=K=V     for filtering, see docs
           'exclude=s'      => \%exclude,
F<dbi.prof> (the default):
fetches, etc.
files: defaults to $filename
        Files => \@files,
files to be deleted after reading. See L<DBI::ProfileData> for more details.
GetOptions(
# get options from command line
=head1 AUTHOR
=head1 COPYRIGHT AND LICENSE
=head1 DESCRIPTION
=head1 NAME
=head1 OPTIONS
=head1 SEE ALSO
=head1 SYNOPSIS
    -help            print this help
           'help'           => sub { exit usage() },
    if 0; # not running under some shell
if ($dumpnodes) {
if (%exclude) { # handle excludes
if (%match) { # handle matches
If the value given starts and ends with slashes (C</>) then it will be
        if ($val =~ m!^/(.+)/$!) {
# instantiate ProfileData object
=item --case-sensitive
=item count
=item --delete
=item --dumpnodes
=item --exclude keyN=value
=item first
=item key1
=item longest
=item --match keyN=value
=item --number N
=item --reverse
=item shortest
=item --sort field
=item total
=item --version
it under the same terms as Perl 5 itself.
Keys are numbered from 1.  For example, let's say you used a
L<DBI::Profile|DBI::Profile>, L<DBI|DBI>.
L<DBI::ProfileDumper|DBI::ProfileDumper>,
Like C<--match>, If the value given starts and ends with slashes
# list of files defaults to dbi.prof
    -match=K=V       for filtering, see docs
           'match=s'        => \%match,
my $case_sensitive = 0;
my $filename       = 'dbi.prof';
my @files = @ARGV ? @ARGV : ('dbi.prof');
my (%match, %exclude);
my $number         = 10;
my $prof = eval {
my $reverse        = 0;
my $sort           = 'total';
my $VERSION = sprintf("1.%06d", q$Revision: 13336 $ =~ /(\d+)/o);
           'number=i'       => \$number,
    -number=N        show top N, defaults to $number
options:
) or exit usage();
    print Dumper($prof->nodes);
    print <<EOS;
    print $prof->report(number => $number);
Print the dbiprof version number and exit.
Print the list of nodes in the form of a perl data structure.
Produce this many items in the report.  Defaults to 10.  If set to
        $prof->exclude($key, $val, case_sensitive => $case_sensitive);
profile dump file F<prof1.out>:
        $prof->match($key, $val, case_sensitive => $case_sensitive);
$prof->sort(field => $sort, reverse => $reverse);
queries where key1 is the statement:
Reads and merges DBI profile data from files and prints a summary.
Remove items for where the specified key matches the given value.  For
    return 1;
           'reverse'        => \$reverse,
    -reverse         reverse the sort
Reverses the selected sort.  For example, to see a report of the
Sam Tregar <sam@tregar.com>
See a report of the ten queries with the longest total runtime in the
See the same report with 15 entries:
See the top 10 most frequently run queries in the profile file
Sets the C<DeleteFiles> option to L<DBI::ProfileData> which causes the
shortest overall time:
Sort results by the given field. Sorting by multiple fields isn't currently
Sorts by the longest single run.
Sorts by the shortest single run.
Sorts by the time taken in the first run.
Sorts by the value of the first element in the Path, which should be numeric.
Sorts by total number of runs.
Sorts by total time run time across all runs.  This is the default
           'sort=s'         => \$sort,
    -sort=S          sort by S, defaults to $sort
# sort the data
sub usage {
supported (patches welcome).  The available sort fields are:
this can be changed with the --case-sensitive option.
This program accepts the following options:
This program is free software; you can redistribute it and/or modify
This tool is a command-line client for the DBI::ProfileData.  It
to exclude UPDATE queries where key1 is the statement:
treated as a regular expression.  For example, to only include SELECT
use Data::Dumper;
use DBI::ProfileData;
use Getopt::Long;
use strict;
Use the C<-sort> option if you want the list sorted.
Using this option causes --match and --exclude to work
#!/usr/bin/perl
            $val = $case_sensitive ? qr/$1/ : qr/$1/i;
    -version         print version number and exit
           'version'        => sub { die "dbiprof $VERSION\n" },
    while (my ($key, $val) = each %exclude) {
    while (my ($key, $val) = each %match) {
You can also sort by C<key2> and C<key3>.
Your report would only show execute queries, leaving out prepares,
