        """
# 1. Add PILFont capabilities, once that's documented.
# 2. Add PILDraw operations.
30 degrees, and saves the result as rotated.png (in PNG format).
# 3. Add support for composing and decomposing multiple-image files.
All operations consume their arguments off the stack (use `dup' to
        alpha = float(self.do_pop())
    # and execute.  Otherwise go interactive.
        angle = int(self.do_pop())
An instance of class PILDriver is essentially a software stack machine
a PILDriver instance.  If there are no command-line arguments, the
are actually diagnostic information that should be interpreted by
        bandlist = []
            bandlist.append(self.do_pop())
before each operation.
        bounding_box = self.do_pop().getbbox()
                break
# by Eric S. Raymond <esr@thyrsus.com>
class PILDriver:
        Clear the stack.
        color = int(self.do_pop())
        Configure the loader for a given mode and size.
                continue
                continue;
        Convert the top image to the given mode.
        Create and push a greyscale image of given size and color.
        Crop and push a rectangular region from the current image.
    def do_add(self):
    def do_blend(self):
    def do_brightness(self):
    def do_clear(self):
    def do_color(self):
    def do_composite(self):
    def do_contrast(self):
    def do_convert(self):
    def do_copy(self):
    def do_crop(self):
    def do_darker(self):
    def do_difference(self):
    def do_draft(self):
    def do_dup(self):
    def do_filter(self):
    def do_format(self):
    def do_getbbox(self):
    def do_getextrema(self):
    def do_invert(self):
    def do_lighter(self):
    def do_merge(self):
    def do_mode(self):
    def do_multiply(self):
    def do_new(self):
    def do_offset(self):
    def do_open(self):
    def do_paste(self):
    def do_pop(self):
    def do_resize(self):
    def do_rotate(self):
    def do_save2(self):
    def do_save(self):
    def do_screen(self):
    def do_sharpness(self):
    def do_show(self):
    def do_size(self):
    def do_subtract(self):
    def do_swap(self):
    def do_thumbnail(self):
    def do_transpose(self):
    def do_verbose(self):
    def execute(self, list):
    def push(self, item):
    def top(self):
        Discard the top element on the stack.
        Display and pop the top image.
            driver.execute(string.split(line))
        driver.execute(sys.argv[1:])
    driver = PILDriver()
        Duplicate the top-of-stack item.
            dup = self.stack[0]
            dup = self.stack[0].copy()
            else:
        else:
    else:
        Enhance brightness in the top image.
        Enhance color in the top image.
        Enhance contrast in the top image.
        enhancer = ImageEnhance.Color(image)
        Enhance sharpness in the top image.
            except EOFError:
    except ImportError:
`execute' method.  This takes an argument list of tokens, pushes them
        extrema = self.do_pop().extrema()
        factor = float(self.do_pop())
        figure = self.do_pop()
        filename = self.do_pop()
        filter = eval("ImageFilter." + string.upper(self.do_pop()))
        for band in mode:
from PIL import Image
                func()
                func = getattr(self, funcname)
            funcname = "do_" + top
            ground.paste(figure, (xoff, yoff))
            ground.paste(figure, (xoff, yoff), figure)
        ground = self.do_pop()
        if figure.mode == "RGBA":
        if hasattr(self, 'format'):     # If it's an image, do a real copy
    if len(sys.argv[1:]) > 0:
if __name__ == '__main__':
            if not hasattr(self, funcname):
            if self.verbose:
            if type(top) != type(""):
    # If we see command-line arguments, interpret them as a stack state
        image1 = self.do_pop()
        image2 = self.do_pop()
    # Image attributes
    # ImageChops operations
    # Image class methods
    # ImageEnhance classes
    # Image module functions (callable)
        image.save(filename)
        image.save(filename, None, options)
        image = self.do_pop()
        import ImageChops
        import ImageEnhance
        import ImageFilter
        import readline
import string
    import sys
        "Interpret a list of PILDriver commands."
In the method descriptions below, a first line beginning with the string
        Invert the top image.
it.  Following <>-enclosed arguments describe how the method interprets
keep copies around).  Use `verbose 1' to see the stack state displayed
        left = int(self.do_pop())
                line = raw_input('pildriver> ');
            list = list[1:]
        list.reverse()
# Local Variables:
        lower = int(self.do_pop())
        Make and push a true copy of the top image.
        mask = self.do_pop()
        Merge top-of stack images in a way described by the mode.
# mode:python
        mode = self.do_pop()
        Modify the top image in the stack to contain a thumbnail of itself.
module runs an interactive interpreter, each line of which is split into
not cleaned off persists and is part of the evaluation context for
        offset = int(self.do_pop())
        Offset the pixels in the top image.
of its upper-left-hand corner and displays the cropped portion.
onto the instance's stack, and then tries to clear the stack by
        Open the indicated image, read it, push the image on the stack.
        options = self.do_pop()
        pass # not available on all platforms
        Paste figure image into ground with upper left at given offsets.
"""PILdriver, an image-processing calculator using PIL.
PILDriver doesn't catch any exceptions, on the theory that these
(Polish-notation interpreter) for sequencing PIL image
        Pop the two top images, produce the scaled difference with offset.
        Pop the two top images, produce the scaled sum with offset.
        Pop the two top images, push an image of the darker pixels of both.
        Pop the two top images, push an image of the lighter pixels of both.
        Pop the two top images, push the difference image
        Pop the two top images, push the multiplication image.
        Pop the two top images, superimpose their inverted versions.
            print driver.stack
                print "\nPILDriver says goodbye."
        print "PILDriver says hello."
                print "Stack: " + `self.stack`
        Process the top image with the given filter.
        "Push an argument onto the evaluation stack."
        Push left, upper, right, and lower pixel coordinates of the top image.
        Push minimum and maximum pixel values of the top image.
        Push the format of the top image onto the stack.
        Push the image size on the stack as (y, x).
        Push the mode of the top image onto the stack.
        Replace two images and a mask with their composite.
        Replace two images and an alpha with the blended image.
        Resize the top image.
        return self.stack[0]
        "Return the top-of-stack element."
        return top
        right = int(self.do_pop())
        Rotate image through a given angle
        Save image with default options.
        Save image with specified options.
    `save rotated.png rotate 30 open test.tiff' loads test.tiff, rotates it
        scale = float(self.do_pop())
                self.do_pop()
        self.do_pop().show()
        self.dup()
        self.push(bounding_box[0])
        self.push(bounding_box[1])
        self.push(bounding_box[2])
        self.push(bounding_box[3])
        self.push(enhancer.enhance(factor))
        self.push(extrema[0])
        self.push(extrema[1])
        self.push(ground)
        self.push(Image.blend(image1, image2, alpha))
        self.push(ImageChops.add(image1, image2, scale, offset))
        self.push(ImageChops.darker(image1, image2))
        self.push(ImageChops.difference(image1, image2))
        self.push(ImageChops.invert(self.do_pop()))
        self.push(ImageChops.lighter(image1, image2))
        self.push(ImageChops.multiply(image1, image2))
        self.push(ImageChops.screen(image1, image2))
        self.push(ImageChops.subtract(image1, image2, scale, offset))
        self.push(Image.composite(image1, image2, mask))
        self.push(image.convert(mode))
        self.push(image.crop((left, upper, right, lower)))
        self.push(image.filter(filter))
        self.push(Image.merge(mode, bandlist))
        self.push(Image.new("L", (xsize, ysize), color))
        self.push(image.offset(xoff, yoff))
        self.push(Image.open(self.do_pop()))
        self.push(image.resize((xsize, ysize)))
        self.push(image.rotate(angle))
        self.push(image.transpose(transpose))
            self.push(list[0])
        self.push(self.draft(mode, (xsize, ysize)))
        self.push(self.pop().format)
        self.push(self.pop().mode)
        self.push(size[0])
        self.push(size[1])
        self.stack = []
        self.stack = [dup] + self.stack
        self.stack = [item] + self.stack
        self.stack = self.stack[1:]
        self.stack = [self.stack[1], self.stack[0]] + self.stack[2:]
        self.top().thumbnail((xsize, ysize))
        self.verbose = self.do_pop()
        Set verbosity flag from top of stack.
    `show crop 0 0 200 300 open test.png' loads test.png, crops out a portion
        size = self.pop().size
space-separated tokens and passed to the execute method.
    # Stack manipulation (callable)
    stack = []          # Stack of pending operations
successive evaluation of PILdriver operators.  Any part of the stack
        Swap the top-of-stack item with the next one down.
the calling code.
the entries on the stack.  Each argument specification begins with a
    # The evaluation stack (internal only)
# The following sets edit modes for GNU EMACS
    # The interpreter loop
the next call of the execute method.
The only method one will normally invoke after initialization is the
# TO DO:
        top = self.stack[0]
            top = self.top()
transformations.  The state of the instance is the interpreter stack.
        transpose = string.upper(self.do_pop())
        Transpose the top image.
            try:
    try:
type specification: either `int', `float', `string', or `image'.
        upper = int(self.do_pop())
        """usage: add <image:pic1> <image:pic2> <int:offset> <float:scale>
        """usage: blend <image:pic1> <image:pic2> <float:alpha>
        """usage: brightness <image:pic1>
        """usage: clear
        """usage: color <image:pic1>
        """usage: composite <image:pic1> <image:pic2> <image:mask>
        """usage: contrast <image:pic1>
        """usage: convert <string:mode> <image:pic1>
        """usage: copy <image:pic1>
        """usage: crop <int:left> <int:upper> <int:right> <int:lower> <image:pic1>
        """usage: darker <image:pic1> <image:pic2>
        """usage: difference <image:pic1> <image:pic2>
        """usage: draft <string:mode> <int:xsize> <int:ysize>
        """usage: dup
Usage examples:
        """usage: extrema
        """usage: filter <string:filtername> <image:pic1>
        """usage: format <image:pic1>
        """usage: getbbox
        """usage: invert <image:pic1>
        """usage: lighter <image:pic1> <image:pic2>
`usage:' means this method can be invoked with the token that follows
        """usage: merge <string:mode> <image:pic1> [<image:pic2> [<image:pic3> [<image:pic4>]]]
        """usage: mode <image:pic1>
        """usage: multiply <image:pic1> <image:pic2>
        """usage: new <int:xsize> <int:ysize> <int:color>:
        """usage: offset <int:xoffset> <int:yoffset> <image:pic1>
        """usage: open <string:filename>
        """usage: paste <image:figure> <int:xoffset> <int:yoffset> <image:ground>
        """usage: pop
        """usage: resize <int:xsize> <int:ysize> <image:pic1>
        """usage: rotate <int:angle> <image:pic1>
        """usage: save2 <string:filename> <string:options> <image:pic1>
        """usage: save <string:filename> <image:pic1>
        """usage: screen <image:pic1> <image:pic2>
        """usage: sharpness <image:pic1>
        """usage: show <image:pic1>
        """usage: size <image:pic1>
        """usage: subtract <image:pic1> <image:pic2> <int:offset> <float:scale>
        """usage: swap
        """usage: thumbnail <int:xsize> <int:ysize> <image:pic1>
        """usage: transpose <string:operator> <image:pic1>
        """usage: verbose <int:num>
#! /usr/bin/python
    verbose = 0
When called as a script, the command-line arguments are passed to
        while 1:
        while len(list) > 0:
        xoff = int(self.do_pop())
        xsize = int(self.do_pop())
        yoff = int(self.do_pop())
        ysize = int(self.do_pop())
