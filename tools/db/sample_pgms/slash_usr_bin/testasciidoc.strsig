        """
    Adds eol() and read_until() to list type.
        Advance position to matching line.
    A list of strings.
        # All file names are relative to configuration file directory.
        asciidoc = asciidocapi.AsciiDocAPI()
        asciidoc.attributes = self.attributes
        asciidoc.execute(infile, outfile, backend)
        asciidoc.options.values = self.options
                backend,
            backend = arg
                BACKEND_EXT[backend])
BACKEND_EXT = {'html4':'.html', 'xhtml11':'.html', 'docbook':'.xml',
    backend = None
            backends = [backend]
BACKENDS = ('html4','xhtml11','docbook','wordpress','html5')    # Default backends.
            backends = self.backends
            break
                break
class AsciiDocTest(object):
class AsciiDocTests(object):
class Lines(list):
    cmd = args[0]
Commands:
    conffile = '/etc/asciidoc/testasciidoc.conf'
            conffile = v
                    continue
__copyright__ = 'Copyright (C) 2009 Stuart Rackham'
                data = normalize_data(l[1:])
    def backend_filename(self, backend):
    def eol(self):
    def generate_expected(self, backend):
    def get_expected(self, backend):
def iif(condition, iftrue, iffalse=None):
    def __init__(self):
    def __init__(self, conffile):
    def __init__(self, lines):
    def is_missing_or_outdated(self, backend):
    def is_missing(self, backend):
    def list(self):
def message(msg=''):
def normalize_data(lines):
    def parse(self, lines, confdir, datadir):
    def read_until(self, regexp):
    def run(self, backend=None):
    def run(self, number=None, backend=None):
def strip_end(lines):
    def update_expected(self, backend):
    def update(self, backend=None, force=False):
    def update(self, number=None, backend=None, force=False):
def usage(msg=None):
            del lines[i]
                directive = reo.groupdict()['directive']
    elif cmd == 'list':
    elif cmd == 'update':
                elif directive == 'attributes':
                elif directive == 'backends':
                elif directive == 'name':
                elif directive == 'options':
                    else:
                else:
            else:
        else:
    else:
        /etc/asciidoc/testasciidoc.conf)
    except getopt.GetoptError:
        except ValueError:
        Execute test.
            exit(1)
                    expected = self.get_expected(backend)
    False value defaults to 0 if the true value is a number.
    False value defaults to '' if the true value is a string.
            f.close()
  -f, --conf-file=CONF_FILE
        finally:
                first = False
        first = True
        f = open(self.backend_filename(backend))
        f = open(self.backend_filename(backend),'w+')
        f = open(self.conffile)
    for arg in args[1:3]:
            for backend in backends:
        for backend in backends:
  --force
    force = False
            force = True
    for i in range(len(lines)-1,-1,-1):
                    for i,v in enumerate(self.options):
                    for line in difflib.unified_diff(got, expected, n=0):
                        for line in lines:
    for o,v in opts:
        for test in self.tests:
                fromfile = self.backend_filename(backend)
            f.writelines([ s + os.linesep for s in lines])
        Generate and return test data output for backend.
        Generate and write backend data.
                    got = self.generate_expected(backend)
    if backend and backend not in BACKENDS:
        if backend is None:
    if cmd == 'run':
    if condition:
                    if data:
                    if 'datadir' in self.globals:
                if directive == 'source':
            iffalse = ''
            iffalse = 0
                if first and re.match(r'^%\s*globals$',s[0]):
            if force or self.is_missing_or_outdated(backend):
    if iffalse is None:
        if isinstance(iftrue, basestring):
                        if isinstance(v, basestring):
            if l:
                    if l[0][0] == '!':
    if len(args) == 0:
            if len(s) > 1:
                    if lines:
    if msg:
if __name__ == '__main__':
                if not l[0].startswith('%'):
        if not lines[i]:
        if not os.path.isdir(self.datadir):
    if not os.path.isfile(conffile):
                if not reo:
        if not self.eol():
                if not self.is_missing(backend):
        if not self.name:
        if not self.title:
            if (not test.disabled or number) and (not number or number == test.number):
            if (not test.disabled or number) and (not number or number == test.number) and (not backend or backend in test.backends):
    if number is not None and  number not in range(1, len(tests.tests)+1):
        If number is specified run test number (1..).
        if o == '--force':
        if o in ('-f','--conf-file'):
            if re.match(regexp, self[self.pos]):
        if self.failed > 0:
        if self.passed > 0:
        if self.skipped > 0:
            if self.source:
        if self.source and os.path.isfile(self.source):
        if tests.failed:
        if type(iftrue) in (int, float):
    Immediate if c.f. ternary ?: operator.
import asciidocapi
    import getopt
import os, sys, re, StringIO, difflib
        infile = self.source
                    lines = []
                        lines.append(line)
                        lines = lines[3:]
            lines = Lines(f.readlines())
        lines = Lines(lines)
        lines = self.generate_expected(backend)
  list                          List tests
        Lists tests to stdout.
            l = lines.read_until(r'^%')
        matching regexp.
                        message()
                        message('--- got')
        message('illegal BACKEND: %s' % backend)
        message('illegal test NUMBER: %d' % number)
                            message(line)
        message('missing CONF_FILE: %s' % conffile)
        message(msg + '\n')
                        message('+++ %s' % fromfile)
    message(USAGE)
                msg = 'MISSING: %s' % self.source
                msg = 'NO ASCIIDOC SOURCE FILE SPECIFIED'
            # Must be at least one non-blank line in addition to delimiter.
            number = int(arg)
    number = None
                # Optional globals precede all tests.
Options:
        opts,args = getopt.getopt(sys.argv[1:], 'f:', ['force'])
            os.mkdir(self.datadir)
               > os.path.getmtime(self.backend_filename(backend)))
               os.path.getmtime(self.source)
                os.path.normpath(os.path.join(self.datadir, self.name)),
                                os.path.normpath(self.globals['datadir']))
        outfile = StringIO.StringIO()
        Parse conf file test section from list of text lines.
        Parse configuration file.
        print('')
            print('CREATING: %s' % self.datadir)
        print('%d: %s' % (self.number, self.title))
            print '%d: %s%s' % (test.number, iif(test.disabled,'!'), test.title)
                        print('FAILED: %s: %s' % (backend, fromfile))
            print(msg)
                        print('PASSED: %s: %s' % (backend, fromfile))
                    print('SKIPPED: %s: %s' % (backend, fromfile))
            print('SOURCE: asciidoc: %s' % self.source)
    print >>sys.stderr, msg
            print('TOTAL FAILED:  %s' % self.failed)
            print('TOTAL PASSED:  %s' % self.passed)
            print('TOTAL SKIPPED: %s' % self.skipped)
            print('WRITING: %s' % f.name)
    # Process command line options.
                    raise (ValueError, 'illegal directive: %s' % l[0])
        Regenerate and update expected test data outputs.
        Regenerate expected test data and update configuratio file.
                reo = re.match(r'^%\s*(?P<directive>[\w_-]+)', l[0])
        result = []
            result.append(self[self.pos])
                        result = False
            result = f.readlines()
    result = [ s for s in lines if not s.startswith('#') ]
            result = [ s.rstrip() for s in result ]
        result = True   # Assume success.
        Return a list of lines from current position up until the next line
        Return expected test data output for backend.
        return iffalse
        return iftrue
        return not os.path.isfile(self.backend_filename(backend))
        return outfile.getvalue().splitlines()
        return result
    return result
        return self.is_missing(backend) or (
        return self.pos >= len(self)
        return '%s-%s%s' % (
        Returns True if the output test data file is missing or out of date.
        Returns True if there is no output test data file for backend.
        Return the path name of the backend  output file that is generated from
        Return True if test passes.
        Run all tests.
Run AsciiDoc conformance tests specified in configuration FILE.
  run [NUMBER] [BACKEND]        Execute tests
        self.attributes = {}
                    self.attributes = eval(' '.join(data))
        self.backends = BACKENDS
                    self.backends = eval(' '.join(data))
                                self.confdir,
        self.confdir = confdir
        self.confdir = os.path.dirname(self.conffile)
                                self.confdir, os.path.normpath(data[0])))
        self.conffile = os.path.normpath(conffile)
        self.datadir = datadir
        self.datadir = None     # Where output files are stored.
                        self.datadir = os.path.join(
        self.datadir = self.confdir # Default expected files directory.
                    self.description = l[1:]
        self.description = []   # List of lines followoing title.
        self.disabled = False
                        self.disabled = True
        self.extend([s.rstrip() for s in lines])
                        self.failed +=1
                self.failed += test.failed
        self.globals = {}
                    self.globals = eval(' '.join(normalize_data(s[1:])))
        self.__init__()
                    self.name = data[0].strip()
        self.name = ''          # Optional test name.
            self.name = os.path.basename(os.path.splitext(self.source)[0])
        self.number = None      # Test number (1..).
        self.options = []
                    self.options = eval(' '.join(data))
                            self.options[i] = (v,None)
                        self.passed += 1
        self.passed = self.failed = self.skipped = 0
                self.passed += test.passed
        self.pos = 0
            self.pos += 1
                    self.skipped += 1
            self.skipped += len(backends)
                self.skipped += test.skipped
        self.source = None      # AsciiDoc test source file name.
                        self.source = os.path.normpath(os.path.join(
                    self.tests.append(test)
        self.tests = []             # List of parsed AsciiDocTest objects.
                        self.title = l[0]
                        self.title = l[0][1:]
        self.title = ''         # Optional test name.
            self.title = self.source
                self.update_expected(backend)
            s = [ l for l in s if l]    # Drop blank lines.
            s = lines.read_until(r'^%+$')
    Strip blank strings from the end of list of strings.
    Strip comments and trailing blank strings from lines.
                    strip_end(expected)
                    strip_end(got)
    strip_end(result)
            # Strip line terminators.
        super(Lines, self).__init__()
        sys.exit(1)
sys.path.append('/usr/share/asciidoc/')
                    test = AsciiDocTest()
                    test.number = len(self.tests)
                    test.parse(s[1:], self.confdir, self.datadir)
                test.run(backend)
    tests = AsciiDocTests(conffile)
        tests.list()
        tests.run(number, backend)
        tests.update(number, backend, force=force)
                test.update(backend, force=force)
        the test name and output file type.
        try:
    try:
        Update all test data overwriting existing data'''
  update [NUMBER] [BACKEND]     Regenerate and update test data
        usage()
        usage('illegal command options')
        usage('illegal COMMAND: %s' % cmd)
USAGE = '''Usage: testasciidoc [OPTIONS] COMMAND
        Use configuration file CONF_FILE (default configuration file is
#!/usr/bin/env python
__version__ = '0.1.1'
        while not lines.eol():
        while not self.eol():
        'wordpress':'.html','slidy':'.html','html5':'.html'}
