^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^$$^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^^^^^%%%^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^^^^^=^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^^@^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^<^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^,^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^:^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^.^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^#^^^^^^^^^^^^#^^$$^^^^^^^^^^^^^^^^^
^^^^^^?^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^(^^(^((^^^^^^(^(^(((^^^^^^^^^^^^^^^^
^^^^^^+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^!!!!!!!!!!!!!!!!!!^^^^^^^^^^^^^^^^^^^
^^^^^)^^^^^^^^^^^*^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^&&&&&&&&&&&&&&&&&&&&&^^^^^^^^^^^^^^^^
^^^^'^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
"$&'**#%)(
(((((((((
((((((((((((((((((
&(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
00000000
^^^^^^^^/^^0^^^^^1^^^^^^^^^^^^^^^^^^^^^^^^
// 133MR1 Deprecated feature to allow inclusion of 
1.33MR33
 * 1989-2001 by  Will Cohen, Terence Parr, and Hank Dietz
^^^^^^^^^^^^^^^^^^2^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^3^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^4^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^5^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^6^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^7^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^8^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^9^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
^^^^^^^^^^^^^^A^^^^^^^^^^^^^^^^^^^^^^^^^^^
ANTLRTokenType
	ANTLRTokenType act%d();
	ANTLRTokenType nextTokenType(void);
AParser.h
__assert_fail
^^^^^B^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Build interactive scanner (not valid for C++ mode)
^^^^^^^^^^C^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
class %s : public DLGLexerBase {
Compression level 1
Compression level 2
const int %s::DfaStates=%d;
const int %s::MAX_MODE=%d;
const int %s::%s=%d;
CONTINUATION
__ctype_b_loc
__ctype_tolower_loc
__ctype_toupper_loc
^^^^^^^^^^^^^^^^D^^^^^^^^^^^^^^^^^^^^^^^^^
DEC_VALUE
#define DfaStates	%d
#define DLGLexer %s
#define MAX_MODE %d
#define %s
#define %s %d
#define ZZINTERACTIVE
#define ZZSHIFT(c) (1+c)
#define ZZSHIFT(c) (b_class_no[zzauto][1+c])
Directory where all output files should go (default=".")
DLexerBase.h
DLexer.h
DLGChar %salternatives[%d] = {
dlg: invalid option: '%s'
DLGLexer
		: DLGLexerBase(in, bufsize, %d)
 * D L G L e x e r  C l a s s  D e f i n i t i o n
 * D L G tables
 * DLG Version %s
dlg warning: ambiguous regular expression 
dlg: Warning: Can't read file %s.
dlg: Warning: Can't write to file %s.
^^^^^^^E^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 Error: %s
^^^^^^^^^^^F^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fatal: attrib/AST stack overflow %s(%d)!
 Fatal: %s
__fprintf_chk
^^^^^^^^^^^^^^^^^^G^^^^^^^^^^^^^^^^^^^^^^^
Generate ansi C
Generate C++ output
 * Generated from:
GLIBC_2.0
GLIBC_2.1
GLIBC_2.3
GLIBC_2.3.4
GLIBC_2.7
__gmon_start__
GREAT_GREAT
^^^^^^^^^^^^^^^^^^H^^^^^^^^^^^^^^^^^^^^^^^
../h/err.h
HEX_VALUE
#ifdef DLGLexerIncludeFile
#ifndef %s
#include "dlgauto.h"
#include DLGLexerIncludeFile
#include "pcctscfg.h"
#include "pccts_stdio.h"
#include "%s"
	int ZZSHIFT(int c) { return 1+c; }
	int ZZSHIFT(int c) { return b_class_no[automaton][1+c]; }
Invalid automaton mode = %d 
invalid range  
invalid token
_IO_getc
_IO_stdin_used
__isoc99_sscanf
ITZ-cl only valid in C++ mode; -cl ignored...
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^JKLMNOO^^^^^^^^^^P^^^^^^^Q^^^^^^^^^^^^^^^^^^RS^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^UVWXW^^^^^^^^^Y^^^^^^^^^^^^^^^^^^^^^[\]^^^^^^^^^^^^^
k <= sizeof(f)/sizeof(f[0])
LEXACTION
Lexical error
LEXMEMBER
LEXPREFIX
libc.so.6
__libc_start_main
/lib/ld-linux.so.2
line %d: syntax error at "%s" missing %s
Make lexical analyzer case insensitive
Make lexical analyzer case sensitive (default)
 missing
/* must have 0 for zzalternatives[DfaStates] */
NAME_PER_PER
No compression (default)
no expression for *
no expression for +
no expression for action  
No input stream, function, or string
no regular expressions
OCTAL_VALUE
ONE_MORE
output file implicit in C++ mode; ignored...
PARSERCLASS
protected:
Ptr%sMemberFunc %s::actions[%d] = {
 * Purdue University Electrical Engineering
Rename lexer class (DLGLexer); only used for -CC
Rename lexical mode output file
[\r\t\ ]+
	&%s::act%d
	&%s::act%d,
%sDfaState %saccepts[%d] = {
%sDfaState %sdfa_base[] = {
%sDfaState *%sdfa[%d] = {
%sDfaState %sst%d[%d] = {
	%s(DLGInputStream *in,
%s(%d): unable to allocate memory
	&%s::erraction,
set_ext(%d words): cannot allocate set
set_new: Cannot allocate set with max of %d
	shift%d
	shift%d,
%s, line %d:
%s near line %d (text was '%s')
; "%s" not
%s [options] f1 f2 ... fn
__sprintf_chk
%s %sact%d()
	%s %s	%s
	static ANTLRTokenType (%s::*actions[%d])();
	static const int DfaStates;
	static const int MAX_MODE;
	static const int %s;
	static DfaState accepts[%d];
	static DfaState dfa_base[];
	static DfaState *dfa[%d];
	static DfaState st%d[%d];
	static DLGChar alternatives[%d];
static %s zzalternatives[DfaStates+1] = {
	static unsigned char *b_class_no[];
	static unsigned char shift%d[%d];
static void
__strcat_chk
__strcpy_chk
%s unsigned char *%sb_class_no[] = {
%s unsigned char %sshift%d[%d] = {
%s  Version %s   1989-2001
 syntax error at "%s"
typedef ANTLRTokenType (%s::*Ptr%sMemberFunc)();
	typedef %s DfaState;
		unsigned bufsize=2000)
unsigned char
unsigned int
unsigned long
unsigned short
unterminated action
user-defined code in DLG class header
Use standard i/o rather than file
void (*actions[%d])() = {
	void     advance(void);
	void	  mode(int);
-Wambiguity
Warn if expressions ambiguous
 Warning: %s
ZERO_MORE
	zzerraction,
