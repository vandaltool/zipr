# along with this program; if not, write to the Free Software
basic_single_escape () {
#!/bin/sh
# but WITHOUT ANY WARRANTY; without even the implied warranty of
    case `echo "testing\c"`,`echo -n testing` in
	*c*,*)   echo_n=-n echo_c=     ;;
    chmod 600 $config $command
    # class is balanced and contains two characters.
		clean_and_exit
	clean_and_exit
clean_and_exit() {
    cleanup
	cleanup
cleanup() {
	*c*,-n*) echo_n=   echo_c=     ;;
command=".mysql.$$"
config=".my.cnf.$$"
# Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
# Disallow remote root login
    done
    # don't allow *any* escape mechanism, so they cannot contain a single
	do_query ""
do_query() {
    do_query "DELETE FROM mysql.db WHERE Db='test' OR Db='test\\_%'"
    do_query "DELETE FROM mysql.user WHERE User='';"
    do_query "DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1', '::1');"
    do_query "DROP DATABASE test;"
    do_query "FLUSH PRIVILEGES;"
    do_query "UPDATE mysql.user SET Password=PASSWORD('$esc_pass') WHERE User='root';"
    echo
    echo "$1" >$command
    echo "$1" | sed 's/\(['"'"'\]\)/\\\1/g'
    echo "Aborting!"
echo "access.  This is also intended only for testing, and should be removed"
echo "All done!  If you've completed all of the above steps, your MySQL"
echo "before moving into a production environment."
echo "By default, a MySQL installation has an anonymous user, allowing anyone"
echo "By default, MySQL comes with a database named 'test' that anyone can"
  echo "Can't find a 'mysql' client in PATH or ./bin"
    echo "Cleaning up..."
    echo " - Dropping test database..."
    echo $echo_n "Change the root password? [Y/n] $echo_c"
echo $echo_n "Disallow root login remotely? [Y/n] $echo_c"
	echo $echo_n "Enter current password for root (enter for none): $echo_c"
    echo $echo_n "New password: $echo_c"
    echo $echo_n "Re-enter new password: $echo_c"
echo $echo_n "Reload privilege tables now? [Y/n] $echo_c"
echo $echo_n "Remove anonymous users? [Y/n] $echo_c"
echo $echo_n "Remove test database and access to it? [Y/n] $echo_c"
    echo $echo_n "Set root password? [Y/n] $echo_c"
echo "ensures that someone cannot guess at the root password from the network."
	echo " ... Failed!"
	echo " ... Failed!  Not critical, keep moving..."
echo "go a bit smoother.  You should remove them before moving into a"
echo "In order to log into MySQL to secure it, we'll need the current"
echo "installation should now be secure."
    echo "[mysql]" >>$config
    echo "# mysql_secure_installation config file" >$config
	*)       echo_n=   echo_c='\c' ;;
echo "Normally, root should only be allowed to connect from 'localhost'.  This"
echo "NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MySQL"
    echo "OK, successfully used password, moving on..."
    echo "password='$esc_pass'" >>$config
echo "password for the root user.  If you've just installed MySQL, and"
	echo "Password updated successfully!"
	echo "Password update failed!"
echo "production environment."
	echo "Reloading privilege tables.."
echo "Reloading the privilege tables will ensure that all changes made so far"
    echo " - Removing privileges on test database..."
echo "root user without the proper authorisation."
echo "      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!"
echo "Setting the root password ensures that nobody can log into the MySQL"
    echo " ... skipping."
	echo "Sorry, passwords do not match."
	echo "Sorry, you can't use an empty password here."
echo "so you should just press enter here."
	echo " ... Success!"
echo "Thanks for using MySQL!"
echo "them.  This is intended only for testing, and to make the installation"
echo "to log into MySQL without having to have a user account created for"
    echo "user=root" >>$config
echo "will take effect immediately."
    echo "You already have a root password set, so you can safely answer 'n'."
echo "you haven't set the root password yet, the password will be blank,"
    else
    esac
    esc_pass=`basic_single_escape "$password1"`
    esc_pass=`basic_single_escape "$rootpass"`
    exit 1
  exit 1
    fi  
find_mysql_client
find_mysql_client()
  for n in ./bin/mysql mysql
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
get_root_password
get_root_password() {
# GNU General Public License for more details.
	    hadpass=0
	    hadpass=1
    if [ $? -eq 0 ]; then
	if [ $? -eq 1 ]; then
if [ $hadpass -eq 0 ]; then
    if [ "$password1" != "$password2" ]; then
    if [ "$password1" = "" ]; then
if [ "$reply" = "n" ]; then
    if test $status -eq 0
	if [ "x$password" = "x" ]; then
    # Inside a character class, \ and ' are not special, so the ['\] character
interrupt() {
# it under the terms of the GNU General Public License as published by
	make_config
make_config() {
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
mysql_client=""
    $mysql_client --defaults-file=$config <$command
      mysql_client=$n
    $n --no-defaults --help > /dev/null 2>&1
prepare() {
    # quote.  The string sed gets (as argv[1]) is:  s/\(['\]\)/\\\1/g
# quoting any character (\C => C, for any C), but my.cnf parsing allows
# quoting only \, ' or ".  For example, password='a\b' quotes a 3-character
	read password
    read password1
    read password2
read reply
    reload_privilege_tables
	reload_privilege_tables
reload_privilege_tables() {
# Reload privilege tables
    remove_anonymous_users
remove_anonymous_users() {
# Remove anonymous users
    remove_remote_root
remove_remote_root() {
    remove_test_database
remove_test_database() {
# Remove test database
# Remove the files before exiting.
      return
    return $?
    return 0
	return 0
	return 1
    rm -f $config $command
rootpass=""
	rootpass=$password
	rootpass=$password1
    #sed 's,^,> ,' < $command  # Debugging
    #sed 's,^,> ,' < $config  # Debugging
set_echo_compat
set_echo_compat() {
	set_root_password
set_root_password() {
# Set the root password
# Simple escape mechanism (\-escape any ' and \), suitable for two contexts:
# - single-quoted option values on the right hand side of = in my.cnf
# - single-quoted SQL strings
    status=$?
	status=$?
    status=1
# string in my.cnf, but a 2-character string in SQL.
    stty echo
    stty -echo
	stty echo
	stty -echo
# The actual script starts here
# the Free Software Foundation; version 2 of the License.
    then
    # The quoting on this sed command is a bit complex.  Single-quoted strings
# These two contexts don't handle escapes identically.  SQL strings allow
# This program is distributed in the hope that it will be useful,
# This program is free software; you can redistribute it and/or modify
# This simple escape works correctly in both places.
    touch $config $command
trap "interrupt" 1 2 3 6 15
    while [ $status -eq 1 ]; do
# You should have received a copy of the GNU General Public License
