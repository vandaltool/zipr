## -----------------------------------------------------------------------
	"$0: Warning: color palette truncated (%d colors ignored)\n", $lost;
## 16 x uint8 r,g,b	; color map, in 6-bit format (each byte is 0..63)
## across rows and odd-nybble rows are zero-padded.
    # Advance to the next free slot
# and trailing whitespace, as is required by the spec.
## At the start of row, the "previous pixel" is assumed to be zero.
##   (at your option) any later version; incorporated herein by reference.
	$b = get_numeric_token();
	$b = hex($3);
	$b = hex($3) << 4;
	$b = hex($3) >> 4;
	$b = hex($3) >> 8;
    $b = int($b*$maxmult);
##   Boston MA 02111-1307, USA; either version 2 of the License, or
	$bytes++;
$bytes  = 0;
	    $ch = getc(STDIN);
	$ch = getc(STDIN);
		    $ch = getc(STDIN);
		$ch = getc(STDIN);
	$color_count{$rgb}++;
    $color_index{$rgb} = $i;
	$color_index{$rgb} = $nix;
    $colors[$i] = $rgb;
	$colors[$nix] = $rgb;
@colors = sort { $color_count{$b} <=> $color_count{$a} } keys(%color_count);
@colors = (undef) x 16;
## Command line options of the form #rrggbb=i indicate that
## Convert a PNM file with max 16 colors to a simple RLE-based format:
	# Convert to 6-bit representation
##   Copyright 2004-2008 H. Peter Anvin - All Rights Reserved
@data = ();
	die "$0: Premature EOF at ($x,$y) of ($xsize,$ysize)\n"
die "$0: stdin is not a PNM file" if ( $form !~ /^P([1-6])$/ );
	die "Internal error: unknown format: $form\n";
    do {
	    do {
    } else {
} else {
	    } else {
	} else {
    } elsif ( $arg =~ /^\#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})=([0-9]+)$/i ) {
    } elsif ( $arg =~ /^\#([0-9a-f]{3})([0-9a-f]{3})([0-9a-f]{3})=([0-9]+)$/i ) {
    } elsif ( $arg =~ /^\#([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{4})=([0-9]+)$/i ) {
    } elsif ( $form == 1 ) {
    } elsif ( $form == 2 ) {
    } elsif ( $form == 3 ) {
    } elsif ( $form == 4 ) {
    } elsif  ( $form == 5 ) {
		$erun = 255;
		$erun = $run-16;
eval { binmode STDIN; };
eval { binmode STDOUT; };
eval { use bytes; };
	exit 1;
	exit(1);
    $force_index{$rgb} = $i;
foreach $arg ( @ARGV ) {
foreach $rgb ( keys(%force_index) ) {
for ( $i = 0 ; $i < 16 ; $i++ ) {
$form = $1+0;
$form = get_token();
    for ( $x = 0 ; $x < $xsize ; $x++ ) {
for ( $y = 0 ; $y < $ysize ; $y++ ) {
# Get a single RGB token depending on the PNM type
# Get a token, and make sure it is numeric (and exists)
# Get a token from the PPM header.  Ignore comments and leading
	$getrgb_leftover_bit_cnt--;
    $getrgb_leftover_bit_cnt = 0;
	    $getrgb_leftover_bit_cnt = 8;
    $getrgb_leftover_bit_val = 0;
	$getrgb_leftover_bit_val <<= 1;
	    $getrgb_leftover_bit_val = unpack("C", $rgb);
	$g = get_numeric_token();
	$g = hex($2);
	$g = hex($2) << 4;
	$g = hex($2) >> 4;
	$g = hex($2) >> 8;
    $g = int($g*$maxmult);
	$i = $4 + 0;
	$i   = $color_index{$rgb} + 0;
@icolors = sort by_intensity @colors;
    if ( $arg =~ /^\#([0-9a-f])([0-9a-f])([0-9a-f])=([0-9]+)$/i ) {
    if ( $ch eq '#' ) {
	    if ( $ch eq '#' ) {
	if ( $ch eq '#' ) {
    if ( !defined($color_index{$rgb}) ) {
    if ( defined($colors[$i]) ) {
    if ( defined($index_forced{$i}) ) {
    if ( !defined($ny) ) {
    if ( defined($nybble_tmp) ) {
	if ( defined($nybble_tmp) ) {
if ( $form == 1 || $form == 4 ) {
    if ( $form == 6 ) {
	if ( !$getrgb_leftover_bit_cnt ) {
    if ( $i > 15 ) {
	if ( $i == $last ) {
if ( $lost ) {
    $i = $force_index{$rgb};
	if ( $run >= 16 ) {
	    if ( $run > 271 ) {
    # If same, sort based on RGB components,
	    if ( !scalar(@pnmrgb = getrgb($form)) );
    if ( $this != $last ) {
    if ( $token !~ /^[0-9]+$/ ) {
    $index_forced{$i} = $rgb;
# in luminosity-sorted order
# Insert forced colors into "final" array
# Insert remaining colors in the remaining slots,
##   it under the terms of the GNU General Public License as published by
	    $last = $i;
	last if ( $ch =~ /^[ \t\n\v\f\r\#]$/ );
    last if ( $nix >= 16 );
    $last = $prev = 0;
##     littleendian, +16
    $lost++ if ( !defined($color_index{$rgb}) );
$magic = 0x1413f33d;
    $maxcol = 255;		# Internal convention
    $maxcol = get_numeric_token();
$maxmult = 64/($maxcol+1);	# Equal buckets conversion
## M    ... if M > 0 then run length is M
# Must be called before each pixel row is read
    my($ch);
	my($ch);
    my($form) = @_;
    my($ia) = $ra*0.299 + $ga*0.587 + $ba*0.114;
    my($ib) = $rb*0.299 + $gb*0.587 + $bb*0.114;
    my($last,$this,$run) = @_;
    my($ny) = @_;
    my($ra,$ga,$ba) = unpack("CCC", $a);
    my($rb,$gb,$bb) = unpack("CCC", $b);
    my($rgb);
    my($r,$g,$b,$maxmult) = @_;
    my($rgb,$r,$g,$b);
    my($token, $ch);
    my($token) = get_token();
## N	... if N is != previous pixel, one pixel of color N
$nix = 0;
    $nix++ while ( defined($colors[$nix]) && $nix < 16 );
# Now we have our pick of colors.  Sort according to intensity;
	    $ny = 0;		# Force the last byte out
	$nybble_tmp = $ny;
    $ny = $ny & 0x0F;
	$ny = ($ny << 4) | $nybble_tmp;
## ... otherwise run sequence follows ...
## ... otherwise run sequence is encoded in two nybbles,
# Output color map
    # Output final datum for row; we're always at least one pixel behind
# Output header
	    output_nybble(0);
	    output_nybble($erun);
	    output_nybble($erun >> 4);
	    output_nybble($run);
	    output_nybble($this);
	output_nybble($this);
    output_nybble(undef);	# Flush row
    output_run($prev, $last, $run);
	    output_run($prev, $last, $run);
	# Padding for unused color entries
    $pixels, $bytes, 100*($size-$bytes)/$size;
$pixels = $xsize * $ysize;
	# Plain PBM
	# Plain PGM
	# Plain PPM
## ppmtolss16
##	ppmtolss16 [#rrggbb=i ...] < input.ppm > output.rle
	    $prev = $last;
	print chr($ny);
	print $colors[$i];
    printf STDERR
printf STDERR "%d pixels, %d bytes, (%2.2f%% compression)\n",
	print pack("CCC", 63*$i/15, 63*$i/15, 63*$i/15);
print pack("Vvv", $magic, $xsize, $ysize);
	print STDERR "$0: Color index out of range: $arg\n";
	print STDERR "$0: More than one color index $i\n";
	print STDERR "$0: Unknown argument: $arg\n";
	print STDERR "Format error on input\n";
	push(@data, $rgb);
	# Raw PBM
	# Raw PGM
	# Raw PPM, most common
	    return;
	    return (0,0,0) if ( $ch eq '1'); # Black
	    return (255,255,255) if ( $ch eq '0' ); # White
    return ( $ba <=> $bb );
    return ( $ga <=> $gb ) if ( $ga != $gb );
    return ( $ia <=> $ib ) if ( $ia != $ib );
    return ( $ra <=> $rb ) if ( $ra != $rb );
    return $rgb;
	return ($r,$g,$b);
	return ($r,$r,$r);
    return $token;
    return $token + 0;
	return undef;
	    return undef if ( !defined($ch) );
		    return undef if ( !defined($ch) );
		return undef if ( !defined($ch) );
	return undef if ( !defined($ch) ); # EOF
	    return undef unless ( read(STDIN,$rgb,1) == 1 );
	return undef unless ( read(STDIN,$rgb,1) == 1 );
	return undef unless ( read(STDIN,$rgb,3) == 3 );
	return unpack("CCC", $rgb);
    $rgb = pack("CCC", $r, $g, $b);
	$rgb = rgbconvert($pnmrgb[0], $pnmrgb[1], $pnmrgb[2], $maxmult);
    $rgb = rgbconvert($r, $g, $b, 64/256);
	$rgb = shift(@data);
    $rgb = shift @icolors;
	$r = get_numeric_token();
	$r = ( $getrgb_leftover_bit_val & 0x80 ) ? 0x00 : 0xff;
	$r = hex($1);
	$r = hex($1) << 4;
	$r = hex($1) >> 4;
	$r = hex($1) >> 8;
    $r = int($r*$maxmult);
	    $run++;
	$run--;
    $run = 0;
	    $run = 0;
		$run = 0;
	    $run  = 1;
		$run -= 271;
	$r = unpack("C", $rgb);
$size = ($pixels+1)/2;
# Sort list of colors according to freqency
    start_new_row();
sub by_intensity() {
sub get_numeric_token() {
sub getrgb($) {
sub get_token() {
sub output_nybble($) {
sub output_run($$$) {
sub rgbconvert($$$$) {
sub start_new_row() {
## the color #rrggbb (hex) should be assigned index i (decimal)
##   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
## Then, a sequence of nybbles:
## The nybble sequences are on a per-row basis; runs may not extend
# this is more or less an ugly hack to cover for the fact that
##   This program is free software; you can redistribute it and/or modify
# This routine eats exactly one character of trailing whitespace,
# to and including the end of line.)
    $token = $ch;
	$token .= $ch;
## uint16 xsize		; littleendian
## uint16 ysize		; littleendian
## uint32 0x1413f33d    ; magic (littleendian)
undef %force_index;
undef @icolors;
	undef $nybble_tmp;
undef $nybble_tmp;
# unless it is a comment (in which case it eats the comment up
## Usage:
# using PPM as input doesn't let the user set the color map,
#!/usr/bin/perl
# which the user really needs to be able to do.
    while ( 1 ) {
	    } while ( $ch ne "\n" );
		} while ( $ch ne "\n" );
    } while ( $ch =~ /^[ \t\n\v\f\r]$/ );
	} while ( $ch =~ /^[ \t\n\v\f\r]$/ );
	} while ( defined($ch) && $ch ne "\n" );
    while ( $run ) {
while ( scalar(@icolors) ) {
    # with highest priority given to G, then R, then B.
$xsize = get_numeric_token();
$ysize = get_numeric_token();
