# ---------------------------------------------------------------------
#    2006/02/21
#    2007/02/01
#    2009/06/22
# and 02 is Mac. More data give info about manufacturer, etc.  The 
#    A patch for harddisk emulation images from <colimit@gmail.com>.
#    A patch from  Ben Collins <bcollins@ubuntu.com> to make the 
#    A patch from Santiago Garcia <manty@debian.org> to use a virtual sector
# architecture the image is designed for, where 00 is i86, 01 is PowerPC
# bootable CD image
	    "bootable CD (or cd-image) given by <cd-image> and write \n",
($boot, $isoIdent, $version, $toritoSpec,
($boot, $media, $loadSegment, $systemType, $unUsed, 
# boot. The first byte has to be 01, the next byte determines the
# CD001     and ($toritoSpec)
   close(FILE);
   close(OUT);
$cnt=$count==0?$sCount:$count;
# ($count==0)
	$count=0;
        $count=1200*1024/$vSecSize;  
        $count=1440*1024/$vSecSize;  
        $count=2880*1024/$vSecSize;  
	$count=$firstSector + $partitionSize;
   $count=read(FILE, $sec, $vSecSize*$secCount, 0) ;
# defined by the El Torito standard).
# descriptor. This descriptor contains at its start the text ($isoIdent)
	die "Boot indicator in Initial/Default-Entry is not 0x88. CD is not bootable. \n";
	die "Cannot read image/device \"$imageFile\". Aborting\n";
	die "Invalid Validation Entry on image \n";
	die "This data image does not seem to be a bootable CD-image\n";
# EL TORITO SPECIFICATION
# entry and has a size of 32 bytes. 
	exit 0;
	exit 0;    
# final two bytes must contain 0x55 and 0xAA respectively (as 
#    For BootMediaType=4 (harddisk emulation) SectorCount is always 1, and geteltorito.pl
# for details
# For information on El Torito see 
#    from MBR (offset+size of the first partitition).
# geteltorito.pl: a bootimage extractor
# Get latest version from:
($header, $platform, $unUsed, $manufact, $unUsed, $five, $aa)=
	    "   -h:        This help. \n",
# http://en.wikipedia.org/wiki/El_torito
# http://userpages.uni-koblenz.de/~krienke/ftp/noarch/geteltorito
if( $boot != 0x88 ){
   if( $count != $vSecSize*$secCount ){
if( defined($opt_h) || $#ARGV <0 ){
if( defined($opt_o) ){
if( defined($opt_v) ){
if( $header != 1 || $five != 0x55 || $aa != 0xaa ){
if( $isoIdent ne "CD001" || $toritoSpec ne "EL TORITO SPECIFICATION" ){
if( length($outputFilename) ){
if( $media == 0 ){
if( $media == 1 ){
if( $media == 2 ){
if( $media == 3 ){
if( $media == 4 ){
if( ! -r $imageFile ){
$imageFile=$ARGV[0];
$image=getSector($imgStart, $cnt, $imageFile);
$initialEntry=substr($sector, 32, 32);
#    Initial release
# krienke@uni-koblenz.de
# License: GPL
	$MBR=getSector($imgStart, 1, $imageFile );
   my($name)=shift;
   my ($sec, $count);
   my ($secNum, $secCount, $file)=@_;
   my($value)=shift;
	    "\n\n";
# Now fetch the sector of the booting catalog 
# Now read the bootimage to stdout
# Now we examine the initial/defaultentry which follows the validate
	    "   -o <file>: Write extracted data to file <file> instead of STDOUT.\n",
# Only use the internal sector counter if the real size is unknown
   open(FILE, $file) || die "Cannot open \"$file\" \n";
   open(OUT, ">".$name)|| die "$0: Cannot open outputfile \"$name\" for writing. Stop.";
   $outputFilename="$opt_o";
	$partition1=substr($MBR, 446, 16);
   print "$image";
   print OUT $value;
	print STDERR "1.2meg floppy";
	print STDERR "1.44meg floppy";
	print STDERR "2.88meg floppy";
print STDERR "Booting catalog starts at sector: $bootP \n";
print STDERR "Boot media type is: ";
print STDERR "El Torito image starts at sector $imgStart and has $cnt sector(s) of $vSecSize Bytes\n";
	print STDERR "harddisk";
print STDERR "Image architecture: ";
   print STDERR "Image has been written to stdout ....\n"; 
print STDERR "Mac" if( $platform == 2 );
print STDERR "Manufacturer of CD: $manufact\n";
print STDERR "\n";
   print STDERR "\nImage has been written to file \"$outputFilename\".\n";
	print STDERR "no emulation";
print STDERR "PowerPC" if( $platform == 1 );
print STDERR "unknown ($platform)" if( $platform > 2 );
print STDERR "x86" if( $platform == 0 );
# Read a particular sector from a file
# Read Sector 17 from CD which should contain a Boot Record Volume
$ret=getopts('hvo:');
$ret=undef;$version=undef;$opt_h=undef;$loadSegment=undef;$systemType=undef;
   return($sec);
#    returns just MBR. This patch guesses the correct bootimage size
# R. Krienke 08/2001
       $sCount, $imgStart, $unUsed)=unpack( "CCvCCvVC", $initialEntry);
# Script that will extract the first El Torito bootimage from a
	    "Script will try to extract an El Torito image from a \n",
$secSize=2048;
# sector counting starts at 0, not 1
$sector=getSector(17, 1, $imageFile );
$sector=getSector($bootP, 1, $imageFile );
# see http://www.cdpage.com/Compact_Disc_Variations/eltoritoi.html
   seek(FILE, $secNum*$secSize, 0);
#    Several patches included from Nathan Stratton Treadway(nathant@ontko.com)
#    size (vSecSize) of 512 bytes, as defined on "El Torito" specs and change
sub getSector{
sub usage{
sub writeOutputFile{
	    "the data extracted to STDOUT or to a file.\n",
# The first 32 bytes of this sector contains the validation entry for a
#    to adjust the platform output as well as fixes for other minor bugs
               unpack( "CCvA24vCC", $validateEntry);
#    unpack of the sector count from n to v to get the correct sector count.
 	$unUsed, $bootP)= unpack( "Ca5CA32A32V", $sector );
	($unUsed, $firstSector, $partitionSize) = unpack( "A8VV", $partition1);
         usage(0);
use Getopt::Std;
#!/usr/bin/perl
#    utility work on PPC machines (change from 'L'-encoding in pack to 'V')
$utilVersion="0.5"; 
$validateEntry=substr($sector, 0, 32);
# Version 0.1
# Version 0.2
# Version 0.3
# Version 0.4
# Version 0.5
	    "   -v:        Print version of script and exit.\n",
$vSecSize=512;
       warn "Error reading from file \"$file\"\n";
	warn "\n$0 [-hv] [-o outputfilename] cd-image \n",
 	warn "Version: $utilVersion \n";
# We are there:
# Write eltorito data into a file
   writeOutputFile($outputFilename, $image);
