              
                                                     
:::::::::
::::::::::::::::::
!!!!!!!!!
!!!!!!!!!!!!!!!!!!
!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\~[\]\)>$#]
	/* 00 */	"Invalid"
	/* %02d */	
	/* %02d */	""
	/* %02d */	"invalid"
	/* %02d */	"%s"
$[0-9]+.
$[0-9]+.[0-9]+
 0 /* MR13 empty set expression  - undefined rule ? infinite left recursion ? */ 
0; /* no user action */
0 /* report */
1.33MR33
 1 /* MR12 no context (-prc off) */ 
1: MR_BackTraceStack.count != 0
 1 /* no context: prc is off */ 
1 /* user action */
 %-23s line %-4d  %s
  %2d %-30s
  %2d end %-26s
#%-2d in rule %s (line %d %s)
#%-2d in rule %s (line %d %s) to rule %s
  %2d to %-27s
  %2d #tokclass %-20s
  %2d #token %-23s
7',%1:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
888883888888
    %-9s%s   %s
A context guard may contain only Token references - guard will be ignored
A context guard may not contain an option block: {...} or looping block: (...)* or (...)+
action buffer overflow; size %d
action cannot be attached to a token name (%s); ignored
~ ACTION is an undefined operation
addFoLink: incorrect rule graph
addFoLink: NULL FOLLOW link
add: invalid addition
additional #first statement ignored
additional #header statement ignored
additional #parser statement ignored
addParm: invalid node for adding parm
addParm: NULL object
addParm: unable to alloc parameter
addTexpr: invalid regular expression
addTname: invalid token name
After: TokenInd[old_pos==%d] is %d
After: TokenInd[target==%d] is %d
a label ("%s") for a context guard element is meaningless
aLoopBegin
aLoopBlk
alpha in an "(alpha)? beta" block. It is not possible for antlr to
-alpha MR_BackTraceStack.count != 0
already been matched by alpha and what part remains to be matched.
alternative without predicate
Ambiguities/errors shown in low detail (default)
Ambiguities/errors shown in more detail
Ambiguities for k>1 grammars shown with exact tuples (not lookahead sets)
Ambiguities yield warnings even if predicates or (...)? block
  Ambiguity Aid                 
Ambiguity aid depth ("-aad ...") must be a number between 1 and max(k,ck)=%d
Ambiguity aid for a rule (rule name or line number)
analysis_point: no end block on (...)? block
analysis resource limit (# of tree nodes) must be greater than 0
(ANTLRChar *)""
ANTLRChar *%s_zztokens[%d]={
ANTLRChar *zztokens[%d]={
ANTLR_INFO
antlr [options] f1 f2 ... fn
ANTLRParser
Antlr parser generator   Version %s   1989-2001
 * A n t l r  S e t s / E r r o r  F i l e  H e a d e r
ANTLRTokenPtr
ANTLRTokenPtr 
 * A n t l r  T r a n s l a t i o n  H e a d e r
 * ANTLR Version %s
AParser.h
     appears to "cover" the second predicate when compared without context.
  Applies to predicates with lookahead depth > 1
  are compared without lookahead context information.  For some ambiguous
     are identical and have no resolving power
     are identical when compared without context and may have no
(...)? as last alternative of block is unnecessary
(...)? as only alternative of block is unnecessary
__assert_fail
ASTBase::
ASTBase *_ast = NULL, *_sibling = NULL, *_tail = NULL;
ASTBase.h
ASTBase **_root
ASTBase::tmake(
_ast%d%d->
_ast%d%d = (AST *)_ast;
_ast%d%d = new AST(_t%d%d);
_ast%d%d = newAST(_t%d%d);
_ast%d%d = new AST(_t%d%d); /* MR27 */
_ast%d%d = newAST(_t%d%d); /* MR27 */
*_ast%d%d=NULL
_ast%d%s
_ast = NULL;
_ast = NULL; 
AST **_root;
AST**_root
At least one <<action>> following a token match contains a reference to LA(...) or LATEXT(...)
At least one <<action>> following a token match contains a reference to LT(...)
ATokenBuffer.h
AToken.h
a token has already been forced to token number %d; ignored
ATokPtr.h
{\}#[A-Za-z0-9_]*
$[_a-zA-Z][_a-zA-Z0-9]*
#[_a-zA-Z][_a-zA-Z0-9]*
bad context guard
Before: TokenInd[old_pos==%d] is %d
Before: TokenInd[target==%d] is %d
  be reached when input matched the context of the predicate and the predicate
  between the alternative with the semantic predicate and one without
_blk%d_alt%d
~ BLOCK is an undefined operation
Blocks nested too deeply
)) break;
break;  /* MR7 */
buildAction: cannot alloc space for action
buildAction: invalid action
buildRuleRef: invalid rule name
buildToken: invalid token name
buildWildCard: invalid token name
cannot allocate error class node
cannot allocate first set name
cannot allocate fset
cannot allocate fset in newJunction
cannot allocate ft
cannot allocate ftbl
cannot allocate hash table
cannot allocate lock array
cannot allocate MR_find_in_aSubBlk jList
cannot allocate MR_find_in_aSubBlk matchList
cannot allocate MR_find_in_aSubBlk plainContext
cannot allocate MR_find_in_aSubBlk predList
cannot allocate PointerStack
cannot allocate RulePtr array
cannot allocate string table
cannot allocate token class node
cannot allocate UserAction
Cannot alloc hasAkaName
cannot alloc signal entry
cannot compute context of predicate in front of (..)? block
cannot have nested classes
cannot mix old-style $i with new-style labels
cannot mix with new-style labels with old-style $i
cannot open token defs file '%s'
'>' can only appear after a nonterminal
Can't allocate dup_matchSets
Can't alloc space for set_pdq
  Can't consider suppression for predicates with lookahead depth > 1
can't create %s
can't define #tokclass %s using #tokclass or #errclass %s
can't make context tree for NULL pred tree
Can't specify both -aa (ambiguity aid) and -alpha ("(alpha)? beta" aid)
case NoSignal: break;  /* MR7 */
case %s :
Chain of referenced rules:
Choice 1: %s  alt %d  line %d  file %s
  Choice 1: %s  line %d  file %s
Choice 2: %s  alt %d  line %d  file %s
  Choice 2: %s  line %d  file %s
    Choice %d: %-25s  line %d  file %s
     Choice:%d  Depth:%d  Group:%d
(-ck %d  -aa %s  %s  -aad %d)
(-ck %d  -aa %s  %s  [-ck value limits -aad %d])
class ASTBase;
class def output file conflicts with parser output file: %s
class meta-op used without C++ option
class %s : public ANTLRParser {
class %s %s {
 [complain to nearest government official
ComputeErrorSet: non junction passed
ComputeErrorSet: rk != nil
compute this follow set because it is not known what part of beta has
ComputeTokSets: no token def
const ANTLRChar *%s::tokenName(int tok) 
const ANTLRChar *%s::_token_tbl[]={
 consume();
consumeUntil\( ~[\)]+ \)
consumeUntil\( [\ \t]* \{~[\}]+\} [\ \t]* \)
context predicate's guardNodes == NULL
context predicate's source == NULL
couldn't complete k=1
Cross Reference:
ctx cannot allocate
__ctype_b_loc
__ctype_tolower_loc
__ctype_toupper_loc
 /* [%d] 
(%d)%13s
default :
default errclass for '%s' would conflict with token/errclass/tokclass
DefErrSetForC1: nil set to dump?
DefErrSetForCC1: nil set to dump?
#define ANTLR_SUPPORT_CODE
#define ANTLR_VERSION %s
#define ANTLR_VERSION	%s
#define DEMAND_LOOK
#define EXCEPTION_HANDLING
#define GENAST
#define LL_K %d
#define NUM_SIGNALS %d
#define PCCTS_PURIFY(r,s) memset((char *) &(r),'\0',(s));
#define %s
#define %s %d
#define setwd%d %s_setwd%d
#define %s_h
#define %s %s
#define %s %s_%s
#define STDPCCTS_H
#define STDPCCTS_%s_H
#define ZZCAN_GUESS
#define zzEOF_TOKEN %d
#define zzerr%d %s_err%d
#define zzSET_SIZE %d
#define zzTRACE_RULES
  depth=k=%d
depth > MR_AmbSourceSearchLimit
depth > suppressChainLength
Directory where all output files should go (default=".")
DLexerBase.h
DLGmaxToken
	DLGmaxToken=9999};
DLGminToken
	DLGminToken=0
doEclass: NULL eset
Do not generate lexical (dlg-related) files (default=FALSE)
Do not generate output parser code (default=FALSE)
Do not generate sets for token expression lists (default=FALSE)
Do not generate tokens.h (default=FALSE)
Don't use the notorious PURIFY macro (replaced by MR23 initial value syntax) to zero return arguments of rules
don't you want a ')' with that '*'?
don't you want a ')' with that '+'?
dumpAction: NULL action
dumpAction: output FILE is NULL for %s
dumpAfterActions: output file was NULL for some reason
DumpFormals: invalid string
DumpInitializer: invalid string
DumpListOfParmNames: NULL parm
Dump of First/Follow Cache
DumpOldStyleParms: NULL parm
dumpPredAction action->inverted
dumpPredEntry p->source->inverted != 0
DumpType: invalid type string
duplicate exception handler for label '%s'
duplicate rule definition: '%s'
} else {
} else break; /* MR6 code for exiting loop "for sure" */
else break; /* MR6 code for exiting loop "for sure" */
else {FAIL(1,err%d
else {FAIL(%d
else _signal=NoSemViableAlt;
else {zzFAIL(1,zzerr%d
else {zzFAIL(%d
empty error set for alt - probably because of undefined rule or infinite left recursion
end (...)? block at
End dump of First/Follow Cache
#endif /* %s_h */
enum ANTLRTokenType {
	enum { SET_SIZE = %i };
eoln found in char literal (in user action)
eoln found in regular expression
eoln found in string
eoln found in string (in user action)
{\}#errclass
errclass name conflicts with regular expression  '%s'
error: required argument for option %s omitted
 error: %s
exceeded max depth of FOLLOW recursion (%d)
exceeded max # of input files
exception
exception: cannot allocate action
exception: cannot allocate handler
exception: cannot allocate sig name
/* exception handlers */
EXPERIMENTAL change to (...)* and (...)+ syntax error sets
EXPERIMENTAL Maintenance Release style hoisting enabled
extern SetWordType setwd%d[];
extern SetWordType %s%s[];
extern SetWordType zzerr%d[];
extern struct _rv%d
extern void %s%s();
Extra info: p=pred t=tnodes f=first/follow m=monitor o=orphans 0=noop
fatal: attrib/AST stack overflow %s(%d)!
Fewer output values than output formals for rule reference
     (file %s alt %d line %d and alt %d line %d)
file '%s' can't be opened
file %s doesn't exist; ignored
file '%s' ignored as '-' (stdin option) was specified first
findImmedAction: invalid node
findImmedAction: NULL node
{\}#first
FirstSetSymbol
/** #FirstSetSymbol(%s) **/
FoLink: invalid diagram node: ntype==%d
 Follow[
      follow sets computed as a result of an "(alpha)? beta" block
FOLLOW(%s) must be in cache but isn't
FoPop: FoStack stack-ptr is playing out of its sandbox
FoPop: tried to access non-existent stack
FoPush: cannot allocate FOLLOW stack
FoPush: FoStack stack-ptr is playing out of its sandbox
FoPush: tried to access non-existent stack
FoPush: tried to push NULL rule
for (;;) {
for #tokclass %s %s..%s - first token number > second token number
found consumeUntil( {...} )
found expr '%s' at target %d in lclass[%d]; changed to %d
found expr '%s' for id %s in lclass[%d]; changed to %d
found rexpr %s
found the exception operator '@' - but no exception group was found
found token %s
__fprintf_chk
freeBlkFsets: invalid node
genAction: invalid node and/or rule
genAction: not action
genBlk: invalid node
genBlk: not junction
GenCrossRef: FoLinks are screwed up
GenCrossRef: why are you passing me a null grammar?
genDefFile: cannot open %s
Generate an error class for each non-terminal (default=FALSE)
Generate ANSI-compatible code (default=FALSE)
Generate code for Abstract-Syntax-Trees (default=FALSE)
Generate code to trace rule invocation (default=FALSE)
Generate C++ output (default=FALSE)
Generate cross reference (default=FALSE)
 * Generated from:
Generate line info about grammar actions in C parser
Generate parsers that delay lookahead fetches until needed
Generate stdpccts.h for non-ANTLR-generated-files to include
genExpr: cannot allocate IF expr pdq set
genExprTree: tree is NULL
genJunction: not generic junction
genJunction: not junction
genLexDescr: rexpr %s not in hash table
genLexFile: cannot open %s
genLoopBegin: invalid Loop Graph
genLoopBegin: invalid node and/or rule
genLoopBegin: not junction
genLoopBegin: not loop block
genLoopBlk: not junction
genLoopBlk: not loop block
genOptBlk: not junction
genOptBlk: not opt block
genPlusBlk: invalid node and/or rule
genPlusBlk: not a valid Plus block
genPlusBlk: not junction
genPlusBlk: not Plus block
genPredTreeOrig: predicate tree is wacked
GenRemapFile: cannot open %s
genRule: can't open output file
genRule: not junction
genRule: not rule
genRuleRef: invalid node and/or rule
genRuleRef: not rule reference
genSubBlk: not junction
genSubBlk: not subblock
genToken: invalid node and/or rule
genToken: not token
getInitializer: invalid string
-gk does not work currently in C++ mode; -gk turned off
-gk incompatible with semantic predicate usage; -gk turned off
-gk option could cause trouble for <<...>>? predicates
GLIBC_2.0
GLIBC_2.1
GLIBC_2.3
GLIBC_2.3.4
GLIBC_2.4
__gmon_start__
 goto %s_handler;  /* MR7 */
grammar-element
  ("=>" guard)
  ("&&" guard)
guard is 0 tokens long
guard is %d tokens long - lookahead is limited to max(k,ck)==%d
hasAction: expr '%s' doesn't exist
hasAction: invalid expr
hash table mechanism is broken
{\}#header
../h/err.h
 hit analysis resource limit while analyzing alts %d and %d %s
hit unknown situation during predicate hoisting
Hoisting of predicate suppressed by alternative without predicate.
#i AST ref too big
$i attrib ref too big
#ifdef __USE_PROTOS
if ( !guessing ) {
if ( guessing ) goto fail;
if (!guessing) {    /* MR10 */
if ( guessing ) zzGUESS_FAIL;
$i.field attrib ref too big
if ( !_match_wsig(%s) ) {
#ifndef ANTLR_VERSION
#ifndef PCCTS_PURIFY
#ifndef %s
#ifndef %s_h
#ifndef STDPCCTS_H
#ifndef STDPCCTS_%s_H
#ifndef zzTRACE_RULES
if ( !_setmatch_wsig(%s) ) {
if (_signal) {
if (!_signal)
if (_signal) goto %s_handler;
if (_signal != NoSignal)
if (_sva) _signal=NoViableAlt;
if ( _tail==NULL ) _sibling = _ast; else _tail->setRight(_ast);
if ( zzcnt > 1 ) break;
if ( zzguessing ) goto fail;
if (!zzguessing) {    /* MR10 */
if ( zzguessing ) zzGUESS_FAIL;
if ( !_zzmatch_wsig(%s) ) {
if ( !zzrv ) {
if ( !zzrv ) zzGUESS_DONE;
if ( !zzrv ) zzGUESS_DONE; /* MR28 */
illegal MR_AmbAidDepth
Illegal pred->expr
Illegal predicate->expr
implicit token definition not allowed with #tokdefs
  Implies -prc on and -mrhoist on
  Implies -prc on but does *not* imply -mrhoistk for k>1 predicates
in (...)* block
in (...)+ block
in {...} block
in (...)? block at
#include
#include "antlr.h"
#include "ast.c"
#include "ast.h"
#include "dlgdef.h"
#include "err.h"
#include "pcctscfg.h"
#include "pccts_setjmp.h"
#include "pccts_stdio.h"
#include "%s"
#include %s
#include "%s.h"
In C++ mode use "newAST(...)" rather than "new AST(...)"
In C++ mode use parser's tmake method rather than "ASTBase::tmake(...)"
 *** incomplete ***
 Incomplete Set at k=%d !
 Incomplete Tree at k=%d !
Increase MaxLexClasses in generic.h and recompile all C files
Increase StrTableSize in hash.h and recompile hash.c
infinite left-recursion to rule %s from rule %s
inf_text_buffer_ptr
inf_text_buffer_size
_inf_zzgettok
in guarded predicates all tokens in the guard must be at the same height
inlineX_set
 #$%%*&@# internal error: %s
    Intersection of lookahead[%d] sets:
int *_retsignal
int *_retsignal;
int _signal;
int _signal=NoSignal;
int _sva=1;
int zzcnt=1;
invalid aPlusBlk
Invalid automaton mode = %d 
invalid block
invalid element in consumeUntil( {...} )
invalid meta token
invalid node type
invalid option: '%s'
invalid or missing context guard
invalid set to tree conversion
invalid token
 ! /* inverted pred */ (
i of $i.j attrib ref too big
_IO_getc
_IO_putc
_IO_stdin_used
It is unusual (but ok) for a semantic predicate to test context past the end of its own rule
                               j 
 jjjn    fnn f            b                       
j of $i.j attrib ref too big
k>99 is too big for this implementation of ANTLR!
(-k %d  -aa %s  %s  -aad %d)
(-k %d  -aa %s  %s  [-k value limits -aad %d])
K: MR_BackTraceStack.count != 0
k <= sizeof(f)/sizeof(f[0])
label definition clashes with rule definition: '%s'
label definition clashes with token/tokclass definition: '%s'
label definitions must be unique per rule: '%s'
(LA(%d)==
 LA(%d)==%d
 LA(%d)==%s
LATEXT(i)
length of guard (%d) does not match the length of semantic predicate (%d)
<<%%%%lexaction
{\}#lexaction
{\}#lexclass
lexclass: cannot allocate ExprStr
lexclass name conflicts with token/errclass label '%s'
Lexical error
 lexical error: %s (text was '%s')
<<%%%%lexmember
{\}#lexmember
lexmode: invalid mode
<<%%%%lexprefix
{\}#lexprefix
libc.so.6
__libc_start_main
/lib/ld-linux.so.2
Like -gl but replace '\' with '/' in #line filenames for MS C/C++ systems
Limit max # of tree nodes used by grammar analysis
Limits exp growth of -aa listing - default=1 (max=ck value)
#line %d "%s"
line %d: syntax error at "%s" missing %s
#line ~[\n\r]* (\n|\r|\r\n)
#line[\ \t]* [0-9]+ {[\ \t]* "~["]+" ([\ \t]* [0-9]*)* } (\n|\r|\r\n)
link(_root, &_sibling, &_tail);
list_add: attempting to add NULL list element
list_add: cannot alloc new list node
list_add: cannot alloc sentinel node
list_apply: NULL function to apply
LOOKAHEAD
  lookahead context information.  For some ambiguous lookahead
  lookahead sequences the second predicate may not have any power to
Lookahead token may appear multiple times in -aa listing
look(%d);
main: cannot allocate Cycles List
main: cannot allocate FoStack
main: cannot allocate FoTOS
main: cannot allocate TokenStr
main: can't open class Parserx.c file
main: can't open class Parserx.h file
main: can't open err file
Maintenance Release style hoisting enabled for predicates with lookahead depth = 1
makeBlk: invalid graph
makeLoop: invalid graph
makeOpt: invalid graph
makePlus: invalid graph
make_tree_from_sets: LL_k must be > 1
malformed consumeUntil( {...} ); missing '{'
mark_label_used... ntype != nToken
mark_label_used... TokNode has no label
matchSets[0] alloc
matchSets[1] alloc
max token number is %d
me->source == NULL
meta-symbol
MismatchedToken
 missing
missing class definition for trailing '}'
Missing <<; found dangling >>
Missing /*; found dangling */
Missing /*; found dangling */ in action
More output actuals than output formals for rule reference
};    /* MR10 */
 /* MR10 Distinct OR context optimization */ 
/* MR10 ()+ */ else {
/* MR10 */ else {
/* MR10 */ if (0) {}     /* last alternative of block is guess block */
/* MR10 ()+ */ if ( zzcnt > 1 ) break;
/* MR10 ()+ */ if ( !zzrv ) zzGUESS_DONE;
/* MR10 */ if ( !zzrv ) zzGUESS_DONE;
/* MR10 individual OR gates suppressed when all predicates are leaves
|| /* MR10 was wrong */ 
/* MR12 individual AND gates suppressed when all predicates are leaves
 /* MR13 empty error set for this alt - undef rule ? infinite left recursion ? */
) { /* MR21 option -mrblksynerr */
/* MR23 In order to remove calls to PURIFY use the antlr
/* MR23 skip error clause for (...| epsilon) when exceptions in use */
/* MR23 skip error clause for {...} when exceptions in use */
MR_all_leaves_same_height ALT or EpToken
-mrblkerr
MR_comparePredLeaves: not both PRED_LIST
MR_computeTreeAND: p->ALT unexpected
MR_computeTreeAND: q->ALT unexpected
MR_computeTreeIntersection: p->ALT unexpected
MR_computeTreeIntersection: p->EpToken unexpected
MR_computeTreeIntersection: q->ALT unexpected
MR_computeTreeIntersection: q->EpToken unexpected
MR_distinctORcontextOpt: can't get here when using MR_predSimplify
MR_find_in_aSubBlk: pred depth < 1
MR_find_in_aSubBlk: predDepth > CLL_k
MR_First: non junction passed
MR_guardpred_plainSet not Junction
-mrhoist
mrhoist.c
-mrhoistk
MR_max_height_of_tree ALT or EpToken
MR_merge_tree_contexts: can't alloc chain
MR_nameToRule: RulePtr not initialized
MR_pointerStackPop underflow
MR_pointerStackTop underflow
MR_predFlatten AND/OR no child
MR_projectTreeOntoSet: EpToken unexpected
MR_suppressK: can't allocate chain
MR_suppressK_client: chain empty
MR_suppressK_client: MR_BackTraceStack.count != 0
MR_suppressK_client: suppressSets alloc
MR_suppressK_client TRAV incomplete
MR_suppressSearchReport: no match to #token in chain
MR_suppressSearchReport: no match to #token set in chain
MR_traceAmbSourceK TRAV incomplete
MR_traceAmbSource REACH incomplete
MR_tree_equ: b->EpToken unexpected
MR_tree_equ: big: ALT node has siblings
MR_tree_equ: s->EpToken unexpected
MR_tree_equ: small: ALT node has siblings
MR_tree_matches_constraints: set_deg != 1
must have at least one token of look-ahead (setting to 1)
must have at least one token of lookahead (setting to 1)
must have compressed lookahead >= full LL(k) lookahead (setting -ck to -k)
mystrdup: NULL string
(new AST(
(new AST)
(newAST(
(newAST)
newEntry: out of memory for terminals
newExpr: cannot alloc Expr node
new: NULL terminal
new_pred: cannot alloc predicate
NewSetWd: cannot alloc set wd
new token definition '%s' not allowed - only #token with name already defined by #tokdefs file allowed
		NLA = %d;
		NLA = %s;
  !!!!nnd 
No grammar description found (exiting...)
no grammar description recognized
no #header action was found
<<nohoist>> appears as init-action - use <<>> <<nohoist>>
No input stream, function, or string
No label or expr for token %d
  No longer considered experimental
no longer used; predicates employed if present
no more room in File List Area
NonTerminal
~ NONTERMINAL is an undefined operation
no previously defined #pred with name "%s"
-nopurify
 -nopurify option */
no regular expressions found in grammar
NoSemViableAlt
Not a rule block
note: Start rules: {
note: the following is a list of rules which *may* have incorrect
note: the list of rules with compromised follow sets is empty
note: there were %d messages about "(alpha)? beta" blocks added to the generated code
note: there were no messages about "(alpha)? beta" blocks added to the generated code
note: Unreachable C or C++ code was generated for empty expression sets,
note: use -e3 to get exact information on ambiguous tuples
/* nothing */ }
not possible to compute follow set for alpha in an "(alpha)? beta" block.  
      not the one which follows as is the case with semantic predicates.
NoViableAlt
~[\n\r'\]+
~[\n\r"\]+
~[\n\r]+
~[\n\r\)\(\$#\>\]\["'/]+
~[\n\r\*]+
\(\n|\r|\r\n)
\n|\r|\r\n
NULL block
null expr
number of allowable lexclasses exceeded
numeric references to attributes (e.g. $i or $i.j) in semantic pred will be null during guess mode
of (..) 
of (..)* 
of (..)+ 
of {..} 
of the rule itself 
one or more $i in action(s) refer to non-token elements
one (or more) predicate expression hoisted into rule "%s" are always false - see output file for more information
one (or more) predicate expressions hoisted into rule "%s" are always false - use "-info p" for more information
only one grammar class allowed in this release
 /* Opt 
 (optional branch) */
Or: invalid graph
  or send hate-mail to parrt@parr-research.com;
outname: filename too big
outname: NULL filename
[...] out of context 'rule > [...]'
out of memory
out of memory in tdif while checking predicates
 out of memory while analyzing alts %d and %d of %s
 out of memory while analyzing alts %d and %d %s
out of memory while building rule '%s'
pAction: not action node
pAction: NULL node
parameter buffer overflow; size %d
 * Parr Research Corporation
{\}#parser
<<%%%%parserclass %s>>
parser.dlg
#parser meta-op incompatible with -CC; ignored
#parser meta-op incompatible with '-gp prefix'; '-gp' ignored
Part (or all) of predicate with depth > 1 suppressed by 
PassAction
pBlk: invalid ()* block
PCCTS_PURIFY(_retv,sizeof(
PCCTS_PURIFY(_retv,sizeof(struct _rv%d))
pEnd == NULL
pEnd < pStart
pJunc: not junction
pJunc: NULL node
  please pray to the ``bug'' gods that there is a trival fix.]
popint: stack underflow
{\}#pred
predEntry->source == NULL
predicate alt 1 not completed
predicate alt 2 not completed
predicate buffer overflow; size %d
predicate contains elements both with and without context
predicate context is not complete
(...)? predicate must be first element of production
predicate refers to lookahead token %d. Semantic lookahead is limited to max(k,ck)==%d
predicate: %s missing, bad, or with i=0; assuming i=1
Predicate Suppressed
     predicate text: "%s"
predicate tree is wacked
PredRuleRef stack not empty
#pred %s previously defined - ignored
pred %s <<%s>>?
pred tree context is empty
pred tree is orphan OR or AND list
pred tree is really wacked
Prefix all generated rule functions with a string
__printf_chk
PRINT: NULL object
Print out the grammar w/o actions (default=no)
Print out the grammar w/o actions & w/FIRST sets (default=no)
-pr is no longer used (predicates employed if present); see -prc, -mrhoist, -mrhoistk
private:
        probably due to undefined rules or infinite left recursion.
ProcessArgs: command line NULL
productions have no lookahead in predicate checking routine
protected
protected:
Provide additional information for "(alpha)? beta" error messages
pRuleRef: not rule ref node
pRuleRef: NULL node
prune: ALT node in FIRST tree
pToken: not token node
pToken: NULL node
 * Purdue University Electrical Engineering
pushint: stack overflow
QuotedTerm
REACH: NULL object
Read grammar from stdin
Read names of grammar files from specified file
redefinition of action for expr %s; ignored
redefinition of action for %s; ignored
redefinition of errclass or conflict w/token or tokclass '%s'; ignored
redefinition of expr %s; ignored
redefinition of tokclass or conflict w/token '%s'; ignored
redefinition of #tokclass '%s' to #token not allowed; ignored
redefinition of token %s; ignored
reference in exception handler to undefined label '%s'
RegisterCycle: couldn't alloc new cycle
RegisterCycle: FoStack is screwed up beyond belief
RegisterCycle(%s): FoStack stack-ptr is playing out of its sandbox
RegisterCycle: tried to access non-existent stack
RegisterCycle: tried to register NULL rule
RemapForcedTokens: cannot allocate TokenInd
RemapForcedTokens: expr not in hash table
RemapForcedTokens: token not in hash table
Remap...: invalid diagram node
remapping %d to %d
Rename err.c
Rename lexical output--parser.dlg
Rename mode.h
/* rename PCCTS-supplied AST symbols to be 'ParserName_symbol' */
/* rename PCCTS-supplied symbols to be 'ParserName_symbol' */
Rename remap.h
/* rename rule functions to be 'ParserName_func' */
Rename stdpccts.h header (turns on -gh)
Rename tokens.h
Report when tnode usage exceeds value during ambiguity resolution
required grammar class not found (exiting...)
  resolve the ambiguity.
     resolving power for some lookahead sequences.
Restricting the context of a predicate because of overlap in the lookahead set
*_retsignal = NoSignal;
*_retsignal = _signal;
		return (ANTLRTokenType)%d;
return _retv;
		return %s;
  { return _token_tbl[tok]; }
$retval attrib ref too big
 _retv = %s;
_retv.%s
rJunc: lock array is NULL
rJunc: not action
rJunc: not junction
rJunc: NULL node
(*_root)
rRuleRef: not rule ref
rToken: not token node
rToken: NULL node
Rule %20s referenced by {
RuleBlk p2 does not point to another RuleBlk
RuleBlkWithHalt->end not RuleBlk or does not have halt set
RuleBlkWithHalt->end not RuleBlk or has no halt set
RuleBlkWithHalt has no halt set
RuleBlkWithHaltStack not consistent
rule element: cannot allocate assignment
rule element: cannot allocate predicate fail action
rule->end->halt already set
rule->end->halt not set
RuleEntry not found
RuleEntry == NULL
rule grammar: cannot allocate base class name
rule grammar: cannot allocate #first action
rule grammar: cannot allocate header action
Rule hash table is screwed up beyond belief
rule laction: cannot allocate action
rule lmember: cannot allocate action
rule lprefix: cannot allocate action
rule name > max of %d
RulePtr not initialized
RulePtr[] not yet initialized
RulePtr==NULL
RuleRefStack and RuleBlkWithHaltStack not same size
rule rule: cannot allocate error action
rule rule: cannot allocate param decl
rule rule: cannot allocate ret type
    rule %s
rule %s accepts no parameter(s)
  rule %s  line %d  %s
rule %s must be defined but isn't
rule %s not defined
rule %s requires parameter(s)
rule %s returns a value(s)
Rule %s uses rule %s via RulePtr before it has been initialized
Rules which make use of the incorrect follow set will also be incorrect
rule %s yields no return value(s)
rule token: cannot allocate action
(%s) && 
	%s(ANTLRTokenBuffer *input);
%s(ANTLRTokenBuffer *input) : %s(input,%d,%d,%d,%d)
%s = (ANTLRTokenPtr)LT(1);
%s_ast = _ast%d%d;
 *%s_ast=NULL
%s_ast = zzastCur;
save_fs calloc
/* %s -- DLG Description of scanner
self-referential error class '%s'; ignored
~ SEMANTIC-PREDICATE is an undefined operation
Send grammar.c/grammar.cpp to stdout
  sequences they may not have any power to resolve the ambiguity.
%s_errset
%s_errsetbar
Set compressed lookahead depth; fast approximate lookahead
set context: 
set_ext(%d words): cannot allocate set
Set full LL(k) lookahead depth (default==1)
setHasAction: expr '%s' doesn't exist
setHasAction: invalid expr
set_new: Cannot allocate set with max of %d
set_pdq failed
Set the warning level to 1 (default)
setUpperRange: NULL token node
setUpperRange: NULL token string
(setwd%d[LA(%d)]&0x%x)
SetWordType %s::err%d[%d] = {
SetWordType setwd%d[%d] = {
SetWordType %s%s[%d] = {
SetWordType %s::setwd%d[%d] = {
SetWordType %s::%s%s[%d] = {
SetWordType zzerr%d[%d] = {
%s forced to %d
should only have one halt at a time
_signal=MismatchedToken;
 _signal=NoSignal;
_signal=NoSignal;  /* MR7 */
skipCharLiteral
skipStringLiteral
%s, line %d:
/* %s -- List of labelled tokens and stuff
/* %s -- List of symbols to remap
%s NAND (not AND) expr
%s near line %d (text was '%s')
%s NOR (not OR) expr
; "%s" not
$%s not parameter, return value, (defined) element label
 %s=NULL
 * %s: P a r s e r  H e a d e r 
 * %s: P a r s e r  S u p p o r t
 * %s -- P C C T S  I n c l u d e
__sprintf_chk
%sresynch(setwd%d, 0x%x);
%s::_rv%d
%s_setbar
%s%s_handler:
%s::%s%s(
%s%s(%s);
%s%s(&_signal%s%s); 
%s%s(%s,&_signal%s%s); 
%s%s(%s%s%s);
%s%s(%s%s&_signal%s%s);
__stack_chk_fail
 * Standard PCCTS include file with -fh %s -- P C C T S  I n c l u d e
	static  const ANTLRChar *tokenName(int tk);
	static const ANTLRChar *_token_tbl[];
static const unsigned LL_K=%d;
	static SetWordType err%d[%d];
	static SetWordType setwd%d[%d];
	static SetWordType %s%s[%d];
%s = _t%d%d;
'-' (stdin) ignored as files were specified first
stdpccts.h
__strcat_chk
__strcpy_chk
string table overflow
strmember: NULL string
	struct _rv%d
struct _rv%d
struct _rv%d {
struct _rv%d _retv;
{ struct _rv%d _trv; _trv = 
subchild(_root, &_sibling, &_tail);
subroot(_root, &_sibling, &_tail);
SubstErrorClass: NULL eset
/* Suppressed by MR6 */ /*** else break; ***/
switch ( _signal ) {
switch ( _signal ) {  /* [%s] */
 syntax error at "%s"
syn(zzBadTok, %s, zzMissSet, zzMissTok, zzErrk);
%s = zzaCur;
tab width must be between 1 and 8
tAction for ampersandpred: k <= 1
tAction save_fset alloc
tcontext inconsistent
 _t%d%d = (ANTLRTokenPtr)LT(1);
 _t%d%d = (ANTLRTokenPtr)LT(1);  /* MR10 */
 * Terence Parr, Russell Quong, Will Cohen, and Hank Dietz: 1989-2001
 * Terence Parr, Will Cohen, and Hank Dietz: 1989-2001
The alt without the predicate includes all cases where the predicate is false.
The context set for the predicate:
The first predicate appears to "cover" the second predicate when they
The following predicate expression will always be false:
The following predicates are identical when compared without
The intersection of the two sets
    the lookahead buffer size in C mode is %d token(s) (including the one just recognized)
The lookahead set for the alt WITHOUT the semantic predicate:
The -mrblkerr option is designed only for k=1 ck=1 grammars
The -mrblkerr option is EXPERIMENTAL
The new (modified) form of the predicate:
The original context set for the predicate:
The original predicate:
  The original predicate for choice 1 with available context information:
  The original predicate for choice 2 with available context information:
The predicate:
  The predicate for choice 1 after expansion (but before simplification)
  The predicate for choice 1 after expansion (but without context information):
  The predicate for choice 2 after expansion (but before simplification)
  The predicate for choice 2 after expansion (but without context information):
The predicate is empty (or always true)
the predicates used to disambiguate
the predicates used to disambiguate optional/exit paths of 
the predicate used to disambiguate the first choice of
the predicate used to disambiguate the first choice of the optional/exit paths of 
There are no token ptrs for rule references: '$%s'
there is no rule "%s" so "-aa %s" will never match
there was no ambiguity that matched "-aa %s"
There were %d tnodes created to resolve ambiguity between:
There were %d tuples whose ambiguity could not be resolved by full lookahead
     These alts have ambig lookahead sequences resolved by a predicate for
     the second choice. The second choice may not be reachable.
     The second predicate may have no resolving power for some lookahead sequences.
The sequence of references which generate that sequence of tokens:
The token sequence which is suppressed:
this cannot be printed
  This is a reminder, not a warning or error.
this #tokclass statment conflicts with a previous #tokclass %s("%s") statement
this #token statment conflicts with a previous #token %s("%s") statement
      this will reference the immediately preceding token,
Tklink: invalid token name and/or expr
tlink: bad tree
tlink: invalid tree
/* tnodes created for rule %s:  %d */
Tnum: invalid terminal
{\}#tokclass
#tokclass not in hash table
{\}#tokdefs
{\}#token
token label has no associated rexpr: %s
token name %s and rexpr %s already defined; ignored
token not in sym tab when it should be
#token requires at least token name or rexpr
tokensInChain alloc
	token_tbl = _token_tbl;
TokenTerm
      To locate: search the generated code for "empty set expression"
too many rules???
topint: stack underflow
Trace of references leading to attempt to compute the follow set of
	traceOptionValueDefault=0;		// MR10 turn trace OFF
	traceOptionValueDefault=1;		// MR10 turn trace ON
TRANS: NULL object
TRAV: NULL object
tree context:
Tree Nodes:  peak %d  created %d  lost %d
Tree Nodes:  peak %dk  created %dk  lost %d
tree too short
-treport
 = _trv.
     Try using a context guard '(...)? =>'
tToken: constrain is not a valid set
<\t-<"tQ
Ttrack: can't extend ExprStr
Ttrack: can't extend TokenStr
Turn on/off computation of context for hoisted predicates
Turn on/off k>1 EXPERIMENTAL Maintenance Release style hoisting
Turn on/off k=1 Maintenance Release style hoisting
= &_tv%d%d
_tv%d%d,
undefined rule '%s' referenced in errclass '%s'; ignored
undefined token '%s' referenced in errclass '%s'; ignored
Unexpected ntype
unknown label in exception handler: '%s'
unknown meta-op: %s
UnknownToken#%d
unrecognized -info option "%c"
$[..] use invalid in C++ mode
$[] use invalid in C++ mode
$$ use invalid in C++ mode
Use #lexmember only in C++ mode (to insert code in DLG class header
Use #lexprefix only in C++ mode (to insert code in DLG class header
   Use upward inheritance ("rule >[Attrib a] : ... <<$a=...>>")
#-variable or other AST item referenced w/o -gt option
$-variables in actions outside of rules are not allowed
void %s::
	void %s%s(
	void zzdflthandlers( int _signal, int *_retsignal );
 warning: alt %d line %d and alt %d line %d of %s
 warning: alt %d %shas no predicate to resolve ambiguity
 warning: alts %d and %d %sambiguous upon
 warning(approx): alts %d and %d %sambiguous upon
 warning: optional/exit path and alt(s) %sambiguous upon
 warning: predicate applied for >1 lookahead %d-sequences
 warning: %s
 warning: %s of %s in rule %s
 warning: %s rule %s
  was false.
When using predicate context (-prc on) -mrhoist on is recommended
} while ( 
} while ( 1 );
} while (%s);
why not do this in calloc wrapper
Width of tabs (1 to 8) for grammar.c/grammar.cpp files
WildCard
~ WILDCARD is an undefined operation (implies 'nothing')
 * with AHPCRC, University of Minnesota
 with identical context */
without "-prc on" (guard)? && <<pred>>? ... doesn't make sense
   WITHOUT predicate: all alternatives without predicates (combined)
   WITHOUT predicate: line %d  %s
Without this restriction the alternative without the predicate could not
   WITH predicate: line %d  %s
 * with Purdue University Electrical Engineering
You can no longer use attributes returned by rules when also using ASTs
     You may only want one lookahead %d-sequence to apply
     You may want to use a complementary predicate or rearrange the alts
zzaArg(zztasp%d,%s)
zzaArg(zztasp%d,%s).
zzaArg(zztasp%s,%s)
zzadvance
	zzadvance();
zzaPush(%s);
zzaStack
zzastArg(%s)
 zzastDPush;
zzASTgvars
zzastnew
zzastnew()
zzastPush(zzmk_ast(zzastnew(),zzaCur)); /* MR27 */
zzast_sp
zzastStack
zzbegcol
zzbegexpr
zzBLOCK(zztasp%d);
zzbufovf
zzbufsize
zzcharfull
zzclose_stream
zzcnt++;
zzconstr_attr
zzconstr_attr(
 zzCONSUME;
zzconsumeUntil
zzconsumeUntilToken
zzdflthandlers
zzdflthandlers( int _signal, int *_retsignal )
zzdflthandlers( _signal, _retsignal )
zzdflthandlers(_signal,_retsignal);
zzdouble_link
zzdup_ast
zzedecode
zzempty_attr
zzendcol
zzendexpr
zzerraction
zzerraction()
zzerraction(void)
zzerr_in
	(*zzerr)("%s");
zzerrstd
zzEXIT(zztasp1);
zzEXIT(zztasp%d);
) {zzfailed_pred("%s",%s, { %s } );}
zzfill_inf_look
zzfree_ast
zzGUESS_BLOCK
zzGUESS_DONE
zzguessing
zzGuessSeq
zzguess_start
zzinf_labase
zzinf_last
zzinf_text
zzinf_text_buffer
zzinf_tokens
zzlabase
zzLexErrCount
zzlextext
 zzLOOP(zztasp%d);
zzLOOP(zztasp%d);
zzMake0;
_zzmatch
zzmatch(%d);
zzmatch(%s);
_zzmatch_wdfltsig
zzmatch_wdfltsig((ANTLRTokenType)%d,%s);
zzmatch_wdfltsig(%s,%s);
_zzmatch_wsig
zzmatch_wsig(%d,%s_handler);
zzmatch_wsig(%s, %s_handler);
,&zzMissSet,&zzMissText,&zzBadTok,&zzBadText,&zzErrk); goto fail;}
zzmk_ast(zzastnew(),
zzNON_GUESS_MODE {
zzparser
 && (zzpf=1, 
zzpre_ast
zzrdfunc
zzrdstream
zzreal_line
zzreplchar
zzreplstr
zzrestore_antlr_state
zzrestore_dlg_state
zzresynch
!zzrv && 
zzsave_antlr_state
zzsave_dlg_state
zzset_deg
zzset_el
_zzsetmatch
zzsetmatch(%s, %s);
_zzsetmatch_wdfltsig
zzsetmatch_wdfltsig(%s,(ANTLRTokenType)%d,%s);
_zzsetmatch_wsig
zzsetmatch_wsig(%s, %s_handler);
	zzskip();
zzStackOvfMsg
zzsubchild
zzsubroot
zzSyntaxErrCount
zzsyn(zzMissText, zzBadTok, %s, zzMissSet, zzMissTok, zzErrk, zzBadText);
zztextLA
zztmake(
zztokenLA
zztokens
zztoktext
zzTraceCurrentRuleName
zzTraceDepth
zzTraceGuessDone
zzTraceGuessFail
zzTraceGuessOption
zzTraceGuessOptionValue
zzTraceIn
zzTRACEIN((ANTLRChar *)"%s");
zzTRACEIN("%s");
zzTraceOption
zzTraceOptionValue
zzTraceOut
zzTRACEOUT((ANTLRChar *)"%s");
zzTRACEOUT("%s");
zzTraceReset
