	    --)
	    --admon-graphics-path)
  --admon-graphics-path=PATH      the path to the admonition graphics
	    --admon-graphics-size)
  --admon-graphics-size=INT       the size of the admonition graphics
# along with this program; if not, write to the Free Software
    arg="$1"
# As a special exception to the GNU General Public License, if you
# (at your option) any later version.
Automatic Graphics:
Basic Output Control:
#!/bin/bash
# byte-by-byte.
	c0=${arg:$i:1}
	    c1=${arg:$((i+1)):1}
	    c2=${arg:$((i+2)):1}
	c=${arg:$i:1}
	case "$1" in
    cat <<EOF
cat <<EOF
	    -c | --css-file)
  -c, --css-file=FILE             file to output CSS to
	    --classsynopsis-language)
  --classsynopsis-language=LANG   the default programming language to be used
	    cmd="cp \"$doc_icons_admon_path/$doc_icon_file\" \"$doc_outdir/$doc_icon_file\""
		cmd="cp \"$doc_indir/$doc_media\" \"$doc_outdir/$doc_media\""
		cmd="cp \"$doc_indir/$fig\" \"$doc_outdir/$fig\""
	    cmd="echo '<stylesheet xmlns=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\">\
	cmd="xmllint --nonet --xinclude \"$doc_indir/$doc_infile\" |\
	    cmd="xsltproc --nonet --xinclude $params -o \"$doc_outdir/$doc_outfile\"\
command="$1";
COMMAND is one of:
# configuration script generated by Autoconf, you may include it under
convert_2html() {
    convert_2html "$command" $@;
	convert_docbook2html $@;
convert_docbook2html() {
Convert FILE into $upformat.
	convert_mallard2html $@;
convert_mallard2html() {
	    --copy-graphics)
  --copy-graphics                 copy graphics into the output directory
    copy_icons
copy_icons() {
# Copyright (C) 2006 Shaun McCance <shaunm@gnome.org>
Create a CSS file for a Mallard document.
    create_css $@;
create_css() {
  css          create a CSS file for a Mallard document
CSS Options:
                                  (currently only for Mallard)
datadir=${datarootdir}
datarootdir=${prefix}/share
	    -d | --chunk-depth)
  -d, --chunk-depth=INT           how deep sections should be chunked
    __dir__='';
	__dir__="$__dir__$d/"
	dir=`dirname "$doc_output"`
# distribute this file as part of a program that contains a
Docbook Chunking:
DocBook Styling:
    doc_cache="$doc_outdir/index.cache"
    ) > "$doc_cache_in"
    doc_cache_in="$doc_outdir/index.cache.in"
		doc_chunk_depth="$2";;
		doc_classsynopsis_language="$2";;
		doc_copy_icons="1";;
		doc_css_file="$2";;
		doc_custom_xslt="$2";;
		doc_extension="$2";;
	    doc_extension=`echo "$doc_outfile" | grep -o '\..*'`
    doc_format="$1"
		doc_funcsynopsis_style="$2";;
	    doc_icon_file="${doc_icon}.png"
		doc_icons_admon_path="$2";;
		doc_icons_admon_path="${p}48x48/status"
		doc_icons_admon_path="${p}${doc_icons_admon_size}x${doc_icons_admon_size}/status"
		doc_icons_admon_size="$2";;
	    doc_icons=$(list_icons "$doc_indir/$doc_infile")
	    doc_icons_to_copy="$doc_icons $doc_icons_to_copy"
	    doc_inbase=$(basename "$doc_infile" ".docbook")
	doc_inbase=$(basename "$doc_infile" ".page")
	doc_inbase=$(basename "$doc_infile" ".xml")
		doc_indir=""
	doc_indir=$( (cd $(dirname "$doc_input") && pwd) )
	    doc_indir=$(dirname "$1")
		doc_indir="$doc_indir/"
                 - \"$doc_indir/$doc_infile\""
	doc_infile=$(basename "$doc_input")
	    doc_input="$1"
	doc_input="$1"
	    doc_input_esc=$(urlencode "$doc_input" | sed -e 's/\&/\&amp;/g' -e 's/</\&lt;/g' -e "s/'/\&apos;/g")
		doc_input_full=$(cd "$doc_input" && pwd)
    doc_input_page="$1"
	doc_input_page="index.page"
	doc_input=$(urldecode $(echo "$doc_input" | sed -e 's/^file:\/\///'))
		doc_no_figures="1";;
	doc_outbase=$(basename "$doc_outfile" "$doc_extension")
	doc_outdir=`(cd "$dir" && pwd)`
	doc_outdir=`(cd "$doc_output" && pwd)`
	doc_outdir=`pwd`
	doc_outfile=`basename "$doc_output"`
	    doc_outfile="${doc_inbase}${doc_extension}"
	doc_outfile_q="1"
		doc_output="$2";;
	doc_output="index.css"
    doc_tmpfiles="$doc_tmpfiles doc_cache_in doc_cache_out"
		doc_verbose=1;;
    done
	    done
    done || exit 1;
    done | sort | uniq
	done | while read doc_input; do
    echo $1 | sed -e 's/\//\n/g' | while read d; do
	echo '</cache:cache>'
	echo '<cache:cache xmlns:cache="http://projectmallard.org/cache/1.0/"'
		echo "$doc_indir$doc_media"
		    echo "$doc_input_file"
	    echo -n "%"
	    echo -n "$c"
	    echo -n "$c0"
	    echo "<page cache:href='file://$doc_input_esc'/>"
    echo "$progname: $1" 1>&2;
    echo "$PROGRAM ($PACKAGE) $VERSION";
		echo "$PROGRAM ($PACKAGE) $VERSION"
		echo "$(pwd)/$doc_input"
echo_verbose() {
	    echo_verbose "$cmd"
		echo_verbose "$cmd"
	echo_verbose "$cmd"
    echo_verbose "Creating $doc_output using $doc_input_page"
	    echo_verbose "mkdir \"$__dir__\""
	echo '             xmlns="http://projectmallard.org/1.0/">'
    echo "$XSL_CACHE_LS" | xsltproc - "$doc_cache" | while read doc_input; do
	    echo "$XSL_DOCBOOK_MEDIA" \
	    echo "$XSL_ICONS" | xsltproc --nonet --xinclude - "$1"
    echo "$XSL_MALLARD_CSS" | xsltproc -o "$doc_output" - "$doc_input_page";
	    echo "$XSL_MALLARD_MEDIA" \
	    echo "$XSL_MEDIA" | xsltproc --nonet --xinclude - "$1" \
	    -e | --extension)
  -e, --extension=EXT             the extension to append to output files
                                  elements, either 'KR' or 'ANSI'
elif [ "$command" = "css" ]; then
elif [ "$command" = "help" ]; then
elif [ "$command" = "list-icons" ]; then
elif [ "$command" = "list-media" ]; then
elif [ "$command" = "-V" -o "$command" = "--version" ]; then
    elif [ -d "$doc_output" -o $(echo "$doc_output" | sed -e 's/.*\/$/\//') = "/" ]; then
    else
	    else
error() {
	    error "With multiple input files, output must be a directory"
	    eval "$cmd"
		eval "$cmd"
	eval "$cmd"
    eval set -- "$options";
    exit 0
    exit 0;
		exit 0;;
    exit 1;
		exit 1;;
export LANG=C
                                  for classsynopsis elements
	for doc_icon in $(echo $doc_icons_to_copy | tr ' ' '\n' | grep '^admon-' | sort | uniq); do
	    for doc_icon in $(echo $doc_icons | tr ' ' '\n' | grep '^admon-' | sort | uniq); do
		for doc_input_file in "$doc_input_full/"*.page; do
    format="$1"
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
	    --funcsynopsis-style)
  --funcsynopsis-style=STYLE      the style to be used to render funcsynopsis
# General Public License for more details.
# gnome-doc-html - Convert documentation to HTML
# gnome-doc-html.  Generated from gnome-doc-html.in by configure.
  help         display this help and exit
	    -h | --help)
  -h, --help                      display this help and exit
  html         convert the documents to HTML
    i="0"
    if [ "$?" != "0" ]; then print_help_css 1>&2; exit 1; fi
    if [ "$?" != "0" ]; then print_help_html $doc_format 1>&2; exit 1; fi
    if [ "$#" = "0" ]; then print_help_html $doc_format 1>&2; exit 1; fi
	if [ "$#" != "1" -o -d "$1" ]; then
	if [ "$#" != "1" ]; then
if [ "$command" = "html" -o "$command" = "xhtml" ]; then
	if [ -d "$1" ]; then
	if [ ! -d "$__dir__" ]; then
	    if [ -d "$doc_input" ]; then
	if [ "$doc_inbase" = "$doc_infile" ]; then
	    if [ "$doc_indir" = "." ]; then
	if echo "$c" | grep -q '[a-zA-Z/:_\.\-]'; then
	if [ ! -f "$doc_input" ]; then error "$doc_input: No such file"; fi
If FILE is not supplied, uses index.page as input.
	if [ "x$c0" = "x%" ]; then
if [ "x$command" = "x" ]; then
	if [ "x$doc_admon_graphics_size" != "x" ]; then
	if [ "x$doc_chunk_depth" != "x" ]; then
	if [ "x$doc_classsynopsis_language" != "x" ]; then
	if [ "x$doc_copy_icons" != "x1" -a "x$doc_icons_path" != "x" ]; then
    if [ "x$doc_copy_icons" = "x1" ]; then
	if [ "x$doc_copy_icons" = "x1" ]; then
	if [ "x$doc_css_file" != "x" ]; then
	if [ "x$doc_custom_xslt" != "x" ]; then
	if [ "x$doc_extension" = "x" ]; then
    if [ "x$doc_extension" = "x" ]; then doc_extension=".$doc_format"; fi
	if [ "x$doc_funcsynopsis_style" != "x" ]; then
	if [ "x$doc_icons_admon_path" = "x" ]; then
	    if [ "x$doc_icons_admon_size" != "x" ]; then
    if [ "x$doc_input_page" = "x" ]; then
	if [ "x$doc_no_figures" != "x1" -a "$doc_indir" != "$doc_outdir" ]; then
	if [ "x$doc_outfile_q" != "x1" ]; then
    if [ "x$doc_output" = "x" ]; then
    if [ "x$doc_verbose" = "x1" ]; then echo $1; fi
    if [ "x$(echo "$1" | sed -e 's/.*\.//')" = "xpage" -o -d "$1" ]; then
	    i=$((i+1))
	i=$((i+1))
	    i=$((i+3))
                       <import href=\"$xsltdir/mallard/html/mal2$doc_format.xsl\"/>\
                       <include href=\"$doc_custom_xslt\"/></stylesheet>' |\
# it under the terms of the GNU General Public License as published by
      -ladmon-graphics-path:
      -ladmon-graphics-size:
      -lchunk-depth:
      -lclasssynopsis-language:
      -lcopy-graphics
      -lcss-file:
      -lcustom-xslt:
      -lextension:
      -lfuncsynopsis-style:
      -lhelp
    list_icons $@;
list_icons() {
	    list_icons "$1/"*.page
  list-icons   list automatic icons and watermarks
    list_media $@;
list_media() {
	    list_media "$1/"*.page
  list-media   list all referenced media files
      -lno-figures
    longopts='
      -loutput:
      -lverbose
      -lversion
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Miscellaneous:
	    mkdir "$__dir__" || error "Could not create directory"
mkdir_p() {
	mkdir_p "$dir"
		mkdir_p "$doc_outdir/"`dirname "$doc_media"`
		mkdir_p "$doc_outdir/"`dirname "$fig"`
	mkdir_p "$doc_output"
	    -n | --no-figures)
  -n, --no-figures                do not copy figures into the output directory
	    -o | --output)
  -o, --output=PATH               the file or directory to output to
  -o, --output=PATH               the file to output to
    options=`getopt -qn$progname $longopts -- c:d:e:o:x:nvVh "$@"`
    options=`getopt -qn$progname $longopts -- o:vVh "$@"`
PACKAGE=gnome-doc-utils
	params='--param db.chunk.chunk_top 0'
	params='--param mal.chunk.chunk_top 0'
	    params="$params \"$doc_classsynopsis_language\""
	    params="$params \"$doc_funcsynopsis_style\""
	    params="$params --param db.chunk.max_depth $doc_chunk_depth"
	    params="$params --stringparam db2html.classsynopsis.language"
	    params="$params --stringparam db2html.css.file \"$doc_css_file\""
	    params="$params --stringparam db2html.funcsynopsis.style"
	params="$params --stringparam db.chunk.basename \"$doc_outbase\""
	params="$params --stringparam db.chunk.extension \"$doc_extension\""
	    params="$params --stringparam mal2html.css.file \"$doc_css_file\""
	params="$params --stringparam mal.cache.file \"$doc_cache\""
		params="$params --stringparam $param \"$doc_icon\""
	    params="$params --stringparam theme.icon.admon.path \"$doc_icons_admon_path\""
	    params="$params --stringparam theme.icon.admon.size \"$doc_icons_admon_size\""
		param="theme.icon."$(echo $doc_icon | sed -e 's/-/./');
pkgdatadir=${datarootdir}/gnome-doc-utils
	    p="$pkgdatadir/icons/hicolor/"
prefix=/usr
	    printf "%X" "'$c'"
	    printf "\x$c1$c2"
    print_help;
print_help() {
    print_help 1>&2;
		print_help_css
print_help_css() {
		print_help_css 1>&2
print_help_html() {
		print_help_html $doc_format
		print_help_html $doc_format 1>&2
Process a documentation file.
progname=`echo "$0" | sed 's%^.*/%%'`
PROGRAM=gnome-doc-html
    rm "$doc_cache_in"
    shift
	    shift
# the Free Software Foundation; either version 2 of the License, or
# the same distribution terms that you use for the rest of that program.
# This is important to make sure string manipulation is handled
# This program is distributed in the hope that it will be useful, but
# This program is free software; you can redistribute it and/or modify
		unset doc_input_full
	    unset p
    upformat=`echo $format | tr a-z A-Z`
urldecode() {
urlencode() {
Usage: $progname <COMMAND> [OPTIONS] FILES...
Usage $progname css [OPTIONS] [FILE]
Usage: $progname $format [OPTIONS] FILE
VERSION=0.20.10
  version="1.0">
	    -v | --verbose)
  -v, --verbose                   print all the commands executed
	    -V | --version)
  -V, --version                   print version information and exit
    while [ "$#" != "0" ]; do
	while [ "$#" != "0" ]; do
    while [ "$1" != "--" ]; do
    while [ "$i" -lt ${#arg} ]; do
		| while read doc_media; do
# WITHOUT ANY WARRANTY; without even the implied warranty of
	    -x | --custom-xslt)
  -x, --custom-xslt=PATH          custom XSLT to include in the transform
  xhtml        convert the documents to XHTML
  xmlns:cache="http://projectmallard.org/cache/1.0/"
  xmlns:mal="http://projectmallard.org/1.0/"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  <xsl:apply-templates/>
XSL_CACHE_LS='
    </xsl:call-template>
    <xsl:call-template name="l10n.gettext">
<xsl:call-template name="mal2html.css.content"/>
  </xsl:choose>
  <xsl:choose>
    </xsl:choose>
    <xsl:choose>
XSL_DOCBOOK_MEDIA='
  </xsl:for-each>
  <xsl:for-each select="//audiodata|//imagedata|//videodata">
  <xsl:for-each select="cache:cache/mal:page">
  <xsl:for-each select="//mal:media">
XSL_ICONS='
  </xsl:if>
  <xsl:if test="//blockquote[1]">
  <xsl:if test="//classsynopsis[@language = '"'"'cpp'"'"'][1] or //programlisting[@language = '"'"'cpp'"'"']">
  <xsl:if test="//classsynopsis[@language = '"'"'python'"'"'][1] or //programlisting[@language = '"'"'python'"'"']">
<xsl:import href="'$xsltdir'/common/theme.xsl"/>
<xsl:import href="'$xsltdir'/gettext/gettext.xsl"/>
<xsl:import href="'$xsltdir'/mallard/html/mal2html-css.xsl"/>
XSL_MALLARD_CSS='
XSL_MALLARD_MEDIA='
	XSL_MEDIA="$XSL_DOCBOOK_MEDIA"
	XSL_MEDIA="$XSL_MALLARD_MEDIA"
    </xsl:otherwise>
    <xsl:otherwise>
<xsl:output method="text"/>
<xsl:output method="text" encoding="utf-8"/>
</xsl:stylesheet>'
<xsl:stylesheet
xsltdir=${datarootdir}/xml/gnome/xslt
                 \"$xsltdir/mallard/html/mal2$doc_format.xsl\" \"$doc_indir/$doc_infile\""
</xsl:template>
<xsl:template match="/">
<xsl:template match="*">
<xsl:template match="caution">
<xsl:template match="/FALSE">
<xsl:template match="important">
<xsl:template match="mal:note">
<xsl:template match="note">
<xsl:template match="text()"/>
<xsl:template match="tip">
<xsl:template match="warning">
      <xsl:text>admon-bug&#x000A;</xsl:text>
  <xsl:text>admon-caution&#x000A;</xsl:text>
  <xsl:text>admon-important&#x000A;</xsl:text>
      <xsl:text>admon-important&#x000A;</xsl:text>
      <xsl:text>admon-note&#x000A;</xsl:text>
  <xsl:text>admon-tip&#x000A;</xsl:text>
      <xsl:text>admon-tip&#x000A;</xsl:text>
  <xsl:text>admon-warning&#x000A;</xsl:text>
      <xsl:text>admon-warning&#x000A;</xsl:text>
    <xsl:text>watermark-code-cpp&#x000A;</xsl:text>
    <xsl:text>watermark-code-python&#x000A;</xsl:text>
    <xsl:text>&#x000A;</xsl:text>
		| xsltproc --nonet --xinclude - "$doc_indir/$doc_infile" \
                 xsltproc --nonet --xinclude $params -o \"$doc_outdir/$doc_outfile\"\
    xsltproc -o "$doc_cache" "$xsltdir/mallard/cache/mal-cache.xsl" "$doc_cache_in"
          xsltproc $params -o \"$doc_outdir/$doc_outfile\" \"$xsltdir/docbook/html/db2$doc_format.xsl\" -"
    <xsl:value-of select="@cache:href"/>
        <xsl:value-of select="@fileref"/>
    <xsl:value-of select="@src"/>
        <xsl:value-of select="unparsed-entity-uri(@entityref)"/>
    </xsl:when>
      </xsl:when>
    <xsl:when test="contains(concat('\'' '\'', @style, '\'' '\''), '\''advanced'\'')">
    <xsl:when test="contains(concat('\'' '\'', @style, '\'' '\''), '\''bug'\'')">
    <xsl:when test="contains(concat('\'' '\'', @style, '\'' '\''), '\''important'\'')">
    <xsl:when test="contains(concat('\'' '\'', @style, '\'' '\''), '\''tip'\'')">
    <xsl:when test="contains(concat('\'' '\'', @style, '\'' '\''), '\''warning'\'')">
      <xsl:when test="@entityref">
      <xsl:when test="@fileref">
    <xsl:when test="@role='\''bug'\''">
      <xsl:with-param name="msgid" select="'\''blockquote-watermark-201C'\''"/>
# You should have received a copy of the GNU General Public License
