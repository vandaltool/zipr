            {
            }
         {
         }
                        0);
                       0);
                      0);
   # 0.000000 - 0.000999 = 0 - 999 
   # 0.001000 - 0.999999 = 1 ms - 999.999 ms
   # 1.000000 - n.nnnnnn = 1 s - n.nnnnn s
                        100 - ($stats{'Innodb_buffer_pool_reads'} /
                      100 - ($stats{'Key_reads'} / $stats{'Key_read_requests'}) * 100 :
                       100 - ($stats{'Key_writes'} / $stats{'Key_write_requests'}) * 100 :
                            1024);
$| = 1 if ($op{'detach'} || $relative_live);
__ Aborted _____________________________________________________________
  Ahead Rnd @>>>>>>>>  @>>>>>/s
  Ahead Sql @>>>>>>>>  @>>>>>/s
            # along with the system variable values read thus far, until Aborted_clients
   # As of mysqlreport v3.5 the direct output from SHOW VARIABLES;
# as published by the Free Software Foundation; either version 2
  Average   @>>>>>>>> ms
Block Fragmnt @>>>>>%
Buffer used   @>>>>>> of @>>>>>>  %Used: @>>>>>
# but WITHOUT ANY WARRANTY; without even the implied warranty of
__ Bytes _______________________________________________________________
Cached      @>>>>>>>> of @>>>      %Hit: @>>>>>
   # can be put into INFILE instead. See http://hackmysql.com/mysqlreportdoc
   cat_report($tmpfile) unless $op{'detach'};
            chomp;
      chomp($mycnf{'pass'} = <STDIN>);
Clients     @>>>>>>>>  @>>>>>/s
         close INFILE;
      close INFILE;
   close INFILE;
   close MYCNF;
   close REPORT;
   close SENDMAIL;
   close $tmpfile_fh;
            close $tmpfile_fh[$i];
      collect_reports();
         /^Com_(.*)/;
   $~ = 'COM_1';
   $~ = 'COM_2';
Command line options (abbreviations work):
# Command line options override ~/.my.cnf
Com_        @>>>>>>>>  @>>>>>/s          @>>>>>
   %Com_vals = ();
         $Com_vals{$1} = $stats{$_};
__ Connections _________________________________________________________
Connects    @>>>>>>>>  @>>>>>/s
      connect_to_MySQL();
   connect_to_MySQL();
# Connect to MySQL
# Copyright 2006-2008 Daniel Nichter
      # Count number of status value sets
         # Create a tmp file for each set of status values
  Created   @>>>>>>>>  @>>>>>/s
Created     @>>>>>>>>  @>>>>>/s
__ Created Temp ________________________________________________________
   "c|report-count=i",
Current     @>>>>>>>>
  Current     @>>>>>>            %Usage: @>>>>>
   $d ||= 2;
  Data      @>>>>>>>>                    @>>>>> %Drty: @>>>>>
   # Data Manipulation Statements: http://dev.mysql.com/doc/refman/5.0/en/data-manipulation.html
   # Data, Pages, Rows
   $dbh = DBI->connect($dsn, $mycnf{'user'}, $mycnf{'pass'}) or die;
      $dbh->disconnect();
   "debug"
   --debug           Print debugging information
   # Default required system variable values if not set in INFILE.
   delete $Com_vals{'delete'};
   delete $Com_vals{'delete_multi'} if exists $Com_vals{'delete_multi'};
   delete $Com_vals{'insert'};
   delete $Com_vals{'insert_select'};
   delete $Com_vals{'replace'};
   delete $Com_vals{'replace_select'};
   delete $Com_vals{'select'};
   delete $Com_vals{'update'};
   delete $Com_vals{'update_multi'} if exists $Com_vals{'update_multi'};
  Deleted   @>>>>>>>>  @>>>>>/s
      DELETE  => $stats{'Com_delete'}  +
   "detach",
   --detach          Fork and detach from terminal (run in background)
      $d = int $s / 86400;
Disk table  @>>>>>>>>  @>>>>>/s
   $~ = 'DMS';
   $dms = $DMS_vals{SELECT} + $DMS_vals{INSERT} + $DMS_vals{REPLACE} + $DMS_vals{UPDATE} + $DMS_vals{DELETE};
DMS         @>>>>>>>>  @>>>>>/s          @>>>>>
   %DMS_vals =
   # Doing otherwise causes strange and misleading values.
      $dsn = "DBI:mysql:host=localhost";
      $dsn = "DBI:mysql:host=$mycnf{host}" . ($mycnf{port} ? ";port=$mycnf{port}" : "");
      $dsn = "DBI:mysql:mysql_socket=$mycnf{socket}";
   $~ = 'DTQ';
   $DTQ{'COM_QUIT'} = int (($stats{'Connections'} - 2) - ($stats{'Aborted_clients'} / 2));
   $DTQ{'Com_'} = $stat_val;
   $DTQ{'DMS'}      = $dms;
   $DTQ{'QC Hits'}  = $stats{'Qcache_hits'} if $stats{'Qcache_hits'} != 0;
      $DTQ{($questions > $stat_val ? '+Unknown' : '-Unknown')} = abs $questions - $stat_val;
      else
   else { $key_buffer_usage = -1; }
      else     { `mv $tmpfile $op{outfile}`;   }
   else { $mycnf{'pass'} = $op{'password'}; } # Use password given on command line
            else { print "read_infile: ignore '$_'\n" if $op{debug}; }
   else       { $relative_infiles = 1; }
      else     { `rm -f $tmpfile`; }
            else     { `rm -f $tmpfile_name[$i]`; }
      else       { $stat_label = ''; }
   else { while ($number > 999) { $number /= 1000; $n++; }; }
      elsif($1 eq  'back_log')  # system variable values
      elsif($1 eq '=')  # old style, manually added system variable values
   elsif($mycnf{'host'})
   elsif($t >= 0.001000 && $t <= 0.999999)
   elsif($t >= 1)
   --email ADDRESS   Email report to ADDRESS (doesn't work on Windows)
   email_report($tmpfile) if $op{'email'};
   "email=s",
   # ergo this method is slightly more reliable
eval { require Term::ReadKey; };
                 (exists $stats{'Com_delete_multi'} ? $stats{'Com_delete_multi'} : 0)
                 (exists $stats{'Com_update_multi'} ? $stats{'Com_update_multi'} : 0),
      exit;
   exit;
   exit_tasks_and_cleanup();
exit_tasks_and_cleanup();
      $f = 0;  # $t should = 0 at this point
File        @>>>>>>>>  @>>>>>/s
Flushes     @>>>>>>>>  @>>>>>/s
   "flush-status",
   --flush-status    Issue FLUSH STATUS; after getting current values
   # for details.
   foreach $infile (@ARGV)
   } # foreach $infile (@files)
         for($i = 0; $i < $n_stats; $i++)
   for($i = 0; $i < $op{'c'}; $i++)
   for(keys %stats)
format COM_1 =
format COM_2 =
format DMS =
format DTQ =
format IB =
format IB_DPR =
format IB_LOCK =
format KEY_BUFF_MAX =
format KEY_BUFF_USAGE =
format KEY_RATIOS =
format MYSQL_TIME =
format QCACHE =
format REPORT_END =
# Formats
format SAS =
format SLOW_DMS =
format TAB =
   for(sort { $Com_vals{$b} <=> $Com_vals{$a} } keys(%Com_vals))
   for(sort { $DMS_vals{$b} <=> $DMS_vals{$a} } keys(%DMS_vals))
   for(sort { $DTQ{$b} <=> $DTQ{$a} } keys(%DTQ))
   for(values %Com_vals) { $stat_val += $_; }
   for(values %DTQ) { $stat_val += $_; }
  Free      @>>>>>>>>            %Total: @>>>>>
  From file @>>>>>>>>  @>>>>>/s          @>>>>>
    fsync   @>>>>>>>>
  fsync     @>>>>>>>>  @>>>>>/s
      $f = ($t * 1000000) . " $u";
      $f = ($t * 1000) . ' ms';
      $f = ($t * 1) . ' s';  # * 1 to remove insignificant zeros
Full join     @>>>>>>   @>>>>/s          @>>>>>
Full rng join @>>>>>>   @>>>>/s          @>>>>>
      get_Com_values();
   get_Com_values();
      get_MySQL_version();
   get_MySQL_version();
GetOptions (
   # Get server system variables
   # Get status values
get_user_mycnf() unless $op{'no-mycnf'};
      get_vals();
   get_vals();
      get_vars();
   get_vars();
# GNU General Public License for more details.
      $have_innodb_vals = 0;
$have_innodb_vals = 1; # This might be set to 0 later in get_MySQL_version()
   "help|?",
   --help            Prints this
     $h = int $s / 3600;
Hit:Insert  @>>>>>>:1
Hits          @>>>>>>   @>>>>/s
   --host ADDRESS    Connect to MySQL at ADDRESS
   "host=s",
# http://dev.mysql.com/doc/refman/5.1/en/slow-query-log.html
# http://dev.mysql.com/doc/refman/6.0/en/slow-query-log.html
# http://hackmysql.com/mysqlreport
# http://www.gnu.org/copyleft/gpl.html
         $i = 0;
   $~ = 'IB';
$ib_bp_read_ratio;
   $ib_bp_read_ratio = sprintf "%.2f",
   $ib_bp_total = $stats{'Innodb_buffer_pool_pages_total'} * $stats{'Innodb_page_size'};
   $ib_bp_used  = ($stats{'Innodb_buffer_pool_pages_total'} -
   $~ = 'IB_DPR';
      $~ = 'IB_LOCK';
# idea provide: http://www.mysqlperformanceblog.com/mysql-patches/
      if($1 eq 'Aborted_clients')  # status values
            if(/Aborted_clients/)
            if(/([A-Za-z_]+)[\s\t|]+(\d+)/)
            if(/([A-Za-z_]+)[\s\t|]+([\w\.\-]+)/)  # This will exclude some vars
if(defined $op{'r'})
   if(defined $stats{'Key_blocks_unused'}) # MySQL 4.1.2+
if(exists $op{'password'})
      if($first) { $stat_label = '%Total:'; $first = 0; }
   if(fork())
      if(grep /^Com_/, $_ and $stats{$_} > 0)
   if($have_innodb_vals)
   if($kb) { while ($number > 1023) { $number /= 1024; $n++; }; }
   if($key_buffer_usage != -1) { $~ = 'KEY_BUFF_USAGE', write }
   if($mycnf{'socket'} && -S $mycnf{'socket'})
   if($MySQL_version < 50002)
   if($MySQL_version >= 50002)
      if($MySQL_version >= 50003)
   if($MySQL_version >= 50003)
   if($MySQL_version >= 50103)
      } # if($n_stats > 1)
      if($n_stats == 1)
      if($n_stats > 1)
               if $op{debug};
         if $op{debug};
if($op{'detach'})
      if($op{'flush-status'})
   if(!$op{'infile'})
   if(!$op{'infile'} && !$relative_infiles)
   if($op{'infile'} || $relative_infiles)
if(!$op{'infile'} && !$relative_infiles)
   if($op{'outfile'})
   if($op{'password'} eq '') # Prompt for password
   if($op{r}) { $relative_live    = 1; }  # if -r was given an integer value
   if($questions != $stat_val)
   if($relative_infiles) { read_relative_infiles(); }
   if($relative_live)
   if($report_n == 1)
   if($s >= 3600)
   if($s >= 86400)
   if($short =~ /^(.+)\.(00)$/) { return $1; } # 12.00 -> 12 but not 12.00k -> 12k
      if(/^(.+?)\s*=\s*"?(.+?)"?\s*$/)
      if($stats_past{$_} =~ /\d+/)
         if($stats_present{$_} >= $stats_past{$_}) # Avoid negative values
            if(/^\s*(\w+)\s*=\s*([0-9.]+)(M*)\s*$/)  # e.g.: key_buffer_size = 128M
   if($t > 0 && $t <= 0.000999)
      if($WIN) { `del $tmpfile`;   }
            if($WIN) { `del $tmpfile_name[$i]`;   }
      if($WIN) { `move $tmpfile $op{outfile}`; }
                     If X is a list of infiles (file1 file2 etc.),
Immediate   @>>>>>>>>  @>>>>>/s
   --infile FILE     Read status values from FILE instead of MySQL
   "infile|in=s",
            $_ = <INFILE>; # otherwise, read next line of old vars
            $_ = <INFILE>; # otherwise, read next line of status values
            $_ = <INFILE>; # otherwise, read next line of vars
__ InnoDB Buffer Pool __________________________________________________
__ InnoDB Data, Pages, Rows ____________________________________________
__ InnoDB Lock _________________________________________________________
      # Innodb_row_lock_ values were added in MySQL 5.0.3
   # Innodb_row_lock_ values were added in MySQL 5.0.3
   # Innodb_ status values were added in 5.0.2
  Inserted  @>>>>>>>>  @>>>>>/s
Inserts       @>>>>>>   @>>>>/s
      INSERT  => $stats{'Com_insert'}  + $stats{'Com_insert_select'},
Insrt:Prune @>>>>>>:1   @>>>>/s
            # In this case, the following status values are printed to the current fh,
   $is = 0 if (not defined $is);
# is now standard. For 4.1 and 5.0 patches, the architects of this
__ Key _________________________________________________________________
      $key_buffer_usage =  $vars{'key_buffer_size'} -
   $key_buffer_used = $stats{'Key_blocks_used'} * $key_cache_block_size;
   $~ = 'KEY_BUFF_MAX', write;
   #    key_cache_block_size
   $key_cache_block_size = (defined $vars{'key_cache_block_size'} ?
   $~ = 'KEY_RATIOS', write;
$key_read_ratio
   $key_read_ratio = sprintf "%.2f",
$key_write_ratio
   $key_write_ratio = sprintf "%.2f",
            last if $1 eq 'Uptime';  # exit while() if end of status values
            last if $1 eq 'wait_timeout';  # exit while() if end of vars
      last if !defined $_;
      last if !(--$i);
  Latched   @>>>>>>>>                    @>>>>>
# Later it will be moved to $op{'outfile'} or emailed $op{'email'} if needed.
            {                                      # like pid_file which we don't need
# long_query_time in microseconds. For MySQL 5.1.21+ and 6.0.4+ this
      ($major, $minor, $patch) = ($row[1] =~ /(\d{1,2})\.(\d{1,2})\.(\d{1,2})/);
      ($major, $minor, $patch) = ($vars{'version'} =~ /(\d{1,2})\.(\d{1,2})\.(\d{1,2})/);
   # Make copy of just the Com_ values
make_short($dms), t($dms), perc($dms, $questions)
make_short($ib_bp_used, 1), make_short($ib_bp_total, 1), perc($ib_bp_used, $ib_bp_total)
make_short($key_buffer_usage, 1), perc($key_buffer_usage, $vars{'key_buffer_size'})
make_short($key_buffer_used, 1), make_short($vars{'key_buffer_size'}, 1), perc($key_buffer_used, $vars{'key_buffer_size'})
make_short($qc_ip_r), t($stats{'Qcache_inserts'} - $stats{'Qcache_lowmem_prunes'})
make_short($qc_mem_used, 1), make_short($vars{'query_cache_size'}, 1), perc($qc_mem_used, $vars{'query_cache_size'})
make_short($questions), t($questions)
make_short($stats{'Aborted_clients'}), t($stats{'Aborted_clients'})
make_short($stats{'Aborted_connects'}), t($stats{'Aborted_connects'})
make_short($stats{'Bytes_received'}), t($stats{'Bytes_received'})
make_short($stats{'Bytes_sent'}), t($stats{'Bytes_sent'})
make_short($stats{'Connections'}), t($stats{'Connections'})
make_short($stats{'Created_tmp_disk_tables'}), t($stats{'Created_tmp_disk_tables'})
make_short($stats{'Created_tmp_files'}), t($stats{'Created_tmp_files'})
make_short($stats{'Created_tmp_tables'}), t($stats{'Created_tmp_tables'}), make_short($vars{'tmp_table_size'}, 1, 1)
make_short($stats{'Innodb_buffer_pool_pages_data'}), perc($stats{'Innodb_buffer_pool_pages_data'}, $stats{'Innodb_buffer_pool_pages_total'}), perc($stats{'Innodb_buffer_pool_pages_dirty'}, $stats{'Innodb_buffer_pool_pages_data'})
make_short($stats{'Innodb_buffer_pool_pages_flushed'}), t($stats{'Innodb_buffer_pool_pages_flushed'})
make_short($stats{'Innodb_buffer_pool_pages_free'}), perc($stats{'Innodb_buffer_pool_pages_free'}, $stats{'Innodb_buffer_pool_pages_total'})
make_short($stats{'Innodb_buffer_pool_read_requests'}), t($stats{'Innodb_buffer_pool_read_requests'})
make_short($stats{'Innodb_buffer_pool_reads'}), t($stats{'Innodb_buffer_pool_reads'}), perc($stats{'Innodb_buffer_pool_reads'}, $stats{'Innodb_buffer_pool_read_requests'})
make_short($stats{'Innodb_buffer_pool_write_requests'}), t($stats{'Innodb_buffer_pool_write_requests'})
make_short($stats{'Innodb_data_fsyncs'}), t($stats{'Innodb_data_fsyncs'})
make_short($stats{'Innodb_data_reads'}), t($stats{'Innodb_data_reads'})
make_short($stats{'Innodb_data_writes'}), t($stats{'Innodb_data_writes'})
make_short($stats{'Innodb_pages_created'}), t($stats{'Innodb_pages_created'})
make_short($stats{'Innodb_pages_read'}), t($stats{'Innodb_pages_read'})
make_short($stats{'Innodb_pages_written'}), t($stats{'Innodb_pages_written'})
make_short($stats{'Innodb_rows_deleted'}), t($stats{'Innodb_rows_deleted'})
make_short($stats{'Innodb_rows_inserted'}), t($stats{'Innodb_rows_inserted'})
make_short($stats{'Innodb_rows_read'}), t($stats{'Innodb_rows_read'})
make_short($stats{'Innodb_rows_updated'}), t($stats{'Innodb_rows_updated'})
make_short($stats{'Opened_tables'}), t($stats{'Opened_tables'})
make_short($stats{'Qcache_hits'}), t($stats{'Qcache_hits'})
make_short($stats{'Qcache_inserts'}), t($stats{'Qcache_inserts'})
make_short($stats{'Select_full_join'}), t($stats{'Select_full_join'}), perc($stats{'Select_full_join'}, $stats{'Com_select'})
make_short($stats{'Select_full_range_join'}), t($stats{'Select_full_range_join'}), perc($stats{'Select_full_range_join'}, $stats{'Com_select'})
make_short($stats{'Select_range_check'}), t($stats{'Select_range_check'}), perc($stats{'Select_range_check'}, $stats{'Com_select'})
make_short($stats{'Select_range'}), t($stats{'Select_range'}), perc($stats{'Select_range'}, $stats{'Com_select'})
make_short($stats{'Select_scan'}), t($stats{'Select_scan'}), perc($stats{'Select_scan'}, $stats{'Com_select'})
make_short($stats{'Sort_merge_passes'}), t($stats{'Sort_merge_passes'})
make_short($stats{'Sort_range'}), t($stats{'Sort_range'})
make_short($stats{'Sort_scan'}), t($stats{'Sort_scan'})
make_short($stats{'Table_locks_immediate'}), t($stats{'Table_locks_immediate'})
make_short($stats{'Table_locks_waited'}), t($stats{'Table_locks_waited'}), perc($stats{'Table_locks_waited'}, $stats{'Table_locks_waited'} + $stats{'Table_locks_immediate'});
make_short($stats{'Threads_created'}), t($stats{'Threads_created'})
make_short($stat_val), t($stat_val), perc($stat_val, $questions)
  Max       @>>>>>>>> ms
Max used    @>>>>>>>> of @>>>      %Max: @>>>>>
Memory usage  @>>>>>> of @>>>>>>  %Used: @>>>>>
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   $m = int $s / 60;
  Misc      @>>>>>>>>                    @>>>>>
# modify it under the terms of the GNU General Public License
         $mycnf{$1} = $2;
$mycnf{'host'}   = $op{'host'}   if have_op 'host';
   $mycnf{'pass'} ||= $mycnf{'password'} if exists $mycnf{'password'};
$mycnf{'port'}   = $op{'port'}   if have_op 'port';
$mycnf{'socket'} = $op{'socket'} if have_op 'socket'; 
$mycnf{'user'} ||= $ENV{'USER'};
$mycnf{'user'}   = $op{'user'}   if have_op 'user';
my ($dbh, $query);
   my ($d, $h, $m) = (0, 0, 0);
my (%DMS_vals, %Com_vals, %ib_vals);
   my $dsn;
   my %DTQ;
   my $f;  # formatted 
            my ($fh, $name) = tempfile()
   my $first = 1;
my $have_innodb_vals;
         my $i;
   my $i;
my ($ib_bp_used, $ib_bp_total, $ib_bp_read_ratio);
   my $infile;
   my $infile = shift;
   my $i = $op{'com'};
   my($is, $of) = @_;
my ($key_cache_block_size, $key_buffer_used, $key_buffer_usage);
   my $key = shift;
   my ($major, $minor, $patch);
my %mycnf; # ~/.my.cnf
my $MySQL_version;
   my $n = 0;
   my $n_stats;  # Number of multiple sets of status values in an infile
   my ($number, $kb, $d) = @_;
my ($qc_mem_used, $qc_hi_r, $qc_ip_r); # Query Cache
my ($questions, $key_read_ratio, $key_write_ratio, $dms, $slow_query_t);
my $real_uptime;
my ($relative_live, $relative_infiles);
   my @report;
   my $report_n; # Report number
   my $report_n = shift;
   my $report = shift;
my $RK = ($@ ? 0 : 1);
      my @row;
   my @row;
   my $short;
   my $slurp;    # Used to check infiles for multiple sets of status values
# mysqlreport makes an easy-to-read report of important MySQL status values.
mysqlreport makes an easy-to-read report of important MySQL status values.
# mysqlreport v3.5 Apr 16 2008
mysqlreport v3.5 Apr 16 2008
   $~ = 'MYSQL_TIME', write;
MySQL @<<<<<<<<<<<<<<<<  uptime @<<<<<<<<<<<   @>>>>>>>>>>>>>>>>>>>>>>>>
   $MySQL_version = sprintf("%d%02d%02d", $major, $minor, $patch);
   my $s = shift;
my ($stat_name, $stat_val, $stat_label);
         my $stat_n;  # Status value set number
my (%stats_present, %stats_past); # For relative reports
my (%stats, %vars); # SHOW STATUS, SHOW VARIABLES
         my @tmpfile_fh;
my ($tmpfile_fh, $tmpfile);
         my @tmpfile_name;
   my $t = shift;
   my $u = chr(($WIN ? 230 : 181));
   my $val = shift;
my $WIN = ($^O eq 'MSWin32' ? 1 : 0);
            next if /^$/;
            next if /^\+/;
      next if /^$/;   # skip blank lines
      next if /^\+/;  # skip divider lines 
      next until /(Aborted_clients|back_log|=)/;
         "\n#\n";
   "no-mycnf",
   --no-mycnf        Don't read ~/.my.cnf
# Not really the end...
      $n_stats = 0;
      $n_stats++ while $slurp =~ /Aborted_clients/g;
            # occurs again. Then begins the second and subsequent sets of status values.
            # of the first set of status values if no sets have occured yet ($stat_n == 0).
# of the License, or (at your option) any later version.
   # One should also add:
   \%op,
$op{'c'}   ||= 1; # Used in collect_reports() if --r given integer value
$op{'com'} ||= 3;
Opened      @>>>>>>>>  @>>>>>/s
   open INFILE, "< $infile" or die "Cannot open INFILE '$infile': $!\n";
         open INFILE, "< $infile" or warn and next;
      open INFILE, "< $infile" or warn and next;
   open MYCNF, "$ENV{HOME}/.my.cnf" or return;
Open        @>>>>>>>> of @>>>    %Cache: @>>>>>
   open REPORT, "< $report";
   open SENDMAIL, "|/usr/sbin/sendmail -t";
   open(STDERR, "> $tmpfile") or die "Cannot dup STDERR: $!\n";
   open(STDIN, "</dev/null");
   open(STDOUT, "> $tmpfile") or die "Cannot dup STDOUT: $!\n";
               or die "read_relative_infiles: cannot open temporary file for writing: $!\n";
   --outfile FILE    Write report to FILE
   "outfile=s",
   --password PASS   Use PASS or prompt for MySQL user's password
   "password:s",
  Pending
perc($stats{'Qcache_free_blocks'}, $stats{'Qcache_total_blocks'})
   --port PORT       Connect to MySQL at PORT
   "port=s",
            print;
               print and next if $stat_n++ == 0;
   print "cat_report\n" if $op{debug};
   print "collect_reports\n" if $op{debug};
   print "connect_to_MySQL: DBI DSN: $dsn\n" if $op{debug};
   print "connect_to_MySQL\n" if $op{debug};
   print "email_report\n" if $op{debug};
   print "exit_tasks_and_cleanup\n" if $op{debug};
   print "get_Com_values\n" if $op{debug};
   print "get_MySQL_version\n" if $op{debug};
      print "get_MySQL_version: no InnoDB reports because MySQL version is older than 5.0.2\n" if $op{debug};
   print "get_user_mycnf\n" if $op{debug};
         print "get_user_mycnf: read '$1 = $2'\n" if $op{debug};
   print "get_vals\n" if $op{debug};
   print "get_vars\n" if $op{debug};
   print <<"HELP";
      print "mysqlreport has forked and detached.\n";
      print "#\n# Beginning report, 0 0:0:0\n#\n";
   print "#\n# Beginning report, 0 0:0:0\n#\n";
      print "\n#\n# Interval report " , $i + 1 , ", +", sec_to_dhms(($i + 1) * $op{'r'}), "\n#\n";
      print "\n#\n# Interval report ", $report_n - 1, ", +",
   print "\nReceived signal at " , scalar localtime , "\n";
      print "Password for database user $mycnf{'user'}: ";
   print "read_infile\n" if $op{debug};
               print "read_infile: read '$_' as $1 = $vars{$1}\n" if $op{debug};
               print "read_infile: save $1 = $2\n" if $op{debug};
         print "read_infile: start old vars\n" if $op{debug};
         print "read_infile: start stats\n" if $op{debug};
         print "read_infile: start vars\n" if $op{debug};
         print "read_infile: unrecognized line: '$_'\n" if $op{debug};
            print "read_relative_infiles: created tmp file '$name' for set $i\n" if $op{debug};
            print "read_relative_infiles: deleted set $i tmp file '$tmpfile_name[$i]'\n"
      print "read_relative_infiles: found $n_stats sets of status values in file '$infile'\n"
   print "read_relative_infiles\n" if $op{debug};
            print "read_relative_infiles: reading set $i tmp file '$tmpfile_name[$i]'\n"
   print "relative_infile_report\n" if $op{debug};
   print @report;
   print SENDMAIL `cat $report`;
   print SENDMAIL "From: mysqlreport\n";
   print SENDMAIL "Subject: MySQL status report on " . ($mycnf{'host'} || 'localhost') . "\n\n";
   print SENDMAIL "To: $op{email}\n";
   print "set_ib_vals\n" if $op{debug};
   print "set_myisam_vals\n" if $op{debug};
      print STDERR "mysqlreport is writing relative reports to '$tmpfile'.\n" unless $op{'detach'}; 
print "tmp file: $tmpfile\n" if $op{debug};
      print "While running detached, mysqlreport writes reports to '$tmpfile'.\n";
   print "write_Com\n" if $op{debug};
   print "write_DMS\n" if $op{debug};
   print "write_DTQ\n" if $op{debug};
   print "write_InnoDB\n" if $op{debug};
   print "write_qcache\n" if $op{debug};
   print "write_relative_report\n" if $op{debug};
   print "write_report\n" if $op{debug};
            push(@tmpfile_fh, $fh);
            push(@tmpfile_name, $name);
   $~ = 'QCACHE';
   $qc_hi_r = sprintf "%.2f", $stats{'Qcache_hits'} / ($stats{'Qcache_inserts'} ||= 1);
$qc_hi_r, t($qc_hi_r)
   $qc_ip_r = sprintf "%.2f", $stats{'Qcache_inserts'} / ($stats{'Qcache_lowmem_prunes'} ||= 1);
   $qc_mem_used = $vars{'query_cache_size'} - $stats{'Qcache_free_memory'};
__ Query Cache _________________________________________________________
   #    query_cache_size
   # Query cache was added in 4.0.1, but have_query_cache was added in 4.0.2,
         $query = $dbh->prepare("FLUSH STATUS;");
      $query = $dbh->prepare("SHOW GLOBAL STATUS;");
      $query = $dbh->prepare("SHOW STATUS;");
   $query = $dbh->prepare("SHOW VARIABLES;");
      $query = $dbh->prepare("SHOW VARIABLES LIKE 'version';");
         $query->execute();
      $query->execute();
   $query->execute();
      $query->finish();
__ Questions ___________________________________________________________
   $questions = $stats{'Questions'};
Range check   @>>>>>>   @>>>>/s          @>>>>>
Range         @>>>>>>   @>>>>/s          @>>>>>
      # Read all of infile into $slurp
Read hit      @>>>>>%
         # Read infile again and copy each set of status values to seperate tmp files
         read_infile($infile);
      read_infile($op{'infile'});
            read_infile($tmpfile_name[$i]);
    Reads   @>>>>>>>>
  Read      @>>>>>>>>  @>>>>>/s
  Reads     @>>>>>>>>  @>>>>>/s
Reads       @>>>>>>>>  @>>>>>/s  
   $real_uptime = $stats{'Uptime'};
Received    @>>>>>>>>  @>>>>>/s
         redo;
            relative_infile_report($report_n++);
         relative_infile_report($report_n++);
$relative_infiles = 0;
$relative_live    = 0;
   --relative X      Generate relative reports. If X is an integer,
# Relevant notes in MySQL manual:
   # Remove DMS values
      REPLACE => $stats{'Com_replace'} + $stats{'Com_replace_select'},
   --report-count N  Collect N number of live relative reports (default 1)
   $~ = 'REPORT_END', write;
   $report_n = 1;
   @report = <REPORT>;
                     reports are generated from the infiles in the order
                     reports are live from the MySQL server X seconds apart.
         # Re-select the main tmp file into which the reports are being written.
   return 0;
   return '0 0:0:0' if $s <= 0;
   return 0 if !$val;
   return 1 if (exists $op{$key} && $op{$key} ne '');
   return "$d $h:$m:$s";
   return $f;
   return if $MySQL_version;
   return if not defined $stats{'Innodb_page_size'};
   return if not exists $vars{'query_cache_size'};
   return if $vars{'query_cache_size'} == 0;
   return if $WIN;
   return(make_short($val / $stats{'Uptime'}, 0, 1));
   return $short;
   return sprintf "%.2f", ($is * 100) / ($of ||= 1);
      @row = $query->fetchrow_array();
   "r|relative:i",
Running     @>>>>>>>> of @>>>
  @<<<<<<<<<< @>>>>>>  @>>>>>/s          @>>>>>
  @<<<<<<<  @>>>>>>>>  @>>>>>/s          @>>>>>        @>>>>>
  @<<<<<<<  @>>>>>>>>  @>>>>>/s  @>>>>>> @>>>>>
   $~ = 'SAS', write; 
Scan          @>>>>>>   @>>>>/s %SELECT: @>>>>>
      $s -= $d * 86400;
         sec_to_dhms($stats{Uptime} - $stats_past{Uptime}),
__ SELECT and Sort _____________________________________________________
      SELECT  => $stats{'Com_select'},
   select STDOUT unless $op{'detach'};
         select $tmpfile_fh;
select $tmpfile_fh;
               select $tmpfile_fh[++$i];
         select $tmpfile_fh[$i];
Sent        @>>>>>>>>  @>>>>>/s
      set_ib_vals() if $have_innodb_vals;
   set_ib_vals() if $have_innodb_vals;
      set_myisam_vals();
   set_myisam_vals();
     $s -= $h * 3600;
   $short = sprintf "%.${d}f%s", $number, ('','k','M','G','T')[$n];
show_help_and_exit() if $op{'help'};
   $SIG{'TERM'} = 'sig_handler';
      sleep($op{'r'});
   $~ = 'SLOW_DMS', write;
   $slow_query_t = format_u_time($vars{long_query_time});
$slow_query_t, make_short($stats{'Slow_queries'}), t($stats{'Slow_queries'}), perc($stats{'Slow_queries'}, $questions), perc($stats{'Slow_queries'}, $dms), $vars{'log_slow_queries'}
Slow        @>>>>>>>>  @>>>>>/s
Slow @<<<<<<< @>>>>>>  @>>>>>/s          @>>>>>  %DMS: @>>>>>  Log: @>> 
      $slurp = do { local $/;  <INFILE> };
   $s -= $m * 60;
   "socket=s",
   --socket SOCKET   Connect to MySQL at SOCKET
Sort mrg pass @>>>>>>   @>>>>/s
Sort range    @>>>>>>   @>>>>/s
   # Sort remaining Com values, print only the top $op{'com'} number of values
Sort scan     @>>>>>>   @>>>>/s
   $stat_label = '%Total:' unless $op{'dtq'};
         $stat_n = 0;
      $stat_name = $_;
$stat_name, make_short($stat_val), t($stat_val), perc($stat_val, $questions)
$stat_name, make_short($stat_val), t($stat_val), perc($stat_val, $questions), perc($stat_val, $dms)
$stat_name, make_short($stat_val), t($stat_val), $stat_label, perc($stat_val, $questions)
               $stats{$1} = $2;
      $stats{'Innodb_buffer_pool_pages_data'}    = $stats_present{'Innodb_buffer_pool_pages_data'};
      $stats{'Innodb_buffer_pool_pages_dirty'}   = $stats_present{'Innodb_buffer_pool_pages_dirty'};
                   $stats{'Innodb_buffer_pool_pages_free'}) *
      $stats{'Innodb_buffer_pool_pages_free'}    = $stats_present{'Innodb_buffer_pool_pages_free'};
   $stats{'Innodb_buffer_pool_pages_latched'} = 0 if not defined $stats{'Innodb_buffer_pool_pages_latched'};
$stats{'Innodb_buffer_pool_pages_latched'}, perc($stats{'Innodb_buffer_pool_pages_latched'}, $stats{'Innodb_buffer_pool_pages_total'})
      $stats{'Innodb_buffer_pool_pages_latched'} = $stats_present{'Innodb_buffer_pool_pages_latched'};
  $stats{'Innodb_buffer_pool_pages_misc'}, perc($stats{'Innodb_buffer_pool_pages_misc'}, $stats{'Innodb_buffer_pool_pages_total'})
      $stats{'Innodb_buffer_pool_pages_misc'}    = $stats_present{'Innodb_buffer_pool_pages_misc'};
      $stats{'Innodb_buffer_pool_pages_total'}   = $stats_present{'Innodb_buffer_pool_pages_total'};
$stats{'Innodb_buffer_pool_read_ahead_rnd'}, t($stats{'Innodb_buffer_pool_read_ahead_rnd'})
$stats{'Innodb_buffer_pool_read_ahead_seq'}, t($stats{'Innodb_buffer_pool_read_ahead_seq'})
                       ($stats{'Innodb_buffer_pool_read_requests'} ?
                           $stats{'Innodb_buffer_pool_read_requests'}) * 100 :
$stats{'Innodb_buffer_pool_wait_free'}, t($stats{'Innodb_buffer_pool_wait_free'})
      $stats{'Innodb_data_pending_fsyncs'}       = $stats_present{'Innodb_data_pending_fsyncs'};
$stats{'Innodb_data_pending_fsyncs'}, t($stats{'Innodb_data_pending_fsyncs'})
      $stats{'Innodb_data_pending_reads'}        = $stats_present{'Innodb_data_pending_reads'};
$stats{'Innodb_data_pending_reads'}, t($stats{'Innodb_data_pending_reads'})
      $stats{'Innodb_data_pending_writes'}       = $stats_present{'Innodb_data_pending_writes'};
$stats{'Innodb_data_pending_writes'}, t($stats{'Innodb_data_pending_writes'})
                   $stats{'Innodb_page_size'};
      $stats{'Innodb_page_size'}                 = $stats_present{'Innodb_page_size'};
$stats{'Innodb_row_lock_current_waits'}
         $stats{'Innodb_row_lock_current_waits'} = $stats_present{'Innodb_row_lock_current_waits'};
$stats{'Innodb_row_lock_time'}
$stats{'Innodb_row_lock_time_avg'}
         $stats{'Innodb_row_lock_time_avg'}      = $stats_present{'Innodb_row_lock_time_avg'};
$stats{'Innodb_row_lock_time_max'}
         $stats{'Innodb_row_lock_time_max'}      = $stats_present{'Innodb_row_lock_time_max'};
$stats{'Innodb_row_lock_waits'}, t($stats{'Innodb_row_lock_waits'})
                           ($stats{'Key_blocks_unused'} * $key_cache_block_size);
   $stats{'Key_blocks_used'}      = $stats_present{'Key_blocks_used'};
                     ($stats{'Key_read_requests'} ?
                      ($stats{'Key_write_requests'} ?
   $stats{'Max_used_connections'} = $stats_present{'Max_used_connections'};
$stats{'Max_used_connections'}, $vars{'max_connections'}, perc($stats{'Max_used_connections'}, $vars{'max_connections'})
   $stats{'Open_tables'}          = $stats_present{'Open_tables'};
$stats{'Open_tables'}, $vars{'table_cache'}, perc($stats{'Open_tables'}, $vars{'table_cache'})
      %stats_past = %stats;
   %stats_past = %stats;
   %stats_past = %stats_present;
   %stats_present = %stats;
   $stats{'Qcache_free_blocks'}   = $stats_present{'Qcache_free_blocks'};
   $stats{'Qcache_free_memory'}   = $stats_present{'Qcache_free_memory'};
   $stats{'Qcache_total_blocks'}  = $stats_present{'Qcache_total_blocks'};
$stats{'Slow_launch_threads'}, t($stats{'Slow_launch_threads'})
            $stats{$_} = $stats_present{$_} - $stats_past{$_};
   $stats{'Threads_cached'}       = $stats_present{'Threads_cached'};
$stats{'Threads_cached'}, $vars{'thread_cache_size'}, make_short(100 - perc($stats{'Threads_created'}, $stats{'Connections'}))
   $stats{'Threads_connected'}    = $stats_present{'Threads_connected'};
   $stats{'Threads_running'}      = $stats_present{'Threads_running'};
$stats{'Threads_running'}, $stats{'Threads_connected'}
   $stat_val = 0;
   $stat_val   = 0;
      $stat_val  = $Com_vals{$_};
      $stat_val  = $DMS_vals{$_};
      $stat_val  = $DTQ{$_};
sub cat_report # Print given report to screen
sub collect_reports
sub connect_to_MySQL
sub email_report # Email given report to $op{'email'}
sub exit_tasks_and_cleanup
sub format_u_time  # format microsecond (
sub get_Com_values
sub get_MySQL_version
sub get_user_mycnf
sub get_vals
sub get_vars
sub have_op
sub have_op;
sub make_short
sub perc # Percentage
sub read_infile
sub read_relative_infiles
sub relative_infile_report
# Subroutines
sub sec_to_dhms # Seconds to days hours:minutes:seconds
sub set_ib_vals
sub set_myisam_vals
sub show_help_and_exit
sub sig_handler
sub t # Time average per second
sub write_Com # Write COM report in descending order by values
sub write_DMS # Write DMS report in descending order by values
sub write_DTQ # Write DTQ report in descending order by values
sub write_InnoDB
sub write_qcache
sub write_relative_report
sub write_report
   $t = 0 if $t < 0;
   # table_cache was renamed to table_open_cache in MySQL 5.1.3
__ Table Locks _________________________________________________________
__ Tables ______________________________________________________________
Table       @>>>>>>>>  @>>>>>/s    Size: @>>>>>
   $~ = 'TAB', write;
      Term::ReadKey::ReadMode(0), print "\n" if $RK;
      Term::ReadKey::ReadMode(2) if $RK;
                     that they are given.
# The format_u_time sub simply beautifies long_query_time.
# The GNU General Public License is available at:
            # The infile must begin with the system variable values.
   # Therefore, it is more logical to not relativize these values.
            # Therefore, the first occurance of Aborted_clients indicates the beginning
# The report is written to a tmp file first.
   # These values are either "at present" or "high water marks".
# This program is distributed in the hope that it will be useful,
# This program is free software; you can redistribute it and/or
__ Threads _____________________________________________________________
Time acquiring
) time value
($tmpfile_fh, $tmpfile) = tempfile() or die "Cannot open temporary file for writing: $!\n";
   # to INFILE if needed.
   # Total Com values
   # Total Com values and write first line of COM report
  Total     @>>>>>>>> ms
Total       @>>>>>>>>  @>>>>>/s
  Updated   @>>>>>>>>  @>>>>>/s
      UPDATE  => $stats{'Com_update'}  +
Usage         @>>>>>> of @>>>>>>  %Used: @>>>>>
use DBI;
use File::Temp qw(tempfile);
use Getopt::Long;
   "user=s",
   --user USER       Connect to MySQL as USER
use strict;
#!/usr/bin/perl -w
               $vars{$1} = $2;
               $vars{$1} = ($3 ? $2 * 1024 * 1024 : $2);
   $vars{'key_buffer_size'} = 8388600 if !exists $vars{'key_buffer_size'}; # 8M
                            $vars{'key_cache_block_size'} :
   $vars{'log_slow_queries'} = '?'    if !exists $vars{'log_slow_queries'};
   $vars{'long_query_time'} = '?'     if !exists $vars{'long_query_time'};
   $vars{'max_connections'} = 100     if !exists $vars{'max_connections'};
   $vars{'table_cache'} = 64          if !exists $vars{'table_cache'};
      $vars{'table_cache'} = $vars{'table_open_cache'};
   $vars{'table_cache'} = $vars{'table_open_cache'} if exists $vars{'table_open_cache'};
   $vars{'thread_cache_size'} = 0     if !exists $vars{'thread_cache_size'}; 
   $vars{'tmp_table_size'} = 0        if !exists $vars{'tmp_table_size'};
   $vars{'version'} = "0.0.0"         if !exists $vars{'version'};
$vars{'version'}, sec_to_dhms($real_uptime), (($op{infile} || $relative_infiles) ? '' : scalar localtime)
Visit http://hackmysql.com/mysqlreport for more information.
Waited      @>>>>>>>>  @>>>>>/s  %Total: @>>>>>
Wait Free   @>>>>>>>>  @>>>>>/s
Waits       @>>>>>>>>  @>>>>>/s
# What began as a simple but great idea has become the new standard:
         while($_ && $_ =~ /=/)
         while($_)
         while(<INFILE>)
   while(<INFILE>)
   while(<MYCNF>)
   while(@row = $query->fetchrow_array()) { $stats{$row[0]} = $row[1]; }
   while(@row = $query->fetchrow_array()) { $vars{$row[0]} = $row[1]; }
      write;
   write;
   write_Com();
   write_DMS();
   write_DTQ();
Write hit     @>>>>>%
   write_InnoDB() if $have_innodb_vals;
   write_qcache(); 
      write_relative_report();
      write_report();
   write_report();
    Writes  @>>>>>>>>
  Writes    @>>>>>>>>  @>>>>>/s
Writes      @>>>>>>>>  @>>>>>/s
  Written   @>>>>>>>>  @>>>>>/s
