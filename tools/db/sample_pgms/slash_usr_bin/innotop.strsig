 =================== ===============================
 ==== ==== ====
 === ===
         |'(?:(?!(?<!\\)').)*')
                     }
                  }
               : $_;
               '',
               }
               },
            ' ',
            '',
            " ",
            )
            );
            ];
            }
            },
         : '';
         . "_"
         '<' => {
         '>' => {
         '-' => {
         ', ',
         ',',
         '',
         '+' => {
         ("(?:(?!(?<!\\)").)*"
         ()
         )
         );
         }
         },
         };
         $_ =>
        @_;
      '',
      ),
      );
      ],
      },
      };
   '^' => {
   '=' => {
   '-' => {
   '!' => {
   '?' => {
   '/' => {
   '@' => {
   '$' => {
   '*' => {
   '\\' => {
   '#' => {
   '%' => {
   '+' => {
   #   : '<=>';
   # -----
   # ################################################################
# ---------- ----------
# ###########################################################################
# ############################################################################
      : 0;
   "000-000-000", "001-003-000", # config file was one big name-value hash.
   "001-003-000", "001-004-002", # config file contained non-user-defined stuff.
         "%02d:%02d",
         "%02d:%02d:%02d",
               0, # don't parse full lock information
# 1          2
            . ')||1)) as R_W_Ratio',
   # '1: len 6; hex 000000005601; asc     V ;'
         /$1 =~ m#[^\040-\176]# ? "[BINARY]" : $1/egx;
         /$1 =~ m#\p{IsC}# ? "[BINARY]" : $1/egx;
300" to return true when the query is more than five minutes old.  That's all
# 3          4
         ^\*{3}\s([^\n]*)  # *** (1) WAITING FOR THIS...
         (?=(?:^\*{3})|\z) # Followed by another three stars or EOF
   # '4: SQL NULL, size 4 '
5.1.15, and 5.2.3.  If it doesn't run correctly for you, that is a bug that
   # '5: len 30; hex 687474703a2f2f7777772e737765657477617465722e636f6d2f73746f72; asc http://www.sweetwater.com/stor;...(truncated)'
   # '6: SQL NULL'
         a => {
   a => {
         A => {
#          [ { a => 1, b => 2}, { a => 3, b => 4 } ]
# aaaaaa
      # a blank line above them if specified.
about the table's data sources.  Most of this is customizable via the table
# Accepts a DB connection name and a (string) query.  Returns a $sth that's been
# Accepts a DB connection name and the name of a prepared query (e.g. status, kill).
Accepts two unsigned integers and converts them into a single longlong.  This is
accept the default if you don't intend to use this.
   'Access denied',
   'Access denied for user',
# a completion function and a hashref of hints.
A configuration file is read-only be default.  You can override that with
      $action->();
      action => \&add_quick_filter,
      action => \&choose_filters,
      action => \&choose_server_groups,
      action => \&choose_servers,
      action => \&clear_quick_filters,
            action => \&create_deadlock,
      action => \&display_help,
      action => \&display_license,
      action => \&edit_configuration,
            action => \&edit_current_var_set,
      action => \&edit_table,
      action_for => {
      action_for      => {
      action_for        => {
      action_for        => {},
   action_for    => \%action_for,
         ? $action_for{$char}->{action}
         $_ => $action_for{$_}->{label}
   # Action keys
      action => \&next_server_group,
      $action = pause('Press e to explain, f for full query, o for optimized query');
      $actions{$action}->($info);
# actions defined in lookup tables.  Each mode may have its own lookup table,
      action => \&start_S_mode,
            action => sub {
            action => sub { analyze_query('e'); },
            action => sub { analyze_query('f'); },
            action => sub { choose_sort_cols('innodb_transactions'); },
            action => sub { choose_sort_cols('open_tables'); },
            action => sub { choose_sort_cols('processlist'); },
            action => sub { $clear_screen_sub->(); toggle_config('status_inc') },
            action => sub { edit_table('deadlock_transactions') },
            action => sub { edit_table('innodb_transactions') },
            action => sub { edit_table('processlist') },
            action => sub { get_config_interactive('cmd_filter') },
      action => sub { get_config_interactive('interval') },
            action => sub { kill_query('CONNECTION') },
            action => sub { kill_query('QUERY') },
            action => sub { purge_master_logs() },
            action => sub { reverse_sort('innodb_transactions'); },
            action => sub { reverse_sort('open_tables'); },
            action => sub { reverse_sort('processlist'); },
            action => sub { send_cmd_to_servers('CREATE TABLE IF NOT EXISTS test.innodb_lock_monitor(a int) ENGINE=InnoDB', 0, '', []); },
            action => sub { send_cmd_to_servers('DROP TABLE IF EXISTS test.innodb_lock_monitor', 0, '', []); },
            action => sub { send_cmd_to_servers('START SLAVE', 0, 'START SLAVE SQL_THREAD UNTIL MASTER_LOG_FILE = ?, MASTER_LOG_POS = ?', []); },
            action => sub { send_cmd_to_servers('STOP SLAVE', 0, '', []); },
            action => sub { set_display_precision(-1) },
            action => sub { set_display_precision(1) },
            action => sub { set_s_mode('g') },
            action => sub { set_s_mode('s') },
            action => sub { set_s_mode('v') },
      action => sub { switch_mode('B') },
      action => sub { switch_mode('C') },
      action => sub { switch_mode('D') },
      action => sub { switch_mode('F') },
      action => sub { switch_mode('I') },
      action => sub { switch_mode('L') },
      action => sub { switch_mode('M') },
      action => sub { switch_mode('O') },
      action => sub { switch_mode('Q') },
      action => sub { switch_mode('R') },
      action => sub { switch_mode('T') },
            action => sub { switch_var_set('S_set', -1) },
            action => sub { switch_var_set('S_set', 1) },
            action => sub { toggle_config('status_inc') },
            action => sub { toggle_filter('innodb_transactions', 'hide_inactive') },
            action => sub { toggle_filter('innodb_transactions', 'hide_self') },
            action => sub { toggle_filter('processlist', 'hide_inactive') },
            action => sub { toggle_filter('processlist', 'hide_self') },
            action => sub { toggle_visible_table('Q', 'q_header') },
            action => sub { toggle_visible_table('T', 't_header') },
      action => \&toggle_aggregate,
activating a built-in one that's not currently displayed, press the (n)ew key,
            active => 0,
   active_columns => {
   active_columns sort_cols visible_tables varsets colors stmt_sleep_times
   active_connections => {
   active_filters => {
      active_secs        => $active_secs,
   active_secs                 => { hdr => 'SecsActive',          num => 1, label => 'Seconds transaction has been active', },
         active_secs        => { src => 'active_secs' },
   active_server_groups => {
# Actual DBI connections to MySQL servers.
Actually, this still needs a little more work.  If your L<"interval"> is less
   adaptive_hash_index => {
      adaptive_hash_index => \@adaptive_hash_index,
   # Add aggregation and turn into a real set TODO: total hack
      # Add in any other sections the caller requested.
         add_new_dsn();
         add_new_dsn('localhost', 
         add_new_dsn($new);
     add_new_dsn($opts{h} || 'localhost', $params[0], 'test.innotop_dl', 
            add_new_server_group($new);
      add_new_var_set($new_value);
 add_pool_alloc     Add'l Pool   Additonal pool alloca  IB_bp_add_poo
   add_pool_alloc              => { hdr => 'Add\'l Pool',         num => 1, label => 'Additonal pool allocated' },
         add_pool_alloc             => { src => 'IB_bp_add_pool_alloc', trans => [qw(shorten)], },
# add_quick_filter {{{3
Adds a '%' character after the value returned by the L<"percent">
Adds commas to large numbers every three decimal places.
         # Add SHOW VARIABLES to the hash
    # Add the column to every table.
       # Add the column to the list of defined columns
       # Add the column to the list of visible columns
add to the L<"slave_sql_status"> table.
A DSN is a Data Source Name, which is the initial argument passed to the DBI
A file to which innotop will write information when there is a crash.  See
a frown :-( means the output is incomplete, which is probably due to a deadlock
   'After create'                 => 1,
After pivoting, the table will look like this:
# after processing.  Initial values are defaults.
After you've connected, innotop should show you something like the following:
against which to compare the column, and a color to assign if the rule matches.
            agg   => 0,
agg: an aggregate function.  See L<"GROUPING">.  The default is L<"first">.
         $_->{agg}   = 'avg';
   agg     => 'first',  # Aggregate function
   agg_funcs     => \%agg_funcs,
            aggonly => 0,
   aggonly => 0,        # Whether to show only when tbl_meta->{aggregate} is true
aggonly: controls whether the column only shows when grouping is enabled on the
      aggregate => 0,
      aggregate => 1,
aggregated across multiple servers.  This is a known limitation of the grouping
aggregate function for every column you want in the result.
aggregate property.  This property doesn't persist to the config file.
# Aggregates a table.  If $group_by is an arrayref of columns, the grouping key
A hashref of connection specifications.  These are just specifications of how to
A hashref of filters applied to table rows.  See L<"FILTERS"> for more.
A hashref of functions that can be used for grouping.  See L<"GROUPING">.
A hashref of innotop's database connections.  These are actual DBI connection
A hashref of innotop's table meta-data, with one entry per table (see
A hashref of key mappings.  These are innotop's global hot-keys.
A hashref of modes.  See L<"MODES"> for more.
A hashref of server groups.  See L<"SERVER GROUPS">.
A hashref of transformation functions.  See L<"TRANSFORMATIONS">.
A hashref of variable sets.  See L<"VARIABLE SETS">.
algorithm that may be fixed in the future.
               # Align along the decimal point
# aligned left, and sorted alphabetically, not numerically.
a list of plugins innotop discovered.  You can use the 'j' and 'k' keys to move
Allen K. Smith,
# All events for which plugins may register themselves.  Entries are arrayrefs.
All output is tab-separated instead of being column-aligned with whitespace, and
# Allows the user to show fulltext, explain, show optimized...
All these and more are explained in the following sections.
# All variables to which plugins have access.
# Also a list of params for the prepared query.  This allows not storing prepared
among the columns available but not currently displayed.  Finally, you can
amount of time after executing a statement.  See L<"SQL STATEMENTS"> for a
An alternative way to start the table editor without entering the configuration
# analyze_query {{{3
            ? "(\$a->{$name} || $df) $op (\$b->{$name} || $df)"
and a list of filters currently enabled for that table.  Type the names of
and compactly.  (Under Microsoft Windows, you also need Win32::Console::ANSI for
      # and don't ask which server to connect to.  Also, if we're monitoring from a file,
and drop the table with the InnoDB storage engine.  You can safely omit or just
and information from the wait array.  It displays the L<"row_operations">,
and innotop will prompt you for the information it needs:
and issue a PURGE MASTER LOGS on the master.  Use the 'b' key for this.  innotop
and L<"--inc">), innotop actually refreshes one more time than specified so it
and minimum widths.  innotop also does final error checking to ensure there are
   # and move the temp conf file to its new home
and off with the 'i' and 'a' keys.
and press the '^' key to start the table editor.  When prompted, choose
and probably more people that have not been included.
and status, so you can quickly see how many queries or transactions are in a
# and such, and turns it into a single integer
and the configuration file only overrides these defaults.  When you customize a
and the last shows master status.  Filters are applied to eliminate non-slave
and the table is ready to print.
and the table name.
               # and try to grab the last status from the file.
               . "and underscores.");
# and writing them.
an error is prefixed with an exclamation point.
An innotop plugin is a Perl module placed in innotop's L<"plugin_dir">
an object-oriented module it can call certain methods on.  The methods are
Another way to monitor multiple connections at once is with server groups.  You
   $answer = '' if !defined($answer);
      $answer = pause("Innotop's default config location has moved to '$conf_file'.  Move old config file '$old_filename' there now? y/n");
            $answer = prompt('Edit what? (q to quit)');
   $answer =~ s/\s+$//;
any.  See L<"Plugin Events"> for the defined events.  If the plugin returns an
anything, you might want to check and see if a deadlock has wiped out the data
      # Append the RHS onto the LHS until one runs out.
applies further formatting to the column values, including alignment, maximum
# Apply a default property or three.  By default, columns are not width-constrained,
      # Apply filters.
      # Apply filters.  Note that if the table is pivoted, filtering and sorting
   # Apply group-by.
      # Apply missing values to columns.  Always apply averages across all connections.
   # Apply_transformations.
      # are applied later.
are defined:
are just an easy way to quickly view only some rows.
are waiting.  This information comes from the TRANSACTIONS section of the InnoDB
            arg   => $arg,
            $arg = prompt('Specify an argument for the comparison');
# Arguments are a set of values (which may be incremental, derived from
as 'all', 'masters', and 'slaves', which innotop can monitor all together.
as a sum; other columns are left at the default 'first' aggregation.
      asc   => defined($asc) ? $asc : '',
a SET clause in an UPDATE statement.  It will not alter the UPDATE statement,
   # Ask which slave(s) are reading from this master.
a small deadlock (see L<"D: InnoDB Deadlocks">).  If you specify this option,
a smiley face indicating whether the InnoDB output is truncated.  If the smiley
#          { a => spec, b => spec }
a spreadsheet (also known as a crosstab).  Pivoting a table makes columns into
as SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1 to make the slave skip one binlog event
as stated in the manual, but it also makes the normal SHOW INNODB STATUS output
a string or a number.  If you want to compare the column against a string, as
as you wish (for example, shortening large numbers to familiar units).
a table definition to extract and format the data, but it then transforms the
A table is what you'd expect: a collection of columns.  It also has some other
At construction time, innotop has only loaded the general configuration and
# A thread's proc_info can be at least 98 different things I've found in the
A tick is a refresh event, when innotop re-fetches data from connections and
               : ($a->{time} || 0) <=> ($b->{time} || 0);
   attempted_op                => { hdr => 'Action',              num => 0, label => 'The action that caused the error' },
         attempted_op => { src => 'IB_fk_attempted_op' },
Aurimas Mikalauskas,
   'AutoCommit',
      AutoCommit        => 0,
auto-completion on column names.  The filter text can be just the text you want
# * autokey:   which key to treat a bareword as (typically h=host).
   auto_wipe_dl => {
available.  Valid values are 'bold' and 'underline'.
   avg   => sub {
   # Avoid dividing by zero
      awe_mem_alloc dict_mem_alloc);
   awe_mem_alloc               => { hdr => 'AWE Memory',          num => 1, label => '[Windows] AWE memory allocated' },
            awe_mem_alloc pages_modified writes_pending_lru page_creates_sec
         awe_mem_alloc              => { src => 'IB_bp_awe_mem_alloc', trans => [qw(shorten)], },
         b => {
   B => {
 bar  3    4
'bareword' token in the string and decides whether it's supposed to be a key
Bartosz Fenski,
      # because part of that process was to choose connections.
   # Because there are two code paths, some things won't get set.
# become part of tbl_meta as well.  Each filter is just an expression that
becomes a "variable set," or a "list of variables you want to monitor."
be displayed.  The row is a hash reference passed to your subroutine as $set.
be easily processed with other command-line utilities such as awk and sed.  To
   # before printing anything out, so we need to bump up the count one.
## Begin packages ##
begins with the combination of SHOW STATUS and SHOW VARIABLES, but other sources
Behind the scenes innotop compiles the quick-filter into a specially tagged
Behind the scenes innotop will split that variable set into three expressions,
belong to tables and are covered in later sections.
      # be shown; but eliminate aggonly columns if the table isn't aggregated.
    # Be sure to return a reference to the object.
between ticks.
   binlog_cache_overflow       => { hdr => 'Binlog Cache',        num => 1, label => 'Transactions too big for binlog cache that went to disk' },
         binlog_cache_overflow       => { src => '(Binlog_cache_disk_use||0)/(Binlog_cache_use||1)', trans => [ qw(percent) ] },
   binlog_do_db                => { hdr => 'Binlog Do DB',        num => 0, label => 'binlog-do-db setting' },
         binlog_do_db                => { src => 'binlog_do_db' },
   binlog_ignore_db            => { hdr => 'Binlog Ignore DB',    num => 0, label => 'binlog-ignore-db setting' },
         binlog_ignore_db            => { src => 'binlog_ignore_db' },
               binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
               binmode(STDOUT, ':utf8')
   bless {}, shift;
            : "(\$b->{$name} || $df) $op (\$a->{$name} || $df)";
      $body = prompt("Enter subroutine body", undef, undef, $completion);
bottom of every table, not just the first.  And if L<"show_cxn_errors"> is
               . 'bottom.  The first matching rule wins and prevents the '
   bp => \&parse_bp_section,
   bps_in                      => { hdr => 'BpsIn',               num => 1, label => 'Bytes per second received by the server', },
         bps_in         => { src => 'Bytes_received/Uptime_hires',          dec => 1, trans => [qw(shorten)] },
   bps_out                     => { hdr => 'BpsOut',              num => 1, label => 'Bytes per second sent by the server', },
         bps_out        => { src => 'Bytes_sent/Uptime_hires',              dec => 1, trans => [qw(shorten)] },
               : $b->{query} && !$a->{query} ? -1
Brian Miezejewski,
browser, a bug tracker, etc.  Please use these instead of contacting the
   buffer_pool => {
   "BUFFER POOL AND MEMORY"                => "bp",
      buffer_pool         => \@buffer_pool,
 buf_free           Free Bufs    Buffers free in the b  IB_bp_buf_fre
   buf_free                    => { hdr => 'Free Bufs',           num => 1, label => 'Buffers free in the buffer pool' },
         buf_free                   => { src => 'IB_bp_buf_free' },
   BufPoolFill       => q{ $cur->{IB_bp_pages_total} / ($cur->{IB_bp_buf_pool_size} || 1) },
   buf_pool_hit_rate           => { hdr => 'Hit Rate',            num => 0, label => 'Buffer pool hit rate' },
 buf_pool_hit_rate  Hit Rate     Buffer pool hit rate   IB_bp_buf_poo
         buf_pool_hit_rate          => { src => 'IB_bp_buf_pool_hit_rate' },
   buf_pool_hits               => { hdr => 'Hits',                num => 1, label => 'Buffer pool hits' },
         buf_pool_hits              => { src => 'IB_bp_buf_pool_hits' },
   buf_pool_reads              => { hdr => 'Reads',               num => 1, label => 'Buffer pool reads' },
         buf_pool_reads             => { src => 'IB_bp_buf_pool_reads' },
   buf_pool_size               => { hdr => 'Size',                num => 1, label => 'Buffer pool size' },
 buf_pool_size      Size         Buffer pool size       IB_bp_buf_poo
         buf_pool_size              => { src => 'IB_bp_buf_pool_size', trans => [qw(shorten)], },
   bufs_in_node_heap           => { hdr => 'Node Heap Bufs',      num => 1, label => 'Buffers in buffer pool node heap' },
         bufs_in_node_heap   => { src => 'IB_ib_bufs_in_node_heap' },
            bufs_in_node_heap used_cells size free_list_len seg_size inserts
            # Build the pivoted view of the table's meta-data.  If the terminal has color,
         # Build the table of plugins.
            # Build the table of rules.  If the terminal has color, the selected rule
But innotop isn't limited to monitoring a single server; you can define many
         # but it's most important to have consistency.
but will collapse the quoted string to [BINARY] or [TEXT], depending on the
by default.
By default, innotop highlights rows with color so you can see at a glance which
By default innotop will display the problem in red text at the bottom of the
By default, the table shown in L<"S: Variables & Status"> mode also uses
by some information about the SHOW INNODB STATUS output used to render the
   bytes_behind_master         => { hdr => 'ByteLag',             num => 1, label => 'Bytes the slave lags the master in binlog' },
         bytes_behind_master         => { src => 'master_log_file && master_log_file eq relay_master_log_file ? read_master_log_pos - exec_master_log_pos : 0', trans => [qw(shorten)] },
         c => {
   c => {
         # Calculate hi-res uptime and add cxn to the hash.  This duplicates get_driver_status,
      # Calculate the width of what will be displayed, so it can be centered
callbacks for the events.  See L<"Plugin Events"> for more details about each
   # called foreign_index, as opposed to referenced_index which is in the
         . "called \$set, and returns a true value if the filter accepts the row.  Example:\n"
      # Call the subroutine to display this mode.
came.  Uptime_hires is a high-resolution version of the server's Uptime status
can also explicitly add a + in front of columns you want to sort ascending, but
# can be in the form 'foo, bar, foo/bar, foo as bar' much like a SQL SELECT statement.
   @candidates = grep { $_->{cxn} eq $cxn } @candidates;
can edit more than just the table's columns; this screen can start the filter
   'Cannot call SHOW INNODB STATUS',
   Cannot      => \&parse_fk_cant_drop_parent_error,
can print incremental statistics.  This suppresses output during the first
can read more about DBI at L<http://dbi.perl.org/docs/>, and especially at
# can stack ccc next to the bbb.
   'Can\'t connect to local MySQL server through socket',
   'Can\'t connect to MySQL server on',
# can't tell how tall it is.
can use the TAB key to switch to the 'next' group in alphabetical order, or if
      capt => 'Adaptive Hash Index',
      capt => 'Buffer Pool',
      capt => 'Command Summary',
      capt => 'Deadlock Locks',
      capt => 'Deadlock Transactions',
      capt => 'EXPLAIN Results',
      capt => 'File I/O Misc',
      capt => 'Foreign Key Error Info',
      capt => 'InnoDB Locks',
      capt => 'InnoDB Row Operations',
      capt => 'InnoDB Semaphores',
      capt => 'InnoDB Transactions',
      capt => 'InnoDB Wait Array',
      capt => 'Insert Buffers',
         # caption from whatever it's captioning.
      # caption in the display.
      capt => 'I/O Threads',
      capt => 'Log Statistics',
      capt => 'Master Status',
      capt => 'MySQL Process List',
      capt => 'Open Tables',
      capt => 'Page Statistics',
      capt => 'Pending I/O',
      capt => 'Q-mode Header',
      capt => 'Row Operation Misc',
      capt => 'Slave I/O Status',
      capt => 'Slave SQL Status',
      capt => 'T-Mode Header',
      capt      => 'Variables & Status',
   # cases here, but I assume there will only be one.
caused by a cycle in the waits-for graph, so there should be two locks held and
   cell_event_set              => { hdr => 'Ending?',             num => 1, label => 'Whether the cell event is set' },
         cell_event_set     => { src => 'cell_event_set' },
   cell_waiting                => { hdr => 'Waiting?',            num => 1, label => 'Whether the cell is waiting' },
         cell_waiting       => { src => 'cell_waiting' },
   # Certain data may not be present.  Make them '' if not present.
Certain Perl modules are not loaded.  Term::Readline is not loaded, since
         $cfg_editor_action{$key}->{func}->();
change which tables display in each mode, see L<"TABLES">.  Since L<"Q: Query
change with built-in commands, but you can also edit the configuration file.
character is a comment.  innotop will not read the comments, so it won't write
      ' Character set info: ',
         $char = ReadKey($config{interval}->{val});
   charset => {
charset.
      # Check config file version.  Just ignore if either innotop or the file has
   child_db                    => { hdr => 'Child DB',            num => 0, label => 'The database of the child table' },
         child_db     => { src => 'IB_fk_child_db' },
         child_db timestring fk_name records col_name reason txn parent_db
   child_index                 => { hdr => 'Child Index',         num => 0, label => 'The index in the child table' },
         child_index  => { src => 'IB_fk_child_index' },
         $children{$child} = $pid;
# children.  These are usually $sth handles that haven't been finish()ed.
   child_table                 => { hdr => 'Child Table',         num => 0, label => 'The child table' },
         child_table  => { src => 'IB_fk_child_table' },
   @choices = grep { exists $filters{$_} } @choices;
   @choices = grep { grep { $tbl eq $_ } @{$filters{$_}->{tbls}} } @choices;
            chomp $line;
         chomp $line;
      chomp $line;
   chomp($response);
            'Choose a column',
         "Choose a server group $prompt",
      'Choose a set of values to display, or enter the name of a new one',
         "Choose a table",
            choose_connections();
      "Choose connections $prompt",
      'Choose filters',
         choose_filters($tbl);
# Choose from among available connections or server groups.
         choose_group_cols($tbl);
choose how many updates to put on the screen with the L<"num_status_sets">
# choose_mode_tables {{{3
# Chooses a thread for explaining, killing, etc...
# choose_server_groups {{{3
# choose_servers {{{3
         choose_sort_cols($tbl);
      "Choose tables to display",
               'Choose the color(s) the row should be when the rule matches',
               'Choose the comparison operator for the rule',
               'Choose the target column for the rule',
               choose_var_set('S_set');
# choose_visible_table {{{3
Choose which columns are in those tables, and create new columns.
# Choose which server connections are in a server group.  First choose a group,
# Choose which table(s), and in what order, to display in a given mode.
Choose which tables to display, and in what order.
choose which variables to display with the 'c' key, which selects from
Christian Hammers, 
'c' key, or activate the next and previous sets with the '>' and '<' keys.
clarify, if the table is pivoted, the process is extract, group, transform,
            class  => $package,
      # Clean up.
# clear_deadlock {{{3
            clear_deadlock($cxn);
   clear_deadlock($cxn);
      . "clearing deadlock information from the InnoDB monitor.\n\n";
   $clearing_deadlocks = 0;
# clear_quick_filters {{{3
         $clear_screen_sub->();
      $clear_screen_sub->();
   $clear_screen_sub->()
   $clear_screen_sub->();
$clear_screen_sub->();
   $clear_screen_sub = sub {};
   $clear_screen_sub = sub { $lines_printed = 0; print $clear };
   $clear_screen_sub = sub { $lines_printed = 0; system("cls") };
# Clear the screen and load the configuration.
      # Clear the screen if the display width changed.
                     close $file;
         close $file;
      close $file or die("Can't close $conf_file: $OS_ERROR");
   close $file or die("Can't close $tmpfile: $OS_ERROR");
         close $p_in;
 cmd    eq  Binlog Dump  white       
 cmd    eq  Connect      white       
 cmd    eq  Sleep        white       
   cmd_filter => {
   cmd                         => { hdr => 'Cmd',                 num => 0, label => 'Type of command being executed', },
      cmdline => 1,
   $cmd = prompt('Command to send', undef, $cmd);
         cmd             => { src => 'command',    minw => 5,  maxw => 0 },
   cmd_summary => {
      cmd_summary => \@cmd_summary,
   #   ? 'cmp'
   cnt                         => { hdr => 'Cnt',                 num => 0, label => 'Count', agg => 'count', aggonly => 1 },
         cnt             => { src => 'id',         minw => 0,  maxw => 0 },
         cnt                => { src => 'mysql_thread_id',     minw => 0 },
code of the module must be written in such a way that innotop can inspect the
   @col1 = splice(@all_actions, 0, ceil(@all_actions/2));
   @col1 = splice(@all_magic, 0, ceil(@all_magic/2));
         { col => 'cmd',         op => 'eq', arg => 'Binlog Dump', color => 'white' },
         { col => 'cmd',         op => 'eq', arg => 'Connect',     color => 'white' },
         { col => 'cmd',         op => 'eq', arg => 'Sleep',       color => 'white' },
            col   => $col,
         $col_def->{func} = $sub;
            $col_def->{$prop}
         ( $col ) = grep { $_ } split(/\W+/, $col);
            $col = '' if $col =~ m/[^a-z0-9_]/;
   $col->{just} = $col->{num} ? '' : '-';
# Collapses all whitespace to a single space.
# collapse_ws {{{3
collapsing ALL text fields in queries.
         { col => 'lock_wait_time', op => '>',  arg => 10, color => 'green' },
         { col => 'lock_wait_time', op => '>',  arg => 30, color => 'yellow' },
         { col => 'lock_wait_time', op => '>',  arg => 60, color => 'red' },
         $colname = $1;
            $col_name => $max_width;
   color => {
            color => $color
               ? colored($_->[0], $_->[1])
# Color editor key mappings {{{3
   *colored = sub { pop @_; @_; };
               ? colored(substr($_->[0], 0, $this_term_size[0]), $_->[1])
   # coloring.
         # Color is not supported, so we have to add a line underneath to separate the
         # Color is supported, so we can use terminal underlining.
      # Colorize.  Adds a _color column to rows.
         $color = join(' ', unique(grep { exists $ansicolors{$_} } split(/\W+/, $color)));
            $color = prompt_list(
      colors   => [
      colors   => [],
   colors => {
            $col = prompt("Enter column name");
            $col = prompt_list(
               : $col_props{$prop};
         } @$cols;
      $cols,
      cols => {
      $cols{$colname} = {
      cols      => {}, # Generated from current varset
         { col => 'slave_io_running',  op => 'ne', arg => 'Yes', color => 'black on_red' },
         { col => 'slave_sql_running',  op => 'ne', arg => 'Yes', color => 'black on_red' },
      $cols  = sub { qw(name set_0) };
      $cols  = sub { return keys %{$meta->{cols}} };
         { col => 'state',       op => 'eq', arg => 'Locked',      color => 'black on_red' },
      ( $cols, $visible ) = compile_select_stmt($fmt);
      ( $cols, $visible ) = @{$tbl_meta{var_status}}{qw(cols visible)};
         { col => 'time_behind_master', op => '==', arg => 0,     color => 'white' },
         { col => 'time_behind_master', op => '>',  arg => 600,   color => 'red' },
         { col => 'time_behind_master', op => '>',  arg => 60,    color => 'yellow' },
         { col => 'time',        op => '>',  arg => 120,           color => 'yellow' },
         { col => 'time',        op => '>',  arg => 300,           color => 'yellow' },
         { col => 'time',        op => '>',  arg => 30,            color => 'cyan' },
         { col => 'time',        op => '>',  arg => 600,           color => 'red' },
         { col => 'time',        op => '>',  arg => 60,            color => 'green' },
         { col => 'txn_status',  op => 'eq', arg => 'not started', color => 'white' },
# Column definitions {{{3
column has an extraction subroutine, compiled from an expression (see
column.  If you don't explicitly specify a grouping function, the default is
# Column One Column Two
column's aggonly is set true, the column will appear when you toggle grouping on
      # columns and it could crash.  This will only be an issue if it's possible
Columns belong to tables.  You can choose a table's columns by pressing the '^'
               ? $columns{$col_name}->{$prop}
      $columns{$col_name}->{referenced} = 1;
# $columns{foo} for its definition) gets its data from the 'bar' element of
columns.  This keeps things consistent and predictable.
column's values, from the values returned by SHOW STATUS:
column.  You can also (a)dd a column to the table.  This actually just activates
         { col => 'user',        op => 'eq', arg => 'system user', color => 'white' },
         { col => 'wait_status', op => 'eq', arg => 'LOCK WAIT',   color => 'black on_red' },
combination of SHOW STATUS, SHOW VARIABLES, and SHOW INNODB STATUS.  Imagine
            . ')/(Com_commit||1)) as Write_Commit',
   Com_delete   => 50,
   Com_insert   => 50,
         Com_insert_select Com_replace Com_replace_select Com_select Com_update
command-line options are used.  See L<"SERVER CONNECTIONS">.
# Command-line parameters {{{2
   commands => {
commands are killing queries and stopping or starting slaves.
 _____________________ Command Summary _____________________
 Command Summary (? for help) localhost, 25+07:16:43, 2.45 QPS, 3 thd, 5.0.40
# commify {{{3
   commify      => \&commify,
# Compares versions like 5.0.27 and 4.1.15-standard-log
# compile_expr {{{3
# compile_filter {{{3
   # Compile sort and color subroutines
compile them and turn them into a table definition, then extract as usual.  This
            ->{'complete'} = $innodb_sections{$section}->[1];
complex data extracted from SHOW INNODB STATUS, this is slightly messy.  SHOW
         Compression Connections Created_tmp_disk_tables Created_tmp_files
                  Com_replace_select Com_select Com_update Com_update_multi))
   Com_select   => 50,
         Com_stmt_close Com_stmt_execute Com_stmt_fetch Com_stmt_prepare
         Com_stmt_reset Com_stmt_send_long_data )
   Com_update   => 50,
         Com_update_multi)
         Com_xa_commit Com_xa_end Com_xa_prepare Com_xa_recover Com_xa_rollback
         Com_xa_start)
      conf => 'ALL',
      $conf_file = $default_central_conf;
         $conf_file = $default_home_conf;
      $conf_file = $default_home_conf;
      $conf_file = $opts{c};
   $config{$cfg_var}->{val} = $var_sets[$newpos];
      \%config_choices);
   config        => \%config,
               $config{debug}->{val},
# Config editor key mappings {{{3
            $config_file_sections{$1}->{reader}->($file);
# Config file sections {{{2
# Config file sections have some dependencies, so they have to be read/written in order.
      $config_file_sections{$section}->{writer}->($file);
           $config{$key}->{conf} &&
              ( $config{$key}->{conf} eq 'ALL'
      $config{$key}->{val},
   $config{$key}->{val} ^= 1;
   $config{$key}->{val} = $new_value;
   $config{$key}->{val} = $new_value if exists $var_sets{$new_value};
   $config{mode}->{val} = $mode;
      && $config{mode}->{val} =~ m/[S]/ )
            $config{$name}->{read} = 1;
            $config{$name}->{val} = $val;
      $config{$name}->{val} = $val;
      : $config{num_digits}->{val};
   $config{num_digits}->{val} = min(9, max(0, $config{num_digits}->{val} + $dir));
      ? $config{num_status_sets}->{val}
      $config{readonly}->{val} = 0 if $opts{w};
                        $config{readonly}->{val} = 1;
   $config{readonly}->{val} = 1;
   $config{S_func}->{val} = $func;
      . ($config{show_percent}->{val} ? '%' : '');
               $config{status_inc}->{val} ? inc(0, $cxn) : $set,
               $config{status_inc}->{val} ? inc(0, $cxn) : $set, $set, $pre,
# Config storage. {{{2
configuration file.
configuration file exists, the second will not be processed.  Those can be
# Configuration files
configuration file, so it will persist across sessions.
configuration file will be skipped if any DSN, username, or password
configuration file.  You can choose which variable set you want to see with the
# Configuration information and global setup {{{1
configuration information.  Files include the configuration file innotop.conf,
configuration option L<"mode">.
configuration options can come from the command line.  You can also specify a
configuration variable.
configuration variable lets you run innotop and fetch what data you can even
Confirm the command with 'y'.
      conf => [ qw() ],
      conf => [qw(C)],
      conf => [ qw(S) ],
      conf => [qw(S)],
connecting and causes a long time-out.  Instead, innotop retries the connection
connection.
connection, from L<"Q: Query List"> and L<"T: InnoDB Transactions"> modes.
# connection has gone away or can't connect, DO NOT.  Just return undef.
      ' Connection info: ', ($dbh->{mysql_hostinfo} || 'undef'),
connection names of that master's slaves (there is no way for innotop to
      connections     => [],
      connections       => [],
   connections => {
CONNECTIONS">).
# Connections {{{3
   connections active_connections server_groups active_server_groups max_values_seen
connections and printing it to the terminal.
   connections   => \%connections,
      @connections = @connections ? $connections[0] : ();
connections from replication and sleeping queries, and make queries turn from
connection should not crash innotop.  As a result, innotop will continue to run
      $connections{$key} = \%conn;
   $connections{$name} = {
connection that had an error.  Because of this, innotop's behavior might confuse
      # connection total, assume the user wants to just use innotop for a single server
   connect_retry               => { hdr => 'Connect Retry',       num => 1, label => 'Slave connect-retry timeout' },
         connect_retry               => { src => 'connect_retry' },
connect to a server.
considers every character a control character, which can be useful for
      # contains data from an entire non-pivoted row, so there could be a mix of
# Contains logic to generate prepared statements for a given function for a
# contains the DDL string the user entered, which is way too much for this
context-sensitive help.
control character.  The other allowable values are 'unicode' and 'none'.  'none'
controlled from the configuration file and command-line options.  To start
Controls how many sets of status variables to display in pivoted L<"S: Variables
Controls S mode presentation (see L<"S: Variables & Status">).  If g, values are
Controls whether to show the status bar in the display.  See L<"INNOTOP
# Convenience so I can copy/paste these in several places...
Converts a number to a percentage by multiplying it by two, formatting it with
# Convert to percent
            copy => 1,
   'copy to tmp table'            => 1,
# core_dump {{{3
   core_dump( $EVAL_ERROR );
   count => sub {
# create_caption {{{3
# create_deadlock {{{3
created the default built-in variables with their default contents (which is
         Created_tmp_tables Max_used_connections Open_files Open_streams
   # Create header
# create_new_filter {{{3
         create_new_filter($new, $tbl);
creates a row.  This row is another hash, which later steps will refer to as
# create_statusbar {{{3
               create_table2(
            create_table2(
         create_table2(
      create_table2(
# create_table2 {{{3
# create_table {{{3
  CREATE TABLE innodb_lock_monitor(a int) ENGINE=INNODB;
crucial when you have many active connections.  A crashed server or lost
# crunch {{{3
   # Crush the rows together...
            :  $cur->{$_} )
   $cur         ||= $cxns[0];
            ?  $cur->{$_} - ($pre->{$_} || 0)
      $curr,
# current and previous), current, and previous values.
      @current = grep { !$filters{$_}->{quick} } @current;
      # Currently not an issue since there's no way to toggle pivot/nopivot.
   } @current_queries;
   @current_queries = map {
      cust => {},
      cust      => {},
      cust       => {},
      cust            => {},
      cust              => {},
      # customization.
Customize the alignment, width, and formatting of columns, and apply
            $cxn)));
         $cxn);
cxn and Uptime_hires.  cxn is the name of the connection from which the data
 CXN        Cmd        Cnt  ID      User   Host           Time   Query       
 CXN        Cmd    ID         User  Host      DB   Time   Query
 cxn                CXN          Connection from which  cxn          
      $cxn = $dbhs{$cxns[0]}->{dbh}->{mysql_serverinfo} || '';
   cxn                         => { hdr => 'CXN',                 num => 0, label => 'Connection from which the data came', },
 CXN        ID  Type    Waiting  Wait   Active  Mode  DB    Table  Index
   cxn_is_master => {
   cxn_is_slave => {
         $cxn = join(' ', map { ($dbhs{$_}->{err_count} ? '!' : '') . $_ }
      @cxns;
      $cxns,
            $cxns[0],
         $cxns[0],
            $cxn .= "(" . ( scalar(@cxns) - $err_count ) . "/" . scalar(@cxns) . ")";
         $cxn = "Servers: " . $modes{$mode}->{server_group};
   cxns_files_threads => {
      @$cxns = get_connections();
      @cxns = get_connections();
   @cxns = map { $_->{cxn} } @vars;
         cxn         => { src => 'cxn' },
         cxn           => { src => 'cxn' },
         cxn            => { src => 'cxn' },
         cxn              => { src => 'cxn' },
         cxn                => { src => 'cxn' },
         cxn                 => { src => 'cxn' },
         cxn                        => { src => 'cxn' },
         cxn                         => { src => 'cxn' },
         cxn             => { src => 'cxn',        minw => 6,  maxw => 10 },
      @cxns = select_cxn("Choose servers for $name", keys %connections);
      @$cxns = select_cxn('Which servers?', @$cxns);
   cxn_timeout => {
 CXN        When   Load  QPS    Slow  QCacheHit  KCacheHit  BpsIn    BpsOut 
cyan to red as they run longer.
Cyril Scetbon,
         : '%d',
   d => {
         D => {
   D => {
         "%d+%02d:%02d:%02d",
Dane Miller,
# Database connections {{{3
      $data = [ @$data[0..$this_term_size[1] - 1] ];
$Data::Dumper::Indent    = 0;
$Data::Dumper::Quotekeys = 0;
$Data::Dumper::Sortkeys = 1;
               $data->[$i]->{''} = $i == $selected_rule ? '>' : '';
data periodically, so you see an updating view.
# Data-retrieval functions {{{2
data source just like you'd expect.  For example:
David Multer,
DBD::mysql,  Term::ReadKey, and Time::HiRes.  These should be included with most
      ' $DBD::mysql::VERSION: ', $DBD::mysql::VERSION,
      $dbh,
               = ($dbh, 0, 0, 1, 0, 0);
         $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
   $dbh->disconnect;
         $dbh->do("set session wait_timeout=$timeout, interactive_timeout=$timeout");
            $dbh->do($sql);
         $dbh->do($sql);
         $dbh->do($stmt);
      $dbh->do($stmts[-1]);
   db                          => { hdr => 'DB',                  num => 0, label => 'Current database', },
   $dbh->{FetchHashKeyName} = 'NAME_lc'; # Lowercases all column names for fetchrow_hashref
   $dbh->{InactiveDestroy} = 1 unless $destroy; # Can't be set in $db_options
         ? $dbh->prepare('SHOW OPEN TABLES')
   $dbhs{$cxn} ||= {
      && ( !$dbhs{$cxn}->{dbh} || !$dbhs{$cxn}->{dbh}->{Active} || $dbhs{$cxn}->{mode} eq $config{mode}->{val} )
      && $dbhs{$cxn}->{err_count} 
   $dbhs{$cxn}->{start_time} ||= time();
            $dbhs{$cxn}->{stmts}->{$stmt_name} = $stmt_maker_for{$stmt_name}->($dbh);
      && $dbhs{$cxn}->{wake_up} > $clock;
      $_ => $dbhs{$_}->{dbh} ? $dbhs{$_}->{dbh}->{mysql_thread_id} : 0
   dbhs          => \%dbhs,
      dbh        => undef,
# * dbidriver: which DBI driver to use; assumes mysql, supports Pg.
                     'DBI:mysql:;host=localhost;mysql_read_default_group=client', 
 DBI:mysql:;mysql_read_default_group=mysql;host=HOSTNAME
      ' $DBI::VERSION: ', $DBI::VERSION,
         db             => { src => 'database' },
         db               => { src => 'db' },
         db              => { src => 'db',         minw => 6,  maxw => 12 },
deactivate them.  Start the editor by pressing $ to start the configuration
   deadlock_locks => {
      deadlock_locks        => \@deadlock_locks,
# deadlock_thread {{{3
            deadlock_thread( $child, $tbl, $cxn );
   deadlock_transactions => {
      deadlock_transactions => \@deadlock_transactions,
                  $debug,
   debug => {
      _debug( $debug, $EVAL_ERROR);
   debugfile => {
            dec   => 0,
       dec   => 0,
   dec     => 0,     # Whether to align the column on the decimal point
         # Decide how wide columns should be.
decides that the bareword isn't a function or other valid Perl code, it converts
   # Decide what format to use, if not given
   # Decide which type of FK error happened, and dispatch to the right parser.
dec: whether to further align the column on the decimal point.
# default.
default.
default aggregation function in this mode is 'avg'.
default, innotop hides inactive transactions and its own transaction.  You can
   $defaults ||= {};
# Defaults are built-in, but you can add/replace items by passing them as
default setting, innotop notices, and then stores the customizations into the
   @{$defaults}{ keys %$opts } = values %$opts;
         : defined($action_for{$char})
# defined by the %columns hash.
               = defined($columns{$col_name}->{$prop})
            ( (defined $cur->{$_} && $cur->{$_} =~ m/$num_regex/)
defined in the %event_listener_for variable, and are as follows:
         = defined($modes{$mode}->{action_for}->{$char})
           && defined $prev->{$key} && $opts{$key}->{copy} )
             && ( !defined($set->{cmd})        || $set->{cmd} !~ m/Sleep|Binlog Dump/ )
             && ( !defined($set->{info})       || $set->{info} =~ m/\S/               );
         "( defined \$set->{$spec->{col}} && \$set->{$spec->{col}} $spec->{op} $val ) { return '$spec->{color}'; }";
# Defines every column in every table. A named column has the following
Defines how to highlight column headers.  This only works if Term::ANSIColor is
# Defines sets of servers between which the user can quickly switch.
Defines the character to use when drawing graphs in L<"S: Variables & Status">
# Defines the parts of connections.
definition for this.
   # definition of dict_foreign_struct in include/dict0mem.h, where it is
definition of each statement and what it does.  By default innotop does not
delay after any statements.
         delete @all_cols{@visible_cols};
   delete $config{max_height};
            delete $defaults->{mysql_enable_utf8};
   delete $dl->{'fulltext'} unless $debug;
            # Delete everything but the last InnoDB status text from the file.
            delete $innodb_data{'sections'}->{$section};
   delete $keys{'?'};
# delete or update data.  Sometimes it is possible to parse out a lot of
      delete $$rows[0]{cxn} if defined $$rows[0]{cxn};
   delete $section->{'fulltext'} unless $debug;
      delete $stmt_sleep_time_for{$stmt};
         delete @{$store}{ grep { $_ < $clock - $sets } keys %$store };
      delete $stuff->{'fulltext'} unless $debug;
depending on how long it takes innotop to fetch and render data.
# Depending on whether a key was read, do something.  Keys have certain
   # Depending on whether it's a SYNC_MUTEX,RW_LOCK_EX,RW_LOCK_SHARED,
depends on the mode you're in, and what servers you're monitoring.  The first
      # Derive and store the server's start time in hi-res
               $desc = $1;
            desc => 'Connect to host',
            desc => 'Database to use',
            desc => 'Default character set',
            desc   => $desc,
descending.  See L<"SORTING">.
            desc => 'Only read default options from the given file',
            desc => 'Password to use when connecting',
            desc => 'Port number to use for connection',
described in L<"EXPRESSIONS">.
 # description: Adds an 'example' column to every table
description: Foo", where "Foo" is the text innotop will consider to be the
            desc => 'Socket file to use for connection',
            desc => 'User for login if not current user',
         # Design a column format for the values.
    # Design the example column
Design your own expressions to extract and combine data as you need.  This gives
details.
determine this reliably itself).  innotop will find the minimum binlog in use by
      # Determine which sections need to be parsed
   # dialect should let me join a table to a grouped and pivoted table and do this more easily.
dialog is with the '^' key.
dialog.  Press another key to select the type of data you want to edit:
   dict_mem_alloc              => { hdr => 'Dict Mem',            num => 1, label => 'Dictionary memory allocated' },
            dict_mem_alloc pages_created buf_free complete )),
         dict_mem_alloc             => { src => 'IB_bp_dict_mem_alloc' },
didn't look at your connections in aggregate.  (This is a made-up example, but
   die "Can't call in non-interactive mode" if $opts{n};
   die("Can't get timestamp from $text\n") unless $y;
         die("Can't read terminal size") unless @this_term_size;
            die "Column '$col_name' is listed in '$place' for '$table_name', but doesn't exist";
   die "Could not parse this field: '$text'" unless defined $id;
            die "$cxn $stmt_name: $EVAL_ERROR";
   die "Duplicate option $spec->{k}" if $opt_seen{$spec->{k}}++;
      die "Error migrating '$old_filename': file doesn't exist.\n";
      die "Error migrating '$old_filename' to '$new_filename': new file already exists.\n";
            die $EVAL_ERROR;
         die $EVAL_ERROR;
            die "\$EVAL_ERROR in expression $quoted";
      die "I can't find a column named '$col_name' for '$table_name'" unless $columns{$col_name};
   die "I can't parse undef" unless defined $fulltext;
   die if $EVAL_ERROR;
         die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
         die "Mode '$mode' doesn't exist; try one of these:\n"
      die $msg;
      die "No func defined for '$key' in $tbl"
      die "No such config file section $section" unless $config_file_sections{$section};
   die '$sections must be a hashref' unless ref($sections) eq 'HASH';
      die "The following columns are not used: "
            die("Unable to fork for clearing deadlocks!\n");
            die "Undefined property $prop for column $col in table $tbl";
      die "Unknown aggregate function '$col_def->{agg}' "
         die "Unknown section $section in $fulltext\n"
         die "Unknown transformation '$trans' "
      die "Unrecognized DSN part '$key' in '$dsn'\n"
      die "You can't connect to a MySQL server while monitoring a file.  This is probably a bug.";
difference between this column and the built-in ones; it can have all the same
digits after the decimal point.
         $dir ||= '+';
directory.  On UNIX systems, you can place a symbolic link to the module instead
            $dir eq '+'
   dirty_bufs                  => { hdr => 'Dirty Buf',           num => 1, label => 'Dirty buffer pool pages' },
   DirtyBufs         => q{ $cur->{IB_bp_pages_modified} / ($cur->{IB_bp_buf_pool_size} || 1) },
         dirty_bufs                  => { src => $exprs{DirtyBufs},           trans => [qw(percent)] },
Disables fetching SHOW INNODB STATUS, in case your server(s) do not have InnoDB
   'discard_or_import_tablespace' => 1,
# Disconnects a database handle, but complains verbosely if there are any active
discussions are permanent and public.  Of course, if you need to contact us in
# display_B {{{3
# display_C {{{3
# display_D {{{3
# display_explain {{{3
# display_F {{{3
      # Display FK errors caused by invalid DML.
# Display functions {{{2
# display_help {{{3
# display_I {{{3
# display_L {{{3
# display_license {{{3
         @$display_lines);
         } @$display_lines[0..$max_lines - 1]);
                  $display_lines[$i] = [ $display_lines[$i], 'reverse' ];
               $display_lines[$i] = [ $display_lines[$i], 'reverse' ];
            @display_lines = stack_next(\@display_lines, \@this_table, { pad => '  ', vsep => 2 });
# display_M {{{3
# display_O {{{3
# display_Q {{{3
# display_R {{{3
# display_S {{{3
Displays current MySQL processes (threads/connections).  Data source:
Displays data about InnoDB's adaptive hash index.  Data source:
Displays data about InnoDB's buffer pool.  Data source: L<"STATUS_VARIABLES">.
Displays data about InnoDB's current transactions.  Data source:
Displays data about InnoDB's file and I/O operations.  Data source:
Displays data about InnoDB's insert buffer.  Data source: L<"STATUS_VARIABLES">.
Displays data about InnoDB's I/O threads.  Data source: L<"IO_THREADS">.
Displays data about InnoDB's logging system.  Data source: L<"STATUS_VARIABLES">.
Displays data about InnoDB's OS wait array.  Data source: L<"OS_WAIT_ARRAY">.
Displays data about InnoDB's row operations.  Data source:
Displays data about InnoDB's semaphores and mutexes.  Data source:
Displays data about the slave I/O thread.  Data source: 
Displays data about the slave SQL thread.  Data source: L<"STATUS_VARIABLES">.
Displays InnoDB locks.  Data source: L<"INNODB_LOCKS">.
Displays InnoDB page statistics.  Data source: L<"STATUS_VARIABLES">.
Displays InnoDB pending I/O operations.  Data source: L<"STATUS_VARIABLES">.
displays it.
Displays open tables.  Data source: L<"OPEN_TABLES">.
Displays replication master status.  Data source: L<"STATUS_VARIABLES">.
      display_sub       => \&display_B,
      display_sub       => \&display_C,
      display_sub       => \&display_D,
      display_sub       => \&display_F,
      display_sub       => \&display_I,
      display_sub     => \&display_L,
      display_sub       => \&display_M,
      display_sub       => \&display_O,
      display_sub       => \&display_Q,
      display_sub       => \&display_R,
      display_sub       => \&display_S,
      display_sub       => \&display_T,
Displays user-configurable data.  Data source: L<"STATUS_VARIABLES">.
Displays various data about InnoDB's last foreign key error.  Data source:
Displays various InnoDB status values.  Data source: L<"STATUS_VARIABLES">.
Displays various status values.  Data source: L<"STATUS_VARIABLES">.
Displays weighted status variables.  Data source: L<"STATUS_VARIABLES">.
# display_T {{{3
   display_table_captions => {
display.  The statements are customized depending on the server version against
distributed with your operating system or Perl distribution, not from CPAN.
   dl => \&parse_dl_section,
   @{ $dl }{ qw(rolled_back) }
      dl_table  => $dl_table,
   $dl->{'timestring'} = ts_to_string($dl->{'ts'});
   $dl->{'ts'} = [ parse_innodb_timestamp( $ts ) ];
   dl_txn_num                  => { hdr => 'Num',                 num => 0, label => 'Deadlocked transaction number', },
         dl_txn_num       => { src => 'dl_txn_num' },
         dl_txn_num         => { src => 'dl_txn_num' },
   $dl->{'txns'} = {};
      $dl->{'txns'}->{$txn_id} ||= {};
         do {
      do {
# Documentation {{{1
documentation at L<"http://search.cpan.org/dist/DBD-mysql/lib/DBD/mysql.pm"> for
does not prompt you if there is only one possible choice for any input).
   # does not use English.
doesn't map all that well to SQL, but pivoting complicates things pretty
      do_key_action();
# do_key_action {{{3
   # don't ask for a password if mysql_read_default_group=client is in the DSN
   # don't ask for a username if mysql_read_default_group=client is in the DSN
         # Don't auto-vivify $tbl_meta{tbl}-{cols}->{_color}->{trans}
      # Don't do this step if the user just created a new server group,
don't have errors.
   # don't migrate files if new file exists
   # don't proceed if old file doesn't exist
Don't read the central configuration file.
don't see any reason why it won't work on other UNIX-ish operating systems, but
   # don't show cxn if there's only one connection being displayed
# donut {{{3
      do_query($cxn, "drop table $tbl");
         do_query( $cxn, 'EXPLAIN EXTENDED ' . $query ) or die "Can't explain query";
            do_query($cxn, "use $db");
# Do some post-processing on %tbl_meta: compile src properties into func etc.
      do_stmt($info->{cxn}, $q_or_c eq 'QUERY' ? 'KILL_QUERY' : 'KILL_CONNECTION', $info->{id} );
            # Do the action specified
      # Do the action specified
         ("(?:(?!(?<!\\)").)*"  # Double-quoted string
            # Do what the user asked...
      draw_screen
# draw_screen {{{3
            draw_screen(\@display_lines);
         draw_screen(\@display_lines);
      draw_screen( \@display_lines );
      draw_screen(\@display_lines);
   draw_screen(\@display_lines);
            draw_screen(\@display_lines, { clear => 1 });
            draw_screen(\@display_lines, { raw => 1 });
   draw_screen(\@display_lines, { raw => 1 } );
   draw_screen(\@display_lines, { raw => 1 });
   draw_screen(\@display_lines, { show_all => 1 } );
            # Draw the screen and wait for a command.
         # Draw the screen and wait for a command.
Dr. Frank Ullrich,
            dsn  => 'charset',
            dsn  => 'database',
      $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
      $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
   $dsn->{D} ||= $db;
      dsn       => $dsn,
      $dsn->{dsn}, $dsn->{user}, $dsn->{pass},
      $dsn->{have_pass} = $answer && $answer =~ m/1|y/i;
      $dsn->{have_user} = $answer && $answer =~ m/1|y/i;
            dsn  => 'host',
   $dsn->{h} ||= $vars->{hostname}->{Value};
            dsn  => 'mysql_read_default_file',
            dsn  => 'mysql_socket',
      $dsn->{pass} = prompt_noecho("Enter password for '$dsn->{user}' on $connection");
            dsn  => 'password',
            dsn  => 'port',
         $dsn = prompt("Enter a DSN string", undef, "DBI:mysql:;mysql_read_default_group=mysql;host=$name");
   $dsn->{P} ||= $vars->{port}->{Value};
         $dsn->{savepass} = $answer && $answer =~ m/1|y/i;
   $dsn->{S} ||= $vars->{'socket'}->{Value};
      = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n"
            dsn  => 'user',
      $dsn->{user} = '';
      $dsn->{user} = prompt("Enter username for $connection", undef, $user);
   $dsn->{u} ||= $user;
# dulint_to_int {{{3
   dulint_to_int => \&dulint_to_int,
            = $dump
      Dumper($dbh->selectall_arrayref(
      Dumper($dbh->selectrow_hashref(
         = $dump =~ m/^(DATA TUPLE): $d fields;$/m;
         e => {
   e => {
Each built-in table is described below:
         # Each column gets non-existing values set from %columns or defaults from %col_props.
Each element of the data source becomes a row in the final table.
Each event is defined somewhere in the innotop source code.  When innotop runs
Each line is in the format col_name=properties, where the properties are a
Each line is in the format name=variable_list.  See L<"VARIABLE SETS">.
Each of innotop's modes retrieves and displays a particular type of data from
Each row in the display shows a single column in the table you're editing, along
      # Each section read from the config file has one extra property: which table it
Each table begins with a data source, which is an array of hashes.  See below
      # Each tbl_meta section has all the properties defined in %col_props.
Each time innotop extracts values to create a table (see L<"EXPRESSIONS"> and
      e => \&display_explain,
# edit_color_rules {{{3
         edit_color_rules($tbl);
# edit_configuration {{{3
# edit_configuration_variables {{{3
               "Editing color rules for $meta->{capt}.  Press ? for help, q to "
 Editing table definition for Buffer Pool.  Press ? for help, q to quit.
               "Editing table definition for $meta->{capt}.  Press ? for help, q to quit.", '';
editing the definition in the configuration file.
editor, color rule editor, and more.
editor from any mode.  Press the 'p' key to start the plugin editor.  You'll see
editor (see L<"TABLE EDITOR">).
edit other properties, such as the table's sort expression and group-by
# edit_server_groups {{{3
Edits SQL statement sleep delays, which make innotop pause for the specified
# edit_stmt_sleep_times {{{3
# edit_table {{{3
edit the file by hand.
effect the final result as you might expect, but as early as possible for
efficiency.
# element of the array is either a string or an arrayref.  If it's a string it
      # Eliminate innotop's own threads.
            else {
         else {
      else {
   else {
      else { # 'g' mode
# else in the program should read from.
         else { # OK, there wasn't an IP address.
   else { # The default is 'ascii'
   else { # 'v'
   elsif ( $charset && $charset eq 'none' ) {
   elsif ($conf_file and $opts{w}) {
   elsif ( !@$cxns ) {
         elsif ( !defined($pid) ) {
      elsif ( $dump =~ m/-byte offs / ) {
   elsif ( exists $vars{$clock - $offset} && !exists $vars->{$clock - $offset - 1} ) {
   elsif ( -f $default_central_conf and not $opts{s} ) {
   elsif ( -f $default_home_conf ) {
      elsif ( -f "$homepath/.innotop/innotop.ini" ) {
   elsif ( -f "$homepath/.innotop" or -f "$homepath/.innotop/innotop.ini" ) {
   elsif ( -f $new_filename ) {
            elsif ( $line =~ m/^# description: (.*)/ ) {
         elsif ( $lines_printed == 0 || $lines_printed > $this_term_size[1] - 2 ) {
         elsif ( !$opts{n} ) {
      elsif ( $prop_autokey ) {
         elsif ( ref( $val ) eq 'HASH' ) {
      elsif ( $thread_line =~ m/query id \d+ / ) {
elsif ( $windows ) {
enabled, and the plugins/ subdirectory.
enabled and you don't want innotop to try to fetch it.  This can also be useful
enabled, innotop will print the error text to STDOUT as well.  Error messages
enabled take longer than usual to execute SHOW GLOBAL STATUS.  If innotop calls
Enable non-interactive operation.  See L<"NON-INTERACTIVE OPERATION"> for more.
Enable or disable terminal coloring.  Corresponds to the L<"color"> config file
      END
   'end'                          => 1,
# end_of_package InnoDBParser
   # Ensure each column in visible and group_by exists in cols
      # Ensure transformations and aggregate functions are valid
         "Enter column name and filter text",
Enter; otherwise, you will need to change to innotop's directory and type "perl
      "Enter the name of the variable you wish to configure",
   'eq' => 'String equality',
      $err = $1;
      $err = $EVAL_ERROR;
Error handling is not that important when monitoring a single connection, but is
# ERROR-HANDLING SEMANTICS: if the statement throws an error, propagate, but if the
   Error       => \&parse_fk_bad_constraint_error,
error, the group's name is followed by the fraction of the connections that
   $err =~ s/\s+/ /g;
/etc/innotop/innotop.conf, and they are looked for in that order.  If the first
         eval {
      eval {
   eval {
      || $EVAL_ERROR !~ m/^Bareword/;
      $EVAL_ERROR =~ s/ at \(eval.*$//;
      $EVAL_ERROR =~ s/at \(eval.*$//;
            \$EVAL_ERROR =~ s/ at \\(eval.*//s;
      || eval "my \$x= sub { $word  }; 1"
   eval qq{
eval { setpriority(0, 0, getpriority(0, 0) + 10); };
   eval "\$sub = sub { my \$set = shift; $text }";
Events are defined at many places in this subroutine, which is responsible for
            event_set => $event_set ? 1 : 0,
   event_set                   => { hdr => 'Evt Set?',            num => 1, label => '[Win32] if a wait event is set', },
         event_set      => { src => 'event_set' },
event that's not defined, the event is ignored.
# eventually end up in tbl_meta.
even when there is an error; it just won't display any information from the
Every column in innotop is computed by subroutines compiled in the same fashion.
# everything is grouped as one group).
example.
# Example:
# Example: [ 'a', 'b' ]
# Example: foo => { src => 'bar' } means the foo column (look at
example, --noinc (or --no-inc) negates L<"--inc">.
example.  The following module adds a column to the beginning of every table and
   exec_master_log_pos         => { hdr => 'Exec Master Log Pos', num => 1, label => 'Exec Master Log Position' },
         exec_master_log_pos         => { src => 'exec_master_log_pos', hdr => 'Master Pos' },
# executed.
Execute innotop and press '!' to see this information at any time.
executes "SHOW ENGINE INNODB STATUS", while on earlier versions it executes
   'Execution of init_command'    => 1,
exist, innotop will prompt you for connection information and create the
exists, innotop will activate it.  See L<"PLUGINS"> for more information.
         && exists $modes{$mode} && exists $server_groups{$group};
         (exists($tbl_meta{$tbl}->{cols}->{$col})
         exit(0);
   exit(0);
   exit(1);
   explain => {
            . "explained; innotop tries to rewrite certain REPLACE and INSERT queries "
expression.  Press '?' to see the full list, of course.
# Expressions {{{3
Expressions are at the core of how innotop works, and are what enables you to
expressions.  This gives significantly more power than just naming the values to
      $expr =~ s/(?<!\{|\$)\b([A-Za-z]\w{2,})\b/is_func($1) ? $1 : "\$set->{$1}"/eg;
      $expr = "\$set->{$expr}";
         "$exprs{MaxTxnTime} as MaxTxnTime",
         "$exprs{NumTxns} as NumTxns",
         "$exprs{OldVersions} as OldVersions",
         $exp =~ s/as\s+(\w+)\s*//;
extend innotop as you wish.  Recall the table lifecycle explained in
# Extracts status values that can be gleaned from the DBD driver without doing a whole query.
      extract_values
# extract_values {{{3
         extract_values($innodb_status, $innodb_status, $innodb_status, 'fk_error'),
                  extract_values($res, $res, $res, 'explain')));
         f => {
   f => {
         F => {
   F => {
face is a :-), all is well; there is no truncation.  A :^| means the transaction
far left of the table, even if they're not supposed to be visible.  The rest of
# Feedback and improvements are gratefully received.
Feedback and improvements are welcome.
few words are always [RO] (if readonly is set to 1), the innotop mode, such as
# Fibonacci series to prevent too much banging on the server.
      # Figure out how wide the table will be
   # Figure out the result order (not lexical order) of master logs.
   # Figure out whether the data is all numeric and decide on a sort type.
   # Figure out which master to purge ons.
file and determine the package name and description.
'file'.  And since it can't connect to a server, it can't determine how long the
               $file_data = '';
                  $file_data .= $buffer;
            $file_data =~ s/\A.*(?=^=====================================\n...... ........ INNODB MONITOR OUTPUT)//ms;
file.  Fractional-second sleeps are supported, subject to your hardware's
   "FILE I/O"                              => "io",
   file_io_misc => {
file I/O miscellaneous, and log statistics.  It displays the L<"io_threads">,
      file_io_misc   => \@file_io_misc,
               $file_mtime = $stat[9];
            file   => $p_file,
files are still useful, though.
file.  This keeps the file size down, makes it easier to edit, and makes
file to monitor for InnoDB status output; see L<"MONITORING A FILE"> for more
file was loaded at start-up.
   # Fill in default values for things that couldn't be parsed.
   # Fill in final props from given, previous, and/or default props
   # Fill in things that might not be present
# Fills in missing info from a DSN after successfully connecting to the server.
fill the columns, because it allows the column's value to be calculated from
filter, and when prompted for the subroutine body, press TAB to initiate your
   # filtered, etc as a side effect of set_to_tbl(), so they are the same as the rows
filtered to show tables which are in use by one or more queries, so you can
filter.  Filters are easy to create if you know Perl, and not hard if you don't.
         $filter = prompt("Enter filter name");
      filters => [ ],
      filters => [],
      filters   => [],
   filters => {
# Filters {{{3
filters, color rules, a sort-column list, sort direction, and some information
   $filters{$filter} = {
   filters       => \%filters,
      $filters{$key} = {
   $filters{$key} = {
      $filters{$name} = {
filter, sort, group, color, transform, create.  This slightly convoluted process
      filters => [ qw() ],
      filters   => [qw()],
      filters => [ qw(cxn_is_master) ],
      filters => [ qw( cxn_is_slave ) ],
      filters => [ qw( hide_self hide_inactive ) ],
      filters => [ qw(hide_self hide_inactive hide_slave_io) ],
      filters => [ qw(table_is_open) ],
Filters remove rows from the display.  They behave much like a WHERE clause in
filters you want to apply and press Enter.
filter that is otherwise like any other filter.  It just isn't saved to the
Filter which rows display with built-in filters, user-defined filters, and
      # Finally!  Enough validation...
         $final_props{$key} = $defaults->{$key};
      $final_props{$key} = $given_props{$key};
         $final_props{$key} = $prev->{$key};
      # Find each column's max width.
   # Find out how wide the LHS can be and still let the RHS fit next to it.
   # Find out which server.
   # Find out which thread to do.
      # Find the current group's position.
# Find the home directory; it's different on different OSes.
      # Find the info hash of that query on that server.
      # Find the max width of the section of the LHS against which the RHS
   # Find the minimum binary log in use.
   # Find the minimum row on the LHS that the RHS will fit next to.
         finish();
finish();
# finish {{{3
# First arg is a func that can be called in grep.
   # First, find a list of all plugins that exist on disk, and get information about them.
   first => sub {
first table on the screen.  You can disable this behavior with the
'first'.  This is basically a convenience so you don't have to specify an
      # Fix undef values
      # Fix undef values, collapse whitespace.
   fk_error => {
   fk_name                     => { hdr => 'Constraint',          num => 0, label => 'The name of the FK constraint' },
   # FK name, parent info... if possible.
         fk_name      => { src => 'IB_fk_fk_name' },
   fk => \&parse_fk_section,
      $fk_parser_for{$type}->( $section, $complete, $debug, $fulltext, $full );
   # Flatten the hierarchical structure into a single list by grabbing desired
   # flexible requires giving the user enough rope to hang themselves with.
      $fmt_cols = \@cols;
      $fmt_cols = [ grep { $aggregated || !$meta->{cols}->{$_}->{aggonly} } @visible ];
         $fmt_cols = [ @{$meta->{group_by}}, grep { !$is_group{$_} } @$fmt_cols ];
      $fmt eq 'd' ? sprintf(
      : $fmt eq 'h' ? sprintf(
      $fmt_meta = { map { $_ => { hdr => $_, just => '-' } } @cols };
      $fmt_meta = { map  { $_ => $meta->{cols}->{$_}                      } @$fmt_cols };
   $fmt ||= $secs >= 86_400 ? 'd'
         (?=                                    # Followed by any of...
         (.*?)             # Followed by anything, non-greedy
following list:
following statement also affects the output of SHOW INNODB STATUS, which innotop
 foo  1    2
 foo bar
'?' for a list of key mappings.  The rest is a tabular representation of the
            . "for column '$col_name' in table '$table_name'"
         . "for column '$col_name' in table '$table_name'"
for details on data sources.
For each element in the data source, innotop extracts values from the source and
      foreach my $child ( 0..1 ) {
      foreach my $child ( keys %children ) {
   foreach my $class ( sort keys %plugins ) {
      foreach my $col ( @$cols ) {
      foreach my $col ( keys %{$rows->[0]} ) {
      foreach my $col ( keys %{$tbl_meta{$tbl}->{cols}} ) {
   foreach my $col_name ( keys %$cols ) {
      foreach my $col_name ( keys %{$table->{cols}} ) {
      foreach my $col_name ( @{$table->{$place}} ) {
      foreach my $col ( @non_grp ) {
      foreach my $col ( split(/\s+/, $tbl->{sort_cols} ) ) {
foreach my $col ( values %columns ) {
         foreach my $col ( @$visible ) {
   foreach my $conn ( sort keys %connections ) {
      foreach my $cxn ( @$cxns ) {
      foreach my $cxn ( @cxns ) {
   foreach my $cxn ( @$cxns ) {
   foreach my $cxn ( @cxns ) {
   foreach my $cxn ( get_connections() ) {
   foreach my $dsn_part ( split(/,/, $dsn) ) {
         foreach my $event ( $obj->register_for_events() ) {
   foreach my $exp ( @exps ) {
      foreach my $filter ( @{$meta->{filters}} ) {
   foreach my $group ( keys %server_groups ) {
   foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
            foreach my $i ( 0..@$data - 1  ) {
      foreach my $i ( 0..@$rows-1 ) {
         foreach my $item ( @$data ) {
         foreach my $j ( 0..@vars-1 ) {
foreach my $key ( keys %builtin_filters ) {
   foreach my $key ( keys %$cols ) {
   foreach my $key ( keys %given_props ) {
   foreach my $key ( keys %{$modes{$mode}->{action_for}} ) {
   foreach my $key ( keys %opts ) {
      foreach my $key ( keys %$required ) {
      foreach my $key ( keys %$set ) {
   foreach my $key ( sort keys %config ) {
            foreach my $key ( sort keys %$cur_threads ) {
   foreach my $key ( sort keys %filters ) {
   foreach my $key ( sort keys %mvs ) {
   foreach my $key ( sort keys %opts ) {
   foreach my $key ( sort keys %stmt_sleep_time_for ) {
   foreach my $key ( sort keys %temp_table ) {
   foreach my $listener ( @{$event_listener_for{draw_screen}} ) {
   foreach my $listener ( @{$event_listener_for{extract_values}} ) {
   foreach my $listener ( @{$event_listener_for{set_to_tbl_post_create}} ) {
   foreach my $listener ( @{$event_listener_for{set_to_tbl_pre_colorize}} ) {
   foreach my $listener ( @{$event_listener_for{set_to_tbl_pre_create}} ) {
      foreach my $listener ( @{$event_listener_for{set_to_tbl_pre_filter}} ) {
   foreach my $listener ( @{$event_listener_for{set_to_tbl_pre_group}} ) {
      foreach my $listener ( @{$event_listener_for{set_to_tbl_pre_pivot}} ) {
      foreach my $listener ( @{$event_listener_for{set_to_tbl_pre_sort}} ) {
   foreach my $listener ( @{$event_listener_for{set_to_tbl_pre_transform}} ) {
   foreach my $lock ( $text =~ m/(^(?:RECORD|TABLE) LOCKS?.*$)/gm ) {
                  foreach my $lock ( @{$txn->{locks}} ) {
            foreach my $lock ( @{$txn->{locks}} ) {
   foreach my $mode ( sort keys %modes ) {
foreach my $name (keys %cmdline) {
   foreach my $new ( grep { !exists($filters{$_}) } @choices ) {
   foreach my $new ( @new ) {
   foreach my $opt ( @opts ) {
   foreach my $p_file ( <$dir/*.pm> ) {
   foreach my $place ( qw(visible group_by) ) {
      foreach my $prop ( keys %col_props ) {
      foreach my $prop ( keys %parts ) {
            foreach my $result ( @$res ) {
         foreach my $row ( 0.. $#rows ) {
               foreach my $row ( @$data ) {
      foreach my $row ( @$data ) {
            foreach my $row ( @{$meta->{visible}} ) {
            foreach my $row ( @rows ) {
    foreach my $row ( @$rows ) {
   foreach my $row ( @rows ) {
         foreach my $row ( @var_status ) {
      foreach my $rule ( @{$meta->{colors}} ) {
      foreach my $sec ( @$addl_sections ) {
      foreach my $section ( keys %innodb_sections ) {
      foreach my $section ( keys %parser_for ) {
   foreach my $section ( @ordered_config_file_sections ) {
   foreach my $set ( 0 .. $num_sets ) {
   foreach my $set ( sort keys %server_groups ) {
foreach my $spec ( @opt_spec ) {
   foreach my $spec ( sort { $a->{l} cmp $b->{l} } @opt_spec ) {
   foreach my $spec ( @{$tbl->{colors}} ) {
      foreach my $stmt (@stmts[0..2]) {
      foreach my $store ( values %vars ) {
foreach my $table_name ( keys %tbl_meta ) {
   foreach my $table ( values %tbl_meta ) {
   foreach my $tbl ( keys %rule_set_for ) {
   foreach my $tbl ( sort keys %tbl_meta ) {
    foreach my $tbl ( values %$tbl_meta ) {
      foreach my $tbl ( @visible ) {
   foreach my $tbl ( @visible ) {
         foreach my $thd_id ( sort keys %cur_txns ) {
   foreach my $thread (@threads) {
      foreach my $trans ( @{$col_def->{trans}} ) {
         foreach my $trans ( @{$cols->{$col}->{trans}} ) {
         foreach my $txn ( @$cur_txns ) {
            foreach my $txn_id ( keys %{$innodb_status->{IB_dl_txns}} ) {
   foreach my $txn ( @transactions ) {
      foreach my $value ( @values ) {
   foreach my $varset ( sort keys %var_sets ) {
         foreach my $wait ( @{$set->{IB_sm_waits}} ) {
   foreach ( qw(history_list_len) ) {
foreign key errors, open tables, replication status, buffer information,
      # For example, a connection might be used in Q mode but idle in T mode.
For example, imagine you want to filter the processlist table so you only see
for example in the first rule above, you should enter 'Locked' surrounded by
               . "for internal reference.  It can contain only lowercase letters, numbers, "
            . "for internal reference.  It can only contain lowercase letters, numbers, and underscores.");
      # Fork off two children to deadlock against each other.
for later use.  The variables are defined in the innotop variable
format filter_name=text='filter text' tbls='table list'.
format mode_name=table_list.  See L<"TABLES">.
Formats a number as a unit of 1024 (k/M/G/T) and with L<"num_digits"> number of
Formats a number of seconds as time in days+hours:minutes:seconds format.
      # Format server uptime human-readably, calculate QPS...
Formats numbers with L<"num_digits"> number of digits after the decimal point.
         $format      =~ s/\s$/\n/;
format table_name=filter_list.
format the results.  In particular, L<"set_precision"> is often useful to limit
      # Format the table
format.  This mode is the reason I wrote innotop.
# Formatting functions {{{2
            for my $i ( 0 .. $#display_lines ) {
         for my $i ( 0 .. $#display_lines ) {
   # For now, I'm manually pulling these variables out and pivoting.  Eventually a SQL-ish
(For some reason, the ANSI color code "white" is actually a light gray.  Your
for that variable.  This is a global setting, but will probably become
for you, but you can actually edit the command and send anything you wish, such
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
   free_list_len               => { hdr => 'Free List Len',       num => 1, label => 'Length of the free list' },
         free_list_len => { src => 'IB_ib_free_list_len' },
# from %columns.  After all the config is loaded for columns, there's more
# From perlfaq5: add commas.
from them all.  Just separate the connection names with spaces, for example
            . "from your mysql options files (~/.my.cnf, /etc/my.cnf).\n\n";
      f => \&show_full_query,
                  $full )
      = $fulltext
         = $fulltext
   'FULLTEXT initialization'      => 1,
            ->{'fulltext'} = $innodb_sections{$section}->[0];
      = $fulltext =~ m{Buffer pool hit rate $d / $d$}m;
         = $fulltext =~ m{Buffer pool hit rate (\d+ / \d+)$}m;
      = $fulltext =~ m/^$d inserts, $d merged recs, $d merges$/m;
      = $fulltext =~ m#$d log i/o's done, $f log i/o's/second#;
      = $fulltext =~ m/^$d OS file reads, $d OS file writes, $d OS fsyncs$/m;
      = $fulltext =~ m/$d pending log writes, $d pending chkp writes/;
      = $fulltext =~ m/$d pending preads, $d pending pwrites$/m;
      = $fulltext =~ m/^$d queries inside InnoDB, $d queries in queue$/m;
      = $fulltext =~ m/^$d read views open inside InnoDB$/m;
      = $fulltext =~ m/^$d tablespace extents now reserved for B-tree/m;
      = $fulltext =~ m{^$f hash searches/s, $f non-hash searches/s$}m;
      = $fulltext =~ m#^$f inserts/s, $f updates/s, $f deletes/s, $f reads/s$#m;
      = $fulltext =~ m{^(Foreign key constraint fails for table `(.*)/(.*)`:)$}m;
      = $fulltext =~ m{^$f reads/s, $d avg bytes/read, $f writes/s, $f fsyncs/s$}m;
      = $fulltext =~ m{^$f reads/s, $f creates/s, $f writes/s$}m;
      = $fulltext =~ m/^Hash table size $d, used cells $d, node heap has $d buffer\(s\)$/m;
      = $fulltext =~ m/^History list length $d$/m;
      = $fulltext =~ m{^ ibuf aio reads: $d, log i/o's: $d, sync i/o's: $d$}m;
      = $fulltext =~ m/^Ibuf(?: for space 0)?: size $d, free list len $d, seg size $d,$/m;
      = $fulltext =~ m/Last checkpoint at \s*(\d.*)$/m;
      = $fulltext =~ m/Log flushed up to \s*(\d.*)$/m;
      = $fulltext =~ m/Log sequence number \s*(\d.*)$/m;
      = $fulltext =~ m/^Main thread (?:process no. $d, )?id $d, state: (.*)$/m;
      = $fulltext =~ m/^Mutex spin waits $d, rounds $d, OS waits $d$/m;
      = $fulltext =~ m/^Number of rows inserted $d, updated $d, deleted $d, read $d$/m;
      = $fulltext =~ m/^OS WAIT ARRAY INFO: reservation count $d, signal count $d$/m;
      = $fulltext =~ m/^Pages read $d, created $d, written $d$/m;
      = $fulltext =~ m/^Pending flushes \($w\) log: $d; buffer pool: $d$/m;
      = $fulltext =~ m/^Pending normal aio reads: $d, aio writes: $d,$/m;
      = $fulltext =~ m/^Pending writes: LRU $d, flush list $d, single page $d$/m;
      = $fulltext =~ m/^Purge done for trx's n:o < $t undo n:o < $t$/m;
      = $fulltext =~ m/^RW-shared spins $d, OS waits $d; RW-excl spins $d, OS waits $d$/m;
      = $fulltext =~ m/^Total memory allocated $d; in additional pool allocated $d$/m;
      = $fulltext =~ m/^Total number of lock structs in row lock hash table $d$/m;
      = $fulltext =~ m/^\.\.\. truncated\.\.\.$/m ? 1 : 0;
      = $fulltext =~ m/^Trx id counter $t$/m;
         = $fulltext =~ m/^Trying to (add to index) `$n` tuple:\n(.*))?/sm;
         = $fulltext =~ m/^Trying to ([\w ]*) in (child|parent) table, in index `$n` tuple:$/m;
      = $fulltext =~ m/^\*\*\* WE ROLL BACK TRANSACTION \($d\)$/m;
   $fulltext =~ s/[\r\n]+/\n/g;
      func => \&choose_mode_tables,
      func => \&edit_color_rules,
      func => \&edit_configuration_variables,
      func => \&edit_plugins,
      func => \&edit_server_groups,
      func => \&edit_stmt_sleep_times,
      func => \&edit_table,
      = $func eq 'v'
         func => $func,
            func  => $sub,
         func => $sub,
         func  => $sub,
      func => $sub,
      func => sub {
#  * func:   the subroutine
functions.
         g => {
   g => {
      # garbage in the version number.
   general => {
   'ge' => 'String greater-than/equal',
# Get a list of connection names used in this mode.
# Get a list of tables used in this mode.  If innotop is running non-interactively, just use the first.
get a quick look at which tables are 'hot'.  You can use this to guess which
# get_config_interactive {{{3
      get_config_interactive($key);
      get_driver_status(@cxns);
# get_full_processlist {{{3
   # Get globally mapped keys, then overwrite them with mode-specific ones.
   # Get info on locks
# get_innodb_status {{{3
   get_innodb_status([$cxn]);
   get_innodb_status(\@cxns);
   get_innodb_status( \@cxns, [ $wanted{t_header} ? qw(bp) : () ] );
# get_master_slave_status {{{3
   get_master_slave_status(@cxns);
# get_open_tables {{{3
GetOptions( map { $_->{s} => \$opts{$_->{k}} } @opt_spec) or $opts{help} = 1;
Getopt::Long::Configure('no_ignore_case', 'bundling');
# Gets a list of sort columns from the table, like "+cxn -time" and returns a
# Get SHOW STATUS and SHOW VARIABLES together.
# get_status_info {{{3
      get_status_info(@cxns);
   get_status_info(@cxns);
   # Get the data
   # Get the most basic info about the status: beginning and end, and whether
         get_visible_tables();
Giuseppe Maxia,
given by the L<"cmd_filter"> configuration variable.  The variables are then
# given DB connection.  Returns a $sth.
         $given_props{$prop_autokey} = $dsn_part;
         $given_props{$prop_key} = $prop_val;
given status on each server you're monitoring.  The time columns are aggregated
   global => {
# Global key mappings {{{3
# Global variables and environment {{{2
      }gmsx;
      # goes in.
Google Code,
Google.com Site Reliability Engineers,
      got_all   => 0,         # Whether I was able to get the whole thing
   'got handler lock'             => 1,
   'got old table'                => 1,
   # Grab the info
   # Grab the I/O thread info
   # Grab the reads/writes/flushes info
   graph_char => {
graphed; if s, values are like vmstat; if p, values are in a pivoted table.
# Graph widths {{{3
        grep {
            grep { $dbhs{$_} } @cxns);
      grep { $dbhs{$_} && $dbhs{$_}->{err_count} && $dbhs{$_}->{mode} eq $config{mode}->{val} }
      grep { defined $dsn->{$_} && $self->{opts}->{$_} }
                     grep { defined $info->{$_} }
   #      grep { !defined $_ || $_ !~ m/^\d+$/ }
   grep { exists $_->{c} && exists $opts{$_->{k}} }
      grep { $_ && ($_->{file} || $_->{master_host}) }
      = grep { $grep_cond ? $grep_cond->($_) : 1 }
         grep { grep { $tbl eq $_ } @{$filters{$_}->{tbls}} }
              || grep { $mode eq $_ } @{$config{$key}->{conf}} )
            grep { $_ ne 'func' }
         grep { !$opts{n} || $_ } # Suppress empty lines
         grep { $_ && $tbl_meta{$_}->{innodb} }
         $group,
         = @$group_by
      group_by => [],
   group_by => {
   group_by);
      'Group-by columns',
      group_by => [qw(cxn cmd)],
      group_by => [ qw(cxn txn_status) ],
      group_by  => [qw(name)],
grouping isn't enabled, but you do when it is.
grouping so you can monitor variables and status across many servers.  The
group, pressing TAB selects the first group.
grow very large, and there is a limit on the size of the SHOW INNODB
   'gt' => 'String greater-than',
         h => {
         # Handle barewords
            handle_cxn_error($cxn, $EVAL_ERROR);
   handler => {
         Handler_read_prev Handler_read_rnd Handler_read_rnd_next Handler_delete
         Handler_update Handler_write)
   # Handle the general info
   # Handle the individual transactions
         # Handle the typical DSN parts like h=host, P=3306, etc.
      # Handle whatever action the key indicates.
has a huge set of default configuration values that it holds only in memory,
      \%hash;
               @hash{ @cols } = @{$meta->{cols}->{$row}}{@cols};
                     $hash->{cxn}             = $cxn;
                  $hash->{cxn}        = $cxn;
               $hash->{cxn} = $cxn;
               $hash{cxn} = $cxn;
            $hash->{cxn} = $cxn;
         $hash->{cxn} = $cxn;
                     $hash->{dl_txn_num}      = $txn_id;
                  $hash->{dl_txn_num} = $txn_id;
      $hash->{'insert_intention'}
         @{$hash}{ keys %innodb_status } = values %innodb_status;
                     $hash->{mysql_thread_id} = $txn->{tx}->{mysql_thread_id};
               $hash{name} = $row;
      @hash{ qw(cxn id db query secs) } = @{$_}{ qw(cxn mysql_thread_id db info secs) };
      @hash{ qw(cxn id db query secs) } = @{$_}{ qw(cxn mysql_thread_id db query_text active_secs) };
      @{$hash}{ qw(lock_type space_id page_no n_bits index db table txn_id lock_mode) }
# hashrefs of {key, desc, copy, dsn}.  The desc and dsn items are optional.
               $hash{''}   = $row eq $selected_column ? '>' : ' ';
   hash_searches_s             => { hdr => 'Hash/Sec',            num => 1, label => 'Number of hash searches/sec' },
         hash_searches_s     => { src => 'IB_ib_hash_searches_s' },
      ( $hash->{'special'} )
               $hash{src}  = '' if ref $hash{src};
   hash_table_size             => { hdr => 'Size',                num => 1, label => 'Number of non-hash searches/sec' },
         hash_table_size     => { src => 'IB_ib_hash_table_size', trans => [qw(shorten)], },
                  $hash->{timestring} = $innodb_status->{IB_dl_timestring};
                  $hash->{truncates}  = $innodb_status->{IB_dl_complete} ? 'No' : 'Yes';
         $hash->{Uptime_hires} ||= get_uptime($cxn);
                  $hash->{victim}     = $txn_id == $victim ? 'Yes' : 'No';
      $hash->{'waiting'}
            $hash->{when} = 'Now';
         $hash->{when} = 'Total';
      has_read_view      => $has_read_view,
   has_read_view               => { hdr => 'Rd View',             num => 1, label => 'Whether the transaction has a read view' },
         has_read_view      => { src => 'has_read_view' },
      $have_color = 1;
have noticed that certain MySQL versions under very high load with InnoDB
      have_pass => $have_pass,
# have that library, or it might not support that feature.
      have_user => $have_user,
   hdr     => '',
hdr: a column header.  This appears in the first row of the table.
         hdr  => $colname,
#    * hdr    Column header/title
      hdr               => 'Command Summary',
       hdr   => 'Example',
            hdr   => $hdr,
      hdr               => 'InnoDB Buffers',
      hdr               => 'InnoDB Deadlocks',
      hdr               => 'InnoDB FK Err',
      hdr               => 'InnoDB I/O Info',
      hdr               => 'InnoDB Row Ops',
      hdr        => 'InnoDB Txns',
      hdr             => 'Locks',
            @hdr = map { donut(crunch($_, $width), $width) } @hdr;
      hdr               => 'Open Tables',
            $hdr = prompt("Enter column header");
      hdr        => 'Query List',
      hdr               => 'Replication Status',
      hdr               => 'Variables & Status',
=head1 ACKNOWLEDGEMENTS
=head1 AUTHOR
=head1 BUGS
=head1 CONFIGURATION FILE
=head1 CONFIGURING
=head1 COPYRIGHT, LICENSE AND WARRANTY
=head1 CUSTOMIZING
=head1 DATA SOURCES
=head1 DESCRIPTION
=head1 ERROR HANDLING
=head1 FILES
=head1 GLOSSARY OF TERMS
=head1 HOTKEYS
=head1 INNOTOP STATUS
=head1 MODES
=head1 MYSQL PRIVILEGES
=head1 NAME
=head1 NON-INTERACTIVE OPERATION
=head1 OPTIONS
=head1 PLUGINS
=head1 QUICK-START
=head1 SERVER ADMINISTRATION
=head1 SERVER CONNECTIONS
=head1 SERVER GROUPS
=head1 SQL STATEMENTS
=head1 SWITCHING BETWEEN CONNECTIONS
=head1 SYNOPSIS
=head1 SYSTEM REQUIREMENTS
=head1 VARIABLE SETS
=head2 COLORS
=head2 COLUMNS
=head2 EXPRESSIONS
=head2 FILTERS
=head2 GROUPING
=head2 MONITORING A FILE
=head2 MULTIPLE SERVERS
=head2 ONE SERVER
=head2 Package Source Convention
=head2 PIVOTING
=head2 Plugin Editor
=head2 Plugin Events
=head2 Plugin Interface
=head2 Plugin Variables
=head2 Simple Plugin Example
=head2 SORTING
=head2 TABLE EDITOR
=head2 TABLES
=head2 TRANSFORMATIONS
=head3 QUICK-FILTERS
=head3 USER-DEFINED FILTERS
   header_highlight => {
Headers may be abbreviated to fit on the screen in interactive operation.  You
   heap_no                     => { hdr => 'Heap',                num => 1, label => 'Heap number' },
         heap_no          => { src => 'heap_no' },
   heap_size                   => { hdr => 'Heap',                num => 1, label => 'Heap size' },
      heap_size          => $heap_size,
         heap_size          => { src => 'heap_size' },
Here are the kinds of data sources from which data is extracted:
Here's a concrete example, taken from the header table L<"q_header"> in L<"Q:
Here's an example of grouping at work.  Suppose you have a very busy server with
Here's an example: suppose you want to track how many times your slaves have
      'hex' => defined($hex) ? $hex : '',
      hide_caption => 1,
      hide_caption  => 1,
hide_caption property, which overrides this.
   hide_hdr => {
   hide_inactive => {
Hides column headers globally.
   hide_self => {
   hide_slave_io => {
Highlight rows with color.
            # Highlight selected entry
         # Highlight selected entry
      $hints );
      $hints = { map { $_ => $meta->{cols}->{$_}->{label} } keys %{$meta->{cols}} };
      $hints = { name => 'name', set_0 => 'set_0' };
   history_list_len            => { hdr => 'History',             num => 1, label => 'History list length' },
         history_list_len            => { src => 'IB_tx_history_list_len' },
holds the locks something else is waiting for.  You can also enable and disable
$HOMEDIR/.innotop and/or /etc/innotop are used to store
      # Hook in event listeners
   # Hook in event listeners
Hopefully no one has been forgotten.
   host_and_domain             => { hdr => 'Host',                num => 0, label => 'Hostname/IP and domain' },
         host_and_domain    => { src => 'hostname' },
   host_and_port               => { hdr => 'Host/IP',             num => 0, label => 'Hostname or IP address, and port number', },
         host_and_port   => { src => 'host',       minw => 0,  maxw => 0 },
   hostname                    => { hdr => 'Host',                num => 0, label => 'Hostname' },
      hostname           => $hostname,
         ( $hostname, $ip ) = $thread_line =~ m/query id \d+(?: ([A-Za-z]\S+))? $i/m;
         hostname           => { src => $exprs{Host} },
         hostname        => { src => $exprs{Host}, minw => 13, maxw => 8, },
               ( $hostname, $user, $query_status ) = $thread_line
   Host              => q{my $host = host || hostname || ''; ($host) = $host =~ m/^((?:[\d.]+(?=:))|(?:[a-zA-Z]\w+))/; return $host || ''},
Host to connect to.
host, use the -h option.
How many digits to show in fractional numbers and percents.  This variable's
      @{$href}{qw(dbh err_count wake_up this_sleep start_time prev_sleep)}
      $href->{start_time} = time() - $uptime;
hundreds of open connections, and you want to see how many connections are in
         $i++;
         i => {
      $i--;
   $i++;
   I => {
         # I already exited if I'm a child, so I'm the parent.
               $ibinfo .= ':^|';
               $ibinfo .= ':-)';
            $ibinfo .= ':-(';
            $ibinfo,
         $ibinfo .= "InnoDB $vars->{IB_last_secs}s ";
   ib => \&parse_ib_section,
I can no longer find or reproduce the situation where GLOBAL wasn't allowed, but
      id    => $id,
      ( $id, $len, $hex, $asc, $truncated )
 # I'd like to be called when a data set is being rendered into a table, please.
   ( $id, $nullsize ) = $text =~ m/^$d: SQL NULL, size $d $/;
# I don't care much about these.  There are lots of different messages, and
I don't know for sure.  It also runs on Windows under ActivePerl without
      ( $id ) = $text =~ m/^$d: SQL NULL$/;
      $_->{id} != $thread_for{$_->{cxn}} && $grep_cond->($_)
            $idx++;
   if ( 1 == @cxns ) {
   if ( 1 == @cxns && $dbhs{$cxns[0]} && $dbhs{$cxns[0]}->{dbh} ) {
   if ( @_ > 2 ) {
      if ( $aggregated ) {
   if ( $all ) {
         if ( $all_cols{$choice} ) {
               if ( $answer eq 'trans' ) {
         if ( $answer eq 'y' ) {
      if ( $answer eq 'y' ) {
            if ( $answer && grep { $_ eq $answer } @prop ) {
   if ( @ARGV ) {
   if ( @available ) {
   if ( @candidates > 1 ) {
         if ( $cap_len > $width ) {
      if ( $cap_len <= $width - 6 ) {
                  if ( $cfg_ver ge $start && $cfg_ver lt $end && $innotop_ver ge $end ) {
            if ( $cfg_ver gt $innotop_ver ) {
   if ( $charset && $charset eq 'unicode' ) {
            if ( $charset eq 'utf8' ) {
   if ( @choices ) {
      if ( $choices[0] =~ s/^#// && exists $server_groups{$choices[0]} ) {
         if ( !$col_def->{$prop} ) {
   if ( @$cols && %$data ) {
   if ( @$cols && %$info ) {
      if ( $completion ) {
         if ( $config{color}->{val} ) {
         if ( $config{color}->{val} && $config{header_highlight}->{val} ) {
            if ( $config{color}->{val} && $item->{_color} ) {
   if ($config{debugfile}->{val} && $config{debug}->{val}) {
         if ( $config{debug}->{val} ) {
      if ( $config{debug}->{val} ) {
         if ( $config{debug}->{val} && $EVAL_ERROR ) {
      if ( $config{debug}->{val} && $EVAL_ERROR ) {
            if ( $config{debug}->{val} || !$first_table++ );
         if ( $config{debug}->{val} || !$first_table++ );
      if ( !$config{hide_hdr}->{val} && !$prefs->{no_hdr} ) {
         if ( !$config{$name}->{pat} || $val =~ m/$config{$name}->{pat}/ ) {
   if ( $config{show_cxn_errors}->{val} ) {
   if ( !$config{skip_innodb}->{val} && !$info_gotten{innodb_status}++ ) {
      if ( !%connections ) {
      if (!%connections) {
   if ( $curr ) {
   if ( $curr ne $val ) {
   if ( !@cxns ) {
   if ( @cxns == 1 ) {
   if ( $cxn_string =~ m/mysql/i && $setvars ) {
         if ( $db ) {
      if ( !$dbh && $EVAL_ERROR ) {
   if ( ! -d $dirname ) {
   if ( ! -d "$dirname/plugins" ) {
   if ( $debug ) {
   if ( defined $char ) {
   if ( !defined $dsn->{have_pass} and $dsn->{dsn} !~ /mysql_read_default_group=client/ ) {
   if ( !defined $dsn->{have_user} and $dsn->{dsn} !~ /mysql_read_default_group=client/ ) {
      if ( !defined($dsn->{savepass}) ) {
   if ( !defined $dsn->{user} ) {
      if (   !defined $final_props{$key}
      if ( !defined $final_props{$key} ) {
   if ( !defined($id) ) {
         if ( defined $innodb_data{'sections'}->{$section}
         if ( defined $ip ) {
      if ( defined(my $line = <$file>) && $VERSION =~ m/\d/ ) {
   if ( defined $name ) {
         if ( !defined($parts{$prop}) ) {
         if ( defined($pid) && $pid == 0 ) { # I am a child
      if ( defined($query_status) ) {
   if ( !defined($section->{'fk_name'}) ) {
      if ( defined $tid ) {
   # if directories don't exist, create them.  This could cause errors
   if (dirname($old_filename) eq dirname($new_filename)) {
               if ( $display_lines[$i] =~ m/^>/ ) {
            if ( $display_lines[$i] =~ m/^>/ ) {
   if ( !$dl_table ) {
   if ( $driver eq 'Pg' ) {
   if ( !$dsn ) {
   if ( !$dsn->{pass} && !$dsn->{savepass} && $dsn->{have_pass} ) {
   if ( !$dsn->{user} && $dsn->{have_user} ) {
            if ( $dump !~ m/-byte offs TRUE/ ) {
   if ( $dump =~ m/PHYSICAL RECORD/ ) {
            if ( $err ) {
      if ( $err ) {
         if ( $err_count ) {
   if ( $err =~ m/failed: (.*?) at \S*innotop line/ ) {
         if ( $EVAL_ERROR ) {
      if ( $EVAL_ERROR ) {
   if ( $EVAL_ERROR ) {
if ( $EVAL_ERROR ) {
         if ( $EVAL_ERROR && $config{debug}->{val} ) {
         if ( \$EVAL_ERROR && \$config{debug}->{val} ) {
      if ( $EVAL_ERROR !~ m/Deadlock found/ ) {
         if ( $EVAL_ERROR =~ m/$nonfatal_errs/ ) {
         if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
if ( $EVAL_ERROR || $opts{n} ) {
      if ( $EVAL_ERROR ) { print "$EVAL_ERROR in $key"; };
         if ( !exists $cols->{$col_name} ) {
   if ( exists($config_choices{$key}) ) {
         if ( exists $config_file_sections{$1} ) {
   if ( exists($config{$name}) and (!$config{$name}->{pat} or $val =~ m/$config{$name}->{pat}/ )) {
   if ( exists $curr{$new} ) {
         if ( !exists $dbhs{$cxn}->{stmts}->{$stmt_name} ) {
      if ( !exists $server_groups{$new} ) {
         if ( exists $vars{$cxn}->{$clock - 1} ) {
   if ( !exists $var_sets{$new_value} ) {
      if ( exists $vars->{IB_last_secs} ) {
      if ( $exp =~ m/as\s+(\w+)\s*/ ) {
   if ( $expr =~ m/\W/ ) {
   if ( -f "$conf_file" ) {
      if ( -f  "$homepath/.innotop") {
   if ( $file ) {
         if ( $file || 1 == scalar keys %connections ) {
            if ( !$file_mtime ) {
            if ( !$file_mtime || $file_mtime != $stat[9] ) {
         if ( $file ) { # Try to fetch status text from the file.
   if ( !$filter || $filter =~ m/\W/ ) {
   if ( ! -f $old_filename ) {
   if ( $fulltext =~ m/ibd file does not currently exist!/ ) {
   if ($fulltext =~ m/^No buffer pool page gets since the last printout$/m) {
      if ( $func eq 's' ) {
   if ( $func =~ m/s|g/ ) {
      if ( !get_connections() ) {
   if ( grep { $_ eq $filter } @$filters ) {
   if ( grep { $_ eq $table } @$visible ) {
   if ( $hint ) {
   if ( $hints ) {
   if ( !$href->{dbh} || ref($href->{dbh}) !~ m/DBI/ || !$href->{dbh}->ping ) {
         if ( $idx ) {
         if ( $idx == $#visible_cols ) {
            if ( $info->{$col_name}->{maxw} ) {
            if ( $info->{$col_name}->{minw} ) {
            if ( $info->{$_}->{dec} ) {
   if ( !$info_gotten{driver_status}++ ) {
   if ( !$info_gotten{master_logs}++ ) {
   if ( !$info_gotten{replication_status}++ ) {
   if ( !$info_gotten{status}++ ) {
      if ( $innodb_status->{IB_dl_timestring} ) {
   if ( $innodb_status->{IB_fk_timestring} ) {
      if ( $innodb_status->{IB_fk_txn} ) {
         if ( !$innodb_status{IB_got_all} && $config{auto_wipe_dl}->{val} ) {
   if ( $i < scalar(@$left) ) {
If it has, you can create a small deadlock to replace the large one.  Use the
      # If it's a master/slave thread, "Has (read|sent) all" may be the thread's
      if ( $key && $cfg_editor_action{$key} ) {
            if ( $key && $color_editor_action{$key} ) {
         if ( $key && $key eq '?' ) {
      if ( $key && $key eq '?' ) {
      if ( $key ne 'password' || $config{savepass}->{val} ) {
         if ( $key && $plugin_editor_action{$key} ) {
            if ( $key && $tbl_editor_action{$key} ) {
      if ( @last_term_size && $this_term_size[0] != $last_term_size[0] ) {
      if ( lc $answer eq 'y' ) {
If L<"--count"> is given and innotop is in incremental mode (see L<"status_inc">
   if ( length($text) <= $len ) {
            if ( $line =~ m/^package\s+(.*?);/ ) {
            if ( $lines_printed == 0 ) {
   if ( $meta->{aggregate} ) {
   if ( !$meta->{hide_caption} && !$opts{n} && $config{display_table_captions}->{val} ) {
   if ( !$meta->{pivot} ) {
   if ( $meta->{pivot} ) {
      if (@meta_rows > 10) {
   if ( $meta->{sort_cols} ne $val ) {
         if ( $meta->{sort_dir} > 0 ) {
   # if migrating from one file to another in the same directory, just rename them
            if ( ($mode eq 'T' || $mode eq 'W')
      if ( !$modes{$mode} ) {
   if ( $modes{$mode}->{one_connection} ) {
      if ( $modes{$mode}->{server_group} ) {
   if ( $mods ) {
         if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
   if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
   if ( (my $key = $self->prop('autokey')) ) {
         if ( my ($maj, $min, $rev) = $line =~ m/^version=(\d+)\.(\d+)(?:\.(\d+))?$/ ) {
      if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
   if ( (my $required = $self->prop('required')) ) {
   if ( !$name ) {
      if ( $name && exists( $config{$name} ) ) {
   if ( $new ne $variables ) {
   if ( $new_val ) {
      # If no config file was loaded, set readonly to 0 if the user wants to 
         # if no config was loaded but -w was specified,
      # If no connections have been defined, connect to a MySQL database 
   if (not $conf_file) {
      if (not $opts{w}) {
      if ( $obj ) {
   if ( $offset < 0 ) {
   if ($opts{c}) {
if ( $opts{c} and ! -f $opts{c} ) {
      if ( $opts{count} && $clock >= $opts{count} ) {
if ( $opts{'help'} ) {
         if ( $opts{n} ) {
      if ( !$opts{n} ) {
      if ( $opts{n} ) {
   if ( !$opts{n} ) {
   if ( $opts{n} ) {
if ( !$opts{n} ) {
if ( $opts{n} ) {
   if ( !$opts{n} && $config{show_statusbar}->{val} ) {
      if ( $opts{n} && $num_lines ) {
   if ( $opts{n} && $opts{count} && $config{status_inc}->{val}
   if ( $opts{n} || $prefs->{raw} ) {
   if ( !$opts{n} && !$prefs->{raw} && !$prefs->{show_all} && $this_term_size[1] < @$data-1 ) {
   if ( $opts{u} or $opts{p} or $opts{h} or $opts{P} ) {
if ( $opts{version} ) {
      if ( $package ) {
                     if ( pause($msg) eq 'n' ) {
      if $prefs->{clear} || !$modes{$config{mode}->{val}}->{no_clear_screen};
            if ( $prop eq 'trans' ) {
   if ( $query ) {
            if ( $query_status !~ m/^\w+ing/ && !exists($is_proc_info{$query_status}) ) {
   if ( $query_text ) {
            if ( $queue ) {
         if ( $records && $full ) {
      if ( $records && $full ) {
         if ( ref $col_props{$prop} ) {
         if ( ref( $val ) eq 'ARRAY' ) {
      if ( $regex && $response !~ m/$regex/ ) {
         if ( $res ) {
         if ( $retries < 0 ) {
   if ( @rows ) {
      if ( @rows && $meta->{color_func} ) {
      if ( @rows && $meta->{sort_func} ) {
      if ( @$rows && $meta->{sort_func} && !$meta->{aggregate} ) {
   if (scalar @{$modes{$config{mode}->{val}}->{connections}} == 1) {
      if $section->{'reason'};
      if ( $set->{IB_bp_complete} ) {
      if ( $set->{IB_ib_complete} ) {
      if ( $set->{IB_io_complete} ) {
      if ( $set->{IB_lg_complete} && $wanted{log_statistics} ) {
      if ( $set->{IB_ro_complete} ) {
      if ( $set->{IB_sm_complete} && $wanted{semaphores} ) {
      if ( $set->{IB_sm_wait_array_size} && $wanted{wait_array} ) {
   # If setvars exists and it's MySQL connection, set them
            if ( $src ) {
         if ( $sth ) {
   if ( $sth && $sth->{NUM_OF_FIELDS} ) {
      if ( $style eq 'new' ) {
   if ( $tbl && exists($tbl_meta{$tbl}) ) {
   if ( $tbl_meta{var_status}->{fmt} && $fmt eq $tbl_meta{var_status}->{fmt} ) {
   if ( $tbl->{pivot} ) {
   if ( @tbls > 1 ) {
# If terminal coloring is available, use it.  The only function I want from
   if ( $text =~ m/^Mutex at/m ) {
   if ( $text =~ s/([^_]+)[^_]{$max}_/$1_/ ) {
   if ( $text =~ s/_[^_]{$min,$max}_/_/ ) {
                  # If the config file is between the endpoints and innotop is greater than
   # If the header is to be shown, buffer pool data is required.
If the L<"debug"> option is enabled, innotop will display the error at the
# If the mode has a server set in use, prefers that instead.
         # If the prepared query doesn't exist, make it.
      # If there's no connection to a database server, we need to fix that...
   # If there was an error, manufacture my own colored() function that does no
      # If the table is aggregated, re-order the group_by columns to the left of
      # If the table isn't pivoted, just show all columns that are supposed to
   # If the transaction has locks, grab the locks.
   if ( $thread_line ) {
         if ( !$tries ) {
   if ( $trigger ) {
   if ( $txn ) {
   if ( $txn =~ m/^TABLE LOCK|RECORD LOCKS/ ) {
   if ( $type && $fk_parser_for{$type} ) {
   if ( @unused_cols ) {
      if ( $user_prefs ) {
   if ( $user_prefs ) {
         if ( %vars ) {
         if ( $vars->{IB_got_all} ) {
      if ( version_ge($dbh, '4.0.3')) {
         if ( %wanted ) {
         if ( $wanted{adaptive_hash_index} ) {
         if ( $wanted{buffer_pool} ) {
   if ( $wanted{cmd_summary} ) {
               if ( $wanted{deadlock_locks} ) {
               if ( $wanted{deadlock_transactions} ) {
         if ( $wanted{file_io_misc} ) {
      if ( $wanted{innodb_locks} && defined $set->{IB_tx_transactions} && @{$set->{IB_tx_transactions}} ) {
      if ( $wanted{innodb_transactions} ) {
         if ( $wanted{insert_buffers} ) {
         if ( $wanted{io_threads} ) {
      if ( $wanted{master_status} ) {
         if ( $wanted{page_statistics} ) {
         if ( $wanted{pending_io} ) {
   if ( $wanted{processlist} ) {
   if ( $wanted{q_header} ) {
         if ( $wanted{row_operation_misc} ) {
         if ( $wanted{row_operations} ) {
      if ( $wanted{slave_io_status} ) {
      if ( $wanted{slave_sql_status} ) {
      if ( $wanted{t_header} ) {
      if ( $what eq 'TRANSACTION' ) {
      if ( $which ) {
         if ( $which eq 'child' ) {
         if ( $windows ) {
      if ( $windows ) {
if ( !$windows ) {
If you are monitoring a group of servers (see L<"SERVER GROUPS">), the status
If you are monitoring multiple servers (see L<"SERVER CONNECTIONS">), the status
If you don't have the SUPER privilege, you can still run some functions, but you
If you give a filename on the command line, innotop will not connect to ANY
If you have multiple MySQL instances, you can put them into named groups, such
If you have Term::ANSIColor, innotop will use it to format headers more readably
If you're in an InnoDB mode, such as T or B, the next word is "InnoDB" followed
If your filter doesn't work, or if something else suddenly behaves differently,
(If your name has been misspelled, it's probably out of fear of putting
If your plugin manipulates the variables, it is changing global data, which is
If your server is busy, you'll see more output.  Notice the first line on the
            . "If you specify 'mysql_read_default_group=mysql' many options can be read\n"
If you type a name that doesn't exist, innotop will prompt you to create the
# If you update this variable, also update the SYNOPSIS in the pod.
If you want to really customize and create your own column, as opposed to just
   # I got the whole thing (if there has been a big deadlock and there are
I know there was one.
         # Immediately set character set and binmode on STDOUT.
implemented as a sleep time between ticks, so the true interval will vary
      import Term::ANSIColor qw(colored);
inactive.  Exit the editor and restart innotop for the changes to take effect.
in and what server you're connected to.  You can change to other modes with
# inc {{{3
   # In certain modes we might have to collect data for two cycles
            $inc ||= $incvar ? inc(0, $cxn) : $set;
         $inc ||= $incvar ? inc(0, $cxn) : $set;
include lock information, which innotop can parse and display (that's the
Incremental values are calculated as an offset from the last value innotop saw
   index                       => { hdr => 'Index',               num => 0, label => 'The index involved' },
   index_ref                   => { hdr => 'Index Ref',           num => 0, label => 'Index referenced' },
         index_ref     => { src => 'ref' },
         index            => { src => 'index' },
         index         => { src => 'key' },
index.  That tells you connection 11 is blocking connection 12.
in each mode, and innotop remembers which connections you choose.
      $info = $candidates[0];
      %info_gotten = ();
      ( $info ) = grep { $thread == $_->{id} } @candidates;
   info                        => { hdr => 'Query',               num => 0, label => 'Info or the current query', },
      $info->{label}->{maxw} = 30;
# information about the tables and indexes involved, but often the message
         info            => { src => 'info',       minw => 0,  maxw => 0, trans => [ qw(no_ctrl_char) ] },
      $ini,
   'init'                         => 1,
# Initialize %tbl_meta from %columns and do some checks.
            # Initialize the file.
               # Initialize to 130k from the end of the file (because the limit
In L<"M: Master/Slave Replication Status"> mode, you can start and stop slaves
   # innobase_mysql_print_thd in InnoDB source file sql/ha_innodb.cc.
   # innobase/row/row0ins.c row_ins_check_foreign_constraint
      innodb   => '',
      innodb    => '',
   innodb => {
      innodb   => 'bp',
         'Innodb_buffer_pool_wait_free',
      $innodb_data{'fulltext'} = $fulltext;
   $innodb_data{'got_all'} = $got_all || 0;
   ( $innodb_data{'last_secs'} ) = $fulltext
         $innodb_data{'sections'}->{ $header }
                  $innodb_data{'sections'}->{$section},
                  $innodb_data{'sections'}->{$section}->{'complete'},
   $innodb_data{'timestring'} = ts_to_string($innodb_data{'ts'});
   $innodb_data{'ts'} = [ parse_innodb_timestamp( $time_text ) ];
      innodb   => 'dl',
      innodb   => 'fk',
InnoDB has a huge variety of foreign key error messages, and many of them are
   innodb_health => {
   innodb_health2 => {
      innodb   => 'ib',
      innodb   => 'io',
      innodb   => 'lg',
InnoDB Lock Monitor (L<http://dev.mysql.com/doc/en/innodb-monitor.html>).  It's
   innodb_locks  => {
 _________________________________ InnoDB Locks __________________________
      innodb_locks => \@innodb_locks,
         'Innodb_log_waits',
            $innodb_parser->get_status_hash(
InnoDB puts deadlock information before some other information in the SHOW
      innodb   => 'ro',
         Innodb_row_lock_time_avg Innodb_row_lock_time_max Innodb_row_lock_waits
         Innodb_rows_deleted Innodb_rows_inserted Innodb_rows_read
         Innodb_rows_updated)
      $innodb_sections{$name} = [ $text, $end ? 1 : 0 ];
   $innodb_sections{'ROW OPERATIONS'}->[1] ||= $innodb_data{'got_all'};
      innodb   => 'sm',
INNODB STATUS contains a mixture of single values and repeated values that form
INNODB STATUS output.  If there are a lot of locks, the deadlock information can
 INNODB_STATUS       SHOW [ENGINE] INNODB STATUS
   INNODB_STATUS => sub {
               $innodb_status_text,
            $innodb_status_text = $file_data;
            $innodb_status_text = $stmt->fetchrow_hashref()->{status};
   innodb_transactions => {
      innodb_transactions => \@innodb_transactions,
(InnoDB truncates some information in the output), you can see which transaction
      innodb   => 'tx',
"InnoDB Txns" for T mode, followed by a reminder to press '?' for help at any
 innotop
innotop".
innotop begins with a string of text that can look as simple as a value's name
innotop can group, or aggregate, rows together (the terms are used
innotop can pivot a table for more compact display, similar to a Pivot Table in
innotop colorizes the rows.  See L<"COLORS">.
innotop configured to show the q_header table during interactive operation.
 innotop --count 5 -d 1 -n
innotop currently does this for L<"S: Variables & Status"> mode.
innotop decides both words are barewords, and transforms this expression into
innotop displays a table caption above most tables.  This variable suppresses or
innotop does not clear the screen after each tick.
innotop does not continue to query connections that have errors, because they
innotop does not fetch data in parallel from connections, so if you are
innotop does not honor the L<"shorten"> transformation, which normally shortens
innotop does not persist any changes to the configuration file.
innotop does not print a status line (see L<"INNOTOP STATUS">).
innotop doesn't prompt interactively.  Term::ANSIColor and Win32::Console::ANSI
innotop doesn't store its entire configuration in the configuration file.  It
innotop filters the rows, removing those that don't need to be displayed.  See
innotop formats and justifies the rows as a table.  During this step, innotop
   # innotop got upgraded and this is an old config file.
innotop groups the rows together, if specified.  See L<"GROUPING">.
innotop has a simple but powerful plugin mechanism by which you can extend
innotop has been used on MySQL versions 3.23.58, 4.0.27, 4.1.0, 4.1.22, 5.0.26,
innotop has lots of features for power users, but you can start and run it with
innotop has sensible built-in defaults to sort the most important rows to the
innotop hides inactive processes and its own process.  You can toggle these on
innotop in non-interactive mode, give the L"<--nonint"> command-line option.
innotop inspects the plugin module's source to determine the Perl package name.
innotop is a MySQL and InnoDB transaction/status monitor, like 'top' for
innotop is interactive, and you control it with key-presses.
innotop is mostly configured via its configuration file, but some of the
innotop lets you name and save your variable sets, and writes them to the
innotop lets you quickly switch which servers you're monitoring.  The most basic
innotop license.
innotop loads and activates the plugin.
innotop monitors MySQL servers.  Each of its modes shows you a different aspect
innotop - MySQL and InnoDB transaction/status monitor.
innotop only displays the first table in each mode.  This is so the output can
innotop only prints column headers once instead of every tick (see
innotop on your system, you should be able to just type "innotop" and press
innotop optionally pivots the rows (see L<"PIVOTING">), then filters and sorts
innotop pre-selects the longest-running query, or the oldest connection.
innotop prints the full contents of each table instead of only printing one
innotop prompts you for the column, an operator for the comparison, a value
innotop's default configuration file locations are $HOME/.innotop and
innotop sorts the rows.  See L<"SORTING">.
innotop's quick-filters are a shortcut to create a temporary filter that doesn't
innotop to pause briefly after calling SHOW GLOBAL STATUS alleviates this
innotop transforms the column values in each row.  See L<"TRANSFORMATIONS">.
innotop uses a limited set of SQL statements to retrieve data from MySQL for
 innotop -u <username> -p <password> -h <hostname>
 innotop /var/log/mysql/mysqld.err
innotop will ask you if you want to specify a password.  Like the username, the
innotop will ask you if you want to specify a username.  If you say 'y', it will
innotop will prompt you for the column name and filter text.  Again, you can use
innotop will prompt you for the server and/or connection ID to kill (innotop
In other words, the code you're typing is surrounded by an implicit context,
# Input: an arrayref of columns, hashref of col info, and an arrayref of hashes
inputs, as follows:
   "INSERT BUFFER AND ADAPTIVE HASH INDEX" => "ib",
insert buffer, and adaptive hash index.  The data comes from SHOW INNODB STATUS.
               'insert_buffers');
   insert_buffers => {
      insert_buffers      => \@insert_buffers,
   insert_intention            => { hdr => 'Ins Intent',          num => 1, label => 'Whether the thread was trying to insert' },
         insert_intention => { src => 'insert_intention' },
   inserts                     => { hdr => 'Inserts',             num => 1, label => 'Inserts' },
         inserts       => { src => 'IB_ib_inserts' },
in several different styles.  You can show absolute values, or incremental values
instructions to innotop.  The meta-data includes the caption, a list of columns
Instructs innotop to automatically wipe large deadlocks when it notices them.
interchangeably).  This is quite similar to an SQL GROUP BY clause.  You can
interest in the event.  innotop passes some data for each event.  The events are
Internally, table meta-data is defined in a data structure called %tbl_meta.
international characters into this documentation; earlier versions of Perl might
   interval => {
      # in that space.  When the thing is wider than the display, center the
      # in the entry as a row.
in the format tbl_name=column_list.  See L<"GROUPING">.
            . "into SELECT, but this doesn't always succeed.";
into the $set hash.  A bareword is an unquoted value that isn't already
         int(($secs % 3_600) / 60),
         int($secs / 86_400),
         int(($secs % 86_400) / 3_600),
   io_bytes_s                  => { hdr => 'Bytes/Sec',           num => 1, label => 'Average I/O bytes/sec' },
         io_bytes_s     => { src => 'IB_io_avg_bytes_s' },
   io_flush_type               => { hdr => 'Flush Type',          num => 0, label => 'I/O Flush Type' },
         io_flush_type  => { src => 'IB_io_flush_type' },
   io_fsyncs_s                 => { hdr => 'fsyncs/sec',          num => 1, label => 'I/O fsyncs/sec' },
         io_fsyncs_s    => { src => 'IB_io_fsyncs_s' },
   io => \&parse_io_section,
   io_reads_s                  => { hdr => 'Reads/Sec',           num => 1, label => 'Average I/O reads/sec' },
         io_reads_s     => { src => 'IB_io_reads_s' },
   io_threads => {
      io_threads     => \@io_threads,
   io_writes_s                 => { hdr => 'Writes/Sec',          num => 1, label => 'Average I/O writes/sec' },
         io_writes_s    => { src => 'IB_io_writes_s' },
   ip                          => { hdr => 'IP',                  num => 0, label => 'IP address' },
      ip                 => $ip,
         ip                 => { src => 'ip' },
# I put this last as per the Dog book.
I run innotop on Gentoo GNU/Linux, Debian and Ubuntu, and I've had feedback from
is a pause for L<"interval"> seconds, followed by requesting data from MySQL
   is_name_locked              => { hdr => 'Locked',              num => 1, label => 'Whether table is name locked', },
         is_name_locked => { src => 'name_locked' },
isn't waiting, because the Waiting column is 0, but it holds locks on the same
is probably one of the most useful modes for general usage.
issued in those modes, innotop keeps track of which mode caused the error.  If
# is the specified columns; otherwise it's just the empty string (e.g.
It also looks for a description in the source code, to make the plugin editor
it can happen in real life).
it contains:
It does this by calling a subroutine for each column, passing it the source data
=item action_for
=item active_columns
=item active_connections
=item active_filters
=item active_server_groups
=item adaptive_hash_index
=item agg_funcs
=item auto_wipe_dl
=item avg
=item B: InnoDB Buffers
=item buffer_pool
=item C: Command Summary
=item c: Edit Columns
=item charset
=item cmd_filter
=item cmd_summary
=item color
=item --color
=item colors
=item commify
=item config
=item --config
=item connections
=item count
=item --count
=item cxn_timeout
=item dbhs
=item deadlock_locks
=item deadlock_transactions
=item debug
=item debugfile
=item --delay
=item D: InnoDB Deadlocks
=item display_table_captions
=item draw_screen($lines)
=item DSN
=item dulint_to_int
=item event handlers
=item explain
=item extract_values($set, $cur, $pre, $tbl)
=item file_io_misc
=item filters
=item F: InnoDB Foreign Key Errors
=item first
=item fk_error
=item general
=item g: General Configuration
=item global
=item graph_char
=item group_by
=item header_highlight
=item --help
=item hide_hdr
=item --host
=item I: InnoDB I/O Info
=item --inc
=item InnoDB Deadlock Table
=item innodb_locks
=item innodb_transactions
=item insert_buffers
=item interval
=item io_threads
=item k: Row-Coloring Rules
=item L: Locks
=item log_statistics
=item master_status
=item max_values_seen
=item M: Master/Slave Replication Status
=item mode
=item --mode
=item modes
=item new(%variables)
=item no_ctrl_char
=item --nonint
=item num_digits
=item num_status_sets
=item O: Open Tables
=item open_tables
=item OS_WAIT_ARRAY
=item page_statistics
=item --password
=item Password
=item pending_io
=item percent
=item plugin_dir
=item plugins
=item p: Manage Plugins
=item --port
=item processlist
=item q_header
=item Q: Query List
=item readonly
=item register_for_events()
=item R: InnoDB Row Operations and Semaphores
=item row_operation_misc
=item row_operations
=item secs_to_time
=item semaphores
=item server_groups
=item set_precision
=item set_to_tbl
=item S_func
=item shorten
=item show_cxn_errors
=item show_cxn_errors_in_tbl
=item show_percent
=item show_statusbar
=item --skipcentral
=item skip_innodb
=item slave_io_status
=item slave_sql_status
=item sort_cols
=item s: Server Groups
=item S_set
=item S: Statement Sleep Times
=item status_inc
=item STATUS_VARIABLES
=item stmt_sleep_times
=item sum
=item S: Variables & Status
=item tbl_meta
=item t: Choose Displayed Tables
=item t_header
=item tick
=item T: InnoDB Transactions
=item trans_funcs
=item --user
=item Username
=item varsets
=item var_sets
=item var_status
=item --version
=item visible_tables
=item wait_array
=item --write
it helps to be able to see which tables and indexes are the "hot spot" for
it into a hash access.  After the whole string is processed, innotop compiles a
It looks for a line of the form "package Foo;" and if found, considers the
      # It may be narrow enough to pad the sides with underscores and save a
      # It may be the case that the query id is the last thing in the line.
      # It may be time to quit now.
               # It's basically impossible to know which is which.
it's not required.
It's rather like running SHOW VARIABLES LIKE "prefix%" with memory and
# it without prompt.
# I've read the source for this.
# I've read the source for this section.
   j => {
Jan Pieter Kunst,
Jari Aalto,
Jay Pipes,
Jeremy Zawodny,
Johan Idren,
               . join( " ",
            ? join( $col_sep, @$cols )
            : join( $col_sep, map { sprintf( "%-$width_for{$_}s", trunc($info->{$_}->{hdr}, $width_for{$_}) ) } @$cols );
         join(', ', grep { $_ } (
            . join('+', map { "($_||0)" }
            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
         ? '{' . join('}{', map { defined $_ ? $_ : '' } @{$row}{@$group_by}) . '}'
         . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
            : join(' ',  map { "%${width}s" } @hdr) . "\n";
            . join("\n", map { "  $_ $modes{$_}->{hdr}" }  sort keys %modes)
      join(' ', @tbls),
            ? join("\t", map { '%s' } @$visible) . "\n"
         . join(' ', @unused_cols);
               . join( " ", @$val ) . "\n"
            just  => '-',
         just  => '',
       just  => '',
   just    => '-',
         just1 => '-',
#    * just   Alignment; generated from num, user-overridable in tbl_meta
just as with printf formatting codes (not a coincidence).
   # Just for sanity's sake, make sure I understand what to do with each
# just gets printed.  If it's an arrayref, the first element is the string to
just hard to parse.  innotop doesn't always do the best job here, but there's
just: justification.  '-' means left-justified and '' means right-justified,
         { just => '-', sep => '  '});
just to see how it's defined.  To create a new one, just press 'c' and type its
         k => {
   k => {
   # kb_used=hdr='BufUsed' minw='0' num='0' src='percent(1 - ((Key_blocks_unused * key_cache_block_size) / (key_buffer_size||1)))' dec='0' trans='' tbl='q_header' just='-' user='1' maxw='0' label='User-defined'
keeps in its memory, so the larger this variable is, the more memory innotop
# Keeps track of error count, sleep times till retries, etc etc.
            $key = '';
         $key = '';
   key_buffer_hit              => { hdr => 'KCacheHit',           num => 1, label => 'Key cache hit ratio', },
         key_buffer_hit => { src => '1-(Key_reads/(Key_read_requests||1))', dec => 1, trans => [qw(percent)] },
   key_cache => {
   'key cache'                    => 1,
key changes the view to a graph of the same numbers, sort of like B<tload>.
      . "  KEY  COPY  MEANING\n"
# Keyed on a single character, which is read from the keyboard.  Uppercase
# keyed on clock tick.
# Keyed on connection name.  Each entry is a hashref of current and past data sets,
   key_len                     => { hdr => 'Key Length',          num => 1, label => 'Number of bytes used in the key' },
         key_len       => { src => 'key_len' },
key on test.t1, and has been waiting for 10 seconds.  The second connection
            $key = pause('');
         $key = pause('');
      $key = pause('');
key presses that select a mode interactively.  See L<"MODES">.
         Key_read_requests Key_reads Key_write_requests Key_writes )
      } keys %action_for;
        } keys %config;
   } keys %connections;
      } keys %{$cur}
         keys %filters
      $keys{$key} = $modes{$mode}->{action_for}->{$key}->{label};
            keys %$meta
keystrokes; press 'T' to switch to a list of InnoDB transactions, for example.
      key    => 'TAB',
key, which starts the L<"TABLE EDITOR"> and lets you choose and edit columns.
             : 'KILL ?');
             ? 'KILL CONNECTION ?'
 KILL_CONNECTION     KILL
   KILL_CONNECTION => sub {
             ? 'KILL QUERY ?'
# kill_query {{{3
 KILL_QUERY          KILL QUERY
   KILL_QUERY => sub {
# Kills a connection, or on new versions, optionally a query but not connection.
Kristian Kohntopp,
   L => {
      label  => '',
   label   => '',
   # LABEL
label: a small note about the column, which appears in dialogs that help the
      label  => 'Change refresh interval',
            label => "Change the display's sort column",
            label  => "Change the display's sort column",
      label  => 'Choose and edit table filters',
            label => "Choose sort column",
            label  => 'Choose variable prefix',
            label  => 'Choose visible columns',
            label => "Choose which set to display",
      label  => 'Clear quick-filters',
            label  => 'Decrease fractional display precision',
#    * label  Documentation for humans.
      label  => 'Edit configuration settings',
            label  => 'Edit the current set of variables',
      label  => "Edit the displayed table(s)",
       label => 'Example',
            label  => "Explain a thread's query",
         $_->{label} = $_->{hdr};
            label  => 'Increase fractional display precision',
            label => "Kill a query",
            label  => "Kill a query",
            label => "Kill a query's connection",
            label  => "Kill a transaction's connection",
            label  => 'Purge unused master logs',
      label  => 'Quickly filter what you see',
            label  => 'Reverse sort order',
      label  => 'Select/create server connections',
      label  => 'Select/create server groups',
            label  => "Show a thread's full query",
      label  => 'Show help',
      label  => 'Show license and warranty',
            label  => 'Start slave(s)',
            label  => 'Start the InnoDB Lock Monitor',
            label  => 'Stop slave(s)',
            label  => 'Stop the InnoDB Lock Monitor',
            label  => 'Switch to graph (tload) view',
            label  => 'Switch to next variable set',
            label  => 'Switch to pivoted view',
            label  => 'Switch to prev variable set',
            label  => 'Switch to standard (vmstat) view',
      label  => 'Switch to the next server group',
      label  => 'Toggle aggregation',
            label  => 'Toggle idle processes',
            label  => 'Toggle inactive transactions',
            label  => 'Toggle incremental status display',
            label  => 'Toggle the header on and off',
            label  => 'Toggle the innotop process',
            label => 'User-defined',
            label  => 'Wipe deadlock status info by creating a deadlock',
   last_chkp                   => { hdr => 'Last Checkpoint',     num => 0, label => 'Last log checkpoint' },
         last_chkp           => { src => 'IB_lg_last_chkp' },
   last_errno                  => { hdr => 'Last Errno',          num => 1, label => 'Last error number' },
         last_errno                  => { src => 'last_errno' },
   last_error                  => { hdr => 'Last Error',          num => 0, label => 'Last error' },
         last_error                  => { src => 'last_error' },
      last if $line =~ m/^\[/;
            last if $package && $desc;
   last_pct                    => { hdr => 'Pct',                 num => 1, label => 'Last Percentage' },
         last_pct   => { src => 'last_value/last_total',     trans => [qw(percent)] },
      last_secs => 0,         # Num seconds the averages are over
   last_s_file_name            => { hdr => 'S-File',              num => 0, label => 'Filename where last read locked' },
         last_s_file_name   => { src => 'last_s_file_name' },
   last_s_line                 => { hdr => 'S-Line',              num => 1, label => 'Line where last read locked' },
         last_s_line        => { src => 'last_s_line' },
         @last_term_size = @this_term_size;
   last_total                  => { hdr => 'Last Total',          num => 1, label => 'Last Total' },
         $last_total += $last_val;
         last_total => { src => 'last_total' },
   last_value                  => { hdr => 'Last Incr',           num => 1, label => 'Last Value' },
            last_value => $last_val,
         last_value => { src => 'last_value',                agg   => 'sum'},
   last_x_file_name            => { hdr => 'X-File',              num => 0, label => 'Filename where last write locked' },
         last_x_file_name   => { src => 'last_x_file_name' },
   last_x_line                 => { hdr => 'X-Line',              num => 1, label => 'Line where last write locked' },
         last_x_line        => { src => 'last_x_line' },
   "LATEST DETECTED DEADLOCK"              => "dl",
   "LATEST FOREIGN KEY ERROR"              => "fk",
L<"charset"> configuration variable.
L<"cmd_summary"> table, which looks something like the following:
L<"COLORS"> for details.
L<"DEADLOCK_TRANSACTIONS">.
L<"display_table_captions">).  innotop ensures there are no empty lines in the
   # Leave built-in functions alone so they get called as Perl functions, unless
         $left->[$i] = sprintf($format, $left->[$i], $right->[$i - $offset]);
      len   => defined($len) ? $len : defined($nullsize) ? $nullsize : 0,
Lenz Grimmer,
   'le' => 'String less-than/equal',
Lets you choose which tables to display in this mode.  See L<"MODES"> and
Lets you create and edit server groups.  See L<"SERVER GROUPS">.
letters, numbers and underscores.
# letters switch modes.  Lowercase letters access commands when in a mode.
   $level ||= 0;
level deep.  It comes from the lines that look like this:
(lexically or numerically).
L<"EXPRESSIONS">).
L<"EXPRESSIONS">).  The resulting row is a hash whose keys are named the same as
L<"FILES">.
L<"FILTERS">.
   lg => \&parse_lg_section,
L<"hide_hdr">).  innotop does not print table captions (see
L<http://code.google.com/p/innotop/>.  There are mailing lists, a source code
L<http://search.cpan.org/~timb/DBI/DBI.pm>.
# License and warranty information. {{{1
licenses.
like columns in any other table, in terms of data extraction and
like inactive queries, but you can define your own as well.  innotop also lets
likely never to be perfect in this regard.  If innotop doesn't show you what
like SQL's COUNT(*).
limitations.
line does not show any details about individual servers.  Instead, it shows the
line is in the format mode_name=connection_list.
line is in the format mode_name=server_group.
      # line on the screen.
line shows the name of the group.  If any connection in the group has an
$lines is an arrayref of strings.
               $lines_printed++;
            $lines_printed++;
         $lines_printed++;
         $lines_printed = 0;
            $lines_printed = 1;
            $lines_printed = 2;
L<"INNODB_TRANSACTIONS">.
L<"INNOTOP STATUS">.
L<"insert_buffers">, and L<"adaptive_hash_index"> tables by default.
listed in the config file.  Your plugin may load before or after another plugin,
      $listener->draw_screen($display_lines);
      $listener->extract_values($set, $cur, $pre, $tbl);
      $listener->set_to_tbl_post_create(\@rows, $tbl);
      $listener->set_to_tbl_pre_colorize(\@rows, $tbl);
      $listener->set_to_tbl_pre_create(\@rows, $tbl);
         $listener->set_to_tbl_pre_filter($rows, $tbl);
      $listener->set_to_tbl_pre_group(\@rows, $tbl);
         $listener->set_to_tbl_pre_pivot(\@rows, $tbl);
         $listener->set_to_tbl_pre_sort($rows, $tbl);
      $listener->set_to_tbl_pre_transform(\@rows, $tbl);
list is so long, InnoDB has only printed out some of the transactions.  Finally,
List"> mode is so important, innotop automatically disables the L<"q_header">
list of columns by which you want to sort and press Enter.  If you want to
list of expressions, and then into a column list so they can be treated just
lists).  You want to filter on the 'time' column.  Type the text "$set->{time} >
literal string like 'product' works fine as a regular expression.
L<"master_status"> tables by default.
L<"num_digits"> digits after the decimal point, and optionally adding a percent
load_config();
# load_config {{{3
# load_config_active_columns {{{3
# load_config_active_connections {{{3
# load_config_active_filters {{{3
# load_config_active_server_groups {{{3
# load_config_config {{{3
# load_config_connections {{{3
# load_config_filters {{{3
# load_config_group_by {{{3
# load_config_mvs {{{3
# load_config_plugins {{{3
# load_config_server_groups {{{3
# load_config_sort_cols {{{3
# load_config_stmt_sleep_times {{{3
# load_config_tbl_meta {{{3
# load_config_varsets {{{3
# load_config_visible_tables {{{3
   load                        => { hdr => 'Load',                num => 1, label => 'Server load' },
         load           => { src => $exprs{ServerLoad},                     dec => 1, trans => [qw(shorten)] },
 localhost  11  RECORD        0  00:00   00:25  X     test  t1     PRIMARY
 localhost  11  TABLE         0  00:00   00:25  IX    test  t1
 localhost  12  RECORD        1  00:10   00:10  X     test  t1     PRIMARY
 localhost  12  TABLE         0  00:10   00:10  IX    test  t1
 localhost  Query      49    12933  webusr localhost      19:38  SELECT * FROM
 localhost  Query  766446598  test  10.0.0.1  foo  00:02  INSERT INTO table (
 localhost  Sending Da 23     2383  webusr localhost      12:43  SELECT col1,
 localhost  Sleep      120     140  webusr localhost    5:18:12
 localhost  Statistics 12    19213  webusr localhost      01:19  SELECT * FROM
 localhost  Total  0.00  1.07k   697      0.00%     98.17%  476.83k  242.83k
localhost using mysql_read_default_group=client for other connection
         = $lock
   lock_cfile_name             => { hdr => 'Crtd File',           num => 0, label => 'Filename where lock created' },
         lock_cfile_name    => { src => 'lock_cfile_name' },
   lock_cline                  => { hdr => 'Crtd Line',           num => 1, label => 'Line where lock created' },
         lock_cline         => { src => 'lock_cline' },
   lock_mem_addr               => { hdr => 'Addr',                num => 0, label => 'The lock memory address' },
         lock_mem_addr      => { src => 'lock_mem_addr' },
   lock_mode                   => { hdr => 'Mode',                num => 0, label => 'The lock mode' },
         lock_mode        => { src => 'lock_mode' },
         = $lock =~ m/^(?:RECORD|TABLE) .*? insert intention/m ? 1 : 0;
         = $lock =~ m/^(?:RECORD|TABLE) .*? locks (rec but not gap|gap before rec)/m;
         = $lock =~ m/^(?:RECORD|TABLE) .*? waiting/m ? 1 : 0;
   'locks'                        => 1,
# locks and such (probably shouldn't unless you need to).
locks are supported, and by default you'll only see locks for which transactions
locks.  If your server is running pretty well, this mode should show nothing.
      $locks = [parse_innodb_record_locks($txn, $complete, $debug, $full)];
   lock_structs                => { hdr => 'LStrcts',             num => 1, label => 'Number of lock structs' },
      lock_structs       => $lock_structs,
         lock_structs                => { src => 'IB_tx_num_lock_structs' },
         lock_structs       => { src => 'lock_structs' },
   lock_type                   => { hdr => 'Type',                num => 0, label => 'The lock type' },
         lock_type        => { src => 'lock_type' },
   lock_var                    => { hdr => 'Lck Var',             num => 1, label => 'The lock variable' },
         lock_var           => { src => 'lock_var' },
      lock_wait_status   => $lock_wait_status,
   lock_wait_time              => { hdr => 'Wait',                num => 1, label => 'How long txn has waited for a lock' },
      lock_wait_time     => $lock_wait_time,
         lock_wait_time   => { src => 'lock_wait_time', trans => [ qw(secs_to_time) ] },
         lock_wait_time     => { src => 'lock_wait_time',      trans => [ qw(secs_to_time) ] },
         lock_wait_time     => { src => 'lock_wait_time', trans => [ qw(secs_to_time) ] },
   log_flushed_to              => { hdr => 'Flushed To',          num => 0, label => 'Log position flushed to' },
            log_flushed_to log_seq_no pending_log_writes complete )),
         log_flushed_to      => { src => 'IB_lg_log_flushed_to' },
   log_ios_done                => { hdr => 'IO Done',             num => 1, label => 'Log I/Os done' },
         log_ios_done        => { src => 'IB_lg_log_ios_done' },
   log_ios_s                   => { hdr => 'IO/Sec',              num => 1, label => 'Average log I/Os per sec' },
         log_ios_s           => { src => 'IB_lg_log_ios_s' },
   "LOG"                                   => "lg",
   log_seq_no                  => { hdr => 'Sequence No.',        num => 0, label => 'Log sequence number' },
         log_seq_no          => { src => 'IB_lg_log_seq_no' },
   log_statistics => {
      log_statistics => \@log_statistics,
   # Look for info on waits.
looks kind of like a line being filtered between two circles) and choose which
   # Loop through each section.  There are no assumptions about how many
Lowercase keys initiate some action within the current mode.
L<"pending_io">, L<"file_io_misc">, and L<"log_statistics"> tables by default.
L<"PROCESSLIST">.
L<"processlist"> and L<"innodb_transactions">, so you don't see a count when the
L<"processlist"> and L<"innodb_transactions">.  The grouping is by connection
L<"processlist"> table (innotop generally tries to help you with auto-completion
L<"processlist"> table when prompted).
L<"Q: Query List"> mode.  Press '=' to toggle grouping (if necessary, select the
L<"QUICK-START">.  Press '?' at any time while running innotop for
L<"row_operation_misc">, L<"semaphores">, and L<"wait_array"> tables by default.
L<"shorten">, and L<"percent"> transformations.
L<"show_cxn_errors_in_tbl"> configuration option, which is enabled by default.
L<"status_inc">.
L<"STATUS_VARIABLES">.
L<"STATUS_VARIABLES">.  The variables must be numeric and must match the prefix
L<"SWITCHING BETWEEN CONNECTIONS">.
L<"TABLES">.
L<"TABLES">.  Expressions are used in the earliest step, where it extracts
L<"TABLES"> for more information).
L<"TABLES">), it does so from a particular data source.  Largely because of the
   'lt' => 'String less-than',
L<"--write">.  See L<"readonly">.
      =~ m{
          :                   'm';
   M => {
Maciej Dobrzanski,
   # Magic keys
   # magic (special character) keys.
maintainer or author directly, as it makes our job easier and benefits others if the
   main_thread_id              => { hdr => 'Main Thread ID',      num => 1, label => 'Main thread ID' },
         main_thread_id      => { src => 'IB_ro_main_thread_id' },
   main_thread_proc_no         => { hdr => 'Main Thread Proc',    num => 1, label => 'Main thread process number' },
         main_thread_proc_no main_thread_id read_sec del_sec upd_sec ins_sec
         main_thread_proc_no => { src => 'IB_ro_main_thread_proc_no' },
   main_thread_state           => { hdr => 'Main Thread State',   num => 0, label => 'Main thread state' },
         main_thread_state   => { src => 'IB_ro_main_thread_state' },
            ( $maj, $min, $rev ) = $VERSION =~ m/^(\d+)\.(\d+)(?:\.(\d+))?$/;
# make_color_func {{{3
# Makes a two-column table, labels on left, data on right.
Makes innotop display connection errors as rows in the first table on screen.
Makes innotop print connection errors to STDOUT.  See L<"ERROR HANDLING">.
makes innotop write a lot of information to L<"debugfile"> when there is a
# make_sort_func {{{3
   # Make sure certain values aren't undef
# Make sure no changes are written to config file in non-interactive mode.
   'malloc'                       => 1,
'man innotop')
manipulate.  It is probably a good idea if the plugin object saves a copy of it
            map {
         map {
      map  {
      map {
            { map { $_ => $all_cols{$_}->{label} || $all_cols{$_}->{hdr} } keys %all_cols });
         { map { $_ => $cfg_editor_action{$_}->{note} } keys %cfg_editor_action },
   map { $col->{$_} ||= 0 } qw(num minw maxw);
               { map { $_ => $color_editor_action{$_}->{note} } keys %color_editor_action },
            map { $_->{$col} = $trans_funcs{$trans}->($_->{$col}) } @rows;
               { map { $_ => $comp_ops{$_} } keys %comp_ops } );
      = map  { $_ => $config{$_}->{note} || '' }
      { map { $_ => $connections{$_}->{dsn} } @available });
         { map { $_ => $connections{$_}->{dsn} } @cxns });
   map  { $_->{c} => $opts{$_->{k}} }
      map { $data->{$_} = '' unless defined $data->{$_} } @$cols;
      map  { [ $_ . ': ' . $dbhs{$_}->{last_err}, 'red' ] }
        map { defined $_ ? $_ : 'undef' }
   map { $dl->{$_} ||= '' } qw(rolled_back);
      map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
         map  { $_ => $filters{$_}->{note} }
      map { $hash->{$_} ||= 0 } qw(n_bits page_no space_id);
               map { $hash{$_} = $lock->{$_} } qw(lock_type space_id page_no n_bits index db table txn_id lock_mode special insert_intention waiting);
      map { $hash->{$_} ||= "" } qw(index special);
      (map { 'IB_bp_' . $_ => $innodb_status->{'sections'}->{'bp'}->{$_} }
      (map { 'IB_dl_' . $_ => $innodb_status->{'sections'}->{'dl'}->{$_} }
      (map { 'IB_fk_' . $_ => $innodb_status->{'sections'}->{'fk'}->{$_} }
      (map { 'IB_ib_' . $_ => $innodb_status->{'sections'}->{'ib'}->{$_} }
      (map { 'IB_' . $_ => $innodb_status->{$_} } qw(timestring last_secs got_all)),
      (map { 'IB_io_' . $_ => $innodb_status->{'sections'}->{'io'}->{$_} }
      (map { 'IB_lg_' . $_ => $innodb_status->{'sections'}->{'lg'}->{$_} }
      (map { 'IB_ro_' . $_ => $innodb_status->{'sections'}->{'ro'}->{$_} }
      (map { 'IB_sm_' . $_ => $innodb_status->{'sections'}->{'sm'}->{$_} }
      (map { 'IB_tx_' . $_ => $innodb_status->{'sections'}->{'tx'}->{$_} }
            map { "%$info->{$_}->{just}$width_for{$_}s" } @$cols );
         { map { $_ => join(' ', @{$server_groups{$_}}) } @available });
               { map { $_ => $_ } keys %ansicolors } );
         { map { $_ => $_ } keys %cfg_editor_action },
               { map { $_ => $_ } keys %color_editor_action },
               { map { $_ => $_ } keys %$hints },
            { map { $_ => $_ } keys %plugin_editor_action },
               { map { $_ => $_ } keys %tbl_editor_action },
               { map { $_ => $meta->{cols}->{$_}->{label} } keys %{$meta->{cols}} });
      { map { $_ => $meta->{cols}->{$_}->{label} } keys %{$meta->{cols}} });
   #      map  { my $col = $_; map { $_->{$col} } @var_status }
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
            { map { $_ => $plugin_editor_action{$_}->{note} } keys %plugin_editor_action },
               { map { $_ => $_ } @prop },
         map { $p->{$_} = $user_prefs->{$_} } keys %$user_prefs;
      map { $p->{$_} = $user_prefs->{$_} } keys %$user_prefs;
      map { push @visible, $_ if $_ !~ /^cxn$/ } @{$meta->{visible}};
         map { ref $_ ? colored(@$_) : $_ } create_caption('Choose from', @meta_rows), ''),
               { map { $_ => ref $meta->{$_} eq 'ARRAY' ? join(' ', @{$meta->{$_}})
            map { $res->{$_} ||= '' } ( 'partitions', keys %$res);
   map { $result->{$_} ||= '' }
   map { $result{$_} ||= '' }
   map { $result->{$_} ||= 0 }
   map { $result{$_} ||= 0 }
         map { $row->{$_} = collapse_ws($row->{$_}) } @$cols;
   map { $section->{$_} ||= "" }
   map { $section->{$_} ||= 0 }
   map { $section->{$_} ||= 0 } qw(read_views_open n_reserved_extents);
   map { $stuff{$_} ||= 0 } qw(active_secs heap_size lock_structs
   map { $stuff{$_} ||= "" } qw(thread_status txn_doesnt_see_ge
               { map { $_ => $tbl_editor_action{$_}->{note} } keys %tbl_editor_action },
      { map { $_ => $tbl_meta{$_}->{capt} } @{$modes{$mode}->{tables}} }
         { map { $_ => $tbl_meta{$_}->{capt} } @tbls }
         map  { $tbl_meta{$_}->{innodb} => 1 }
      map { $tbl_meta{var_status}->{cols}->{$_}->{just} = ''} @$visible;
               { map { $_ => trunc($hints->{$_}, $this_term_size[0] - $max_name) } keys %$hints },
                  map { "$_:$val->{$_}" } keys %$val
         map { $vars->{$_->[0]} = $_->[1] || 0 } @$res;
      map  { $vars{$_}->{$clock} } @cxns;
      { map { $_ => $var_sets{$_}->{text} } keys %var_sets });
         map { $vars->{$_} ||= $res{$_} } keys %res;
   master_file                 => { hdr => 'File',                num => 0, label => 'Master file' },
         master_file                 => { src => 'file' },
   master_host                 => { hdr => 'Master',              num => 0, label => 'Master server hostname' },
         master_host                 => { src => 'master_host', hdr => 'Master' },
         master_host                 => { src => 'master_host', hdr => 'Master'},
   master_log_file             => { hdr => 'Master Log File',     num => 0, label => 'Master log file' },
         master_log_file             => { src => 'master_log_file', hdr => 'File' },
   master_port                 => { hdr => 'Master Port',         num => 1, label => 'Master port' },
         master_port                 => { src => 'master_port' },
   master_pos                  => { hdr => 'Position',            num => 1, label => 'Master position' },
         master_pos                  => { src => 'position' },
   master_ssl_allowed          => { hdr => 'Master SSL Allowed',  num => 0, label => 'Master SSL Allowed' },
         master_ssl_allowed          => { src => 'master_ssl_allowed' },
   master_ssl_ca_file          => { hdr => 'Master SSL CA File',  num => 0, label => 'Master SSL Cert Auth File' },
         master_ssl_ca_file          => { src => 'master_ssl_ca_file' },
   master_ssl_ca_path          => { hdr => 'Master SSL CA Path',  num => 0, label => 'Master SSL Cert Auth Path' },
         master_ssl_ca_path          => { src => 'master_ssl_ca_path' },
   master_ssl_cert             => { hdr => 'Master SSL Cert',     num => 0, label => 'Master SSL Cert' },
         master_ssl_cert             => { src => 'master_ssl_cert' },
   master_ssl_cipher           => { hdr => 'Master SSL Cipher',   num => 0, label => 'Master SSL Cipher' },
         master_ssl_cipher           => { src => 'master_ssl_cipher' },
   master_ssl_key              => { hdr => 'Master SSL Key',      num => 0, label => 'Master SSL Key' },
         master_ssl_key              => { src => 'master_ssl_key' },
   master_status => {
      master_status    => \@master_status,
   master_user                 => { hdr => 'Master User',         num => 0, label => 'Master username' },
         master_user                 => { src => 'master_user' },
matches the row; if it does, the row gets the specified color, and no further
   $max1 = max(map {length($_)} @col1);
   max_height => {
      $max_name ||= 0;
      $max_name +=  3;
   max_txn                     => { hdr => 'MaxTxnTime',          num => 1, label => 'MaxTxn' },
         max_txn                     => { src => $exprs{MaxTxnTime},          trans => [qw(secs_to_time)] },
   MaxTxnTime        => q/max(map{ $_->{active_secs} } @{ IB_tx_transactions }) || 0/,
   max_values_seen => {
            maxw  => 0,
   maxw    => 0,
               $max_width = max( $max_width, $info->{$col_name}->{minw} );
               $max_width = min( $max_width, $info->{$col_name}->{maxw} );
maxw: similar to minw.
may be included as needed, for example, SHOW MASTER STATUS and SHOW SLAVE
may be mode-specific, but don't belong in any other section.  The syntax is a
# may be read and written in a subroutine, so it's a global.
may slow innotop and make it hard to use, especially if the error is a problem
      =~ m{because it is referenced by `(.*)/(.*)`}m;
               =~ m/^But in child table [^,]*, in index `$n`, (?:the record is not available|there is a record:\n(.*))?/ms;
               =~ m/^But in parent table [^,]*, in index `$n`,\nthe closest match we can find is record:\n(.*)/ms;
         =~ m/^But the parent table `$n`\.`$n`$/m;
      =~ m{Cannot $w table `(.*)/(.*)`}m;
      =~ m/CONSTRAINT `?$n`? FOREIGN KEY \(`?$n`?\) REFERENCES (?:`?$n`?\.)?`?$n`? \(`?$n`?\)/;
      =~ m/CONSTRAINT `$n` FOREIGN KEY \(`$n`\) REFERENCES (?:`$n`\.)?`$n` \(`$n`\)/;
      =~ m/^(?:(\D*) )?$d lock struct\(s\), heap size $d(?:, $d row lock\(s\))?(?:, undo log entries $d)?$/m;
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   merged_recs                 => { hdr => 'Merged Recs',         num => 1, label => 'Merged records' },
            merged_recs merges complete )),
         merged_recs   => { src => 'IB_ib_merged_recs' },
   merges                      => { hdr => 'Merges',              num => 1, label => 'Merges' },
         merges        => { src => 'IB_ib_merges' },
         # Merge using a hash slice, which is the fastest way
      =~ m{Error in foreign key constraint of table (.*)/(.*):$}m;
                           :                              $meta->{$_}
   $meta->{aggregate} ^= 1;
               @{$meta}{$answer, 'user', 'tbl' } = ( $val, 1, $tbl );
      $meta->{color_func} = make_color_func($meta);
         $meta->{colors}->[$dest] = $temp;
         $meta->{colors}->[$idx]  = $meta->{colors}->[$dest];
      $meta->{cols}->{$col} ||= {};
            $meta->{cols}->{$col}->{$prop} = $parts{$prop};
               $meta->{cols}->{$col}->{$prop} = [ split(',', $parts{$prop}) ];
               $meta->{cols}->{$col}->{trans}
         $meta->{cust}->{colors} = 1;
   $meta->{cust}->{filters} = 1;
      $meta->{cust}->{group_by} = 1;
      $meta->{cust}->{sort_cols} = 1;
         $meta->{cust}->{visible} = 1;
# Meta-data (table definitions etc) {{{2
   $meta->{err_count}++;
   $meta->{filters} = [ @choices ];
      $meta->{group_by} = [ grep { exists $meta->{cols}->{$_} } $val =~ m/(\w+)/g ];
      $meta->{"#$group"} = join(' ', @{$server_groups{$group}});
   $meta->{last_err}   = $err;
   $meta->{mode} = $config{mode}->{val};
   $meta->{prev_sleep} = $meta->{this_sleep};
            [@meta_rows[0..$split - 1]],
            [@meta_rows[$split..$#meta_rows]],
         @meta_rows = stack_next(
      $meta->{sort_cols},
      $meta->{sort_cols} = $val;
   $meta->{this_sleep} = $sleep_time;
# meta_to_hdr {{{3
                  meta_to_hdr('explain'),
         meta_to_hdr('fk_error'),
            $meta->{visible}        = \@visible_cols;
   $meta->{wake_up}    = $clock + $sleep_time;
         =~ m/FOREIGN\s+KEY\s*\(`?$n`?\)\s+REFERENCES\s+(?:`?$n`?\.)?`?$n`?\s*\(`?$n`?\)/i;
Michiel Betel,
   # might be many tablespaces with insert buffers.  (In practice I believe
might only display in the mode that caused the error, depending on the mode and
# migrate_config {{{3
         migrate_config($old_filename, $conf_file);
milliseconds to optimize queries.  You might not have seen this pattern if you
         : min(scalar(@$display_lines), $this_term_size[1]);
               = min($this_term_size[1], $config{max_height}->{val});
            minw  => 0,
   minw    => 0,
#    * minw, maxw Auto-generated, user-overridable.
minw: specifies a minimum display width.  This helps stabilize the display,
      MKDEBUG && _d('Adding extra property ' . $opt->{key});
         MKDEBUG && _d("Bad DSN part: $dsn_part");
         MKDEBUG && _d("Copying value for $key from defaults");
         MKDEBUG && _d("Copying value for $key from previous DSN");
         MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
   MKDEBUG && _d('DBH info: ',
            MKDEBUG && _d("$dbh: $sql");
      MKDEBUG && _d("$dbh: $sql");
   MKDEBUG && _d($dsn);
            MKDEBUG && _d('Enabling charset for STDOUT');
         MKDEBUG && _d($EVAL_ERROR);
      MKDEBUG && _d("Finding value for $key");
            MKDEBUG && _d("Going to try again without utf8 support");
         MKDEBUG && _d("Interpreting $dsn_part as $prop_autokey=$dsn_part");
      MKDEBUG && _d('No DSN to parse');
   MKDEBUG && _d("Parsing $dsn");
      MKDEBUG && _d("Setting $prop property");
   MKDEBUG && $self->print_active_handles($dbh);
      mkdir $dirname
      mkdir($dirname) or die "Can't create directory '$dirname': $OS_ERROR";
      mkdir "$dirname/plugins"
      mkdir("$dirname/plugins") or die "Can't create directory '$dirname/plugins': $OS_ERROR";
      =~ m/^mysql tables in use $d, locked $d$/m;
      =~ m#\n(---+)\n([A-Z /]+)\n\1\n(.*?)(?=\n(---+)\n[A-Z /]+\n\4\n|$)#gs;
   mode => {
   # mode changes.
# Mode functions{{{2
   # Mode keys
         $modeline,
            $modes{$config{mode}->{val}}->{connections} = [ keys %connections ];
modes don't pay attention to it.
      $modes{$key}->{connections} = [ @parts ] if exists $modes{$key};
         ? $modes{$mode}->{action_for}->{$char}->{action}
      : @{$modes{$mode}->{connections}};
   $modes{$mode}->{connections} = \@chosen;
   $modes{$mode}->{connections} = [ $cxns[$newpos] ];
         $modes{$mode}->{connections} = [ grep { exists $connections{$_} } @choices ];
      $modes{$mode}->{cust}->{visible_tables} = 1;
   $modes{$mode}->{cust}->{visible_tables} = 1;
      $modes{$mode}->{display_sub}->();
                         . $modes{$mode}->{hdr} . " (? for help)";
   modes         => \%modes,
   $modes{$mode}->{server_group} = '';
         $modes{$mode}->{server_group} = $choices[0];
   $modes{$mode}->{server_group} = ''; # Clear this because it overrides {connections}
      $modes{$mode}->{server_group} = $group;
      $modes{$mode}->{server_group} = $grps[0];
      $modes{$mode}->{server_group} = $grps[ ($pos + 1) % @grps ];
   $modes{$mode}->{server_group} = $new if exists $server_groups{$new};
        @{$modes{$mode}->{visible_tables}};
      $modes{$mode}->{visible_tables} =
   $modes{$mode}->{visible_tables} =
      $modes{$mode}->{visible_tables} = [ grep { $_ ne $table } @$visible ];
mode-specific at some point.  Right now it is honored a bit inconsistently; some
         "%-${mode_width}s %${remaining_width}s",
   # mode will get displayed as long as we're in this mode, but get ignored if the
mode with the '+' and '-' keys.  It is used in the L<"set_precision">,
modify data other plugins use or modify.
   $mods += $query =~ s/^
   $mods += $query =~ s/\s+on\s+duplicate\s+key\s+update.*$//is;
   $mods += $query =~ s/^\s*(?:replace|insert).*?select/select/is;
module for connecting to a server.  It is usually of the form
modules are not loaded.  Term::ReadKey is still used, since innotop may have to
# module to try to handle.
monitoring a large group or many connections, you may notice increased delay
monitoring your server.  You may not see any effects, but some innotop users
monitor many servers at once with innotop. 
more human-friendly.  The description is a comment line of the form "#
      =~ m/OS thread id \d+(?: ([^,]+?))?(?:, thread declared inside InnoDB $d)?$/m;
moves the highlight up or down.  You can then (d)elete or (e)dit the highlighted
      =~ m/Per second averages calculated from the last $d seconds/;
                  =~ m/query id \d+(?: ([A-Za-z]\S+))?(?: $w(?: (.*))?)?$/m;
            =~ m/^(?:Record lock, heap no $d )?([A-Z ]+): n_fields $d; compact format; info bits $d$/m;
            =~ m/^(?:Record lock, heap no $d )?([A-Z ]+): n_fields $d; $d-byte offs [A-Z]+; info bits $d$/m;
            =~ m/^(?:Record lock, heap no $d )?([A-Z ]+): n_fields $d; $d-byte offsets; info bits $d$/m;
         =~ m{^(RECORD|TABLE) LOCKS? (?:space id $d page no $d n bits $d index `?$n`? of )?table `$n(?:/|`\.`)$n` trx id $t lock.mode (\S+)}m;
      =~ m/^The index in the foreign key in table is $n$/m;
      =~ m/Transaction:\n(TRANSACTION.*)\nForeign key constraint fails/s;
      =~ m/^(?:---)?TRANSACTION $t, (\D*?)(?: $d sec)?, (?:process no $d, )?OS thread id $d/m;
      =~ m/^------- TRX HAS BEEN WAITING $d SEC/m;
      =~ m/^Trx read view will not see trx with id >= $t, sees < $t$/m;
   mutex_os_waits              => { hdr => 'Waits',               num => 1, label => 'Mutex OS Waits' },
         mutex_os_waits     => { src => 'IB_sm_mutex_os_waits' },
   mutex_spin_rounds           => { hdr => 'Rounds',              num => 1, label => 'Mutex Spin Rounds' },
            mutex_spin_rounds mutex_spin_waits rw_excl_spins rw_shared_os_waits
         mutex_spin_rounds  => { src => 'IB_sm_mutex_spin_rounds' },
   mutex_spin_waits            => { hdr => 'Spins',               num => 1, label => 'Mutex Spin Waits' },
         mutex_spin_waits   => { src => 'IB_sm_mutex_spin_waits' },
            $mvs{$col}    = max($mvs{$col} || 1, $set->{$col});
      $mvs{$key} = $val;
         my ( $a, $b ) = @_;
      my $action
   my ( $action ) = @_;
my %action_for = (
   my %actions = (
   my @actions = sort grep { m/[a-z]/   } keys %keys;
   my @adaptive_hash_index;
my %agg_funcs = (
         my $agg = $meta->{cols}->{$col}->{agg} || 'first';
      my $aggregated = $meta->{aggregate};
   my @all_actions = map { "$_  $keys{$_}" } @actions;
         my %all_cols     = %{ $tbl_meta{$tbl}->{cols} };
   my @all_magic = map { sprintf('%4s', $action_for{$_}->{key} || $_) . "  $keys{$_}" } @magic;
   my @all_modes = map { "$_  $modes{$_}->{hdr}" } @modes;
my %ansicolors = map { $_ => 1 }
         my $answer;
   my $answer = prompt("Are you sure you want to proceed?  Say 'y' if you do");
      my $answer = prompt("Do you want to specify a password for $connection?", undef, 'n');
      my $answer = prompt("Do you want to specify a username for $connection?", undef, 'n');
         my $answer = prompt("Save password in plain text in the config file?", undef, 'y');
      my $answer = prompt("There is no connection called '$new'.  Create it?", undef, "y");
      my $answer = prompt("There is no filter called '$new'.  Create it?", undef, 'y');
         my $answer = prompt("There is no server group called '$new'.  Create it?", undef, "y");
   my $answer = $term->readline("$question: ", $init);
      my $aref = $tbl_meta{$tbl}->{filters};
      my $aref = $tbl_meta{$tbl}->{group_by};
      my $aref = $tbl_meta{$tbl}->{visible};
         my $arg;
      my @args = grep { defined $_ } @_;
      my $arr  = $stmt->fetchall_arrayref({});
      my ( $attempted_op, $index, $records )
      my ( $attempted_op, $which, $index )
   my @available = sort keys %connections;
   my @available = sort keys %server_groups;
my $bool_regex    = qr/^[01]$/;
            my $buffer;
   my @buffer_pool;
my %builtin_filters = (
   my @candidates = grep {
      my $cap_len = length($caption);
   my ( $caption, @rows ) = @_;
my %cfg_editor_action = (
   my ( $cfg_var, $dir ) = @_;
            my $cfg_ver          = sprintf('%03d-%03d-%03d', $maj, $min, $rev);
my $char;
   my $char = ReadKey(0);
   my $charset = $config{charset}->{val};
      my %children;
         my $choice = prompt_list(
   my $choices = prompt_list(
   my $choices = prompt_list("Choose connections or a group for $mode mode",
   my @choices = unique(grep { $_ } split(/\s+/, $choices));
   my @choices = unique(split(/\s+/, $val));
   my @chosen = choose_or_create_connection($cxns, 'for this mode');
   my ( $class, @opts ) = @_;
    my ( $class, %vars ) = @_;
   my $clear = `clear`;
my $clearing_deadlocks  = 0;
my $clear_screen_sub;
my $clock               = 0;   # Incremented with every wake-sleep cycle
   my ( $cmd, $all, $hint, $cxns ) = @_;
my %cmdline =
   my @cmd_summary;
   # my $cmp
         my $col;
    my $col = {
   my @col1 = splice(@all_modes, 0, ceil(@all_modes/3));
   my @col2 = splice(@all_modes, 0, ceil(@all_modes/2));
         my $col_def = $table->{cols}->{$col_name};
      my $col_def = $table->{cols}->{$col_name};
            my $col_name  = $_;
         my $color;
my %color_editor_action = (
      my @colors = unique(grep { exists $ansicolors{$_} } split(/\W+/, $parts{color}));
my %col_props = (
      my ( $col , $rest ) = $line =~ m/^(.*?)=(.*)$/;
                  my $col = $row->{$col_name};
   my %cols;
      my $col_sep = $opts{n} ? "\t" : '  ';
         my $col = "set_$i";
   my ( $cols, $hints );
   my ( $cols, $info, $data, $prefs ) = @_;
   my ( $cols, $labels, $data, $user_prefs ) = @_;
      my $cols = $meta->{cols};
   my $cols   = $meta->{cols};
      my @cols = 'name';
   my @cols = ('', qw(class desc active));
      my @cols = ('', qw(col op arg color));
      my @cols = ('', qw(name hdr label src));
   my $cols  = $table->{cols};
   my ( $cols, $visible );
      my $col = $tbl_meta{$tbl}->{sort_cols};
      my ( $col, $text ) = split(/\s+/, $response, 2);
my %columns = (
   my $completion = sub { keys %{$tbl_meta{$tbl}->{cols}} };
my %comp_ops = (
my %config = (
   my %config_choices
my %config_file_sections = (
my @config_versions = (
   my ( $connection, $destroy ) = @_;
my %connections;
      my @connections = get_connections($mode);
   my @connections = $modes{$mode}->{server_group}
      my %conn  = map { $_ => $parts{$_} || '' } @conn_parts;
my @conn_parts = qw(user have_user pass have_pass dsn savepass dl_table);
      my @conns = choose_or_create_connection($cxns, 'for this group');
   my @criteria;
   my $cur      = $config{$cfg_var}->{val};
   my ($cur)    = get_connections($mode);
my @current_queries;
   my $current = ref($config{$key}->{val}) ? join(" ", @{$config{$key}->{val}}) : $config{$key}->{val};
      my @current = @{$tbl_meta{$tbl}->{filters}};
   my $curr = join(', ', @{$meta->{group_by}});
   my $curr = $modes{$mode}->{server_group};
   my %curr  = %server_groups;
   my $curr_val = $stmt_sleep_time_for{$stmt} || 0;
               my $cur_thd = $cur_threads->{$key};
            my $cur_threads = $set->{IB_io_threads};
            my $cur_txn = $cur_txns{$thd_id};
         my %cur_txns = map { $_->{mysql_thread_id} => $_ } @$cur_txns;
         my $cur_txns = $set->{IB_tx_transactions};
   my $cur = $vars->{$clock - $offset};
         my $cur  = $vars{$cxn}->{$clock-$set};
   my ( $cxn ) = @_;
   my $cxn = '';
   my ( $cxn, $err ) = @_;
   my ( $cxn ) = get_connections();
   my $cxn   = $info->{cxn};
   my ( $cxn, $query ) = @_;
   my @cxns = @_;
   my @cxns;
   my ( $cxns, $addl_sections ) = @_;
   my ( $cxn ) = select_cxn('Clear on which server? ');
   my ( $cxn ) = select_cxn('On which server', @cxns);
   my @cxns = get_connections();
   my @cxns    = get_connections();
   my @cxns          = get_connections();
   my @cxns             = get_connections();
   my $cxns = join(' ', get_connections());
      my $cxns  = join(' ', @{$server_groups{$new}});
   my ( $cxns, $prompt ) = @_;
   my @cxns = sort { $a cmp $b } get_connections();
   my @cxns     = sort keys %connections;
   my ( $cxn, $stmt_name, @args ) = @_;
   my @cxns = unique map { $_->{cxn} } @candidates;
            my $data = [];
            my $data = $meta->{colors} || [];
      my ( $dbh ) = @_;
   my $dbh;
         my $dbh = connect_to_db($cxn);
   my $dbh = DBI->connect(
      my $dbh = get_new_db_connection($cxn);
      my $dbh = get_new_db_connection($cxn, 1);
my %dbhs;
   my ( $dbh, $target ) = @_;
   my $db    = $info->{db};
   my @deadlock_locks;
   my @deadlock_transactions;
   my ( $debug, $msg ) = @_;
   my $defaults = {
         my $dest = $idx == 0 ? scalar(@{$meta->{colors}} - 1) : $idx - 1;
         my $dest = $idx == scalar(@{$meta->{colors}} - 1) ? 0 : $idx + 1;
         my $df = "''";
         my $df = $tbl->{cols}->{$name}->{num} ? "0"   : "''";
   my $digits = $config{num_digits}->{val};
   my $dir = $config{plugin_dir}->{val};
         my ( $dir, $name ) = $col =~ m/([+-])?(\w+)$/;
   my $dirname  = dirname($conf_file);
      my $dirname = dirname($new_filename);
   my $dir = shift;
            my @display_lines = '';
            my @display_lines = (
         my @display_lines = '';
      my @display_lines = '';
      my @display_lines;
   my @display_lines = ('');
   my @display_lines;
            my @display_lines = create_table(\@cols, $info, $data);
         my @display_lines = create_table(\@cols, $info, \@rows);
   my @display_lines = no_ctrl_char($info->{query});
   my ( $display_lines, $prefs ) = @_;
   my @display_lines = ( '', 'Switch to a different mode:' );
   my ( $dl, $complete, $debug, $full ) = @_;
      my $dl_table = prompt("Optional: enter a table (must not exist) to use when resetting InnoDB deadlock information",
my $d  = qr/(\d+)/;                    # Digit
   my $driver = $self->prop('dbidriver') || '';
   my $dsn;
   my $dsn = $connections{$connection}
my $dsn_parser = new DSNParser();
   my ( $dump, $complete, $debug ) = @_;
      my $engine = version_ge($dbhs{$cxn}->{dbh}, '4.1.2') ? 'engine' : 'type';
         my $err_count = grep { $dbhs{$_} && $dbhs{$_}->{err_count} } @cxns;
   my ( $err, $sub, $body );
my %event_listener_for = map { $_ => [] }
   my ( $expr ) = @_;
my %exprs = (
   my @exps = $str =~ m/\s*([^,]+(?i:\s+as\s+[^,\s]+)?)\s*(?=,|$)/g;
   my @fields = $dump =~ m/ (\d+:.*?;?);(?=$| \d+:)/gm;
   my ( $file ) = @_;
my $file_data     = undef; # Last chunk of text read from file
   my @file_io_misc;
my $file_mtime    = undef; # Status of watched file
      my $filename = shift @ARGV;
   my $file = shift;
my $file          = undef; # File to watch for InnoDB monitor output
my %filters = ();
   my $filters = $tbl_meta{$tbl}->{filters};
   my ( $filter, $tbl ) = @_;
   my %final_props;
      my $first_table = 0;
   my $first_table = 0;
my %fk_parser_for = (
      my @fk_table = create_table2(
my $fl = qr/([\w\.\/]+) line $d/;      # Filename and line number
   my ($fmt_cols, $fmt_meta);
   my $fmt  = get_var_set('S_set');
   my $force = defined $opts->{force};
         my $format
         my $format = join( $col_sep,
         my $format = "%-${max_width}s$pad%${max_r}s";
         my $format   = $opts{n} ? ( "%s\t" x $num_cols ) : ( "%-${width}s " x $num_cols );
      my $format    = "%$p->{just}${max_l}s$p->{sep} %$p->{just1}${max_v}s";
my $f  = qr/(\d+\.\d+)/;               # Float
   my @full_processlist = get_full_processlist(@cxns);
   my $fulltext = $dl->{'fulltext'};
   my $fulltext = $section->{'fulltext'};
   my ( $func ) = @_;
   my $func = $config{S_func}->{val};
      my ($func, $err) = compile_expr($text);
         my $g_format = $opts{n} ? ( "%s\t" x $num_cols ) : ( "%-${width}s " x $num_cols );
   my %given_props;
   ( my $got_all ) = $fulltext =~ m/END OF INNODB MONITOR OUTPUT/;
   my ( $grep_cond ) = @_;
   my ( $grep_cond, $prompt ) = @_;
      my $group_key
   my $group = $modes{$mode}->{server_group};
   my ( $group, $prompt ) = @_;
      my $group = $temp_table{$key};
   my @grps = sort keys %server_groups;
               my %hash;
      my $hash = {};
      my %hash;
               my $hash = extract_values($cur_thd, $cur_thd, $pre_thd, 'io_threads');
            my $hash    = extract_values($cur_txn, $cur_txn, $pre_txn, 'innodb_transactions');
            my $hash = extract_values($inc, $set, $pre, 'q_header');
                     my $hash = extract_values($lock, $lock, $lock, 'deadlock_locks');
         my $hash = extract_values($set, $set, $pre, 'q_header');
         my $hash = extract_values($set, $set, $pre, 't_header');
                  my $hash = extract_values($txn->{tx}, $txn->{tx}, $pre->{tx}, 'deadlock_transactions');
         my $hash = extract_values($vars, $cur, $pre, 'var_status');
            my $hash = extract_values($wait, $wait, $wait, 'wait_array');
               my %hash = map { $_ => $txn->{$_} } qw(txn_id mysql_thread_id lock_wait_time active_secs);
         my $hash = $vars{$cxn}->{$clock};
   my $has_read_view = defined($txn_doesnt_see_ge);
my $have_color    = 0;
         my $hdr;
         my @hdr = @$visible;
         my $header = $innodb_section_headers{$section};
   my ( $high, $low ) = $num =~ m/^(\d+) (\d+)$/;
   my ( $hostname, $one ) = $dbh->selectrow_array(
my $h  = qr/((?:0x)?[0-9a-f]*)/;       # Hex
      my $href = $connections{$conn};
   my $href = $dbhs{$cxn};
   my $i = 0;
      my $ibinfo = '';
   my ( $id, $nullsize, $len, $hex, $asc, $truncated );
   my ( $id, $tbl, $cxn ) = @_;
         my $idx          = 0;
   my $inc  = $func eq 'g' || $config{status_inc}->{val};
            my $inc = inc(0, $cxn);
      my $inc  = inc(0, $cxns[0]);
      my $inc; # Only assigned to if wanted
   my $incvar  = $config{status_inc}->{val};
   my $info;
   my $info = choose_thread(
      my $info = $cols->{$key}
my %info_gotten = (); # Which things have been retrieved for the current clock tick.
      my $info = { map { $_ => { hdr => $_, just => '-', } }  @cols };
   my $info = { map { $_ => { hdr => $_, just => '-', } }  @cols };
   my $info = shift;
   my $ini = join(' ', @{$meta->{filters}});
               my $ini = ref $col_props{$answer} ? join(' ', @{$meta->{$answer}}) : $meta->{$answer};
   my %innodb_data = (
   my @innodb_locks;
my $innodb_parser = InnoDBParser->new;
my %innodb_section_headers = (
   my %innodb_sections;
         my %innodb_status = (
   my $innodb_status
         my $innodb_status_text;
      my $innodb_status = $vars{$cxn}->{$clock};
   my $innodb_status = $vars{$cxn}->{$clock};
   my @innodb_transactions;
my $innotop_license = <<"LICENSE";
            my $innotop_ver      = sprintf('%03d-%03d-%03d', $maj, $min, $rev);
   my @insert_buffers;
my $int_regex     = qr/^\d+$/;
   my @io_threads;
my $i  = qr/((?:\d{1,3}\.){3}\d+)/;    # IP address
   my $i = scalar(@$left) - 1;
   my %is_group = map { $_ => 1 } @$group_by;
         my %is_group = map { $_ => 1 } @{$meta->{group_by}};
my %is_proc_info = (
           my $key = $_;
      my $key;
   my ( $key ) = @_;
   my $key = '';
   my $key;
   my $key = prompt_list(
      my ( $key , $rest ) = $line =~ m/^(.*?)=(.*)$/;
      my ( $key, $rest ) = $line =~ m/^(.+?)=(.*)$/;
   my $key = shift;
      my @keys = $href->{savepass} ? @conn_parts : grep { $_ ne 'pass' } @conn_parts;
   my %keys = map {
      my ( $key , $val ) = split('=', $line);
   my %labels = map { $_ => $meta->{cols}->{$_}->{hdr} } @{$meta->{visible}};
my @last_term_size; # w_chars, h_chars, w_pix, h_pix
         my $last_val = $val - ($pre->{$key} || 0);
         my $left = int(($width - 2 - $cap_len) / 2);
            my $left = int(($width - $cap_len) / 2);
   my ( $left, $right, $user_prefs ) = @_;
my $lines_printed       = 0;
   my $locks;
   my ( $lock_wait_status, $lock_structs, $heap_size, $row_locks, $undo_log_entries )
   my ( $lock_wait_time )
   my $log_name = $master_logs[$min_log]->{log_name};
   my @log_statistics;
   my ( $long, $short ) = $spec->{s} =~ m/^(\w+)(?:\|([^!+=]*))?/;
      my $long  = $spec->{n} ? "[no]$spec->{l}" : $spec->{l};
                  my ( $l, $r ) = $col =~ m/^([\s\d]*)(.*)$/;
   my @magic   = sort grep { m/[^A-Z]/i } keys %keys;
   my @master_logs = get_master_logs($master);
   my %master_logs = map { $_->{log_name} => $i++ } @master_logs;
   my ( $master ) = select_cxn('Which master?', @masters );
   my @masters = map { $_->{cxn} } grep { $_->{file} } @vars;
   my @master_status;
   my ($master_status) = grep { $_->{cxn} eq $master } @vars;
   my @matches = $fulltext
   my $max1 = max(map {length($_)} @col1);
   my $max2 = max(map {length($_)} @col2);
      my $max_i_in_common = min($i + scalar(@$right) - 1, scalar(@$left) - 1);
   my $max = length($text) - $len;
      my $max_lines = $prefs->{show_all}
      my $max_l = max(map{ length($labels->{$_}) } @$cols);
   my $max_l = $this_term_size[0] - $max_r - length($pad);
      my $max_name = max(map { length($_) } keys %$hints );
   my $max_r = max( map { length($_) } @$right) || 0;
               my $max_rodp = max(0, map { $_->{$col_name} =~ m/([^\s\d-].*)$/ ? length($1) : 0 } @$data);
my $MAX_ULONG     = 4294967295; # 2^32-1
      my $max_v = max(map{ length($data->{$_}) } @$cols);
            my $max_width = max( length($info->{$_}->{hdr}), map { length($_->{$col_name}) } @$data);
      my $max_width = max( map { length($_) } @{$left}[$i..$max_i_in_common]);
   my $maxw = max(map { length($_->{l}) + ($_->{n} ? 4 : 0)} @opt_spec);
   my $meta = $dbhs{$cxn};
   my $meta  = $dbhs{$cxn};
   my $meta    =  { map { $_ => $connections{$_}->{dsn} } keys %connections };
      my @meta_rows = create_table2(
         my $meta = $tbl_meta{$tbl};
         my $meta         = $tbl_meta{$tbl};
      my $meta = $tbl_meta{$tbl};
   my $meta = $tbl_meta{$tbl};
   my $meta   = $tbl_meta{$tbl};
         my $meta = $tbl_meta{$tbl}->{cols}->{$col};
   my $meta = $tbl_meta{$tbl} or die "No such table $tbl in tbl_meta";
      my $meta = $tbl_meta{$tbl} or die "There's no table in tbl_meta named $tbl";
   my $min_log = min(map { $master_logs{$_->{master_log_file}} } @slave_status);
   my $min = $max - 1;
      my $min_width = 4;
      my $mode = $config{mode}->{val};
   my $mode = $config{mode}->{val};
   my $mode  = $config{mode}->{val};
   my $mode    = $config{mode}->{val};
   my $mode     = $config{mode}->{val};
      my $mode = $config{mode}->{val} || 'Q';
      my ( $mode, $group ) = $line =~ m/^(.*?)=(.*)$/;
   my $modeline        = ( $config{readonly}->{val} ? '[RO] ' : '' )
      my ( $mode, $rest ) = $line =~ m/^(.*?)=(.*)$/;
my %modes = (
   my $mode = shift;
   my $mode = shift || $config{mode}->{val};
   my @modes   = sort grep { m/[A-Z]/   } keys %keys;
   my ( $mode, $table ) = @_;
   my $mode_width      = length($modeline);
   my $mods = 0;
   my ( $mods, $query ) = rewrite_for_explain($info->{query});
                     my $msg = "innotop's config file format has changed.  Overwrite $conf_file?  y or n";
   my $msg = shift;
my %mvs = (
   my ( $mysql_thread_id, $query_id, $hostname, $ip, $user, $query_status );
   my $n = 0;
   my ( $name ) = @_;
   my $name = $config{"${mode}_set"}->{val};
   my ( $name, $dsn, $dl_table, $have_user, $user, $have_pass, $pass, $savepass ) = @_;
      my $name = "quick_$tbl.$col";
      my ( $name, $rest ) = $line =~ m/^(.*?)=(.*)$/;
      my ( $name, $val ) = $line =~ m/^(.+?)=(.*)$/;
   my $new   = '';
   my $new   = choose_or_create_server_group($group, 'for this mode');
   my $new   = choose_or_create_server_group($group, 'to edit');
   my $new_cxns = prompt_list(
   my $newpos   = ($pos + 1) % @cxns;
   my $newpos   = ($pos + $dir) % @var_sets;
   my $new  = prompt_list(
      my %new_row;
   my @new_rows;
   my @new = unique(grep { !exists $connections{$_} } split(/\s+/, $new_cxns));
   my $new_val  = prompt('Specify a sleep delay after calling this SQL', $num_regex, $curr_val);
   my $new_value = prompt('Enter a value', $config{$key}->{pat}, $current);
   my $new_value = prompt_list(
   my $new = $variables;
my $nonfatal_errs = join('|',
   my @non_grp  = grep { !$is_group{$_} } keys %{$meta->{cols}};
my $n  = qr/([^`\s]+)/;                # MySQL object name
   my ( $num ) = @_;
         my $num_cols = scalar(@$visible);
   my $num_digits = defined $opts->{num_digits}
      my $num_lines = 0;
   my ( $num, $opts ) = @_;
   my ( $num, $precision ) = @_;
my $num_regex     = qr/^[+-]?(?=\d|\.)\d*(?:\.\d+)?(?:E[+-]?\d+|)$/i;
         my $num_rules = scalar @{$tbl_meta{$tbl}->{colors}};
   my $num_sets
   my $num = shift;
      my $obj;
   my ( $offset, $cxn ) = @_;
   my $offset = $i;
   my ($old_filename, $answer);
   my ($old_filename, $new_filename) = @_;
         my $op;
         my $op = 'cmp';
   my @open_tables   = get_open_tables(@cxns);
         my $op = $tbl->{cols}->{$name}->{num} ? "<=>" : "cmp";
my %opts = (
my %opt_seen;
my @opt_spec = (
   my %opts = %{$self->{opts}};
my @ordered_config_file_sections = qw(general plugins filters active_filters tbl_meta
   my $orig = $query;
      my $p = {
   my $p = {
      my ($package, $desc);
   my ($package, undef, $line) = caller 0;
   my $pad = defined $opts->{pad} ? $opts->{pad} : '';
   my $pad   = $p->{pad};
   my @page_statistics;
     my @params = $dsn_parser->get_cxn_params(\%opts); # dsn=$params[0]
my %parser_for = (
      my @parts = grep { exists $connections{$_} } split(/ /, $rest);
      my @parts = grep { exists($tbl_meta{$key}->{cols}->{$_}) } unique split(/ /, $rest);
      my %parts = $rest =~ m/(\S+?)=(\S*)/g;
      my %parts = $rest =~ m/(\w+)='((?:(?!(?<!\\)').)*)'/g; # Properties are single-quoted
      my %parts = $rule =~ m/(\w+)='((?:(?!(?<!\\)').)*)'/g; # Properties are single-quoted
   my $parts = shift;
      my @parts = unique(grep { exists($filters{$_}) } split(/\s+/, $rest));
      my @parts = unique(grep { exists($tbl_meta{$tbl}->{cols}->{$_}) } split(/\s+/, $rest));
      my $part = version_ge($dbhs{$cxn}->{dbh}, '5.1.5') ? 'PARTITIONS' : '';
   my @pending_io;
         my $pid = fork();
         my $pid = waitpid($children{$child}, 0);
my %pluggable_vars = (
my %plugin_editor_action = (
         my $plugin = $plugins->[$idx];
my %plugins = (
         my ( $plugins, $idx ) = @_;
      my $pos = 0;
   my $pos      = grep { $_ lt $cur } @cxns;
   my $pos      = grep { $_ lt $cur } @var_sets;
   my $prefix = qr/^$config{cmd_filter}->{val}/; # TODO: this is a total hack
               my $pre = $prev_status->{IB_dl_txns}->{$txn_id} || $txn;
               my $pre_thd = $pre_threads->{$key} || $cur_thd;
            my $pre_threads = $pre->{IB_io_threads} || $cur_threads;
            my $pre_txn = $pre_txns{$thd_id} || $cur_txn;
         my %pre_txns = map { $_->{mysql_thread_id} => $_ } @$pre_txns;
         my $pre_txns = $pre->{IB_tx_transactions} || $cur_txns;
   my $pre = $vars->{$clock - $offset - 1};
         my $pre = $vars{$cxn}->{$clock-1} || $set;
      my $pre = $vars{$cxn}->{$clock-1} || $set;
      my $pre  = $vars{$cxn}->{$clock - 1} || $set;
         my $pre  = $vars{$cxn}->{$clock-$set-1} || $cur;
      my $prev_status   = $vars{$cxn}->{$clock-1} || $innodb_status;
   my @processlist;
   my ( $prompt ) = @_;
   my ( $prompt, @cxns ) = @_;
   my ( $prompt, $regex, $init, $completion ) = @_;
   my $prop_autokey = $self->prop('autokey');
         my @prop = qw(hdr label src just num minw maxw trans agg); # TODO redundant
   my @q_header;
   my ( $q_or_c ) = @_;
      my $qps    = ($inc->{Questions}||0) / ($inc->{Uptime_hires}||1);
   my $query = shift;
   my ( $query_text )
   my ( $question, $init, $completion, $hints ) = @_;
            my $queue = $event_listener_for{$event};
   my $quoted = quotemeta($expr);
   my $remaining_width = $this_term_size[0] - $mode_width - 1;
         my $res;
         my %res = map {  $_ =~ s/ +/_/g; $_ } $dbhs{$cxn}->{dbh}->{mysql_stat} =~ m/(\w[^:]+): ([\d\.]+)/g;
   my $response;
      my $response = prompt_list(
         my $res = $sth->fetchall_arrayref();
         my $res = $sth->fetchall_arrayref({});
         my $res = $stmt->fetchall_arrayref({})->[0];
   my @result;
   my $result = {};
   my $result;
   my %result;
   my @result = unique(grep { my $a = $_; grep { $_ eq $a } @cxns } split(/\s+/, $choices));
   my $retries = 1;
   my @row_operation_misc;
   my @row_operations;
      my @rows;
   my @rows = ();
   my @rows;
   my %rows_for = (
   my @rows = map { $plugins{$_} } sort keys %plugins;
            my $row = sprintf($format, map { trunc($item->{$_}, $width_for{$_}) } @$cols );
   my @rows = @$rows;
   my ( $rows, $tbl ) = @_;
   my %rule_set_for;
         my @rules = @{ $tbl_meta{$tbl}->{colors} };
         my ( $search_index, $records );
   my ( $secs, $fmt ) = @_;
   my ( $section, $complete, $debug, $full ) = @_;
   my ( $section, $complete, $debug, $fulltext, $full ) = @_;
   my @sections
      my %sections_required =
   my %seen;
   my $selected;
      my $selected_column;
      my $selected_rule;
    my ( $self ) = @_;
   my ( $self ) = @_;
   my $self = {
    my $self = bless { %vars }, $class;
   my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
   my ( $self, $dbh ) = @_;
   my ( $self, $dbh, $dsn ) = @_;
   my ( $self, $dsn ) = @_;
   my ( $self, $dsn, $prev, $defaults ) = @_;
   my ( $self, $fulltext, $debug, $sections, $full ) = @_;
   my ( $self, $info ) = @_;
   my ( $self, $prop, $value ) = @_;
    my ( $self, $rows, $tbl ) = @_;
   my ( $self, $thing, $level ) = @_;
   my @semaphores;
my %server_groups;
    my ( $set ) = @_;
      my $set  = $config{status_inc}->{val} ? inc(0, $cxn) : $vars{$cxn}->{$clock};
         my (\$set, \$cur, \$pre) = \@_;
    my ( $set, $cur, $pre ) = @_;
   my ( $set, $cur, $pre, $tbl ) = @_;
      my $sets = $config{num_status_sets}->{val};
         my $set = $vars{$cxn}->{$clock};
      my $set = $vars{$cxn}->{$clock};
      my $set = $vars{$cxn}->{$clock} or next;
   my $setvars = $self->prop('setvars');
         my $set = $var_status[0];
      my $short = $spec->{t} ? "-$spec->{t}" : '';
   my @slave_io_status;
   my @slaves = map { $_->{cxn} } @slave_status;
   my @slave_sql_status;
   my @slave_status = grep { $_->{master_host} } @vars;
   my $sleep_time      = $meta->{this_sleep} + $meta->{prev_sleep};
      my $sort_func = sub {
         my $split = int(@meta_rows / 2);
            my $sql = "/*!40101 SET NAMES $charset*/";
MySQL AB,
      mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
MySQL.  It displays queries, InnoDB transactions, lock waits, deadlocks,
         . ';mysql_read_default_group=client';
   'MySQL server has gone away',
      my $sql = "SET $setvars";
         ^MySQL\sthread\sid\s[^\n]+\n           # This comes before the query text
   mysql_thread_id             => { hdr => 'ID',                  num => 1, label => 'MySQL connection (thread) ID', },
      mysql_thread_id    => $mysql_thread_id,
      ( $mysql_thread_id, $query_id ) = $thread_line =~ m/^MySQL thread id $d, query id $d/m;
         mysql_thread_id => { src => 'id',         minw => 6,  maxw => 0 },
         mysql_thread_id  => { src => 'mysql_thread_id' },
         mysql_thread_id    => { src => 'mysql_thread_id' },
my $s  = qr/(\d{6} .\d:\d\d:\d\d)/;    # InnoDB timestamp
         my ( $src, $sub, $err );
            my @stat = stat($file);
   my $sth;
         my $sth = do_query($cxn, $cmd);
         my $sth = do_query($cxn, $query);
         my $sth = do_query($cxn, 'SHOW WARNINGS');
         my $sth = do_stmt($cxn, 'SHOW_STATUS') or next;
            my $stmt = do_stmt($cxn, 'INNODB_STATUS') or next;
      my $stmt = do_stmt($cxn, 'OPEN_TABLES') or next;
      my $stmt = do_stmt($cxn, 'PROCESSLIST') or next;
         my $stmt = do_stmt($cxn, 'SHOW_MASTER_LOGS') or next;
         my $stmt = do_stmt($cxn, 'SHOW_MASTER_STATUS') or next;
my %stmt_maker_for = (
   my $stmt = prompt_list('Specify a statement', '', sub { return sort keys %stmt_maker_for });
   my $stmt = "PURGE MASTER LOGS TO '$log_name'";
      my @stmts = (
my %stmt_sleep_time_for = ();
   my ($str) = @_;
   my %stuff = (
      my $stuff = parse_tx_text( $txn, $complete, $debug, $full );
      my $style = $dump =~ m/compact format/ ? 'new' : 'old';
   my ( $sub, $err );
         my ( $sub, $err ) = compile_expr($col_def->{src});
   my ( $sub, $err ) = compile_filter($builtin_filters{$key}->{text});
      my ( $sub, $err ) = compile_filter( "defined \$set->{$col} && \$set->{$col} =~ m/$text/" );
      my ( $sub, $err ) = compile_filter($parts{text});
   my $sub = eval 'sub { my ( $set ) = @_; if ' . join(" elsif ", @criteria) . '}';
   my $sub = eval 'sub { sort {' . join("||", @criteria) . '} @_; }';
   my $success = 0;
   my ( $tables_in_use, $tables_locked )
   my @tables = map { extract_values($_, $_, $_, 'open_tables') } @open_tables;
      my $tables = $modes{$mode}->{visible_tables};
   my $table = $tbl_meta{$table_name};
         my ( $tbl ) = @_;
   my ( $tbl ) = @_;
   my $tbl = choose_visible_table(
   my $tbl = choose_visible_table();
         my ( $tbl, $col ) = @_;
   my $tbl = $connections{$cxn}->{dl_table};
my %tbl_editor_action = (
   my ( $tbl, $filter ) = @_;
   my ( $tbl, $group_by, @rows ) = @_;
         my ( $tbl, $idx ) = @_;
my %tbl_meta = (
    my $tbl_meta = $vars{tbl_meta};
      my $tbl  = $parts{tbl}     or die "There's no table for tbl_meta $col";
      my ( $tbl , $rest ) = $line =~ m/^(.*?)=(.*)$/;
      my ( $tbl, $rule ) = $line =~ m/^(.*?)=(.*)$/;
   my @tbls
   my $tbl = shift;
      my $tbls = join(" ", @{$filters{$key}->{tbls}});
   my @tbls = @{$modes{$mode}->{visible_tables}};
      my @tbls = unique(split(/\s+/, $parts{tbls}));
   my $tbl = $tbls[0];
         my $temp = $meta->{colors}->[$idx];
   my %temp_table;
my $term          = undef;
   my ( $text ) = @_;
      my ( $text, $colname );
   my ( $text, $complete, $debug ) = @_;
   my ( $text, $complete, $debug, $full ) = @_;
      my $text = $filters{$key}->{text};
   my ( $text, $len ) = @_;
   my $text = shift;
   my ( $text, $width) = @_;
   my @t_header;
            my @this_table = create_caption("Sub-Part $res->{id}",
my @this_term_size; # w_chars, h_chars, w_pix, h_pix
   my %thread_for = map {
   my ( $thread_line ) = $txn =~ m/^(MySQL thread id .*)$/m;
      my $thread = prompt_list($prompt,
   my @threads = $fulltext =~ m<^(I/O thread \d+ .*)$>gm;
      my @threads = map { $_->{id} } reverse sort { $sort_func->($a, $b) } @candidates;
   my ( $thread_status, $thread_decl_inside )
      my ( $tid, $state, $purpose, $event_set )
         my $timeout = $config{cxn_timeout}->{val};
   my ( $time_text ) = $fulltext =~ m/^$s INNODB MONITOR OUTPUT$/m;
   my $tmpfile = File::Temp->new( TEMPLATE => 'innotopXXXXX', DIR => $dirname, SUFFIX => '.conf.tmp');
      my $tmp_filename = $tmp->filename;
      my $tmp = File::Temp->new( TEMPLATE => 'innotopXXXXX', DIR => $homepath, SUFFIX => '.conf');
      my @tmp  = map { { name => $_ } } @vars;
   my ($total, $last_total) = (0, 0);
my $t  = qr/(\d+ \d+)/;                # Transaction ID
   my @transactions = $fulltext =~ m/(---TRANSACTION \d.*?)(?=\n---TRANSACTION|$)/gs;
my %trans_funcs = (
   my $tries = 2;
   my ( $trigger ) = $fulltext =~ m/^(DATA TUPLE: \d+ fields;\n.*)$/m;
   my ( $ts ) = $fulltext =~ m/^$s$/m;
   my ( $ts, $type ) = $fulltext =~ m/^$s\s+(\w+)/m;
   my ( $txn, $complete, $debug, $full ) = @_;
      my $txn = $dl->{'txns'}->{$txn_id};
   my ( $txn_doesnt_see_ge, $txn_sees_lt )
   my ( $txn ) = $fulltext
   my ( $txn_id, $txn_status, $active_secs, $proc_no, $os_thread_id )
      my ( $txn_id, $what ) = $header =~ m/^\($d\) (.*):$/;
               my $txn = $innodb_status->{IB_dl_txns}->{$txn_id};
         my $txn = $innodb_status->{IB_fk_txn};
   my @unused_cols = grep { !$columns{$_}->{referenced} } sort keys %columns;
      my $uptime = $dbh->selectrow_hashref("show status like 'Uptime'")->{value};
      my $uptime = secs_to_time( $vars->{Uptime_hires} );
   my $usage
   my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
      my $user = $ENV{USERNAME} || $ENV{USER} || getlogin() || getpwuid($REAL_USER_ID) || undef;
   my $val = $cmdline{$name};
         my $val = $config{$key}->{val};
         my \$val = eval { $expr };
    my $val = # EXPANDED STRING GOES HERE
   my $val = prompt_list(
               my $val = prompt("New value for $answer", undef, $ini);
               my $val = ref($meta->{$_}) ? join(',', @{$meta->{$_}}) : $meta->{$_};
               my $val = $rule->{$_};
         my $val = $set->{$key};
      my $val = $spec->{op} =~ m/^(?:eq|ne|le|ge|lt|gt)$/ ? "'$spec->{arg}'"
   my @values;
   my $variables;
   my $variables = $var_sets{$name}->{text};
   my @vars =
my %vars;
   my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
my %var_sets = (
   my @var_sets = sort keys %var_sets;
         my $vars = $inc ? inc($set, $cxn) : $vars{$cxn}->{$clock - $set};
      my @vars = @{$meta->{visible}};
   my @var_status;
      my @vars = unique(grep { $_ && exists $connections{$_} } split(/\s+/, $rest));
   my $vars = $vars{$cxn};
         my $vars = $vars{$cxn}->{$clock};
      my $vars = $vars{$cxns[0]}->{$clock};
               my @ver_history = @config_versions;
   my $version = sprintf('%03d%03d%03d', $dbh->{mysql_serverinfo} =~ m/(\d+)/g);
         my $victim = $innodb_status->{IB_dl_rolled_back} || 0;
   my @visible;
         my @visible_cols = @{$meta->{visible}};
         my @visible_cols = @{ $tbl_meta{$tbl}->{visible} };
   my @visible = get_visible_tables();
   my $visible = $modes{$mode}->{visible_tables};
   my @visible = $opts{n} ? 'innodb_transactions' : get_visible_tables();
   my @visible = $opts{n} ? 'processlist' : get_visible_tables();
   my @wait_array;
   my @waits = $fulltext =~ m/^(--Thread.*?)^(?=Mutex spin|--Thread)/gms;
   my %wanted  = map { $_ => 1 } @visible;
      my %width_for;
      my $width = min($this_term_size[0], max(map { length(ref($_) ? $_->[0] : $_) } @rows));
         my $width    = $opts{n} ? 0 : int(($this_term_size[0] - $num_cols + 1) / $num_cols);
         my $width    = $opts{n} ? 0 : max($min_width, int(($this_term_size[0] - $num_cols + 1) / $num_cols));
my $windows       = $OSNAME =~ m/MSWin/;
   my ( $word ) = @_;
my $w  = qr/(\w+)/;                    # Words
   my ( $y, $m, $d, $h, $i, $s )
               ) . "\n";
             . "\n";
            . "\n";
         "\n";
         ), "\n";
      . "  ===  ====  =============================================\n";
      ++$n;
   n => {
   n => { action => \&next_server,       label => 'Switch to the next connection' },
      $name = choose_var_set($name);
name=connection_list.  See L<"SERVER GROUPS">.
      name => $filter,
 name               hdr          label                  src          
   name                        => { hdr => 'Name',                num => 0, label => 'Variable Name' },
            name       => $key,
         name => $key,
      name => $key, # useful for later
         name  => $name,
   # Name of the child index (index in the same table where the FK is, see
name of the connection is next on the status line.  This is the name you gave
         $name = prompt("Enter a name");
name=quoted-value list.
 name set0 set1
names of the connections that are active.  Again, these are connection names you
         name       => { src => 'name' },
         $name =~ s/[\s:;]//g;
      $name =~ s/[\s:;]//g;
         $name =~ s/\W//g;
      $name =~ s/\W//g;
#  * name:   the name, repeated
name=value.
 Name                    Value    Pct     Last Incr  Pct    
   # Narrow the list to queries that can be explained.
   n_bits                      => { hdr => '# Bits',              num => 1, label => 'Number of bits' },
         n_bits           => { src => 'n_bits' },
Nearly everything about innotop is configurable.  Most things are possible to
needed, and press 'o' to open the color editor dialog.
needed so the subroutine can calculate things like the difference between this
needs to be replaced with a small one (see L<"auto_wipe_dl">).
   '!~' => 'Negated pattern match',
nested data sets.
   'ne' => 'String not-equal',
      $new = add_new_server_group();
         # Newer-old style.
# New/old-style applies here.  See rem/rem0rec.c
      $new = prompt("Enter variables for $name", undef, $variables);
      $new = prompt_list(
         $new_row{$col} = $agg_funcs{$agg}->( map { $_->{$col} } @$group );
      @new_row{@$group_by} = @{$group->[0]}{@$group_by};
      $new =~ s/\s.*//;
         next if $col eq '_color';
      next if !$filters{$key}->{user} || $filters{$key}->{quick};
      next if $line =~ m/^#/;
   next if not defined $cmdline{$name};
      next if $tbl_meta{$tbl}->{temp};
         next unless $col;
      next unless $col;
      next unless @colors;
         next unless $dbhs{$cxn} && $dbhs{$cxn}->{dbh} && $dbhs{$cxn}->{dbh}->{Active};
      next unless defined $name && defined $val;
      next unless defined $parts{arg};
      next unless defined $parts{color};
         next unless defined $val && $val =~ m/^\d+$/;
      next unless exists $comp_ops{$spec->{op}};
      next unless exists $tbl_meta{$tbl};
         next unless $innodb_status_text
      next unless $key;
      next unless $key && defined $val && $val =~ m/$num_regex/;
      next unless $key && exists $modes{$key};
      next unless $key && exists $tbl_meta{$key};
         next unless $key =~ m/$prefix/i;
      next unless $key && $rest;
         next unless $line =~ m/^\[([a-z_]+)\]$/;
      next unless $line && $plugins{$line};
      next unless $meta->{cust}->{colors};
         next unless $meta->{user};
      next unless $mode && exists $modes{$mode};
      next unless $mode && $group
      next unless $modes{$mode}->{cust}->{visible_tables};
         next unless $name && $name =~ m/^(?:name|set_\d+)$/;
      next unless $name && $rest;
         next unless $name && $tbl->{cols}->{$name};
      next unless $parts{col} && exists $tbl_meta{$tbl}->{cols}->{$parts{col}};
      next unless $parts{op}  && exists $comp_ops{$parts{op}};
      next unless $parts{text} && $parts{tbls};
      next unless $plugins{$class}->{active};
      next unless $set->{IB_tx_transactions};
      next unless $tbl && exists $tbl_meta{$tbl};
      next unless $tbl_meta{$tbl}->{cust}->{filters};
      next unless $tbl_meta{$tbl}->{cust}->{group_by};
      next unless $tbl_meta{$tbl}->{cust}->{sort_cols};
      next unless $tbl_meta{$tbl}->{cust}->{visible};
      next unless $tbl && $rule;
      next unless $txn_id;
      next unless @vars;
      next unless $var_sets{$varset}->{user};
         next unless $vars && %$vars;
      next unless $wanted{$tbl};
nice formatting.
'n' key.  If you're monitoring a server group (see L<"SERVER GROUPS">) this will
      no_clear_screen   => 1,
no crashes due to undefined values.  innotop then adds a caption if specified,
   no_ctrl_char => \&no_ctrl_char,
            '', no_ctrl_char($txn->{query_text});
   # no matching parent record (row_ins_foreign_report_add_err).
   non_hash_searches_s         => { hdr => 'Non-Hash/Sec',        num => 1, label => 'Non-hash searches/sec' },
         non_hash_searches_s => { src => 'IB_ib_non_hash_searches_s' },
not be able to compile it then).
not documented in the MySQL manual, but creating the lock monitor with the
      note => 'Add a column to the table',
      note => 'A debug file in case you are interested in error output',
      note => $builtin_filters{$key}->{note},
      note => 'Character for drawing graphs',
      note => 'Choose filters',
      note => 'Choose group-by (aggregate) columns',
      note => 'Choose sort columns',
      note => 'Choose which table(s) to display in this mode',
      note => 'Connection timeout for keeping unused connections alive',
      note => 'Create a new color rule',
      note => 'Create a new column and add it to the table',
      note => 'Debug mode (more verbose errors, uses more memory)',
      note => 'Directory where plugins can be found',
      note => 'Disable SHOW INNODB STATUS',
      note => 'Edit color rules',
      note => 'Edit columns, etc in the displayed table(s)',
      note => 'Edit general configuration',
      note => 'Edit row-coloring rules',
      note => 'Edit selected column',
      note => 'Edit server groups',
      note => 'Edit SQL statement sleep delays',
#  * note:   explanation
      note => 'How many digits to show in fractional numbers and percents',
      note => 'How many sets of STATUS and VARIABLES values to show',
      note => 'How to highlight table column headers',
      # NOTE: if a table is pivoted and un-pivoted, this will likely cause crashes.
      note => 'Manage plugins',
      note => 'Move highlight down one',
      note => 'Move highlight up one',
      note => 'Move selected column down one',
      note => 'Move selected column up one',
      note => 'Move selected rule down one',
      note => 'Move selected rule up one',
not encrypted in any way.
      note => 'Prefix for values in C mode',
         note  => 'Quick-filter',
      note => 'Remove selected column',
      note => 'Removes idle I/O threads',
      note => 'Removes processes which are not doing anything',
      note => 'Removes servers that are not masters',
      note => 'Removes servers that are not slaves',
      note => 'Removes slave I/O threads from the list',
      note => 'Removes tables that are not in use or locked',
      note => 'Removes the innotop processes from the list',
      note => 'Remove the selected rule',
      note              => 'Shows buffer info from InnoDB',
      note              => 'Shows InnoDB row operation and semaphore info',
      note       => 'Shows InnoDB transactions in top-like format',
      note              => 'Shows I/O info (i/o, log...) from InnoDB',
      note              => 'Shows open tables in MySQL',
      note       => 'Shows queries from SHOW FULL PROCESSLIST',
      note              => 'Shows query load statistics a la vmstat',
      note              => 'Shows relative magnitude of variables',
      note              => 'Shows replication (master and slave) status',
      note            => 'Shows transaction locks',
      note => 'Show the % symbol after percentages',
      note => "The interval at which the display will be refreshed.  Fractional values allowed.",
# NOTE: this DOES modify its arguments, even though it returns a new array.
      note => 'Toggle selected plugin active/inactive',
         note => 'User-defined filter',
      note => 'User-defined filter',
      note              => 'View InnoDB deadlock information',
      note              => 'View the latest InnoDB foreign key error',
      note => 'What to display in S mode: graph, status, pivoted status',
      note => 'What type of characters should be displayed in queries (ascii, unicode, none)',
      note => 'Whether the config file is read-only',
      note => 'Whether to auto-wipe InnoDB deadlocks',
      note => 'Whether to display connection errors as rows in the table',
      note => 'Whether to print connection errors to STDOUT',
      note => 'Whether to put captions on tables',
      note => 'Whether to show column headers',
      note => 'Whether to show GLOBAL variables and status',
      note => 'Whether to show raw or incremental values for status variables',
      note => 'Whether to show the status bar in the display',
      note => 'Whether to use terminal coloring',
      note => "Which mode to start in",
      note => 'Which set of variables to display in S (Variables & Status) mode',
      note => '[Win32] Max window height',
notice when the file format is not backwards-compatible, and upgrade smoothly
   # Now clobber the main config file with the temp.
   # Now read which ones the user has activated.  Each line simply represents an active plugin.
   # Now there is specific display code based on $config{S_func}
   n => !( -t STDIN && -t STDOUT ), # If in/out aren't to terminals, we're interactive
            num   => 0,
         num  => 0,
   num     => 0,
   $num = 0 unless defined $num;
       num   => 1,
      $num /= 1_024;
number of seconds and display it in H:M:S format.  The following transformations
number of times since startup that the replication slave SQL thread has retried
   num_deletes                 => { hdr => 'Del',                 num => 1, label => 'Number of deletes' },
   num_deletes_sec             => { hdr => 'Del/Sec',             num => 1, label => 'Number of deletes' },
         num_deletes_sec => { src => 'IB_ro_del_sec' },
         num_deletes => { src => 'IB_ro_num_rows_del' },
   num_digits => {
         ? "%.${num_digits}f%s"
      # numeric and non-numeric data.  Thus everything has to be 'cmp' type.
   '==' => 'Numeric equality',
   '>'  => 'Numeric greater-than',
   '>=' => 'Numeric greater-than/equal',
   '<'  => 'Numeric less-than',
   '<=' => 'Numeric less-than/equal',
   '!=' => 'Numeric not-equal',
      # Numeric variables get subtracted, non-numeric get passed straight through.
   num_inserts                 => { hdr => 'Ins',                 num => 1, label => 'Number of inserts' },
   num_inserts_sec             => { hdr => 'Ins/Sec',             num => 1, label => 'Number of inserts' },
         num_inserts_sec => { src => 'IB_ro_ins_sec' },
         num_inserts => { src => 'IB_ro_num_rows_ins' },
            $num_lines++;
      $num =~ m/\./ || $n || $force
      $num, ($pad,'k','M','G', 'T')[$n]);
   num_readers                 => { hdr => 'Readers',             num => 1, label => 'Number of readers' },
         num_readers        => { src => 'num_readers' },
   num_reads                   => { hdr => 'Read',                num => 1, label => 'Number of reads' },
   num_reads_sec               => { hdr => 'Read/Sec',            num => 1, label => 'Number of reads' },
         num_reads_sec   => { src => 'IB_ro_read_sec' },
         num_reads   => { src => 'IB_ro_num_rows_read' },
   num_res_ext                 => { hdr => 'BTree Extents',       num => 1, label => 'Number of extents reserved for B-Tree' },
         num_res_ext         => { src => 'IB_ro_n_reserved_extents' },
   num_rows                    => { hdr => 'Row Count',           num => 1, label => 'Number of rows estimated to examine' },
         num_rows      => { src => 'rows' },
   $num =~ s/(^[-+]?\d+?(?=(?>(?:\d{3})+)(?!\d))|\G\d{3}(?=\d))/$1,/g;
   num_status_sets => {
   num_times_open              => { hdr => 'In Use',              num => 1, label => '# times table is opened', },
         num_times_open => { src => 'in_use' },
   num_txns                    => { hdr => 'Txns',                num => 1, label => 'Number of transactions' },
   NumTxns           => q{scalar @{ IB_tx_transactions } },
         num_txns                    => { src => $exprs{NumTxns} },
   num_updates                 => { hdr => 'Upd',                 num => 1, label => 'Number of updates' },
   num_updates_sec             => { hdr => 'Upd/Sec',             num => 1, label => 'Number of updates' },
                       num_updates_sec num_reads_sec num_deletes_sec)],
         num_updates_sec => { src => 'IB_ro_upd_sec' },
         num_updates => { src => 'IB_ro_num_rows_upd' },
#    * num    Whether it's numeric (for sorting).
num: whether the column is numeric.  This affects how values are sorted
         o => {
   o => {
objects.
         $obj = $line->new(%pluggable_vars);
occasionally to see if the error still exists.  If so, it will wait until some
(offsets from their previous values).  Corresponds to the configuration option
of putting the actual file there.  innotop automatically discovers the file.  If
of rows is treated as one group.  This is quite like SQL so far, but unlike SQL,
of tables to which the filter can apply.  By default, user-defined filters apply
of the table being created.  The events are set_to_tbl_pre_filter,
of what's happening in the server.  For example, there's a mode for monitoring
      # OK, it's old-style.  Unfortunately there are variations here too.
         # Older-old style.
         $old_filename = "$homepath/.innotop";
         $old_filename = "$homepath/.innotop/innotop.ini";
   OldVersions       => q{dulint_to_int(IB_tx_trx_id_counter) - dulint_to_int(IB_tx_purge_done_for)},
       on_blue on_cyan on_green on_magenta on_red on_white on_yellow red reset
Once you finish answering these questions, you should be connected to a server.
Once you've entered the required data, your table has a new column.  There is no
      one_connection  => 0,
      one_connection    => 0,
      one_connection    => 1,
one of the columns already defined for the table; it prompts you to choose from
one waited for unless the deadlock information is truncated.
# Online configuration and prompting functions {{{2
      # on localhost using mysql_read_default_group=client
   # Only a certain number of bytes of the query text are included here, at least
        # Only config values that are marked as applying to this mode.
      # Only tables that have quick-filters
On MySQL versions 4.0.3 and newer, this variable is used to set the connection's
      # on the 'name' column.
               # on the size of innodb status is 128k even with Google's patches)
      open $file, "<", $filename
      open my $file, "<", $conf_file or die("Can't open '$conf_file': $OS_ERROR");
         open my $file, '>>', $config{debugfile}->{val};
   open my $file, "+>", $tmpfile
         open my $p_in, "<", $p_file or die $OS_ERROR;
   open_tables => {
         Open_tables Opened_tables Table_locks_immediate Table_locks_waited
 OPEN_TABLES         SHOW OPEN TABLES
   OPEN_TABLES => sub {
   # Open the file for InnoDB status
# Operating modes {{{3
            op    => $op,
            $op = prompt_list(
         $op =~ s/\s+//g;
optimizing your statements.  Something is wrong; it should normally take
options files, such as ~/.my.cnf on UNIX-ish systems.  You can use this to avoid
      opts => {
   $opts ||= {};
      $opts{count}++;
             .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
             .  ($opts{$key}->{desc} || '[No description]')
            = $opts{n}
      ? $opts->{num_digits}
   @opt_spec;
   $opts{$spec->{k}} = undef unless defined $opts{$spec->{k}};
                 $opts{u} ? 1 : 0, $opts{u}, $opts{p} ? 1 : 0, $opts{p});
or as complicated as a full-fledged Perl expression.  It looks at each
               or delete $innodb_data{'sections'}->{$section};
         or die "Cannot open '$filename': $OS_ERROR";
      or die "Cannot print: $OS_ERROR";
               or die "Cannot print to file: $OS_ERROR";
            or die "Cannot print to file: $OS_ERROR";
                  or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
         or die "Can't create directory '$dirname': $OS_ERROR";
         or die "Can't rename '$old_filename' to '$new_filename': $OS_ERROR";
         or die "Can't rename '$old_filename' to '$tmp_filename': $OS_ERROR";
         or die "Can't rename '$tmp_filename' to '$new_filename': $OS_ERROR";
      or die("Can't write to $tmpfile: $OS_ERROR");
         or die "Column '$key' doesn't exist in $tbl";
      or die "No connection named '$connection' is defined in your configuration";
Originally written by Baron Schwartz; currently maintained by Aaron Racine.
or modify its existing functionality, and add new functionality.  innotop's
         |'(?:(?!(?<!\\)').)*') # Or single-quoted string
         or warn "Can't create directory '$dirname/plugins': $OS_ERROR\n";
   # or warnings if a central config doesn't have readonly=1, but being
   os_file_reads               => { hdr => 'OS Reads',            num => 1, label => 'OS file reads' },
         os_file_reads  => { src => 'IB_io_os_file_reads' },
   os_file_writes              => { hdr => 'OS Writes',           num => 1, label => 'OS file writes' },
         os_file_writes => { src => 'IB_io_os_file_writes' },
   os_fsyncs                   => { hdr => 'OS fsyncs',           num => 1, label => 'OS fsyncs' },
         os_fsyncs      => { src => 'IB_io_os_fsyncs' },
      o => \&show_optimized_query,
   os_thread_id                => { hdr => 'OS Thread',           num => 1, label => 'The operating system thread ID' },
      os_thread_id       => $os_thread_id,
         os_thread_id       => { src => 'os_thread_id' },
Other keys do something special like change configuration or show the
   # otherwise, move the existing conf file to a temp file, make the necessary directory structure,
our $conf_file = "";
our $default_central_conf = "/etc/innotop/innotop.conf";
our $default_home_conf = "$homepath/.innotop/innotop.conf";
our $homepath = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
our $VERSION = '1.7.1';
# Output: an array of strings, one per row.
      $OUTPUT_AUTOFLUSH = 1;
   $OUTPUT_AUTOFLUSH = 1;
$OUTPUT_AUTOFLUSH = 1;
Output version information and exit.
over a minute.  That means the query optimizer is having a really hard time
overridden with the L<"--config"> command-line option.  You can edit it by hand
# Override config variables with command-line options
      # Override defaults
own to any table.  Open the table editor with the '^' key, choose a table if
         p => {
   p => {
         P => {
               $package = $1;
package DSNParser;
package InnoDBParser;
 package Innotop::Plugin::Example;
package main;
package name, with double semicolons and so on.
   p => { action => \&pause,             label => 'Pause innotop', },
            { pad => ' | '},
      pad   => ' ',
   page_creates_sec            => { hdr => 'Creates/Sec',         num => 1, label => 'Page creates/sec' },
         page_creates_sec => { src => 'IB_bp_page_creates_sec' },
         page_creates_sec           => { src => 'IB_bp_page_creates_sec' },
   page_no                     => { hdr => 'Page',                num => 1, label => 'Page number' },
         page_no          => { src => 'page_no' },
   page_reads_sec              => { hdr => 'Reads/Sec',           num => 1, label => 'Page reads per second' },
         page_reads_sec   => { src => 'IB_bp_page_reads_sec' },
         page_reads_sec             => { src => 'IB_bp_page_reads_sec' },
   pages_created               => { hdr => 'Created',             num => 1, label => 'Pages created' },
         pages_created    => { src => 'IB_bp_pages_created' },
         pages_created              => { src => 'IB_bp_pages_created' },
 pages_modified     Dirty Pages  Pages modified (dirty  IB_bp_pages_m
   pages_modified              => { hdr => 'Dirty Pages',         num => 1, label => 'Pages modified (dirty)' },
         pages_modified             => { src => 'IB_bp_pages_modified' },
   pages_read                  => { hdr => 'Reads',               num => 1, label => 'Pages read' },
         pages_read       => { src => 'IB_bp_pages_read' },
         pages_read                 => { src => 'IB_bp_pages_read' },
   page_statistics => {
      page_statistics     => \@page_statistics,
   pages_total                 => { hdr => 'Pages',               num => 1, label => 'Pages total' },
 pages_total        Pages        Pages total            IB_bp_pages_t
         pages_total                => { src => 'IB_bp_pages_total' },
   pages_written               => { hdr => 'Writes',              num => 1, label => 'Pages written' },
         pages_written    => { src => 'IB_bp_pages_written' },
         pages_written              => { src => 'IB_bp_pages_written' },
   page_writes_sec             => { hdr => 'Writes/Sec',          num => 1, label => 'Page writes per second' },
            page_writes_sec pages_read pages_written page_reads_sec
         page_writes_sec  => { src => 'IB_bp_page_writes_sec' },
         page_writes_sec            => { src => 'IB_bp_page_writes_sec' },
   p_aio_writes                => { hdr => 'Async Wrt',           num => 1, label => 'Pending asynchronous I/O writes' },
         p_aio_writes       => { src => 'IB_io_pending_aio_writes' },
parameters.  If you need to specify a different username and password, use the
   parent_col                  => { hdr => 'Parent Column',       num => 0, label => 'The referred column in the parent table', },
         parent_col   => { src => 'IB_fk_parent_col' },
   parent_db                   => { hdr => 'Parent DB',           num => 0, label => 'The database of the parent table' },
         parent_db    => { src => 'IB_fk_parent_db' },
   parent_index                => { hdr => 'Parent Index',        num => 0, label => 'The referred index in the parent table' },
         parent_index => { src => 'IB_fk_parent_index' },
   parent_table                => { hdr => 'Parent Table',        num => 0, label => 'The parent table' },
         parent_table => { src => 'IB_fk_parent_table' },
   # parent table.  This may not be possible to find.
         # Parse and merge into %vars storage
   # Parse given props
            = parse_innodb_record_dump( $records, $complete, $debug );
               = parse_innodb_record_dump( $records, $complete, $debug );
         # Parse out the related records in the other table.
   # Parse out the tuple trying to be updated, deleted or inserted.
            $parser_for{$section}->(
# Parses the status text and returns it flattened out as a single hash.
   # Parse the detailed data out of the sections.
   # Parse the parent/child table and index info out
   # Parse the parent/child table and index info out.  There are two types: an
   # Parse the parent/child table info out
# Parse the status and return it.
   # Parse the status text...
   # Parse the txn info out
   # Parsing the line that begins 'MySQL thread id' is complicated.  The only
   part_id                     => { hdr => 'Part ID',             num => 1, label => 'Sub-part ID of the query' },
         part_id       => { src => 'id' },
   partitions                  => { hdr => 'Partitions',          num => 0, label => 'Query partitions used' },
         partitions    => { src => 'partitions' },
      @parts = grep { grep { $tbl eq $_ } @{$filters{$_}->{tbls}} } @parts;
         $parts{$prop} =~ s/\\'/'/g;
         $parts{$prop} =~ s/\\\\/\\/g;
      $parts{user} = 1;
# Pass in the text to parse, whether to be in debugging mode, which sections
      pass      => $pass,
'pass' which is only present if 'savepass' is set.  This section of the
password is optional, but there's an additional prompt that asks if you want to
Password to use for connection.
      pat  => $bool_regex,
      pat  => $int_regex,
      pat  => qr/^.$/,
      pat  => qr/^(?:ascii|unicode|none)$/,
      pat  => qr/^(?:bold|underline)$/,
      pat  => qr/^(?:(?:\d*?[1-9]\d*(?:\.\d*)?)|(?:\d*\.\d*?[1-9]\d*))$/,
      pat  => qr/^[gsv]$/,
      pat  => qr/^\w+$/,
   '=~' => 'Pattern match',
Paul McCullagh,
                        pause();
            pause();
         pause();
      pause();
   pause();
# pause {{{3
            pause($EVAL_ERROR);
               pause("The config file is for a newer version of innotop and may not be read correctly.");
   p_buf_pool_flushes          => { hdr => 'Buffer Pool Flushes', num => 1, label => 'Pending buffer pool flushes' },
         p_buf_pool_flushes => { src => 'IB_io_pending_buffer_pool_flushes' },
   pct                         => { hdr => 'Pct',                 num => 1, label => 'Percentage' },
         pct        => { src => 'value/total',               trans => [qw(percent)] },
   pending_chkp_writes         => { hdr => 'Chkpt Writes',        num => 1, label => 'Pending log checkpoint writes' },
         pending_chkp_writes => { src => 'IB_lg_pending_chkp_writes' },
   pending_io => {
      pending_io     => \@pending_io,
         pending_log_flushes complete )),
   pending_log_writes          => { hdr => 'Log Writes',          num => 1, label => 'Pending log writes' },
         pending_log_writes  => { src => 'IB_lg_pending_log_writes' },
         pending_normal_aio_reads fsyncs_s os_file_writes pending_sync_ios
people successfully running it on Red Hat, CentOS, Solaris, and Mac OSX.  I
         'percent(1-((Innodb_buffer_pool_pages_free||0)/($cur->{Innodb_buffer_pool_pages_total}||1))) as BP_page_cache_usage',
         'percent(1-((Innodb_buffer_pool_reads||0)/(Innodb_buffer_pool_read_requests||1))) as BP_cache_hit_ratio',
         'percent(1-((Qcache_free_blocks||0)/(Qcache_total_blocks||1))) as Blocks_used',
# percent {{{3
         'percent($cur->{Max_used_connections}/($cur->{max_connections}||1)) as CXN_Used_Ever',
         'percent($cur->{Open_tables}/($cur->{table_cache})) as Table_Cache_Used',
         'percent($cur->{Threads_cached}/($cur->{thread_cache_size}||1)) as Thread_Cache_Used',
         'percent($cur->{Threads_connected}/($cur->{max_connections}||1)) as CXN_Used_Now',
         "percent($exprs{QcacheHitRatio}) as Hit_Pct",
   percent      => \&percent,
         'percent(Select_full_join/(Com_select||1)) as Full_Join_Ratio',
Perl code.
Perl distributions, but in case they are not, I recommend using versions
persist when you restart innotop.  To create a quick-filter, press the '/' key.
   p_ibuf_aio_reads            => { hdr => 'IBuf Async Rds',      num => 1, label => 'Pending insert buffer asynch I/O reads' },
         p_ibuf_aio_reads   => { src => 'IB_io_pending_ibuf_aio_reads' },
   # Pivot.
      pivot     => 0,
   # pivoted and nonpivoted.  I have several other 'crash' notes about this if
   # Pivoted tables can be sorted by 'name' and set_x columns; others must be
pivot, filter, sort, create.  If it's not pivoted, the process is extract,
places.  It can help in debugging filters and other user-defined code.  It also
# Place, Suite 330, Boston, MA  02111-1307  USA
Place, Suite 330, Boston, MA  02111-1307  USA.
   p_log_flushes               => { hdr => 'Log Flushes',         num => 1, label => 'Pending log flushes' },
         p_log_flushes      => { src => 'IB_io_pending_log_flushes' },
   p_log_ios                   => { hdr => 'Log I/Os',            num => 1, label => 'Pending log I/O operations' },
         p_log_ios          => { src => 'IB_io_pending_log_ios' },
%pluggable_vars, and are as follows:
         $plugin->{active} = $plugin->{active} ? 0 : 1;
   plugin_dir => {
# Plugin editor key mappings {{{3
plugin functionality is event-based: plugins register themselves to be called
            "Plugin Management.  Press ? for help, q to quit.", '';
   plugins => {
# Plugins!
plugin's description.
         $plugins{$line}->{active} = 1;
         $plugins{$line}->{object} = $obj;
         $plugins{$package} = {
plugin's package name to be Foo.  Of course the package name can be a valid Perl
'plugins' subdirectory of your innotop configuration directory.
   p_normal_aio_reads          => { hdr => 'Async Rds',           num => 1, label => 'Pending asynchronous I/O reads' },
         p_normal_aio_reads => { src => 'IB_io_pending_normal_aio_reads' },
point in the future.  The wait time increases in ticks as the Fibonacci series,
            pop @{$meta->{visible}};
   port                        => { hdr => 'Port',                num => 1, label => 'Client port number', },
   Port              => q{my ($p) = host =~ m/:(.*)$/; return $p || 0},
         port            => { src => $exprs{Port}, minw => 0,  maxw => 0, },
Port to use for connection.
         $pos++;
   possible_keys               => { hdr => 'Poss. Keys',          num => 0, label => 'Possible keys' },
         possible_keys => { src => 'possible_keys' },
# possible, so
# Post-process...
# post-processing too; the subroutines compiled from src get added to
post_process_tbl_meta();
   p_preads                    => { hdr => 'preads',              num => 1, label => 'Pending p-reads' },
         p_preads           => { src => 'IB_io_pending_preads' },
   p_pwrites                   => { hdr => 'pwrites',             num => 1, label => 'Pending p-writes' },
         p_pwrites          => { src => 'IB_io_pending_pwrites' },
   $precision = $config{num_digits}->{val} if !defined $precision;
predefined sets, or lets you create your own sets.  You can edit the current set
preferably Term::ReadLine::Gnu, you'll get nice auto-completion support.
   # Prefer removing the end of a "word"
prefix is "Com_".  You can choose a prefix with the 's' key.
   $prefs ||= {};
   $prefs->{no_hdr} ||= ($opts{n} && $clock != 1);
   prep_stmt => {
press any of these keys and innotop will either take the requested action or
Press '?' at any time to see the currently active keys and what they do.
Pressing 'e' from within the table editor lets you edit the column's properties:
Press 'k' to issue a KILL command, or 'x' to issue a KILL QUERY command.
Press the '?' key to see what keys are active in the current mode.  You can
   $prev     ||= {};
      prev_sleep => 0,
# print, and the second is args to colored().
Print a summary of command-line usage and exit.
         print "Choose a source for the column's data\n\n";
   print "Choose filters for $meta->{capt}:\n";
   print colored("$prompt: ", 'underline');
   print defined($msg) ? "\n$msg" : "\nPress any key to continue";
   print "Enter a new value for '$key' ($config{$key}->{note}).\n";
      PrintError        => 0,
               print "Error: $err\n\n";
         print "Error from $cxn: $EVAL_ERROR\n";
      print $EVAL_ERROR;
   printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
         printf($format, map { ( $config{graph_char}->{val} x int( $width * $set->{$_} )) || '.' } @$visible );
            printf($format, map { defined $_ ? $_ : '' } @{$row}{ @$visible });
            printf($format, map { donut(crunch($_, $width), $width) } @$visible);
            printf($format, map { shorten($mvs{$_} || 0) } @$visible);
      print $file "$class\n";
         print $file "$col=", join(
         print $file "# $config{$key}->{note}\n"
      print $file "$conn=", join(' ', map { "$_=$href->{$_}" } grep { defined $href->{$_} } @keys), "\n";
            print $file "Current variables:\n" . Dumper(\%vars);
            print $file "$key="
      print $file "$key=$mvs{$key}\n";
      print $file "$key=$stmt_sleep_time_for{$key}\n";
      print $file "$key=text='$text' tbls='$tbls'\n";
            print $file "$key=$val\n";
      print $file "$mode=", join(' ', @connections), "\n";
      print $file "$mode=", join(' ', @$tables), "\n";
      print $file "$mode=$modes{$mode}->{server_group}\n";
      print $file "\n[/$section]\n";
      print $file "\n[$section]\n\n";
      print $file "$set=", join(' ', @{$server_groups{$set}}), "\n";
      print $file "$tbl=$col\n";
         print $file "$tbl=", join(
      print $file "$tbl=", join(' ', @$aref), "\n";
      print $file "$varset=$var_sets{$varset}->{text}\n";
   print $file "version=$VERSION\n";
      printf("  --%-${maxw}s %-4s %s\n", $long, $short, $spec->{d});
         # Print headers every now and then.
         # Print headers every now and then.  Headers can get really long, so compact them.
   # Print help first.
printing too much lock information (see L<"D: InnoDB Deadlocks">).
   print $innotop_license;
   print "innotop  Ver $VERSION\n";
         print "Invalid response.\n\n";
            print join(' ', map { sprintf( "%${width}s", donut($_, $width)) } @hdr) . "\n";
      print join( "\n",
      print join("\n",
               print join("\t", @hdr), "\n";
               print join("\t", map { shorten($mvs{$_}) } @$visible), "\n";
               print join("\t", @$visible), "\n";
     print "Loaded config file on start-up, so ignoring -w (see --help)\n"
   print $msg;
                        print "\n";
         print "\n";
      print "\n";
   print "\n";
      print "\nError: $EVAL_ERROR";
      print "\nHint: $hint\n";
                        print "\ninnotop will not save any configuration changes you make.";
         print "\nInnotop will now exit so you can fix the config file.\n";
         print "\n\n";
      print "\n\n";
            print "\n\n"; # One to add space, one to clear readline artifacts
            print "\n\n", word_wrap('Rules are applied in order from top to '
   print $opts{c} . " doesn't exist.  Exiting.\n";
   print "# $package:$line $$ ", @_, "\n";
# Prints lines to the screen.  The first argument is an arrayref.  Each
# Prints out a prompt and reads from the keyboard, then validates with the
      print STDERR "Error at tick $clock $cxn $err" if $config{debug}->{val};
# Print stuff to the screen immediately, don't wait for a newline.
         print "Success on $cxn\n";
         print "There's an error in your filter expression: $err\n\n";
   print "This function will deliberately cause a small deadlock, "
         print "Typical DSN strings look like\n   DBI:mysql:;host=hostname;port=port\n"
   print <<USAGE;
   print "Usage: innotop <options> <innodb-status-file>\n\n";
      print word_wrap("A filter is a Perl subroutine that accepts a hashref of columns "
         print word_wrap("Choose a name for the column.  This name is not displayed, and is used only "
      print word_wrap("Choose a name for the connection.  It cannot contain "
      print word_wrap("Choose a name for the filter.  This name is not displayed, and is only used "
      print word_wrap("Choose a name for the group.  It cannot contain "
   print "You can enter the name of a new connection to create it.\n";
      print "You can enter the name of a new group to create it.\n";
         print "You have not defined any database connections.\n\n";
priority, these rules make locked queries black on a red background, "gray out"
priority.  You can also delete rules and add new ones.  If you add a new rule,
private, please do.
problem.
   processlist => {
      processlist => \@processlist,
 PROCESSLIST         SHOW FULL PROCESSLIST
   PROCESSLIST => sub {
      # proc_info.  In these cases, there won't be any host/ip/user info
   proc_no                     => { hdr => 'Proc',                num => 1, label => 'Process number' },
      proc_no            => $proc_no,
         proc_no            => { src => 'proc_no' },
         $prompt,
# prompt {{{3
prompt for connection passwords when starting up.
# Prompting functions {{{2
# prompt_list {{{3
# prompt_noecho {{{3
# Prompts the user for a value, given a question, initial value,
prompt you for more input.  If your system has Term::ReadLine support, you can
                     } @prop
               \@prop,
# properties:
properties and behaviors.  innotop will write the column's definition to the
properties are self-explanatory, and the only one that is treated specially is
# Properties of each entry:
properties, such as a caption.  Filters, sorting rules, and colorization rules
property.  When you turn grouping on, innotop places the group_by columns at the
      # Prune old data
   p_sync_ios                  => { hdr => 'Sync I/Os',           num => 1, label => 'Pending synchronous I/O operations' },
         p_sync_ios         => { src => 'IB_io_pending_sync_ios' },
# Purges unused binlogs on the master, up to but not including the latest log.
            purge_undo_for is_truncated trx_id_counter complete )),
            purpose   => $purpose,
            push @adaptive_hash_index, extract_values($set, $set, $pre, 'adaptive_hash_index');
            push @buffer_pool, extract_values($set, $set, $pre, 'buffer_pool');
         push @cmd_summary, extract_values($value, $value, $value, 'cmd_summary');
         push @cols, $col;
         push @criteria,
      push @criteria,
               push @$data, \%hash;
                     push @deadlock_locks, $hash;
                  push @deadlock_transactions, $hash;
         push @display_lines,
   push @display_lines, '', 'Actions:';
            push @display_lines, create_caption('Editor key mappings',
         push @display_lines, create_caption('Editor key mappings',
      push @display_lines, create_caption('What configuration do you want to edit?',
            push @display_lines, create_table2(
      push @display_lines, '', @fk_table;
         push @display_lines, get_cxn_errors(@cxns)
      push @display_lines, get_cxn_errors(@cxns)
      push @display_lines, no_ctrl_char($info->{query});
      push @display_lines, '', 'No foreign key error data.';
               push @display_lines, 'Note:', no_ctrl_char($result->{message});
   push @display_lines, '', 'Other:';
      push @display_lines, 'Reason: ' . $innodb_status->{IB_fk_reason};
         push @display_lines, '', set_to_tbl($rows_for{$tbl}, $tbl);
      push @display_lines, '', set_to_tbl($rows_for{$tbl}, $tbl);
   push @display_lines, set_to_tbl(\@tables, 'open_tables'), get_cxn_errors(@cxns);
      push @display_lines, sprintf("   %-${max1}s  %-${max2}s  %s",
      push @display_lines, sprintf("   %-${max1}s  %s",
      push @display_lines, sprintf("%-${max1}s%s",
         push @display_lines, '', "The optimization could not be generated: $EVAL_ERROR";
      push @display_lines, '', 'The query could not be explained.';
            push @display_lines, '', 'The query optimization could not be generated.';
      push @display_lines, '', 'The query optimization could not be generated.';
      push @display_lines, '', '[This query has been re-written to be explainable]';
      push @display_lines, '[This query has been re-written to be explainable]';
            push @file_io_misc, extract_values(
      push @$filters, $filter;
               push @innodb_locks, extract_values(\%hash, \%hash, \%hash, 'innodb_locks');
            push @innodb_transactions, $hash;
            push @insert_buffers, extract_values(
               push @io_threads, $hash;
         push @$left,
         push @log_statistics, extract_values($set, $set, $pre, 'log_statistics');
         push @master_status, extract_values($set, $set, $pre, 'master_status');
            push @{$meta->{visible}}, $col;
      push @new_rows, \%new_row;
            push @page_statistics, extract_values($set, $set, $pre, 'page_statistics');
            push @pending_io, extract_values($set, $set, $pre, 'pending_io');
      push @processlist, map { extract_values($_, $_, $_, 'processlist') } @full_processlist;
            push @q_header, $hash;
         push @q_header, $hash;
               push @$queue, $obj;
      push @result, $hash;
      push @result, @$left;
      push @result, map { $_->{cxn} = $cxn; $_ } @$arr;
      push @result, @$right;
         push @result, @{$stmt->fetchall_arrayref({})};
      push @result, (' ' x $this_term_size[0]) if $p->{vsep} && @$left;
            push @row_operation_misc, extract_values($set, $set, $pre, 'row_operation_misc'),
            push @row_operations, extract_values($inc, $set, $pre, 'row_operations');
         push @rows, $hash;
            push @rows, join($col_sep, map { $item->{$_} } @$cols );
            push @rows, join( $col_sep, map { "-" x $width_for{$_} } @$cols );
         push @rows, $opts{n}
            push @rows, [ pop @rows, $config{header_highlight}->{val} ];
               push @rows, $row;
               push @rows, [ $row, $item->{_color} ];
         push @rows, sprintf($format, $labels->{$col}, $data->{$col});
      push @{$rule_set_for{$tbl}}, \%parts;
      push @{$section->{'transactions'}}, $stuff;
         push @semaphores, extract_values($inc, $set, $pre, 'semaphores');
         push @slave_io_status, extract_values($set, $set, $pre, 'slave_io_status');
         push @slave_sql_status, extract_values($set, $set, $pre, 'slave_sql_status');
         push @{$tbl_meta{$tbl}->{colors}}, {
      push @{$tbl_meta{$tbl}->{filters}}, $name;
            push @{$tbl_meta{$tbl}->{visible}}, $choice;
      push @{$temp_table{$group_key}}, $row;
         push @t_header, $hash;
         push @{$txn->{'locks'}}, parse_innodb_record_locks( $body, $complete, $debug, $full );
         push @values, {
      push @var_status, @rows;
      push @visible, $colname;
            push @wait_array, $hash;
   Q => {
   q => { action => \&finish,            label => 'Quit innotop', },
   q_cache_hit                 => { hdr => 'QCacheHit',           num => 1, label => 'Query cache hit ratio', },
   QcacheHitRatio    => q{(Qcache_hits||0)/(((Com_select||0)+(Qcache_hits||0))||1)},
         q_cache_hit    => { src => $exprs{QcacheHitRatio},                 dec => 1, trans => [qw(percent)] },
   q_header => {
      q_header    => \@q_header,
   qps                         => { hdr => 'QPS',                 num => 1, label => 'How many queries/sec', },
         qps            => { src => 'Questions/Uptime_hires',               dec => 1, trans => [qw(shorten)] },
   queries_in_queue            => { hdr => 'Queries Queued',      num => 1, label => 'Queries in queue' },
         queries_in_queue    => { src => 'IB_ro_queries_in_queue' },
   queries_inside              => { hdr => 'Queries Inside',      num => 1, label => 'Queries inside InnoDB' },
         queries_inside num_rows_del complete )),
         queries_inside      => { src => 'IB_ro_queries_inside' },
queries than the machine actually averages at any given moment.  Configuring
queries that have been running more than five minutes.  Type a new name for your
   query_cache => {
   'query end'                    => 1,
      $query = "EXPLAIN $part\n" . $query;
   query_id                    => { hdr => 'Query ID',            num => 1, label => 'Query ID' },
      query_id           => $query_id,
         query_id           => { src => 'query_id' },
 Query List (? for help) localhost, 32:33, 0.11 QPS, 1 thd, 5.0.38-log
Query List"> mode.  This expression calculates the qps, or Queries Per Second,
query list mode.  This mode does B<not> show InnoDB-related information.  This
query's full text, the results of EXPLAIN, and in newer MySQL versions, even
   query_status => {
   query_status                => { hdr => 'Query Status',        num => 0, label => 'The query status' },
      query_status       => $query_status,
         query_status       => { src => 'query_status' },
      ( $query_status ) = $thread_line =~ m/(Has (?:read|sent) all .*$)/m;
            ( $query_status ) = $thread_line =~ m/query id \d+ (.*)$/;
      $query_text = '';
   query_text                  => { hdr => 'Query Text',          num => 0, label => 'The query text' },
      query_text         => $query_text,
         query_text         => { src => 'query_text',          trans => [ qw(no_ctrl_char) ] },
         query_text         => { src => 'query_text', trans => [ qw(no_ctrl_char) ] },
      $query_text =~ s/\s+$//;
   Questions    => 100,
   questions                   => { hdr => 'Questions',           num => 1, label => 'How many queries the server has gotten', },
         questions      => { src => 'Questions' },
 Questions/Uptime_hires
 Questions, Uptime, Questions/Uptime as QPS
 Questions, Uptime, set_precision(Questions/Uptime) as QPS
 Questions, Uptime, set_precision(Questions/Uptime_hires) as QPS
         quick => 1,
quick-filters.
               . "quit.", '';
quite a lot).  Therefore, the state of the program is exactly as in the innotop
quoted something.
quotes.  If you get an error message about a bareword, you probably should have
   qw( black blink blue bold clear concealed cyan dark green magenta on_black
      qw(child_index fk_name col_name parent_col);
      qw(child_index fk_name col_name parent_table parent_col);
            qw(col op arg color)
               qw(Com_delete Com_delete_multi Com_insert Com_insert_select Com_replace
                     qw(F h P S A))
         qw( hash_table_size hash_searches_s non_hash_searches_s
      qw(heap_no num_fields byte_offset info_bits);
                     qw(h P));
         qw(IB_bp_pages_total IB_bp_pages_read IB_bp_pages_written IB_bp_pages_created)
         qw(IB_ro_queries_inside IB_ro_queries_in_queue),
         qw(IB_sm_mutex_spin_waits IB_sm_mutex_spin_rounds IB_sm_mutex_os_waits),
      qw(last_s_file_name last_x_file_name writer_lock_mode);
         qw( log_ios_done pending_chkp_writes last_chkp log_ios_s
         qw( num_lock_structs history_list_len purge_done_for transactions
      qw(num_readers lock_var last_s_line last_x_line writer_thread);
         qw( pending_buffer_pool_flushes pending_pwrites pending_preads
         qw( Qcache_free_blocks Qcache_free_memory Qcache_not_cached Qcache_queries_in_cache)
         qw( queries_in_queue n_reserved_extents main_thread_state
      qw(style type );
         qw( timestring rolled_back txns complete ));
         qw( trigger parent_table child_index parent_index attempted_op
         qw( Uptime Aborted_clients Aborted_connects Bytes_received Bytes_sent
         qw( Uptime Com_begin Com_commit Com_rollback Com_savepoint
         qw( Uptime Com_dealloc_sql Com_execute_sql Com_prepare_sql Com_reset
         qw( Uptime Handler_read_key Handler_read_first Handler_read_next
         qw( Uptime Innodb_row_lock_current_waits Innodb_row_lock_time
         qw( Uptime Key_blocks_not_flushed Key_blocks_unused Key_blocks_used
         qw(Uptime Questions Com_delete Com_delete_multi Com_insert
         qw( Uptime Select_full_join Select_full_range_join Select_range
         qw( wait_array_size rw_shared_spins rw_excl_os_waits mutex_os_waits
         qw( writes_pending buf_pool_hit_rate total_mem_alloc buf_pool_reads
      qw(writes_pending_lru writes_pending_flush_list writes_pending_single_page
         r => {
   R => {
      RaiseError        => 1,
      { RaiseError => 1, PrintError => 0, AutoCommit => 1 });
range is between 0 and 9 and can be set directly from L<"S: Variables & Status">
      reader => \&load_config_active_columns,
      reader => \&load_config_active_connections,
      reader => \&load_config_active_filters,
      reader => \&load_config_active_server_groups,
      reader => \&load_config_colors,
      reader => \&load_config_config,
      reader => \&load_config_connections,
      reader => \&load_config_filters,
      reader => \&load_config_group_by,
      reader => \&load_config_mvs,
      reader => \&load_config_plugins,
      reader => \&load_config_server_groups,
      reader => \&load_config_sort_cols,
      reader => \&load_config_stmt_sleep_times,
      reader => \&load_config_tbl_meta,
      reader => \&load_config_varsets,
      reader => \&load_config_visible_tables,
            # Read from the file.
   read_master_log_pos         => { hdr => 'Read Master Pos',     num => 1, label => 'Read master log position' },
         read_master_log_pos         => { src => 'read_master_log_pos', hdr => 'Pos' },
         ReadMode('cbreak');
   ReadMode('cbreak');
   ReadMode('noecho');
         ReadMode('normal');
   ReadMode('normal');
   ReadMode('normal') unless $opts{n};
   readonly => {
readonly is set to 0, writes it out again when it exits.  Thus, if readonly is
   reads_pending               => { hdr => 'Pending Reads',       num => 1, label => 'Reads pending' },
            reads_pending pages_total buf_pool_hits writes_pending_single_page
         reads_pending              => { src => 'IB_bp_reads_pending' },
         reads_s flush_type avg_bytes_s pending_ibuf_aio_reads writes_s
   read_views_open             => { hdr => 'Rd Views',            num => 1, label => 'Number of read views open' },
         read_views_open num_rows_upd num_rows_ins num_rows_read
         read_views_open     => { src => 'IB_ro_read_views_open' },
# Really, really, super-global variables.
# Recognized properties:
   # Recompile the sort func. TODO: avoid recompiling at every refresh.
            |^RECORD\sLOCKS\sspace\sid
               ref($_)
            ref $_
   # Re-filter the list of candidates to only those on this server
                           : ref $meta->{$_}            ? '[expression code]'
Refresh only the specified number of times (ticks) before exiting.  Each refresh
registered.  In other words, if the plugin returns qw(foo bar) from
register_for_events(), it must have foo() and bar() methods.  These methods are
   relay_log_file              => { hdr => 'Relay File',          num => 0, label => 'Relay log file' },
         relay_log_file              => { src => 'relay_log_file' },
   relay_log_pos               => { hdr => 'Relay Pos',           num => 1, label => 'Relay log position' },
         relay_log_pos               => { src => 'relay_log_pos' },
   relay_log_size              => { hdr => 'Relay Size',          num => 1, label => 'Relay log size' },
         relay_log_size              => { src => 'relay_log_space', trans => [qw(shorten)] },
   relay_master_log_file       => { hdr => 'Relay Master File',   num => 0, label => 'Relay master log file' },
         relay_master_log_file       => { src => 'relay_master_log_file', hdr => 'Master File' },
Removes quoted control characters from the value.  This is affected by the
# Removes vowels and compacts repeated letters to shorten text.
   'rename'                       => 1,
      rename($old_filename, $new_filename)
      rename($old_filename, $tmp_filename)
   'rename result table'          => 1,
   rename($tmpfile, $conf_file) or die("Can't rename $tmpfile to $conf_file: $OS_ERROR");
      rename($tmp_filename, $new_filename)
   'Reopen tables'                => 1,
re-order the columns with the '+' and '-' keys.
   'Repair done'                  => 1,
   'Repair with keycache'         => 1,
   replicate_do_db             => { hdr => 'Do DB',               num => 0, label => 'Replicate-do-db setting' },
         replicate_do_db             => { src => 'replicate_do_db' },
   replicate_do_table          => { hdr => 'Do Table',            num => 0, label => 'Replicate-do-table setting' },
         replicate_do_table          => { src => 'replicate_do_table' },
   replicate_ignore_db         => { hdr => 'Ignore DB',           num => 0, label => 'Replicate-ignore-db setting' },
         replicate_ignore_db         => { src => 'replicate_ignore_db' },
   replicate_ignore_table      => { hdr => 'Ignore Table',        num => 0, label => 'Replicate-do-table setting' },
         replicate_ignore_table      => { src => 'replicate_ignore_table' },
   replicate_wild_do_table     => { hdr => 'Wild Do Table',       num => 0, label => 'Replicate-wild-do-table setting' },
         replicate_wild_do_table     => { src => 'replicate_wild_do_table' },
   replicate_wild_ignore_table => { hdr => 'Wild Ignore Table',   num => 0, label => 'Replicate-wild-ignore-table setting' },
         replicate_wild_ignore_table => { src => 'replicate_wild_ignore_table' },
replication, one for queries, and one for transactions.  innotop refreshes its
   request_type                => { hdr => 'Type',                num => 0, label => 'Type of lock the thread waits for' },
         request_type       => { src => 'request_type' },
# * required:  which parts are required (hashref).
         require $plugins{$line}->{file};
      require Term::ANSIColor;
   require Term::ReadLine;
         require Win32::Console::ANSI;
   reservation_count           => { hdr => 'ResCnt',              num => 1, label => 'Reservation Count' },
         reservation_count  => { src => 'IB_sm_reservation_count' },
   $response =~ s/\s+$//;
   $response = <STDIN>;
      $response = $term->readline("$prompt: ", $init);
         $res = $sth->fetchall_arrayref();
         $res = $stmt->fetchall_arrayref({})->[0];
               . 'rest of the rules from being applied.');
               $result->{'byte_offset'} = 0;
   $result{'cell_event_set'} = $text =~ m/^wait is ending$/m ? 1 : 0;
   $result{'cell_waiting'} = $text =~ m/^wait has ended$/m ? 0 : 1;
   $result->{'fields'} = [ map { parse_field($_, $complete, $debug ) } @fields ];
result in special ways before outputting it.  It uses the L<"var_status"> table
         $result->{$key} = $info->{func}->($set, $cur, $pre)
         $result->{$key} = $info->{num} ? 0 : '';
         @{$result}{qw( heap_no type num_fields byte_offset info_bits )}
         @{$result}{qw( heap_no type num_fields info_bits )}
      @result{ qw(last_s_file_name last_s_line ) }
      @result{ qw(last_x_file_name last_x_line ) }
      @result{ qw( lock_mem_addr lock_cfile_name lock_cline lock_var) }
      @result{ qw( num_readers waiters_flag )}
      @result{ qw( request_type lock_mem_addr lock_cfile_name lock_cline) }
   @result{ qw(thread waited_at_filename waited_at_line waited_secs) }
      @{$result}{qw( type num_fields )}
      @result{ qw( waiters_flag )}
      @result{ qw( writer_thread writer_lock_mode ) }
      $result{'request_type'} = 'M';
      $result = sprintf(
      $result->{'style'} = $style;
      $result->{'style'} = 'tuple';
retried transactions.  According to the MySQL manual, the
'retries' as the column name, 'Retries' as the column header, and
   # retries=hdr='Retries' minw='0' num='0' src='Slave_retried_transactions' dec='0' trans='' tbl='slave_sql_status' just='-' user='1' maxw='0' label='User-defined'
   return
                     return;
         return;
      return;
   return {
      return $_[0]
      return 0 + @_;
   return '00:00' unless $secs;
   return 0 unless $answer eq 'y';
   return 0 unless $fulltext;
   return 0 unless $num;
         return 0 unless @rules > 0 && $idx < @rules && $idx >= 0;
   return 0 unless $section && $section->{'fulltext'};
   return 0 unless $ts;
   return 1;
   return $answer;
         return  $a->{query} && !$b->{query} ? 1
   return bless $self, $class;
   return $char;
            return $choice;
         return $col;
   return (\%cols, \@visible);
         return $col unless @visible_cols > 1;
   return $config{color}->{val} ? [ $result, 'bold reverse' ] : $result;
      return $cxns[0];
   return $dbh;
      return $dbh->prepare($config{global}->{val} && version_ge( $dbh, '4.0.3' )
      return $dbh->prepare($config{global}->{val} && version_ge( $dbh, '5.0.2' )
      return $dbh->prepare('SHOW FULL PROCESSLIST');
      return $dbh->prepare('SHOW MASTER LOGS');
      return $dbh->prepare('SHOW MASTER STATUS');
      return $dbh->prepare('SHOW SLAVE STATUS');
      return $dbh->prepare(version_ge( $dbh, '5.0.0' )
         return ( !defined($set->{txn_status}) || $set->{txn_status} ne 'not started' )
   return defined(&$word)
         return $dest;
   return ($dsn, $info->{u}, $info->{p});
   return $dsn unless ref $dsn;
   return \%final_props;
   return grep { !$seen{$_}++ } @_;
      return $host;
   return $hostname;
   return $href->{dbh};
         return $idx;
         return $idx == 0 ? @$plugins - 1 : $idx - 1;
         return ($idx - 1) % $num_rules;
         return ($idx + 1) % $num_rules;
         return ($idx + 1) % scalar(@$plugins);
         return $idx == @rules ? $#rules : $idx;
         return $idx unless $col && exists $meta->{cols}->{$col};
         return $idx unless $color;
         return $idx unless $op && exists $comp_ops{$op};
         return $idx == $#visible_cols ? $visible_cols[$idx - 1] : $visible_cols[$idx + 1];
   return if $clearing_deadlocks++;
   return if $config{readonly}->{val};
   # return if no config file was loaded and -w wasn't specified
   return if $opts{u} or $opts{p} or $opts{h} or $opts{P}; # don't load connections if DSN or user/pass options used
      return if !$sub || $err;
   return $info;
   return \%innodb_data;
   return join(',',
   return \%labels;
   return $low + ( $high * $MAX_ULONG );
   return $low unless $high;
   return ( $mods, $query );
   return $name;
   return $new;
   return @new_rows;
   return $num;
   return $num if !defined($num) || $opts{n} || $num !~ m/$num_regex/;
      return qw(file);
    return qw(set_to_tbl_pre_filter);
   return $response;
   return @result;
   return $result;
   return \%result;
   return @rows;
         return scalar grep { $filters{$_}->{quick} } @{ $tbl_meta{$tbl}->{filters} };
    return $self;
   return $self->{$prop};
         return ( !$set->{info} || $set->{info} ne 'SHOW FULL PROCESSLIST' )
         return $set->{master_file} ? 1 : 0;
         return $set->{master_host} ? 1 : 0;
         return $set->{num_times_open} + $set->{is_name_locked};
         return !$set->{state} || $set->{state} !~ m/^(?:Waiting for master|Has read all relay)/;
         return $set->{thread_status} !~ m#waiting for i/o request#;
   return sprintf(
   return sprintf('%02d-%02d-%02d %02d:%02d:%02d', @$parts);
   return sprintf("%.${digits}f", $num * 100)
      return $sth;
   return $sth;
Returns the average of defined elements in the group.
# Returns the difference between two sets of variables/status/innodb stuff.
Returns the first element in the group.
Returns the number of elements in the group, including undefined elements, much
Returns the sum of elements in the group.
# returns true or false.
   return \%stuff;
   return $sub;
   return ( $sub, $err );
   return sub { return @_ } unless @criteria;
   return substr($text, 0, $len);
      return sum(@args);
      return (sum(map { m/([\d\.-]+)/g } @args) || 0) / (scalar(@args) || 1);
   return $tbl;
      return @tbls;
      return $tbls[0];
      return $text;
   return $text;
   return $text if length($text) <= $len;
   return $text if $len && length($text) <= $len;
   return (time() - $dbhs{$cxn}->{start_time}) || .001;
   return undef if $dbhs{$cxn}
   return undef if $file;
   return undef unless @criteria;
   return undef unless $dump;
   return unique(@connections);
   return unique(grep { exists $connections{$_} } split(/\s+/, $new_cxns));
   return unless @candidates;
      return unless $col && $text &&
   return () unless $config{show_cxn_errors_in_tbl}->{val};
   return unless $cxn && exists($connections{$cxn});
   return '' unless defined $text;
   return unless $dl;
      return unless do_query($cxn, "commit"); # Or the children will block against the parent
      return unless do_query($cxn, "create table $tbl(a int) $engine=innodb");
      return unless do_query($cxn, "delete from $tbl");
      return unless do_query($cxn, "drop table if exists $tbl");
      return unless do_query($cxn, "insert into $tbl(a) values(0), (1)");
   return unless @grps;
   return unless $info;
   return unless $master;
   return unless pause("Kill $info->{id}?") =~ m/y/i;
   return unless $section;
   return unless $section && $section->{'fulltext'};
   return unless @slave_status;
   return unless $stmt && exists $stmt_maker_for{$stmt};
   return unless $tbl;
   return unless $tbl && exists $tbl_meta{$tbl};
      return unless $thread && $thread =~ m/$int_regex/;
   return $usage;
         return \$val;
    return $val;
      return $vars->{$clock};
      return $vars->{$clock - $offset};
   return $var_sets{$config{$name}->{val}}->{text};
      return version_ge($dbh, '4.0.0')
   return $version ge sprintf('%03d%03d%03d', $target =~ m/(\d+)/g);
         return $visible_cols[ $idx - 1 ];
         return $visible_cols[ ($idx + 1) % @visible_cols ];
   return ( $y, $m, $d, $h, $i, $s );
            $rev ||= 0;
# reverse_sort {{{3
reverse sort, prefix the column name with a minus sign.  For example, if you
       reverse underline underscore white yellow);
rewrite certain queries to make them EXPLAIN-able.  For example, INSERT/SELECT
# rewrite_for_explain {{{3
# right-hand arrayref, and options hashref.  Tries to stack as high as
   ro => \&parse_ro_section,
 [RO] Query List (? for help) localhost, 01:11:19, 449.44 QPS, 14/7/163 con/run
                  $row->{$col_name} = sprintf("%s%-${max_rodp}s", $l, $r);
               $row->{_color} = $meta->{color_func}->($row);
       $row->{example} = 1;
   # (row_ins_foreign_report_err), and an insert or update of a child record has
   row_locks                   => { hdr => 'RLocks',              num => 1, label => 'Number of row locks' },
      row_locks          => $row_locks,
         row_locks          => { src => 'row_locks' },
   row_operation_misc => {
      row_operation_misc => \@row_operation_misc,
   row_operations => {
row operations, logs, I/O operations, load graph, and more.  You can
   "ROW OPERATIONS"                        => "ro",
      row_operations     => \@row_operations,
            } @rows;
      @rows = apply_group_by($tbl, $meta->{group_by}, @rows);
      @rows = apply_group_by('var_status', [], @rows);
rows are more important.  You can customize the colorization rules and add your
rows.  Assume you start with this table:
      @rows = create_caption($meta->{capt}, @rows)
   @rows = create_table( $fmt_cols, $fmt_meta, \@rows);
   } @{$rows_for{innodb_transactions}};
   } @{$rows_for{processlist}};
            @$rows = grep { $filters{$filter}->{func}->($_) } @$rows;
            @rows = grep { $filters{$filter}->{func}->($_) } @rows;
            @rows = map {
            @$rows = $meta->{sort_func}->( @$rows );
            @rows = $meta->{sort_func}->( @rows );
            @$rows = reverse $meta->{sort_func}->( @$rows );
            @rows = reverse $meta->{sort_func}->( @rows );
            $rows[$row]->{''} = $row eq $selected ? '>' : ' ';
      @rows = @tmp;
rules are evaluated.  The rules look like the following:
      $rule_set_for{$tbl} ||= [];
running configuration to ~/.innotop/innotop.conf on exit, if no configuration
running innotop in another mode, for example T mode, and suddenly you don't see
# Run the program {{{1
   rw_excl_os_waits            => { hdr => 'RW Waits',            num => 1, label => 'R/W Excl. OS Waits' },
         rw_excl_os_waits rw_excl_spins rw_shared_os_waits rw_shared_spins
         rw_excl_os_waits   => { src => 'IB_sm_rw_excl_os_waits' },
   rw_excl_spins               => { hdr => 'RW Spins',            num => 1, label => 'R/W Excl. Spins' },
         rw_excl_spins      => { src => 'IB_sm_rw_excl_spins' },
   rw_shared_os_waits          => { hdr => 'Sh Waits',            num => 1, label => 'R/W Shared OS Waits' },
         rw_shared_os_waits => { src => 'IB_sm_rw_shared_os_waits' },
   rw_shared_spins             => { hdr => 'Sh Spins',            num => 1, label => 'R/W Shared Spins' },
         rw_shared_spins    => { src => 'IB_sm_rw_shared_spins' },
         s => {
   s => {
         S => {
   S => {
safely, however innotop reads the configuration file when it starts, and, if
   # Sample fields:
   # Sanity check props
   save_config();
# save_config {{{3
# save_config_active_columns {{{3
# save_config_active_connections {{{3
# save_config_active_filters {{{3
# save_config_active_server_groups {{{3
# save_config_colors {{{3
# save_config_config {{{3
# save_config_connections {{{3
# save_config_filters {{{3
# save_config_group_by {{{3
# save_config_mvs {{{3
# save_config_plugins {{{3
# save_config_server_groups {{{3
# save_config_sort_cols {{{3
# save_config_stmt_sleep_times {{{3
# save_config_tbl_meta {{{3
# save_config_varsets {{{3
# save_config_visible_tables {{{3
      savepass  => $savepass
   # Save queries in global variable for analysis.  The rows in %rows_for have been
save the password in the innotop configuration file.  If you don't save it in
   # Save to a temp file first, so a crash doesn't destroy the main config file
say it does not persist to the configuration file itself.
   #   = scalar(
         ? scalar(@$display_lines)- 1
   scan_type                   => { hdr => 'Type',                num => 0, label => 'Scan type in chosen' },
         scan_type     => { src => 'type' },
   { s => 'color|C!',   d => 'Use terminal coloring (default)',   c => 'color' },
   { s => 'config|c=s', d => 'Config file to read' },
   { s => 'count=i',    d => 'Number of updates before exiting' },
      \s*create\s+(?:temporary\s+)?table
screenful at a time.
screen, it will prompt you to choose one of them.  Once you do, innotop will
screen.  The first word is the number of seconds since the last SHOW INNODB
screen, which tells you that readonly is set to true ([RO]), what mode you're
            |^\*\*\*\s\(\d\)
   { s => 'delay|d=f',  d => 'Delay between updates in seconds',  c => 'interval' },
            ( $search_index, $records ) = $fulltext
Sebastien Estienne,
   $secs ||= 0;
          : $secs >= 3_600  ? 'h'
         $secs % 60)
         $secs % 60);
# secs_to_time {{{3
   secs_to_time => \&secs_to_time,
   # section
      $section->{$_} ||= 0;
         $section->{'attempted_op'} = $attempted_op || '';
      $section->{'attempted_op'} = $attempted_op || '';
   $section->{'attempted_op'} = 'DDL';
   @{$section}{'awe_mem_alloc'}      = $fulltext =~ m/$d MB of AWE memory/;
section begins with [section-name] and ends with [/section-name].  Each
   @{$section}{'buf_free'}           = $fulltext =~ m/^Free buffers\s*$d$/m;
      @{$section}{'buf_pool_hit_rate'}
      @{$section}{'buf_pool_hit_rate'} = '--';
   @{$section}{'buf_pool_hits', 'buf_pool_reads'}
      @{$section}{'buf_pool_hits', 'buf_pool_reads'} = (0, 0);
   @{$section}{'buf_pool_size'}      = $fulltext =~ m/^Buffer pool size\s*$d$/m;
      $section->{'child_index'} = $index;
            $section->{'child_index'} = $search_index;
   @{$section}{'dict_mem_alloc'}     = $fulltext =~ m/Dictionary memory allocated $d/;
   @{$section}{ 'flush_type', 'pending_log_flushes', 'pending_buffer_pool_flushes' }
   @{$section}{ 'hash_searches_s', 'non_hash_searches_s' }
   @{$section}{ 'hash_table_size', 'used_cells', 'bufs_in_node_heap' }
   @{$section}{ 'history_list_len' } # This isn't present in some 4.x versions
   @{$section}{ 'inserts', 'merged_recs', 'merges' }
   @{$section}{ 'ins_sec', 'upd_sec', 'del_sec', 'read_sec' }
   @{$section}{ 'is_truncated' }
   ( $section->{ 'last_chkp' } )
   ( $section->{ 'log_flushed_to' } )
   @{$section}{ 'log_ios_done', 'log_ios_s' }
   ( $section->{ 'log_seq_no' } )
   $section->{'main_thread_proc_no'} ||= 0;
   @{$section}{ 'main_thread_proc_no', 'main_thread_id', 'main_thread_state' }
   @{$section}{ 'mutex_spin_waits', 'mutex_spin_rounds', 'mutex_os_waits' }
   ( $section->{ 'n_reserved_extents' } )
   @{$section}{ 'num_lock_structs' }
   @{$section}{ 'num_rows_ins', 'num_rows_upd', 'num_rows_del', 'num_rows_read' }
section of SHOW INNODB STATUS.  It is nested one level deep.
section of SHOW INNODB STATUS.  It is nested two levels deep: transactions, then
   @{$section}{ 'os_file_reads', 'os_file_writes', 'os_fsyncs' }
   @{$section}{'page_reads_sec', 'page_creates_sec', 'page_writes_sec'}
   @{$section}{'pages_modified'}     = $fulltext =~ m/^Modified db pages\s*$d$/m;
   @{$section}{'pages_read', 'pages_created', 'pages_written'}
   @{$section}{'pages_total'}        = $fulltext =~ m/^Database pages\s*$d$/m;
   $section->{'parent_db'} ||= $section->{'child_db'};
            $section->{'parent_index'} = $search_index;
   @{$section}{ 'pending_ibuf_aio_reads', 'pending_log_ios', 'pending_sync_ios' }
   @{$section}{ 'pending_log_writes', 'pending_chkp_writes' }
   @{$section}{ 'pending_normal_aio_reads', 'pending_aio_writes' }
   @{$section}{ 'pending_preads', 'pending_pwrites' }
   @{$section}{ 'pending_preads', 'pending_pwrites' } = (0, 0)
   @{$section}{ 'purge_done_for', 'purge_undo_for' }
   @{$section}{ 'queries_inside', 'queries_in_queue' }
   @{$section}{ qw(attempted_op parent_db parent_table) } = $fulltext
   @{$section}{ qw(child_db child_table) } = $fulltext
   @{$section}{ qw(child_index) } = $fulltext
      @{$section}{ qw(col_name parent_db parent_table parent_col) }
   @{$section}{ qw(fk_name col_name parent_db parent_table parent_col) }
      @{$section}{qw(parent_db parent_table)}
   @{$section}{ qw(reason child_db child_table) }
   @{$section}{ qw(reason) } = $fulltext =~ m/:\s*([^:]+)(?= Constraint:|$)/ms;
      @{$section}{ qw(writes_pending_lru writes_pending_flush_list writes_pending_single_page) });
   @{$section}{'reads_pending'} = $fulltext =~ m/^Pending reads $d/m;
   @{$section}{ 'reads_s', 'avg_bytes_s', 'writes_s', 'fsyncs_s' }
   ( $section->{ 'read_views_open' } )
   ( $section->{'reason'} ) = $fulltext =~ m/(Cannot .*)/s;
   $section->{'reason'} =~ s/\n(?:InnoDB: )?/ /gm
   $section->{'reason'} =~ s/\s+/ /g
            $section->{'records'}
            $section->{'records'} = '';
         ( $section->{'records'} )
   @{$section}{ 'reservation_count', 'signal_count' }
   @{$section}{ 'rw_shared_spins', 'rw_shared_os_waits', 'rw_excl_spins', 'rw_excl_os_waits' }
   $sections ||= {};
               && (!%$sections || (defined($sections->{$section} && $sections->{$section})) )) {
section's entries have a different syntax depending on the data they need to
   # sections from it.
   @{$section}{ 'size', 'free_list_len', 'seg_size' }
      sections  => {},        # Parsed values from each section
               \%sections_required,
         $sections_required{$sec} = 1;
   $section->{'threads'} = {};
         $section->{'threads'}->{$tid} = {
   $section->{'timestring'} = ts_to_string($section->{'ts'});
   @{$section}{ 'total_mem_alloc', 'add_pool_alloc' }
   $section->{'transactions'} = [];
      $section->{'trigger'} = parse_innodb_record_dump( $trigger, $complete, $debug );
   @{$section}{ 'trx_id_counter' }
   $section->{'ts'} = [ parse_innodb_timestamp( $ts ) ];
      $section->{'txn'} = parse_tx_text( $txn, $complete, $debug, $full );
   $section->{'type'} = $type;
   $section->{'wait_array_size'} = scalar(@waits);
   $section->{'waits'} = [ map { parse_wait_array($_, $complete, $debug) } @waits ];
         $section->{$which . '_index'} = $index;
   @{$section}{'writes_pending'} = List::Util::sum(
   @{$section}{'writes_pending_lru', 'writes_pending_flush_list', 'writes_pending_single_page' }
# See dict/dict0dict.c, function dict_foreign_error_report
See L<"ERROR HANDLING">.
See L<"ERROR HANDLING"> for more details about innotop's error handling.
(see L<"SERVER CONNECTIONS">).
See L<"VARIABLE SETS">.
# see source file row/row0ins.c
# See srv_printf_innodb_monitor in innobase/srv/srv0srv.c
see the table editor screen again.  Press 'q' to exit the table editor, and
      # See whether there are any connections defined for this mode.  If there's only one
   seg_size                    => { hdr => 'Seg. Size',           num => 1, label => 'Segment size' },
         seg_size      => { src => 'IB_ib_seg_size' },
      'SELECT /*!50038 @@hostname, */ 1');
      'Select a thread to analyze',
      'Select a thread to kill the ' . $q_or_c,
# select_cxn {{{3
         'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
            $selected ||= 0;
         $selected ||= 0;
               $selected_column ||= $meta->{visible}->[0];
            $selected_column ||= $meta->{visible}->[0];
               $selected_column = $tbl_editor_action{$key}->{func}->($tbl, $selected_column);
            $selected = $plugin_editor_action{$key}->{func}->(\@rows, $selected);
               $selected_rule ||= 0;
            $selected_rule ||= 0;
               $selected_rule = $color_editor_action{$key}->{func}->($tbl, $selected_rule);
         "select * from $tbl where a = $id",
 Select_full_join          39479   0.85%          0    0.00%
 Select_full_range_join     4097   0.09%          0    0.00%
 Select_range            1354177  29.17%          0    0.00%
 Select_range_check            0   0.00%          0    0.00%
         Select_range_check Select_scan Slow_queries Sort_merge_passes
 Select_scan             3244858  69.89%          2  100.00%
# Selects connection(s).  If the mode (or argument list) has only one, returns
   select_type                 => { hdr => 'Select Type',         num => 0, label => 'Type of select used' },
         select_type   => { src => 'select_type' },
      $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
      = $self->parse_status_text($fulltext, $debug, $sections, $full );
      $self->print_active_handles( $handle, $level + 1 );
      $self->{$prop} = $value;
   semaphores => {
      semaphores         => \@semaphores,
   "SEMAPHORES"                            => "sm",
   send_cmd_to_servers($stmt, 0, 'PURGE {MASTER | BINARY} LOGS {TO "log_name" | BEFORE "date"}', [$master]);
               { sep => '  ' });
               { sep => '  ' }));
            { sep => '  ' }));
         { sep => '  ' }));
         sep   => ':',
"server1 server2."  Again, if you type the name of a connection that doesn't
server connections and switch between them by pressing the '@' key.  See
      server_group    => '',
      server_group      => '',
   server_groups => {
      ? @{$server_groups{$modes{$mode}->{server_group}}}
   $server_groups{$name} = \@cxns;
      $server_groups{$name} = \@vars;
      $server_groups{$new} = \@conns;
   server_groups => \%server_groups,
server it's monitoring has been up; so it calculates the server's uptime as time
   ServerLoad        => q{ $cur->{Threads_connected}/(Questions||1)/Uptime_hires },
servers at all.  It will watch the specified file for InnoDB status output and
# Server sets {{{3
servers from the slave tables, and non-master servers from the master table.
servers, it can also send commands to servers.  The most frequently useful
servers which support the GLOBAL option to SHOW VARIABLES and SHOW STATUS.  In
         . "   \$set->{active_secs} > 5\n"
$set and $cur will be the same values.  However, if L<"status_inc"> is set, $cur
set, a set of current values, and a set of previous values.  These are all
            $set->{$col}  = 1 unless defined $set->{$col} && $set->{$col} =~ m/$num_regex/;
            $set->{$col} /= $mvs{$col};
            $set->{$col}  = ($set->{$col} || 1) / ($set->{Uptime_hires} || 1);
# set_display_precision {{{3
         'set_precision(('
# set_precision {{{3
         'set_precision(Com_commit/Uptime_hires) as Commit_PS',
         'set_precision((Com_rollback||0)/(Com_commit||1)) as Rollback_Commit',
         'set_precision((Com_select+(Qcache_hits||0))/(('
         "set_precision($exprs{BufPoolFill} * 100) as buf_fill",
         "set_precision($exprs{DirtyBufs} * 100) as dirty_bufs",
         'set_precision(Opened_tables/Uptime_hires) as Opens_PS',
         'set_precision((Qcache_hits||0)/(Qcache_inserts||1)) as Hit_Ins',
         'set_precision((Qcache_lowmem_prunes||0)/Uptime_hires) as Lowmem_Prunes_sec',
         'set_precision(Questions/Uptime_hires) as QPS',
         'set_precision(Select_full_join/Uptime_hires) as Full_Join_PS',
   set_precision => \&set_precision,
         'set_precision(Slow_queries/Uptime_hires) as Slow_PS',
         'set_precision(Threads_created/Uptime_hires) as Threads_PS',
               $set, $pre, 'file_io_misc');
             && ( !$set->{query_text}    || $set->{query_text} !~ m/INNODB STATUS$/ );
 $set->{Questions}/$set->{Uptime_hires}
# Sets (arrayrefs) of variables that are used in S mode.  They are read/written to
sets its value to 1.
Sets the configuration option L<"readonly"> to 0, making innotop write the
    # Set the example column's data source to the value 1.
$set.  The values innotop extracts are determined by the table's columns.  Each
      # Set timeouts so an unused connection stays alive.
setting.
set to 0, any changes you make by hand while innotop is running will be lost.
# set_to_tbl {{{3
set_to_tbl_post_create.
      set_to_tbl_pre_colorize set_to_tbl_pre_transform set_to_tbl_pre_pivot
      set_to_tbl_pre_create set_to_tbl_post_create
      set_to_tbl_pre_filter set_to_tbl_pre_sort set_to_tbl_pre_group
set_to_tbl_pre_sort,set_to_tbl_pre_group, set_to_tbl_pre_colorize,
set_to_tbl_pre_transform, set_to_tbl_pre_pivot, set_to_tbl_pre_create,
         "set transaction isolation level serializable",
   'setup'                        => 1,
# Setup and tear-down functions {{{2
      # Set up the table for creating a deadlock.
   # Set up whether to pivot and how many sets to extract.
# * setvars:   a list of variables to set after connecting
   S_func => {
shared by innotop and all plugins.  Plugins are loaded in the order they're
   { s => 'help',       d => 'Show this help message' },
         (shift @all_actions || ''));
         (shift @all_magic || ''));
         (shift @all_modes || ''));
         (shift @col1      || ''),
         (shift @col1        || ''),
         (shift @col2      || ''),
            shift @{$meta->{visible}};
# shorten {{{3
            shorten($qps) . " QPS",
   shorten      => \&shorten,
# Shortens text to specified length.
   { s => 'host|h=s',   d => 'Connect to host' },
should be reported.
   show_cxn_errors => {
   show_cxn_errors_in_tbl => {
             ? 'SHOW ENGINE INNODB STATUS'
SHOW FULL PROCESSLIST immediately afterward, the processlist contains more
# show_full_query {{{3
             ? 'SHOW GLOBAL STATUS'
             ? 'SHOW GLOBAL VARIABLES'
         # Show help
      # Show help
             : 'SHOW INNODB STATUS');
"SHOW INNODB STATUS".  The statements are as follows:
 SHOW_MASTER_LOGS    SHOW MASTER LOGS
   SHOW_MASTER_LOGS => sub {
 SHOW_MASTER_STATUS  SHOW MASTER STATUS
   SHOW_MASTER_STATUS => sub {
# show_optimized_query {{{3
   show_percent => {
shows captions on all tables globally.  Some tables are configured with the
 SHOW_SLAVE_STATUS   SHOW SLAVE STATUS
   SHOW_SLAVE_STATUS => sub {
             : 'SHOW STATUS');
   show_statusbar => {
 SHOW_STATUS         SHOW [GLOBAL] STATUS
   SHOW_STATUS => sub {
Shows the output of EXPLAIN.  Data source: L<"EXPLAIN">.
Shows transactions involved in the last detected deadlock.  Data source:
Shows which locks were held and waited for by the last detected deadlock.  Data
             : 'SHOW VARIABLES');
         'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
 SHOW_VARIABLES      SHOW [GLOBAL] VARIABLES
   SHOW_VARIABLES => sub {
show you something like this:
   signal_count                => { hdr => 'Signals',             num => 1, label => 'Signal Count' },
         signal_count reservation_count )],
         signal_count       => { src => 'IB_sm_signal_count' },
sign (see L<"show_percent">).
Similarly, in L<"T: InnoDB Transactions"> mode, the L<"t_header"> table is
simple key=value list.  innotop writes a comment above each value to help you
Since errors might only happen in certain modes because of the SQL commands
since innotop started running.
Since this DSN is passed to the DBD::mysql driver, you should read the driver's
   { s => 'inc|i!',     d => 'Measure incremental differences',   c => 'status_inc' },
single line each time the screen updates, in the style of B<vmstat>.  The 'g'
   size                        => { hdr => 'Size',                num => 1, label => 'Size of the tablespace' },
         size          => { src => 'IB_ib_size' },
   skip_counter                => { hdr => 'Skip Counter',        num => 1, label => 'Skip counter' },
         skip_counter                => { src => 'skip_counter' },
   skip_innodb => {
   SlaveCatchupRate  => ' defined $cur->{seconds_behind_master} && defined $pre->{seconds_behind_master} && $cur->{seconds_behind_master} < $pre->{seconds_behind_master} ? ($pre->{seconds_behind_master}-$cur->{seconds_behind_master})/($cur->{Uptime_hires}-$pre->{Uptime_hires}) : 0',
   slave_catchup_rate          => { hdr => 'Catchup',             num => 1, label => 'How fast the slave is catching up in the binlog' },
         slave_catchup_rate          => { src => $exprs{SlaveCatchupRate}, trans => [ qw(set_precision) ] },
   slave_io_running            => { hdr => 'Slave-IO',            num => 0, label => 'Whether the slave I/O thread is running' },
         slave_io_running            => { src => 'slave_io_running', hdr => 'On?' },
   slave_io_state              => { hdr => 'Slave IO State',      num => 0, label => 'Slave I/O thread state' },
         slave_io_state              => { src => 'slave_io_state', hdr => 'State' },
   slave_io_status => {
      slave_io_status  => \@slave_io_status,
   slave_open_temp_tables      => { hdr => 'Temp',                num => 1, label => 'Slave open temp tables' },
         slave_open_temp_tables      => { src => 'Slave_open_temp_tables' },
'Slave_retried_transactions' as the source.  Now the column is created, and you
Slave_retried_transactions status variable gives you that data: "The total
slaves at once.  innotop fills in a default command of START SLAVE or STOP SLAVE
   slave_sql_running           => { hdr => 'Slave-SQL',           num => 0, label => 'Whether the slave SQL thread is running' },
         slave_sql_running           => { src => 'slave_sql_running', hdr => 'On?' },
   slave_sql_status => {
slave_sql_status as the table, then press 'n' to create the column.  Type
      slave_sql_status => \@slave_sql_status,
   @slaves = select_cxn("Which slaves are reading from $master?", @slaves);
   @slave_status = grep { my $item = $_; grep { $item->{cxn} eq $_ } @slaves } @slave_status;
      sleep(1 + $id);
(Sleep), and some connections executing queries (Query and Sending Data).
         sleep($config{interval}->{val});
      sleep($stmt_sleep_time_for{$stmt_name}) if $stmt_sleep_time_for{$stmt_name};
# Sleep times after certain statements {{{3
Sleep times are stored in the L<"stmt_sleep_times"> section of the configuration
   slow                        => { hdr => 'Slow',                num => 1, label => 'How many slow queries', },
   slow_queries => {
         slow           => { src => 'Slow_queries',                         dec => 1, trans => [qw(shorten)] },
   { s => 'mode|m=s',   d => 'Operating mode to start in',        c => 'mode' },
   sm => \&parse_sm_section,
   { s => 'nonint|n',   d => 'Non-interactive, output tab-separated fields' },
so explaining may not work right if the query is truncated.
so it tries less frequently as time passes.
# Some common patterns
Some modes have keys mapped to open this dialog directly, and to quickly reverse
some MySQL versions, you need certain privileges to do this; if you don't have
some numbers to human-readable formats.
               # Some properties are arrays, others scalars.
               # Some properties (trans) are arrays, others scalars
   # Some servers will output ibuf information for tablespace 0, as though there
      # Some things may not be in the text, so make sure they are not
   # Some things may not be in the txn text, so make sure they are not
so much code devoted to parsing this messy, unparseable output that innotop is
      # Sort.
      sort_cols => '',
   sort_cols => {
      sort_cols => '-active_secs txn_status cxn mysql_thread_id',
      sort_cols => 'cxn',
      sort_cols => 'cxn -lock_wait_time',
      sort_cols => 'cxn mysql_thread_id',
      sort_cols => 'cxn thread',
      sort_cols => 'cxn -time',
      sort_cols => '-num_times_open cxn db tbl',
      sort_cols => 'slave_io_running cxn',
      sort_cols => 'slave_sql_running cxn',
      sort_cols => '-time cxn hostname mysql_thread_id',
      sort_cols => '-value',
      sort_cols => 'when cxn',
      'Sort columns (reverse sort with -col)',
      sort_dir => '1',
      sort_dir  => '1',
      sort_dir  => 1,
sort direction.  Press '?' as usual to see which keys are mapped in any mode.
   # sorted by existing columns.  TODO: this will crash if you toggle between
sorted by value descending and compared to the last variable, as shown above.
         [ sort keys %cfg_editor_action ],
               [ sort keys %color_editor_action ],
      sort keys %$dsn );
               [ sort keys %$hints ],
            [ sort keys %plugin_editor_action ],
               [ sort keys %tbl_editor_action ],
      # Sort longest-active first, then longest-idle.
      # Sort.  Note that if the table is pivoted, sorting might have the wrong
         Sort_range Sort_rows Sort_scan)
Sort the rows to put important data first or group together related rows.
      # Sort type is not really possible on pivoted columns, because a 'column'
so there is a potential for conflict or interaction between plugins if they
   # So this section is complete if the entire file is complete.
source code, plus the configuration variables from the L<"general"> section in
Sourceforge.net,
# source.  Fortunately, most of them begin with a gerunded verb.  These are
source: L<"DEADLOCK_LOCKS">.
source (see L<"DATA SOURCES">).  See L<"EXPRESSIONS"> for more on expressions.
   space_id                    => { hdr => 'Space',               num => 1, label => 'Tablespace ID' },
         space_id         => { src => 'space_id' },
   { s => 'password|p=s',   d => 'Password to use for connection' },
              :                                             $spec->{arg};
   # Special case, which I don't know how to trigger, but see
   special                     => { hdr => 'Special',             num => 0, label => 'Special/Other info' },
         special       => { src => 'extra' },
         special          => { src => 'special' },
specified, which are likely to be the server's hostname.  A connection that has
Specifies a configuration file to read.  This option is non-sticky, that is to
Specifies the amount of time to pause between ticks (refreshes).  Corresponds to
Specifies the mode in which innotop should start.  Corresponds to the
Specifies what kind of characters to allow through the L<"no_ctrl_char">
Specifies where plugins can be found.  By default, innotop stores plugins in the
Specifies whether innotop should display absolute numbers or relative numbers
Specifies which set of variables to display in L<"S: Variables & Status"> mode.
specifying a username or password for the connection.
specify to group on certain columns, or if you don't specify any, the entire set
   $spec->{k} = $short || $long;
   $spec->{l} = $long;
   $spec->{n} = $spec->{s} =~ m/!/;
              : $spec->{op} =~ m/^(?:=~|!~)$/             ? "m/" . quotemeta($spec->{arg}) . "/"
   $spec->{t} = $short;
         splice(@{$tbl_meta{$tbl}->{colors}}, $idx, 1);
   # Split it into sections.  Each section begins with
   # Split them into three kinds of keys: MODE keys, action keys, and
   { s => 'port|P=i',   d => 'Port number to use for connection' },
      : sprintf(
                  : sprintf('%-' . $cap_len . 's', $_);
                  ? [ sprintf('%-' . $cap_len . 's', $_->[0]), $_->[1] ]
            sprintf("%${max_width}s$pad%${max_r}s", ' ', $right->[$i - $offset]);
   sprintf("%.${precision}f", $num);
SQL.  innotop has several built-in filters, which remove irrelevant information
   src     => '',
src: an expression that innotop uses to extract the column's data from its
       src   => 'example', # Get data from this column in the data source
            $src = prompt("Enter column source");
            src   => $src,
         src  => $text,
   S_set => {
   { s => 'skipcentral|s',     d => 'Skip reading the central configuration file' },
      \s+(?:\S+\s+)as\s+select/select/xis;
# stack_next {{{3
# Stacks one display section next to the other.  Accepts left-hand arrayref,
start for creating your own.  Press 'e' to edit the current variable set, or
               start_S_mode();
# start_S_mode {{{3
starts.  Passwords in the innotop configuration file are saved in plain text,
Starts the configuration editor to edit global and mode-specific configuration
Starts the plugin configuration editor.  See L<"PLUGINS"> for details.
Starts the row-coloring rules editor on one of the displayed table(s).  See
Starts the table editor on one of the displayed tables.  See L<"TABLE EDITOR">.
      start_time => 0,
 state  eq  Locked       black on_red
   state                       => { hdr => 'State',               num => 0, label => 'Connection state', maxw => 18, },
statement_name=sleep_time.  See L<"S: Statement Sleep Times">.
statements are rewritable.
# statements globally.  Returns a $sth that's been executed.
 Statement           SQL executed
statements.  That's the data source for variable sets.  You can now query this
# statements.  They aren't indicative of some transaction trying to insert,
         state           => { src => 'state',      minw => 0,  maxw => 0 },
            state     => $state,
   'statistics'                   => 1,
STATUS">.
   'status'                       => 1,
STATUS, as well as many of the non-repeated values from SHOW INNODB STATUS.
   status_inc => {
& Status"> mode.  It also controls the number of old sets of variables innotop
STATUS output.  A large deadlock can fill the entire output, or even be
status text.  If you have a very busy server, you may have frequent lock waits;
STATUS, which InnoDB uses to calculate some per-second statistics.  The next is
Steven Kreuzer,
         $sth = $dbh->prepare($query);
         $sth = $dbhs{$cxn}->{stmts}->{$stmt_name};
         $sth = do_stmt($cxn, 'SHOW_VARIABLES') or next;
         $sth->execute();
            $sth->execute(@args);
            $sth = undef;
         $stmt = do_stmt($cxn, 'SHOW_SLAVE_STATUS') or next;
      stmts      => {},  # bucket for prepared statements.
      $stmt_sleep_time_for{$key} = $val;
      $stmt_sleep_time_for{$stmt} = $new_val;
   stmt_sleep_times => {
   # Stop altering arguments now.
    # Store reference to innotop's variables in $self
# Stores info on currently displayed queries: cxn, connection ID, query text.
# Stores status, variables, innodb status, master/slave status etc.
store.  You can put comments in the file; any line that begins with a #
   # Strip garbage from the error text if possible.
# Strips out non-printable characters within fields, which freak terminals out.
            |^-------\sTRX\sHAS\sBEEN\sWAITING
   $stuff{'fulltext'} = $txn if $debug;
   $stuff{'hostname'} ||= $stuff{'ip'};
   $stuff{'locks'} = $locks if $locks;
         : sub{};
      sub {
      sub { $_[0]->{query} },
      sub { 1 },
sub add_new_dsn {
sub add_new_server_group {
sub add_new_var_set {
sub add_quick_filter {
sub analyze_query {
sub apply_group_by {
sub as_string {
sub choose_connections {
sub choose_filters {
sub choose_group_cols {
sub choose_mode_tables {
sub choose_or_create_connection {
sub choose_or_create_server_group {
sub choose_server_groups {
sub choose_servers {
sub choose_sort_cols {
sub choose_thread {
sub choose_var_set {
sub choose_visible_table {
sub clear_deadlock {
sub clear_quick_filters {
sub collapse_ws {
sub commify {
sub compile_expr {
sub compile_filter {
sub compile_select_stmt {
 sub compute_column_value {
sub connect_to_db {
sub core_dump {
sub create_caption {
sub create_deadlock {
sub create_new_filter {
sub create_statusbar {
sub create_table {
sub create_table2 {
sub crunch {
sub _d {
sub deadlock_thread {
sub _debug {
sub disconnect {
sub display_B {
sub display_C {
sub display_D {
sub display_explain {
sub display_F {
sub display_help {
sub display_I {
sub display_L {
sub display_license {
sub display_M {
sub display_O {
sub display_Q {
sub display_R {
sub display_S {
sub display_T {
sub do_key_action {
sub donut {
sub do_query {
sub do_stmt {
sub draw_screen {
sub dulint_to_int {
sub edit_color_rules {
sub edit_configuration {
sub edit_configuration_variables {
sub edit_current_var_set {
sub edit_plugins {
sub edit_server_groups {
sub edit_stmt_sleep_times {
sub edit_table {
               ( $sub, $err ) = compile_expr($src);
      ( $sub, $err ) = compile_filter($body);
sub extract_values {
sub fill_in_dsn {
 sub filter {
sub finish {
sub get_config_interactive {
sub get_connections {
sub get_cxn_errors {
sub get_cxn_params {
sub get_dbh {
sub get_driver_status {
sub get_full_processlist {
sub get_hostname {
sub get_innodb_status {
sub get_master_logs {
sub get_master_slave_status {
sub get_new_db_connection {
sub get_open_tables {
sub get_status_hash {
sub get_status_info {
sub get_uptime {
sub get_var_set {
sub get_visible_tables {
sub handle_cxn_error {
sub inc {
sub is_func {
sub kill_query {
sub load_config {
sub load_config_active_columns {
sub load_config_active_connections {
sub load_config_active_filters {
sub load_config_active_server_groups {
sub load_config_colors {
sub load_config_config {
sub load_config_connections {
sub load_config_filters {
sub load_config_group_by {
sub load_config_mvs {
sub load_config_plugins {
sub load_config_server_groups {
sub load_config_sort_cols {
sub load_config_stmt_sleep_times {
sub load_config_tbl_meta {
sub load_config_varsets {
sub load_config_visible_tables {
sub make_color_func {
sub make_sort_func {
sub meta_to_hdr {
sub migrate_config {
 sub new {
sub new {
sub next_server {
sub next_server_group {
sub no_ctrl_char {
sub parse {
sub parse_bp_section {
sub parse_dl_section {
sub parse_field {
sub parse_fk_bad_constraint_error {
sub parse_fk_cant_drop_parent_error {
sub parse_fk_section {
sub parse_fk_transaction_error {
sub parse_ib_section {
sub parse_innodb_record_dump {
sub parse_innodb_record_locks {
sub parse_innodb_timestamp {
sub parse_io_section {
sub parse_lg_section {
sub parse_ro_section {
sub parse_sm_section {
sub parse_status_text {
sub parse_tx_section {
sub parse_tx_text {
sub parse_wait_array {
sub pause {
sub percent {
sub post_process_tbl_meta {
sub print_active_handles {
sub prompt {
sub prompt_list {
sub prompt_noecho {
sub prop {
sub purge_master_logs {
 sub register_for_events {
         sub { return @available },
      sub { return @available },
         sub{ return @cxns },
            sub { return keys %all_cols; },
               sub { return keys %ansicolors },
               sub { return keys %comp_ops },
      sub{ return keys %config_choices },
      sub { return keys %filters },
               sub { return keys %{$meta->{cols}} },
      sub { return keys %{$meta->{cols}} },
         sub { return keys %{$tbl_meta{$tbl}->{cols}} },
      sub { return keys %var_sets },
      sub { return @{$modes{$mode}->{tables}} },
         sub { return @tbls },
         sub { return @threads });
sub reverse_sort {
sub rewrite_for_explain {
subroutine, like this:
# Subroutines {{{1
# subroutine that will sort that way.
sub save_config {
sub save_config_active_columns {
sub save_config_active_connections {
sub save_config_active_filters {
sub save_config_active_server_groups {
sub save_config_colors {
sub save_config_config {
sub save_config_connections {
sub save_config_filters {
sub save_config_group_by {
sub save_config_mvs {
sub save_config_plugins {
sub save_config_server_groups {
sub save_config_sort_cols {
sub save_config_stmt_sleep_times {
sub save_config_tbl_meta {
sub save_config_varsets {
sub save_config_visible_tables {
sub secs_to_time {
sub select_cxn {
sub send_cmd_to_servers {
sub set_display_precision {
sub set_precision {
sub set_s_mode {
sub set_to_tbl {
 sub set_to_tbl_pre_filter {
sub shorten {
sub show_full_query {
sub show_optimized_query {
sub stack_next {
sub start_S_mode {
               : substr($_, 0, $this_term_size[0]);
            && substr($innodb_status_text, 0, 100) =~ m/INNODB MONITOR OUTPUT/;
         . substr($text, int($len/2) + $max + 1);
      \$sub = sub {
      $sub = sub { return $EVAL_ERROR };
sub switch_mode {
sub switch_var_set {
sub toggle_aggregate {
sub toggle_config {
sub toggle_filter {
sub toggle_visible_table {
sub trunc {
sub ts_to_string {
sub unique {
sub usage {
sub version_ge {
sub word_wrap {
         $success = 1;
   sum   => sub {
# Supports PostgreSQL via the dbidriver element of $info, but assumes MySQL by
suppressed so you see only the L<"innodb_transactions"> table.
surrounded by code-ish things like dollar signs or curly brackets.  If innotop
   { s => 'user|u=s',   d => 'User for login if not current user' },
   { s => 'version',    d => 'Output version information and exit' },
# switch_mode {{{3
   switch_mode('S');
switch to the first connection.
switch to the mode, press the key listed in front of its heading in the
   { s => 'write|w',    d => 'Write running configuration into home directory if no config files were loaded' },
               sysseek($file, (-128 * 1_024), 2);
   'System lock'                  => 1,
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
systems, you can issue `man perlgpl' or `man perlartistic' to read these
   "\t" => {
   t => {
TAB key to switch to the next group.  If you're not currently monitoring a
   'table cache'                  => 1,
   $table->{color_func} = make_color_func($table);
# Table definitions {{{3
# Table editor key mappings {{{3
table if necessary, and press the 's' key.  You'll see a list of columns you can
   table_is_open => {
table is sorted.
   'Table lock'                   => 1,
table's columns, because that's likely what you're trying to edit.  However, you
table (see L<"GROUPING">).  By default, this is disabled.  This means columns
table shows the locks each transaction held and waited for.  A deadlock is
   tables_in_use               => { hdr => 'Tbl Used',            num => 1, label => 'Number of tables in use' },
         tables_in_use      => { src => 'tables_in_use' },
      tables_in_use      => $tables_in_use,
         tables_in_use undo_log_entries tables_locked has_read_view
            |^TABLE\sLOCK
   tables_locked               => { hdr => 'Tbl Lck',             num => 1, label => 'Number of tables locked' },
         tables_locked      => { src => 'tables_locked' },
      tables_locked      => $tables_locked,
tables might be locked implicitly.
   $table->{sort_func}  = make_sort_func($table);
table, so you can see the relative weight of the variables.
# table specifies columns and column data sources.  The column is
      tables            => [qw(buffer_pool page_statistics insert_buffers adaptive_hash_index)],
      tables            => [qw(cmd_summary)],
      tables            => [qw(deadlock_transactions deadlock_locks)],
      tables            => [qw(fk_error)],
      tables            => [qw(innodb_locks)],
      tables            => [qw(io_threads pending_io file_io_misc log_statistics)],
      tables            => [qw(open_tables)],
      tables            => [qw(q_header processlist)],
      tables            => [qw(row_operations row_operation_misc semaphores wait_array)],
      tables            => [qw(slave_sql_status slave_io_status master_status)],
      tables            => [qw(t_header innodb_transactions)],
      tables            => [qw(var_status)],
tables.  The first two divide the slave's status into SQL and I/O thread status,
      # table, the columns are different, so on a pivoted table, allow filtering
table.  This ensures you'll see the L<"processlist"> table, even if you have
table where it happened, when and who and what query caused it, and so on.
table you want to filter, if asked.  You'll then see a list of possible filters
# Takes a number that InnoDB formats as two ulint integers, like transaction IDs
# Takes a string and turns it into a hashref you can apply to %tbl_meta tables.  The string
# Takes out the middle of text to shorten it.
# Takes refs of @cols, %labels and %data, %user_prefs
       tbl   => '',
   $tbl ||= choose_visible_table();
       $tbl->{cols}->{example} = $col;
   tbl                         => { hdr => 'Table',               num => 0, label => 'Table', },
   tbl     => '',    # Helps when writing/reading custom columns in config files
   tbl_meta => {
                  $tbl_meta{explain}->{visible},
         $tbl_meta{fk_error}->{visible},
      $tbl_meta{$key}->{cust}->{sort_cols} = 1;
      $tbl_meta{$key}->{cust}->{visible} = 1;
      $tbl_meta{$key}->{sort_cols} = $rest;
      $tbl_meta{$key}->{sort_func} = make_sort_func($tbl_meta{$key});
      $tbl_meta{$key}->{visible} = [ @parts ];
      $tbl_meta{$tbl}->{color_func} = make_color_func($tbl_meta{$tbl});
      $tbl_meta{$tbl}->{colors} = $rule_set_for{$tbl};
         $tbl_meta{$tbl}->{cols}->{$col} = {
         $tbl_meta{$tbl}->{cust}->{colors} = 1;
      $tbl_meta{$tbl}->{cust}->{colors} = 1;
      $tbl_meta{$tbl}->{cust}->{filters} = 1;
   $tbl_meta{$tbl}->{cust}->{filters} = 1;
      $tbl_meta{$tbl}->{cust}->{group_by} = 1;
            $tbl_meta{$tbl}->{cust}->{visible} = 1;
         $tbl_meta{$tbl}->{cust}->{visible} = 1;
      $tbl_meta{$tbl}->{filters} = \@current;
      $tbl_meta{$tbl}->{filters} = [ grep { $_ ne $filter } @$filters ];
      $tbl_meta{$tbl}->{filters} = [ @parts ];
      $tbl_meta{$tbl}->{group_by} = [ @parts ];
   tbl_meta      => \%tbl_meta,
            || ($tbl_meta{$tbl}->{pivot} && $col eq 'name'));
   $tbl_meta{$tbl}->{sort_dir} *= -1;
      $tbl_meta{$tbl}->{sort_func} = make_sort_func($tbl_meta{$tbl});
         $tbl_meta{$tbl}->{visible} = [ grep { $_ ne $col } @visible_cols ];
         $tbl_meta{$tbl}->{visible} = [ unique(@{$tbl_meta{$tbl}->{visible}}, $col) ];
      $tbl_meta{var_status}->{cols}    = $cols;
      $tbl_meta{var_status}->{fmt}     = $fmt;
   $tbl_meta{var_status}->{pivot} = $func eq 'v';
   #           $tbl_meta{var_status}->{sort_cols} =~ m/(\w+)/g)
   $tbl_meta{var_status}->{sort_func} = make_sort_func($tbl_meta{var_status});
      $tbl_meta{var_status}->{visible} = $visible;
tbl_name=column_list.  If a column is prefixed with '-', that column sorts
tbl_name=column_list.  See L<"COLUMNS">.
tbl_name=property_list.  See L<"COLORS">.
      $tbl = prompt_list(
      tbls => $builtin_filters{$key}->{tbls},
      @tbls = grep { exists $tbl_meta{$_} } @tbls;
      tbls => [qw(innodb_transactions processlist)],
      tbls => [qw(io_threads)],
      tbls => [qw(master_status)],
      tbls => [qw(open_tables)],
      tbls => [qw(processlist slave_io_status)],
      tbls => [qw(slave_io_status slave_sql_status)],
         tbl           => { src => 'table' },
         tbl            => { src => 'table' },
         tbl              => { src => 'table' },
         tbls  => [$tbl],
      tbls => [$tbl],
         tbls => \@tbls,
            tbl   => $tbl,
      temp      => 1, # Do not persist to config file.
      $temp_table{$group_key} ||= [];
         $term->Attribs->{completion_function} = $completion;
   $term->Attribs->{completion_function} = $completion;
terminal formatting codes to be honored).  If you install Term::ReadLine,
terminal's auto-completion.  You'll see the names of the columns in the
terminal's display may vary; experiment to find colors you like).
terminal when you monitor queries that contain binary data, such as images.
Term::ReadKey in particular has been known to cause problems if installed from
      # Term::ReadLine might have re-set $OUTPUT_AUTOFLUSH.
   $term = Term::ReadLine->new('innotop');
   # Test if the cxn should not even be tried
                     'test.innotop_dl');
      text => $body,
      text => $builtin_filters{$key}->{text},
         $text = $colname = $exp;
      text => <<'      END',
         $text    = $exp;
         /[TEXT]/gx;
      text => join(
         = $text =~ m/^a writer \(thread id $d\) has reserved it in mode  (.*)$/m;
      = $text =~ m/^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)$/;
         = $text =~ m/^$d: len $d; hex $h; asc (.*);(\.\.\.\(truncated\))?$/;
         = $text =~ m/Last time read locked in file $fl$/m;
         = $text =~ m/Last time write locked in file $fl$/m;
         = $text =~ m/^(.)-lock on RW-latch at $h created in file $fl$/m;
         = $text =~ m/^Mutex at $h created file $fl, lock var $d$/m;
         = $text =~ m/^number of readers $d, waiters flag $d$/m;
      = $text =~ m/^--Thread $d has waited at $fl for $f seconds/m;
         = $text =~ m/^waiters flag $d$/m;
         text => $parts{text},
         text => $rest,
      $text =~ s/
   $text =~ s/(.{0,$width})(?:\s+|$)/$1\n/g;
   $text =~ s/(.)\1+/$1/g;
      $text =~ s/([\\'])/\\$1/g;
   $text =~ s/(?<![_ ])[aeiou]//g;
# $text should not include the leading space or the second trailing semicolon.
   $text =~ s/^IB_\w\w_//;
   $text =~ s/ +$//mg;
   $text =~ s/\s+/ /g;
   $text = substr($text, 0, int($len/2))
         text  => $text,
#  * text:   text of the subroutine
than one second, you might be dividing by zero because Uptime is incremental in
that calculates a high-resolution queries-per-second value.
that code, it executes the callback function for each plugin that expressed its
   # that get pushed to the screen.
that ought to feel very natural to you: a SQL SELECT list.
that refer to the products table, type '/' and then 'info product'.
That's actually quite a worrisome picture.  You've got a lot of idle connections
That's okay, but you also have a lot in Statistics status, collectively spending
that you had a huge table with one column per variable returned from those
   # thd=hdr='Thd' minw='0' num='0' src='Threads_connected' dec='0' trans='' tbl='slave_sql_status' just='-' user='1' maxw='0' label='User-defined'
   thd_is_not_waiting => {
   t_header => {
      t_header            => \@t_header,
The arguments are the set of values, the current values, the previous values,
The arguments to the subroutine are named $set, $cur, and $pre.  In most cases,
      # The caption is too wide to add underscores on each side.
         # The caption is wider than the thing it labels, so we have to pad the
The color editor dialog displays the rules applied to the table, in the order
The column header: this is the label that appears at the top of the column, in
      # The column may already exist in the table, in which case this is just a
the column name.
The column name: this needs to be a word without any funny characters, e.g. just
The columns by which the table is grouped are specified in its group_by
The column's data source: this is an expression that determines what data from
The command summary table is built by extracting variables from
# the config file.
the config file.
the configuration file, innotop will prompt you for a password each time it
The configuration file is arranged into sections like an INI file.  Each
# The configuration file is broken up into sections like a .ini file.  This
the configuration option L<"interval">.
the core_dump file which contains verbose error messages if L<"debug"> is
# the current data set, whatever that is.
The data source for variable sets, and indeed the entire S mode, is the
            . "The db and port are optional and can usually be omitted.\n"
# the DBI connection.  These are saved in the connections section in the config file.
The default is 'ascii', which considers anything outside normal ASCII to be a
      # the display.
The easiest way to explain the plugin functionality is probably with a simple
                  # the endpoint, innotop has a newer config file format than the file.
the error.  Try enabling L<"debug"> to make innotop throw an error instead.
the exact details on all the options you can pass the driver in the DSN.  You
The example shows what you see if the prefix is "Select_".  The default
The filter text can actually be any Perl regular expression, but of course a
The filter text is the text of the subroutine's code.  The table list is a list
The first line innotop displays is a "status bar" of sorts.  What it contains
The first line in the file is innotop's version number.  This lets innotop
The first line shows which table you're editing, and reminds you again to press
The following is a brief description of each mode, in alphabetical order.  To
The following list describes each section of the configuration file and the data
The following people and organizations are acknowledged for various reasons.
the following Perl code:
the format name=properties, where the properties are a name=value list.  The
The 'general' section contains global configuration variables and variables that
The Gentoo MySQL Team,
the global and mode-specific ones depending on the current mode.
The global configuration hash.
the graphs in L<"S: Variables & Status"> mode.  Each line is in the format
# the hash elements for extract_values to use.
the highlight to the desired one, then press the * key to toggle it active or
the incremental difference between $cur and $pre.
The informational header can be toggled on and off with the 'h' key.  By
the InnoDB Lock Monitor with the key mappings in this mode.
The innotop plugin interface is quite simple: innotop expects the plugin to be
The innotop table editor lets you customize tables with keystrokes.  You start
The interval at which innotop will refresh its data (ticks).  The interval is
         # The IP address is the only non-word thing left, so it's the most
The key mappings are Vim-style, as in many other places.  Pressing 'j' and 'k'
The lifecycle is slightly different if the table is pivoted, as noted above.  To
them back out to the file when it exits.  Comments in read-only configuration
them, innotop will not be able to fetch any variable and status data.  This
The mode in which innotop should start.  Allowable arguments are the same as the
# the module is the colored() function.
The module must conform to innotop's plugin interface.  Additionally, the source
The mysql_read_default_group=mysql option lets the DBD driver read your MySQL
the name of an item in the source, or it can be a more complex expression, as
# then choose which connections are in it.
The next two words indicate the server's queries per second (QPS) and how many
then prompt you for a user name.  If you have a MySQL option file that specifies
the number of digits you see.  Extending the above example, here's how:
# the ones that don't.
the optimized query resulting from EXPLAIN EXTENDED.  innotop also tries to
The percentage columns are percentage of the total of all variables in the
The plugin editor lets you view the plugins innotop discovered and activate or
The plugin must implement a method named the same as each event for which it has
The plugin's constructor is passed a hash of innotop's variables, which it can
            "The query could not be explained.  Only SELECT queries can be "
         (.*?)                                  # The query text
There are many built-in variable sets as well, which should give you a good
# There are new-style and old-style record formats.  See rem/rem0rec.c
   # there are, who holds and wants what locks, and who gets rolled back.
there is a corresponding entry in the L<"plugins"> configuration file section,
There is an informative header that shows general status information about
There is auto-completion and prompting at each step.
         # There is more RHS to push on the end of the array
There is no difference between innotop's built-in columns and user-defined
      # There is no room to put them side by side.  Add them below, with
               # The remaining tokens are, in order: hostname, user, query_status.
            # There might not be ANYTHING except the query status.
   # there will be different text output
   # The Row Operations section is a special case, because instead of ending
the screen.  The events all pass the same data: an arrayref of rows and the name
the screen when one connection is waiting for locks another connection holds:
# These are pre-processed to live in %filters above, by compiling them.
# These are stored in their own section in the config file.  These are just initial values:
# These can be overridden by action_for in %modes.
# These columns are post-processed after being defined, because they get stuff
      # The section is user-defined by definition (if that makes sense).
            # The selected row will be highlighted; otherwise a > at the left will indicate.
      # These parts can always be gotten.
the servers you're monitoring.  You switch between modes with uppercase keys.
these slave connections and suggest it as the argument to PURGE MASTER LOGS.
The simplest case is when you're monitoring a single server.  In this case, the
   # the source code shows there will only ever be one).  I have to parse both
the source (see L<"TABLES">) innotop will put into the column.  This can just be
# The 'spec' is a hashref of hdr => label, just => ('-' or '').  It also supports min and max-widths
The subroutines that extract the data from the set are compiled from
      # The table data.
the table editor with the '^' key.  If there's more than one table on the
      # The table header.
the table header.  This can have spaces and funny characters, but be careful not
The table life-cycle is as follows:
the table.  Several columns are set this way, such as the count column on
   # The table's meta-data is generated from the compiled var_set.
# the terms of the GNU General Public License as published by the Free Software
the terms of the GNU General Public License as published by the Free Software
   # The thingie in top-right that says what we're monitoring.
the user has customized, a list of columns, a list of visible columns, a list of
The username defaults to your login name on the system you're running innotop on.
The value in the third step needs to be correctly quoted.  innotop does not try
the visible columns appear in order after them.
The 'v' key changes the view to a pivoted table of variable names on the left,
they are evaluated.  Each row is evaluated against each rule to see if the rule
   # they are the only word in $expr, in which case treat them as hash keys.
# they come from someone trying to create a foreign key, or similar
   # thing always in the line is the thread and query id.  See function
         # thing it labels to a consistent width.
thing on the line.
      $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
This causes InnoDB to print its output to the MySQL file every 16 seconds or so,
This changes innotop's behavior in the following ways:
# This config variable is only useful for MS Windows because its terminal
This data is extracted from the transaction list in the LATEST DETECTED DEADLOCK
This data is from SHOW FULL PROCESSLIST.
This data is from SHOW OPEN TABLES.
This data is from the list of threads in the the FILE I/O section of SHOW INNODB
This data is from the result set returned by EXPLAIN.
This data is from the SEMAPHORES section of SHOW INNODB STATUS and is nested one
This data is from the transaction list in the LATEST DETECTED DEADLOCK
This data is from the TRANSACTIONS section of SHOW INNODB STATUS.
This data is from the TRANSACTIONS section of SHOW INNODB STATUS and is nested
# This defines expected properties and defaults for the column definitions that
This event occurs inside the function that extracts values from a data source.
This event occurs inside the subroutine that prints the lines to the screen.
   # this ever becomes possible.
This example is simple, but it shows how easy it is to choose which variables
This feature is included so you can customize the side-effects caused by
# This hash defines every filter that can be applied to a table.  These
# This hash defines every table that can get displayed in every mode.  Each
# This hash defines server connections.  Each connection is a string that can be passed to
# This hash defines the max values seen for various status/variable values, for graphing.
This hash holds all built-in table definitions, which contain a lot of default
      # This is a new-style record.
# This is a subroutine because it's called from a key to quit the program.
This is followed by the server's uptime.
# This is for code cleanup:
This is innotop version $VERSION, a MySQL and InnoDB monitor.
This is the broadest category, into which the most kinds of data fall.  It
# This is the container for the command-line options' values to be stored in
This is the default rule set for the L<"processlist"> table.  In order of
This is the plugin's constructor.  It is passed a hash of innotop's variables,
This is the prefix that filters variables in L<"C: Command Summary"> mode.
   # This is used so errors that have to do with permissions needed by the current
   # This loop builds a tabular view of the plugins.
      # This loop builds a tabular view of the rules.
      # This loop builds a tabular view of the tbl_meta's structure, showing each column
This means you can do what may have seemed impossible: to a limited extent
This method must return a list of events in which the plugin is interested, if
 # This method will be called when the event fires.
This might happen because a connection isn't monitored in a particular mode, for
this mode by default.  Instead, use Uptime_hires:
This mode calculates statistics, such as queries per second, and prints them out
This mode contains the L<"buffer_pool">, L<"page_statistics">,
This mode displays information about the InnoDB buffer pool, page statistics,
This mode displays the L<"deadlock_transactions"> and L<"deadlock_locks"> tables
This mode displays the L<"fk_error"> table by default.
This mode displays the L<"innodb_locks"> table by default.  Here's a sample of
This mode displays the L<"open_tables"> mode by default.
This mode displays the L<"q_header"> and L<"processlist"> tables by default.
This mode displays the L<"slave_sql_status">, L<"slave_io_status">, and
This mode displays the L<"t_header"> and L<"innodb_transactions"> tables by
This mode displays the output from SHOW FULL PROCESSLIST, much like B<mytop>'s
This mode doesn't really display any tables like other modes.  Instead, it uses
This mode is similar to mytop's Command Summary mode.  It shows the
This mode shows information about current locks.  At the moment only InnoDB
This mode shows InnoDB row operations, row operation miscellaneous, semaphores,
This mode shows InnoDB's I/O statistics, including the I/O threads, pending I/O,
This mode shows the last InnoDB foreign key error information, such as the
This mode shows the output of SHOW SLAVE STATUS and SHOW MASTER STATUS in three
This mode shows the transactions involved in the last InnoDB deadlock.  A second
This mode shows transactions from the InnoDB monitor's output, in B<top>-like
This optional item tells innotop a table name it can use to deliberately create
This option enables more verbose errors and makes innotop more strict in some
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
This program is copyright (c) 2006 Baron Schwartz.
# This program is copyright (c) 2006 Baron Schwartz, baron at xaprb dot com.
# This program is free software; you can redistribute it and/or modify it under
This program is free software; you can redistribute it and/or modify it under
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
(This sample is truncated at the right so it will fit on a terminal when running
This section comes from MySQL's SHOW OPEN TABLES command.  By default it is
This section contains column lists for table group_by expressions.  Each line is
This section contains statement sleep times.  Each line is in the format
This section defines colorization rules.  Each line is in the format
This section defines variable sets for use in L<"S: Status & Variables"> mode.
This section defines which tables are visible in each mode.  Each line is in the
This section holds a list of package names of active plugins.  If the plugin
This section holds a list of which connections are active in each mode.  Each
This section holds a list of which server group is active in each mode.  Each
This section holds server groups.  Each line is in the format
This section holds table column lists.  Each line is in the format
This section holds the maximum values seen for variables.  This is used to scale
This section holds the server connections you have defined.  Each line is in
This section holds the sort definition.  Each line is in the format
This section holds user-defined filters (see L<"FILTERS">).  Each line is in the
This section stores user-defined or user-customized columns (see L<"COLUMNS">).
This section stores which filters are active on each table.  Each line is in the
      this_sleep => 1,
            $this_term_size[0]--;
            $this_term_size[1]
         @this_term_size = Term::ReadKey::GetTerminalSize(\*STDOUT);
This transformation only operates within quoted strings, for example, values to
This variable accepts fractions of a second.
thoroughly.  Roughly speaking, filtering and sorting happen as late as needed to
 --Thread 1568861104 has waited at btr0cur.c line 424 ....
   thread_decl_inside          => { hdr => 'Thread Inside',       num => 0, label => 'What the thread is declared inside' },
         thread_decl_inside lock_wait_time proc_no row_locks);
         thread_decl_inside => { src => 'thread_decl_inside' },
      thread_decl_inside => $thread_decl_inside,
   thread                      => { hdr => 'Thread',              num => 1, label => 'Thread number' },
   'Thread initialized'           => 1,
         = $thread =~ m{I/O thread $d state: (.+?) \((.*)\)(?: ev set)?$}m;
   thread_purpose              => { hdr => 'Purpose',             num => 0, label => "The thread's purpose" },
         thread_purpose => { src => 'purpose' },
         $threads[0],
         Threads_cached Threads_connected Threads_created Threads_running)
threads (connections) exist.  Finally, the server's version number is the last
         threads os_file_reads pending_aio_writes pending_log_ios os_fsyncs
         thread         => { src => 'thread' },
         thread             => { src => 'thread' },
   thread_status               => { hdr => 'Thread Status',       num => 0, label => 'The thread status' },
         thread_status  => { src => 'state' },
         thread_status      => { src => 'thread_status' },
      thread_status      => $thread_status,
            thread    => $tid,
tick and the previous tick.
tick, so innotop may appear to hang.
 time   >   120          yellow      
 time   >   30           cyan        
 time   >   600          red         
 time   >   60           green       
   time_behind_master          => { hdr => 'TimeLag',             num => 1, label => 'Time slave lags master' },
         time_behind_master          => { src => 'seconds_behind_master', trans => [ qw(secs_to_time) ] },
   time                        => { hdr => 'Time',                num => 1, label => 'Time since the last event', },
timeout, so MySQL doesn't close the connection if it is not used for a while.
         'time'           => { src => 'active_secs', hdr => 'Active', trans => [ qw(secs_to_time) ] },
         'time'             => { src => 'active_secs', trans => [ qw(secs_to_time) ] },
         'time'             => { src => 'active_secs',         trans => [ qw(secs_to_time) ], agg => 'sum' },
         time            => { src => 'time',       minw => 5,  maxw => 0, trans => [ qw(secs_to_time) ], agg => 'sum' },
         'time'             => { src => 'waited_secs', trans => [ qw(secs_to_time) ] },
   timestring                  => { hdr => 'Timestring',          num => 0, label => 'Time the event occurred' },
         timestring   => { src => 'IB_fk_timestring' },
         timestring         => { src => 'timestring' },
            $tmp[$j]->{$col} = $rows[$i]->{$vars[$j]};
To add the column, switch to the replication-monitoring mode with the 'M' key,
To clear quick-filters, press the '\' key and innotop will clear them all at
To create a group, press the '#' key and type the name of your new group, then
   # TODO: a new step in set_to_tbl: join result to itself, grouped?
   # TODO: can these be auto-generated from %modes?
# TODO: guess which connections are slaves of a given master.
   # TODO: make it so.
         # TODO: make this editor hotkey-driven and give readline support.
# TODO: pull all the little pieces out into subroutines and stick events in each of them.
      # TODO: save prev values
   # TODO: some more columns:
# TODO: there are a few places that don't remember prev set so can't pass it.
         # TODO: this duplicates %col_props.
   # TODO: this would also enable pulling Q and T data together.
   # TODO: using a SQL-ish language would also allow pivots to be easier -- treat the pivoted data as a view and SELECT from it.
# TODO: write some tests for this
To get reasonable results, you might need to group as well as pivoting.
# toggle_config {{{3
# toggle_filter{{{3
toggle this on and off with the 'i' and 'a' keys.
to make it too wide and waste space on-screen.
To monitor a database on another system using a particular username and password:
To monitor InnoDB status information from a file:
To monitor servers normally:
   # too many locks to print, the output might be truncated)
# to parse (hashref; if empty, parse all), and whether to parse full info from
top of the table.  Like anything else in innotop, you can customize how any
To quit innotop, press the 'q' key.
to quote the value because it doesn't know whether it should treat the value as
To run innotop non-interactively in a pipe-and-filter configuration:
to "search for."  For example, to filter the L<"processlist"> table on queries
   # Toss out the rows that don't have master/slave status...
To start innotop, open a terminal or command prompt.  If you have installed
To start the sort dialog, start the L<"TABLE EDITOR"> with the '^' key, choose a
   total                       => { hdr => 'Total',               num => 1, label => 'Total' },
   total_mem_alloc             => { hdr => 'Memory',              num => 1, label => 'Total memory allocated' },
 total_mem_alloc    Memory       Total memory allocate  IB_bp_total_m
         total_mem_alloc            => { src => 'IB_bp_total_mem_alloc', trans => [qw(shorten)], },
         total      => { src => 'total' },
         $total      += $val;
to the newly created plugin object.
to the table for which they were created, but you can manually override that by
      # to toggle pivoting on and off, which it's not at the moment.
            trans => [],
       trans => [],
   trans   => [],
            |^(?:---)?TRANSACTION
transaction identifiers, for example.
transaction is waiting, but those currently held, too.  You can do this with the
   Transaction => \&parse_fk_transaction_error,
transactions. This variable was added in version 5.0.4."  This is appropriate to
   "TRANSACTIONS"                          => "tx",
trans: a list of column transformations.  See L<"TRANSFORMATIONS">.
transformation.
Transformations change how a value is rendered.  For example, they can take a
transformations.  However, you're protected from the tedious details by a syntax
transformations to columns to extract parts of their values or format the values
transformation.  This keeps non-printable characters from confusing a
   trans_funcs   => \%trans_funcs,
Trevor Price,
# Tries to figure out a hostname for the connection.
# Trim to desired precision.
# trunc {{{3
truncated, and prevent you from seeing other information at all.  If you are
   # Truncate rows that will surely be off screen even if this is the only table.
   truncates                   => { hdr => 'Trunc',               num => 0, label => 'Whether the deadlock is truncating InnoDB status' },
         truncates          => { src => 'truncates' },
      trunc => $truncated ? 1 : 0,
            ^Trx\sread\sview
# Try to lower my priority.
      # Try to parse SQL a user might have typed in a CREATE statement or such
   # Try to remove a single "word" from somewhere in the center
         # Try to split and stack the meta rows next to each other
      ts        => '',        # Timestamp the server put on it
turning an arrayref of hashrefs into an arrayref of lines that can be printed to
two levels deep.
Two tables have default group_by lists and a count column built in:
      = $txn
   txn => {
   txn_doesnt_see_ge           => { hdr => "Txn Won't See",       num => 0, label => 'Where txn read view is limited' },
         txn_doesnt_see_ge  => { src => 'txn_doesnt_see_ge' },
      txn_doesnt_see_ge  => $txn_doesnt_see_ge,
   txn_id                      => { hdr => 'ID',                  num => 0, label => 'Transaction ID' },
         txn_id           => { src => 'txn_id' },
         txn_id             => { src => 'txn_id' },
      txn_id             => $txn_id,
   txn_sees_lt                 => { hdr => 'Txn Sees',            num => 1, label => 'Where txn read view is limited' },
         txn_sees_lt query_status ip query_text lock_wait_status user);
         txn_sees_lt        => { src => 'txn_sees_lt' },
      txn_sees_lt        => $txn_sees_lt,
   txn_status                  => { hdr => 'Txn Status',          num => 0, label => 'Transaction status' },
         txn_status         => { src => 'txn_status' },
         txn_status         => { src => 'txn_status',          minw => 10, maxw => 10 },
      txn_status         => $txn_status,
   txn_time_remain             => { hdr => 'Remaining',           num => 1, label => 'Time until txn rollback/commit completes' },
   TxnTimeRemain     => q{ defined undo_log_entries && defined $pre->{undo_log_entries} && undo_log_entries < $pre->{undo_log_entries} ? undo_log_entries / (($pre->{undo_log_entries} - undo_log_entries)/((active_secs-$pre->{active_secs})||1))||1 : 0},
         txn_time_remain    => { src => $exprs{TxnTimeRemain}, trans => [ qw(secs_to_time) ] },
         $txn->{'tx'} = parse_tx_text( $body, $complete, $debug, $full );
   tx => \&parse_tx_section,
         type child_table parent_col complete )),
type the names of the connections you want the group to contain.
         u => {
-u and -p options, respectively.  To monitor a MySQL database on another
         : undef;
      # undef.
   # undef.
      undef, sub { return keys %$meta }, $meta);
         undef, 'test.innotop_dl');
               'underline',
   # under some circumstances.  Some versions include 300, some 600.
undocumented feature).
   undo_for                    => { hdr => 'Undo',                num => 0, label => 'Undo for' },
         undo_for                    => { src => 'IB_tx_purge_undo_for' },
   undo_log_entries            => { hdr => 'Undo',                num => 1, label => 'Number of undo log entries' },
         undo_log_entries   => { src => 'undo_log_entries' },
      undo_log_entries   => $undo_log_entries,
         # Un-escape escaping
# Unfortunately, suppressing echo with Term::ReadLine isn't reliable; the user might not
# Unifies all the work of filtering, sorting etc.  Alters the input.
# unique {{{3
      [ unique(grep { $_ && exists $tbl_meta{$_} } split(/\s+/, $new)) ];
         [ unique(grep { $_ && exists $tbl_meta{$_} } split(/\s+/, $rest)) ];
                  = [ unique(grep { exists $trans_funcs{$_} } split(',', $parts{$prop})) ];
   'Unknown database',
   'Unknown MySQL server host',
      unless defined($section->{'pending_preads'});
         unless exists $agg_funcs{$col_def->{agg}};
         unless exists $opts{$key};
            unless exists $trans_funcs{$trans};
            unless $header;
         unless $info->{func};
unless you have defined a deadlock table for the connection (see L<"SERVER
            unshift @display_lines, '',
         unshift @display_lines, '',
      unshift @$display_lines, create_statusbar();
   unshift @display_lines, no_ctrl_char($query);
            unshift @{$meta->{visible}}, $col;
            unshift @rows, [
         unshift @rows,
            unshift @rows, (" " x $left) . $caption . (" " x ($width - $left - $cap_len));
            unshift @rows, ('-' x $width);
       unshift @{$tbl->{visible}}, 'example';
      unshift @$visible, $table;
   until_condition             => { hdr => 'Until Condition',     num => 0, label => 'Slave until condition' },
         until_condition             => { src => 'until_condition' },
   } until ( @cxns );
         } until defined $arg;
         } until defined $color;
      } until ( $dsn );
         } until ( !$err);
   until_log_file              => { hdr => 'Until Log File',      num => 0, label => 'Slave until log file' },
         until_log_file              => { src => 'until_log_file' },
   until_log_pos               => { hdr => 'Until Log Pos',       num => 1, label => 'Slave until log position' },
         until_log_pos               => { src => 'until_log_pos' },
      } until ( $name );
   } until ( $new );
         } until ( $op );
   } until ( $variables );
   'update'                       => 1,
   # update or a delete of a parent record leaves a child orphaned
         "update $tbl set a = $id where a <> $id",
         # Update the max ever seen, and scale by the max ever seen.
upgrades easier.
Uppercase keys switch between modes.
            $uptime,
      $usage .= "  If the DSN is a bareword, the word is treated as the '$key' key.\n";
      $usage .= "  $key    "
use constant MKDEBUG => $ENV{MKDEBUG};
use Data::Dumper;
use DBI;
   used_bufs                   => { hdr => 'Used Bufs',           num => 1, label => 'Number of buffer pool pages used' },
         used_bufs                   => { src => $exprs{BufPoolFill},         trans => [qw(percent)]},
   used_cells                  => { hdr => 'Cells Used',          num => 1, label => 'Number of cells used' },
         used_cells          => { src => 'IB_ib_used_cells' },
use English qw(-no_match_vars);
use File::Basename qw(dirname);
use File::Temp;
useful for certain operations with InnoDB, which uses two integers as
         # useful marker for where I have to start guessing.
use Getopt::Long;
   # Use $$ instead of $PID in case the package
use in the sort expression and the current sort expression, if any.  Enter a
use List::Util qw(max);
use List::Util qw(max min maxstr sum);
use POSIX qw(ceil);
      user => 0,
   user    => 0,
            user  => 1,
         user => 1,
         user  => 1,
      user => 1,
user choose columns.
 user   eq  system user  white       
   user                        => { hdr => 'User',                num => 0, label => 'Database username', },
   'User lock'                    => 1,
            ( $user, $query_status ) = $thread_line =~ m/$ip $w(?: (.*))?$/;
   $user =~ s/@.*//;
         user               => { src => 'user' },
         user               => { src => 'user',                maxw => 10 },
         user            => { src => 'user',       minw => 5,  maxw => 8 },
               $user = 'system user';
         $user = 'system user';
User to use for connection.
            "User $txn->{user} from $txn->{hostname}, thread $txn->{mysql_thread_id} was executing:",
      user      => $user,
      user               => $user,
#  * user:   whether it's a user-defined filter (saved in config)
use sigtrap qw(handler finish untrapped normal-signals);
 use strict;
use strict;
use TAB and other keys to auto-complete and edit input.
use Term::ReadKey qw(ReadMode ReadKey);
use that as its data source.  It will always show a single connection called
use Time::HiRes qw(time sleep);
 use warnings FATAL => 'all';
use warnings FATAL => 'all';
#!/usr/bin/perl
usually see the information that was being truncated by the large deadlock.
# Utility functions {{{2
         v => {
      val  => '*',
      val  => 0,
      val  => 1,
      val  => 10,
      val  => 2,
      val  => 28800,
      val  => 30,
      val  => 9,
      val  => 'ascii',
      val  => 'bold',
      val  => 'Com_',
               "$_='$val'";               # Enclose in single quotes
      val  => 'general',
      val  => $have_color,
      val  => "$homepath/.innotop/core_dump",
      val  => "$homepath/.innotop/plugins",
# Valid aggregate functions.
      # Validate the incoming values...
# validation regex until the input is correct.
# Valid comparison operators for color rules
# Valid functions for transformations.
Valid grouping functions are defined in the %agg_funcs hash.  They include
# Valid Term::ANSIColor color strings.
      val  => "Q",
      val  => 's',
               $val =~ s/([\\'])/\\$1/g;  # Escape backslashes and single quotes
               $val = [ split(' ', $val) ] if ref($col_props{$answer});
   value                       => { hdr => 'Value',               num => 1, label => 'Value' },
         @{$value}{qw(total last_total)} = ($total, $last_total);
Values are aggregated across all servers.  The Pct columns are not correctly
      } values %$cols;
values from a data source to form rows.
# Values from this hash are just copied to tbl_meta, which is where everything
         value      => { src => 'value',                     agg   => 'sum'},
            value      => $val,
                  $val = [ unique(grep{ exists $trans_funcs{$_} } @$val) ];
         $val = '' unless defined($val);
# variable defines those sections and the subroutines responsible for reading
# Variable sets {{{3
Variable sets are used in L<"S: Variables & Status"> mode to define more easily
      $variables = prompt("Enter variables for $name", undef );
variables (see L<"MODES">).  innotop prompts you to choose a variable from among
variable, which is important if your L<"interval"> setting is sub-second.
         $vars{$cxn}->{$clock} ||= {};
         $vars->{cxn} = $cxn;
   varsets => {
      $var_sets{$name} = {
      @{$var_sets{$name}}{qw(text user)} = ( $new, 1);
   $var_sets{$name} = { text => $variables, user => 1 };
   var_sets      => \%var_sets,
                  && $vars->{IB_tx_is_truncated} ) {
         @{$vars}{ keys %$res } = values %$res;
   var_status => {
      var_status => \@var_status,
            ($vars->{Threads} || 0) . "/" . ($vars->{Threads_running} || 0) . "/" . ($vars->{Threads_cached} || 0) . " con/run/cac thds",
         $vars->{Uptime_hires} ||= get_uptime($cxn);
         (version_ge($dbh, '4.0.11') ? "start transaction" : 'begin'),
   versions                    => { hdr => 'Versions',            num => 1, label => 'Number of InnoDB MVCC versions unpurged' },
         versions                    => { src => $exprs{OldVersions} },
   victim                      => { hdr => 'Victim',              num => 0, label => 'Whether this txn was the deadlock victim' },
         victim             => { src => 'victim' },
# vim: tw=160:nowrap:expandtab:tabstop=3:shiftwidth=3:softtabstop=3
virtually no configuration.  If you're just getting started, see
            $visible_cols[$idx - 1] = $col;
            $visible_cols[$idx + 1] = $col;
            $visible_cols[$idx]     = $visible_cols[$idx - 1];
            $visible_cols[$idx]     = $visible_cols[$idx + 1];
      visible   => [], # Generated from current varset
      @visible = @{$meta->{visible}};
      visible => [ qw(cxn buf_pool_size buf_free pages_total pages_modified buf_pool_hit_rate total_mem_alloc add_pool_alloc)],
      visible => [ qw(cxn cmd cnt mysql_thread_id state user hostname db time info)],
      visible => [ qw(cxn cnt mysql_thread_id user hostname txn_status time undo_log_entries query_text)],
      visible => [ qw(cxn db tbl num_times_open is_name_locked)],
      visible => [ qw(cxn hash_table_size used_cells bufs_in_node_heap hash_searches_s non_hash_searches_s) ],
      visible => [ qw(cxn history_list_len versions undo_for dirty_bufs used_bufs num_txns max_txn lock_structs)],
      visible => [ qw(cxn inserts merged_recs merges size free_list_len seg_size)],
      visible => [ qw(cxn log_seq_no log_flushed_to last_chkp log_ios_done log_ios_s)],
      visible => [ qw(cxn master_file master_pos binlog_cache_overflow)],
      visible => [ qw(cxn master_host slave_io_running master_log_file relay_log_size read_master_log_pos slave_io_state)],
      visible => [ qw(cxn master_host slave_sql_running time_behind_master slave_catchup_rate slave_open_temp_tables relay_log_pos last_error)],
      visible => [ qw(cxn mutex_os_waits mutex_spin_waits mutex_spin_rounds
      visible => [ qw(cxn mysql_thread_id lock_type waiting lock_wait_time time lock_mode db tbl index insert_intention special)],
      visible => [ qw(cxn mysql_thread_id timestring user hostname victim time undo_log_entries lock_structs query_text)],
      visible => [ qw(cxn mysql_thread_id waiting lock_mode db tbl index special insert_intention)],
      visible => [ qw(cxn num_inserts num_updates num_reads num_deletes num_inserts_sec
      visible => [ qw(cxn os_file_reads os_file_writes os_fsyncs io_reads_s io_writes_s io_bytes_s)],
      visible => [ qw(cxn pages_read pages_written pages_created page_reads_sec page_writes_sec page_creates_sec)],
      visible => [ qw(cxn p_normal_aio_reads p_aio_writes p_ibuf_aio_reads p_sync_ios p_log_flushes p_log_ios)],
      visible => [ qw(cxn queries_in_queue queries_inside read_views_open main_thread_state)],
      visible => [ qw(cxn thread thread_purpose thread_status)],
      visible => [ qw(cxn thread time waited_at_filename waited_at_line request_type num_readers lock_var waiters_flag cell_waiting cell_event_set)],
      visible => [ qw(cxn when load qps slow q_cache_hit key_buffer_hit bps_in bps_out)],
      visible   => [qw(name value pct last_value last_pct)],
      visible => [ qw(select_type tbl partitions scan_type possible_keys index key_len index_ref num_rows special)],
      visible => [ qw(timestring child_db child_table child_index parent_db parent_table parent_col parent_index fk_name attempted_op)],
   visible_tables => {
      visible_tables    => [qw(buffer_pool page_statistics insert_buffers adaptive_hash_index)],
      visible_tables    => [qw(cmd_summary)],
      visible_tables    => [qw(deadlock_transactions deadlock_locks)],
      visible_tables    => [qw(fk_error)],
      visible_tables    => [qw(innodb_locks)],
      visible_tables    => [qw(io_threads pending_io file_io_misc log_statistics)],
      visible_tables    => [qw(open_tables)],
      visible_tables    => [qw(q_header processlist)],
      visible_tables    => [qw(row_operations row_operation_misc semaphores wait_array)],
      visible_tables    => [qw(slave_sql_status slave_io_status master_status)],
      visible_tables    => [qw(t_header innodb_transactions)],
      visible_tables    => [qw(var_status)],
# vi the minw and maxw params.
      vsep  => 0,
         w => {
   wait_array => {
   wait_array_size             => { hdr => 'Wait Array Size',     num => 1, label => 'Wait Array Size' },
         wait_array_size    => { src => 'IB_sm_wait_array_size' },
      wait_array         => \@wait_array,
   waited_at_filename          => { hdr => 'File',                num => 0, label => 'Filename at which thread waits' },
         waited_at_filename => { src => 'waited_at_filename' },
   waited_at_line              => { hdr => 'Line',                num => 1, label => 'Line at which thread waits' },
         waited_at_line     => { src => 'waited_at_line' },
   waiters_flag                => { hdr => 'Waiters',             num => 1, label => 'Waiters Flag' },
         waiters_flag       => { src => 'waiters_flag' },
      # Wait for a bit.
      # Wait for the children to exit.
waiting.
   waiting                     => { hdr => 'Waiting',             num => 1, label => 'Whether lock is being waited for' },
         waiting          => { src => 'waiting' },
            waits signal_count reservation_count complete )),
   wait_status                 => { hdr => 'Lock Status',         num => 0, label => 'Status of txn locks' },
         wait_status        => { src => 'lock_wait_status' },
      wake_up    => 0,
want to sort by column a ascending, then column b descending, type 'a -b'.  You
want to use.  This setting is per-mode, so you can monitor different connections
      warn $msg;
            warn "Unknown config file section '$1'";
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
way is by pressing the '@' key and typing the name(s) of the connection(s) you
      # we just use the first connection.
whatever data is necessary, but avoids the need to write complicated and lengthy
what status.  Using the built-in grouping rules, you can press 'Q' to enter
what variables you want to monitor.  Behind the scenes they are compiled to a
What you're doing is creating a subroutine that returns true if the row should
when events happen.  They then have a chance to influence the event.
Whenever innotop fetches data from MySQL, it adds two extra bits to each set:
   when                        => { hdr => 'When',                num => 0, label => 'Time scale' },
when it starts.
         when           => { src => 'when' },
When surrounded by the rest of the subroutine's code, this is executable Perl
# When there's an error we retry the connection every so often, increasing in
When this happens you may notice a slight delay.  At the next tick, you will
When you create a server connection using '@', innotop asks you for a series of
when you created the connection -- most likely the MySQL server's hostname.
when you don't have the SUPER privilege, required to run SHOW INNODB STATUS.
When you monitor more than one connection, innotop's status bar changes.  See
whether innotop is avoiding querying that connection.
Whether terminal coloring is permitted.
Whether the configuration file is readonly.  This cannot be set interactively.
Whether to show absolute or incremental values for status variables.
Whether to show GLOBAL variables and status.  innotop only tries to do this on
which it can manipulate (see L<"Plugin Variables">).  It must return a reference
which looks like this:
which makes it easier to read if the data is changing frequently.
which they are executed; for example, on MySQL 5 and newer, INNODB_STATUS
# which trumps the global table -- so keys can be context-sensitive.  The key
         } while ( $answer ne 'q' );
   while (++$clock) {
         } while ( !$col );
   while ( @col1 ) {
      while ( $curr ne $grps[$pos] ) {
   while ( !$dbh && $tries-- ) {
   } while ( $err );
   } while ( exists($actions{$action}) );
      } while ( !$filter || $filter =~ m/\W/ );
         } while ( !$hdr );
   while ( $i >= 0 && length($left->[$i]) <= $max_l ) {
      while ( $i < @$left && $i - $offset < @$right ) {
While innotop is primarily a monitor that lets you watch and analyze your
      while ( $i - $offset < @$right ) {
      } while ( $key ne 'q' );
   } while ( $key ne 'q' );
   while ( $key ne 'q' ) {
   while ( my ($header, $body) = splice(@sections, 0, 2) ) {
      while ( my $line = <$file> ) {
   while ( my $line = <$file> ) {
         while ( my $line = <$p_in> ) {
               while ( my ($start, $end) = splice(@ver_history, 0, 2) ) {
   while ( my ( $start, $name, $text, $end ) = splice(@matches, 0, 4) ) {
   while ( !$name || !exists($var_sets{$config{$name}->{val}}) ) {
   while ( $num >= 1_024 ) {
         while ( $res = $sth->fetchrow_hashref() ) {
   while ( $retries-- >= 0 && !$success ) {
While running innotop, press the '$' key to bring up the configuration editing
   } while ( !$success );
               while ( sysread($file, $buffer, 4096) ) {
         while ( $visible_cols[$idx] ne $col ) {
         . "whitespace, colons or semicolons."), "\n\n";
         %width_for = map {
   $width ||= $this_term_size[0];
will always be shown by default, whether grouping is enabled or not.  If a
            # will be highlighted; otherwise a > at the left will indicate.
will not be the same as $set, because $set will already contain values that are
         . "will only allow rows if their active_secs column is greater than 5.");
will prompt you for a master to run the command on, then prompt you for the
      # will sit.
with a couple of its properties such as its header and source expression (see
With no options specified, innotop will attempt to connect to a MySQL server on
without destroying your customized configuration.
without the elevated privileges.
with successive updates scrolling across the screen from left to right.  You can
with the 'a' and 'o' keys, respectively.  You can send these commands to many
   # with the beginning of another section, it ends with the end of the file.
with the 'e' key.
with the 'e' or 'f' keys.  InnoDB doesn't print the full query in transactions,
'w' key to 'wipe' the large deadlock with a small one.  This will not work
won't necessarily see all the same data.
# word_wrap {{{3
# Wraps text at word boundaries so it fits the screen.
      # write a config
   writer_lock_mode            => { hdr => 'Wrtr Lck Mode',       num => 0, label => 'Writer lock mode' },
         writer_lock_mode   => { src => 'writer_lock_mode' },
      writer => \&save_config_active_columns,
      writer => \&save_config_active_connections,
      writer => \&save_config_active_filters,
      writer => \&save_config_active_server_groups,
      writer => \&save_config_colors,
      writer => \&save_config_config,
      writer => \&save_config_connections,
      writer => \&save_config_filters,
      writer => \&save_config_group_by,
      writer => \&save_config_mvs,
      writer => \&save_config_plugins,
      writer => \&save_config_server_groups,
      writer => \&save_config_sort_cols,
      writer => \&save_config_stmt_sleep_times,
      writer => \&save_config_tbl_meta,
      writer => \&save_config_varsets,
      writer => \&save_config_visible_tables,
   writer_thread               => { hdr => 'Wrtr Thread',         num => 1, label => 'Writer thread ID' },
         writer_thread      => { src => 'writer_thread' },
            writes_pending_flush_list buf_pool_size add_pool_alloc
   writes_pending_flush_list   => { hdr => 'Flush List Writes',   num => 1, label => 'Number of flush list writes pending' },
         writes_pending_flush_list  => { src => 'IB_bp_writes_pending_flush_list' },
   writes_pending              => { hdr => 'Writes',              num => 1, label => 'Number of writes pending' },
   writes_pending_lru          => { hdr => 'LRU Writes',          num => 1, label => 'Number of LRU writes pending' },
         writes_pending_lru         => { src => 'IB_bp_writes_pending_lru' },
   writes_pending_single_page  => { hdr => '1-Page Writes',       num => 1, label => 'Number of 1-page writes pending' },
         writes_pending_single_page => { src => 'IB_bp_writes_pending_single_page' },
         writes_pending             => { src => 'IB_bp_writes_pending' },
         # write to $default_home_conf
         x => {
               (" " x $left) . $caption . (" " x ($width - $left - $cap_len)),
            ("_" x $left) . " $caption " . ("_" x ($width - $left - $cap_len - 2));
      }xms;
   $y += 2000;
Yaar Schnitman,
               "You are editing column $tbl.$col.\n",
You can also ask innotop to calculate the earliest binlog in use by any slave
You can also configure innotop to automatically detect when a large deadlock
you can also select un-grouped columns.  innotop actually aggregates every
You can also type many connection names, and innotop will fetch and display data
You can choose which group to monitor with the '#' key, and you can press the
You can choose which tables to show by pressing the '$' key.  See L<"MODES"> and
You can configure MySQL and innotop to monitor not only locks for which a
You can customize innotop a great deal.  For example, you can:
You can do more than just edit the columns with the table editor, you can also
You can enable or disable a filter on any table.  Press the '%' key (mnemonic: %
You can EXPLAIN a query from this mode with the 'e' key.  This displays the
You can kill a connection, or in newer versions of MySQL kill a query but not a
You can kill queries or processes with the 'k' and 'x' keys, and EXPLAIN a query
You can negate some options by prefixing the option name with --no.  For
You can quickly switch to the 'next' connection in alphabetical order with the
You can quickly toggle grouping on a table with the '=' key, which toggles its
You can report bugs, ask for improvements, and get other help and support at
You can run innotop in non-interactive mode, in which case it is entirely
You can see the first connection, ID 12, is waiting for a lock on the PRIMARY
# You can set properties with the prop() sub.  Don't set the 'opts' property.
You can switch between the views by pressing a key.  The 's' key prints a
      # You can't filter on a nonexistent column.  But if you filter on a pivoted
You can use keystrokes to move the rules up and down, which re-orders their
you create quick-filters, which do not get saved to the configuration file, and
you.  It's a feature, not a bug!
you just need to be sure the table doesn't exist, and that innotop can create
you'll see your column at the end of the table.
You may want to use some of the functions listed in L<"TRANSFORMATIONS"> to help
you might have made an error in your filter, and innotop is silently catching
You must connect to MySQL as a user who has the SUPER privilege for many of the
you need.
You need appropriate privileges to create and drop the deadlock tables if needed
You need Perl to run innotop, of course.  You also need a few Perl modules: DBI,
You need special privileges to start and stop slave servers.
You need the PROCESS privilege to see the list of currently running queries in Q
you need to do.
you need to see, just look at the status text directly.
    # YOUR CODE HERE
Your display might now look like the following:
you're not monitoring any groups, TAB will switch to the first group.
your server.  You can toggle it on and off with the 'h' key.  By default,
your username, you don't have to specify a username.
# You should have received a copy of the GNU General Public License along with
You should have received a copy of the GNU General Public License along with
you switch to a different mode, innotop will retry the connection instead of
you unlimited flexibility.
you want to monitor.
            |\Z
