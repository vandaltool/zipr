            }
        }
# A literal newline, so that program text is formatted correctly
                    "already included in",
# Arnold Robbins, arnold@skeeve.com, Public Domain
# At this point, `program' has the program.
#! /bin/sh
    *)      break;;
    case $1 in
        close(input[stackptr])
}'  # close quote ends `expand_prog' variable
            close(t)
                continue
            continue;;
            # diagnostic if $x is the null string
            echo igawk: version 2.0 1>&2
            } else
    esac
eval gawk $opts -- '"$processed_program"' '"$@"'
            exit 0 ;;
expand_prog='
            f=`expr "$1" : '-.file=\(.*\)'`
    -f*)    f=`expr "$1" : '-f\(.*\)'`
    for (i = 1; i <= ndirs; i++) {
    for (; stackptr >= 0; stackptr--) {
            # found it
            fpath = pathto($2)
    -f)     program="$program$n@include ${2?'missing operand'}"
function pathto(file,    i, t, junk)
            gawk --version
if [ "$1" = debug ]
            if (fpath == "") {
            if (! (fpath in processed)) {
        if ((getline junk < t) > 0) {
    if (index(file, "/") != 0)
        if (pathlist[i] == "")
            if (tolower($1) != "@include") {
if [ -z "$program" ]
# igawk --- like gawk but do @include processing
# Initialize variables to empty
    input[stackptr] = ARGV[1] # ARGV[1] is first file
                    input[stackptr], FNR, $2) > "/dev/stderr"
                input[++stackptr] = fpath  # push onto stack
# July 1993
    ndirs = split(path, pathlist, ":")
    path = ENVIRON["AWKPATH"]
            pathlist[i] = "."
                print
                print $2, "included in", input[stackptr],
                printf("igawk:%s:%d: cannot find %s\n",
                    processed[fpath] > "/dev/stderr"
                processed[fpath] = input[stackptr]
processed_program=`gawk -- "$expand_prog" /dev/stdin <<EOF
$program
program=
     program=${1?'missing program'}
            program="$program$n${2?'missing operand'}"
            program="$program$n@include ${2?'missing operand'}"
            program="$program$n@include $f";;
            program="$program$n$t";;
    return ""
        return file
            return t
            set -- -W"${@?'missing operand'}"
    set -x
    shift
     shift
            shift;;
    --)     shift; break;;
    stackptr = 0
            t=`expr "$1" : '-.source=\(.*\)'`
            # The ${x?'message here'} construct prints a
        t = (pathlist[i] "/" file)
    -[vF]*) opts="$opts '$1'" ;;
    -[vF])  opts="$opts $1 '${2?'missing operand'}'"
    -[W-]file=*)
    -[W-]file)
        while ((getline < input[stackptr]) > 0) {
while [ $# -ne 0 ] # loop over arguments
    -[W-]*) opts="$opts '$1'" ;;
    -W)     shift
    -[W-]source=*)
    -[W-]source)
    -[W-]version)
