        ;;
      ;;
	   /*) ;;
[ $? != 0 ] && { usage; exit 1; }
  [ "$1" = "-d" ] && { dirflag="-d"; shift; }
#actual possibilities DEFAULT(XSL-FO/passivetex), FOP and DBLATEX
# Allow FORMAT_DIR to be over-ridden, so that we can be
# along with this program; if not, see <http://www.gnu.org/licenses/>.
	  # and only after the first iteration.
ARGS=$(${GETOPT} \
	   *) asearchpath="${PWD}/${asearchpath}" ;;
# Ask the format script what stylesheet to use.
# (at your option) any later version.
Available FORMATs depend on the type of the XML file (which is
        BACKEND_EXTENSIONS=0
BACKEND_EXTENSIONS=1
  BASH="${BASH} -x"
BASH=/bin/bash     # GNU bash, for running the format scripts
${BASH} "$FORMAT" post-process || exit 1
#!/bin/bash
# but WITHOUT ANY WARRANTY; without even the implied warranty of
  case "$1" in
	case "$2" in
case "$2" in
	  case "${asearchpath}" in
case "$DEST_FORMAT" in
case $(echo $rootel) in
	case $POSTARGS in
  case "$USE_BACKEND" in
      cat >&2 "${VALIDATION}"
	    cat /dev/stdin > ${TMP_STYLESHEET}
      cat << EOF
  cat << EOF
      cat << EOF > "$encodingmod"
    cat << EOF > "$papersizemod"
    cat << EOF >> "$STYLESHEET"
  cat << EOF >> "$STYLESHEET"
  cat << EOF > "$STYLESHEET"
cd "$XSLT_PROCESSED_DIR"
  charmap=$("$LOCALE_PATH" charmap 2>/dev/null)
#check if we could use fop/dblatex backend as default(if not, use passivetex)
CLEANFILE_COUNT=0
    CLEANFILE_COUNT=$(($CLEANFILE_COUNT + 1))
                  command line
# Copyright (C) 2001, 2002, 2003  Tim Waugh <twaugh@redhat.com>
  DBLATEX)
DBLATEX_PATH=/usr/bin/dblatex
# Decide what source format this is.  Default to DocBook.
declare -a CLEANFILES
declare -a XSL_MODS
  DEFAULT)
DEST_FORMAT="$1"
determined automatically).
# Disable network entities
# document type without needing any help.
    done
                  do not attempt to validate the input before processing
  #do we have xmllint validation tool?
  #do we have xsltproc tool?
    echo >&2 \
  echo >&2 "I don't know how to convert ${SOURCE_FORMAT} into ${DEST_FORMAT}."
    echo >&2 "mktemp failed!"
    echo >&2 "mktemp failed. $3"
	echo >&2 "No XML Catalogs?  Trying again with --catalogs:"
  echo >&2 "Source format: ${SOURCE_FORMAT} / root element: ${rootel} "
		echo >&2 Using default backend...
		echo >&2 Warning: dblatex not found or not executable.
		echo >&2 Warning: fop not found or not executable.
    echo >&2 "xmlto: Can't continue, xsltproc tool not found or not executable."
      echo >&2 "xmlto: Fix document syntax or use --skip-validation option"
      echo >&2 "xmlto: $INPUT_FILE does not validate (status ${xmllint_status})"
    echo >&2 "xmlto: Skipping validation... " \
  echo >&2 "xmlto: Using default backend..."
  echo >&2 "xmlto: Warning: dblatex not found or not executable."
  echo >&2 "xmlto: Warning: fop not found or not executable."
    echo >&2 "xmlto: xmllint validation tool not found or not executable."
   echo -e >&2 "${XSLTPROC_PATH} ${XSLTOPTS} ${SEARCHPATH_FORMATTED} \\\\\n -o \"${XSLT_PROCESSED}\" \\\\\n \"${STYLESHEET}\" \\\\\n \"${INPUT_FILE}\""
	echo -e >&2 "${XSLTPROC_PATH} ${XSLTOPTS} ${SEARCHPATH_FORMATTED}\\\\\n -o \"${XSLT_PROCESSED}\" \\\\\n \"${STYLESHEET}\" \\\\\n \"${INPUT_FILE}\""
  echo "xmlto version 0.0.25"
[ ! -e "$INPUT_FILE" ] && echo >&2 Input file "$INPUT_FILE" not found && \
elif [ -n "`type -t $LOCALE_PATH`" ]
  elif [ -z "$3" ]
# Enable XInclude
    eval 'CLEANFILES[$CLEANFILE_COUNT]="${'$2'}"'
    # eval is for SEARCHPATH_FORMATTED's proper expansion
  # eval is for SEARCHPATH_FORMATTED's proper expansion
eval set -- "$ARGS"
    eval "\"${XMLLINT_PATH}\" --noout --nonet --xinclude --postvalid --noent ${SEARCHPATH_FORMATTED} \"${INPUT_FILE}\"" 2>"${VALIDATION}"
    eval "\"${XSLTPROC_PATH}\"" ${XSLTOPTS} ${SEARCHPATH_FORMATTED} -o "\"${XSLT_PROCESSED}\"" "\"${STYLESHEET}\"" "\"${INPUT_FILE}\""
  eval "\"${XSLTPROC_PATH}\" ${XSLTOPTS} ${SEARCHPATH_FORMATTED} -o \"${XSLT_PROCESSED}\" \"${STYLESHEET}\" \"${INPUT_FILE}\""
  exit 1
    exit 2
    exit 3
      exit $(($xmllint_status + 10))
export DBLATEX_PATH
export FOP_PATH
export GCP_PATH
export INPUT_FILE
export LINKS_PATH
export LYNX_PATH
export OUTPUT_DIR
export PDFXMLTEX_PATH
export POSTARGS
export POSTPOSTARGS
export SEARCHPATH
export USE_BACKEND
export VERBOSE
export W3M_PATH
export XMLTEX_PATH
export XSLT_PROCESSED
export XSLT_PROCESSOR
export ZIP_PATH
  --extensions)
  --extensions    turn on stylesheet extensions for this tool chain
  # Extremely verbose
FIND=find      # This must be GNU find (need -maxdepth)
  # fop1.extensions for the rest
  fo | pdf | ps | dvi)
FOP_PATH=/usr/bin/fop
    FOPVERSION="fop"
    FOPVERSION="fop1"
	for asearchpath in "$2"; do
For documents of type "$(basename "$source")":
/*) FORMAT="$DEST_FORMAT" ;;
: ${FORMAT_DIR=${prefix}/share/xmlto/format}
	FORMAT_DIR="${PWD}/${FORMAT_DIR}"
 *) FORMAT="${FORMAT_DIR}/${SOURCE_FORMAT}/${DEST_FORMAT}" ;;
  fo:root)
  # For paper sizes we know about, specify them.
    for source in $(${FIND} "$FORMAT_DIR" -maxdepth 1 -type d)
GCP_PATH=/bin/cp
# Get absolute pathnames for FORMAT_DIR and OUTPUT_DIR.
GETOPT=getopt # a getopt that supports --longoptions
# GNU General Public License for more details.
                  (good for diagnostics)
GREP=/bin/grep     # GNU grep, for searching patterns
  --help)
  h=$("$LOCALE_PATH" LC_PAPER 2>/dev/null | head -n 1)
if [ "$#" != "2" ]
  if [ $? == 4 ]
if [ "$BACKEND_EXTENSIONS" -eq 1 ]
  if [ -d "$FORMAT_DIR" ]
if [ ! -d "$OUTPUT_DIR" ]
if [ ! -e "$FORMAT" ]
  if eval $2='$(${MKTEMP} $dirflag "${TMPDIR:-/tmp}/${prefix}.XXXXXX")'
  if [ "$h" = "297" ]
    if make_temp xsl encodingmod "Using default output encoding."
  if [ -n "$charmap" ]
    if [ "$NO_AUTOSIZE" -eq 0 ] && [ -n "$papersizemod" ]
  if [ -n "$paperheight" -a -n "$paperwidth" ]
  if [ -n "$papertype" ]
if [ -n "`type -t $LOCALE_PATH`" ]
if [ -n "`type -t $PAPERCONF_PATH`" ]
	IFS=":"
if [ "$SKIP_VALIDATION" -eq 0 ] && [ "$SOURCE_FORMAT" != "fo" ]
	IFS="${oldIFS}"
      if [ "$source" = "$FORMAT_DIR" ]; then continue; fi
# If the destination format is an absolute pathname then it's a
#  * If the failure message is empty or missing, exits on failure
    if [ "$VERBOSE" -ge 1 ]; then
  if [ "$VERBOSE" -gt 2 ]
if [ "$VERBOSE" -gt 2 ]
  if [ x`$FOP_PATH -v 2>/dev/null | $GREP 0_[12]` = x ]; then
if [ "x${FORMAT_DIR##/*}" != "x" ]
    if [ $xmllint_status -ne 0 ]
if [ "$XSL_MOD_COUNT" -gt "0" -a -n "$STYLESHEET" ]
if [ x"$USE_BACKEND" = xDBLATEX ] && \
if [ x"$USE_BACKEND" = xFOP ] && [ -z "`type -t $FOP_PATH`" ]
if [ -z "$DEST_FORMAT" -o -z "$INPUT_FILE" ]
if [ -z "${STYLESHEET}" ]
if [ -z "$STYLESHEET" ]
	if [ -z "`type -t $DBLATEX_PATH`" ]
	if [ -z "`type -t $FOP_PATH`" ]
  if [ -z "`type -t $XMLLINT_PATH`" ]
  if [ -z "`type -t $XSLTPROC_PATH`" ]
    i=$(($i + 1))
/*) INPUT_FILE="$2" ;;
 *) INPUT_FILE="$PWD/$2" ;;
	  # isn't surprised if he does ``--searchpath .''
# it under the terms of the GNU General Public License as published by
LINKS_PATH=/usr/bin/links
# List of files to remove after exit
  local dirflag="" prefix="xmlto"
LOCALE_PATH=/usr/bin/locale
	local oldIFS="${IFS}"
	--longoptions=help,version,extensions,searchpath:,skip-validation,stringparam:,noclean,noautosize,with-fop,with-dblatex \
    ls "$source"
LYNX_PATH=/usr/bin/lynx
# Magic encoding, based on locale
    # make sure expansions are protected from eval
make_temp () {
# make_temp [-d] filenametag varname [message upon failure]
make_temp -d "" XSLT_PROCESSED_DIR
	-)  make_temp stdin-xsl TMP_STYLESHEET
    make_temp xsl papersizemod "Using default paper type." &&
  make_temp xsl STYLESHEET
# Make verbosity level uniformly available to called scripts
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  -m fragment     use the XSL fragment to customize the stylesheet
  mkdir -p "$OUTPUT_DIR"
MKTEMP=mktemp # See http://www.mktemp.org if missing on your system
	MYPARAM="$2"
  [ -n "$1" ] && prefix="xmlto-$1"
  --noautosize)
NO_AUTOSIZE=0
  NO_AUTOSIZE=1
  --noautosize    do not autodetect paper size via locales or paperconf
  --noclean)
  --noclean       temp files are not deleted automatically
  --noextensions)
  --noextensions  do not use passivetex/fop extensions
  # No stylesheet: no XSL-T processing to do.
	[ -n "${SEARCHPATH}" ] && SEARCHPATH_FORMATTED="--path \"${SEARCHPATH}\""
	-n xmlto -- x:m:o:p:v "$@")
  -o directory    put output in the specified directory instead of
OPTIONs are:
# ... or use magic paper size, based on LC_PAPER
	/*) OUTPUT_DIR="$2" ;;
OUTPUT_DIR="$WD"
	 *) OUTPUT_DIR="$WD/$2" ;;
PAPERCONF_PATH=paperconf
  paperheight=`"$PAPERCONF_PATH" -mh | sed 's/ //g'`
  papername=`"$PAPERCONF_PATH" -n`
    papertype=A4
  paperwidth=`"$PAPERCONF_PATH" -mw | sed 's/ //g'`
                  pass a named parameter to the stylesheet from the
PDFXMLTEX_PATH=/usr/bin/pdfxmltex
             "Please make sure xmllint is installed."
	"") POSTARGS="$2" ;;
	*) POSTPOSTARGS="$2" ;;
  -p postprocopts pass option to postprocessor
prefix=/usr
# Process any options
  REAL_STYLESHEET="$STYLESHEET"
#  * Remembers the temporary file's name so it can be deleted on exit
    return 0
    return 2
    rm -f "${VALIDATION}"
rootel=$(echo "xpath *" | "$XMLLINT_PATH" --shell "$INPUT_FILE" 2> /dev/null | head -n 3 |$TAIL -n 1 | cut -f 4 -d " " )
#rootel=$(head -n 4 "$INPUT_FILE" | tr -d '\n' | \
# run from the build directory.
# Run the format script in post-process mode to finish off.
  --searchpath)
SEARCHPATH=
  --searchpath    colon-separated list of fallback directories
	  SEARCHPATH="${SEARCHPATH}${XML_SEARCHPATH_SEPARATOR}${asearchpath}"
#     sed -e 's/^<?[^?>]*?>//g' -e 's/^<![^>]*>//g' -e 's/^<\([^ ]*\).*$/\1/')
# Seems reasonable fix the file command and teach it to identify the DTD/Schema but this is faster to write:
        shift
	shift 2
# Since we know DEST_FORMAT, we know whether or not to use $papersizemod.
  --skip-validation
  --skip-validation)
SKIP_VALIDATION=0
	SKIP_VALIDATION=1
: ${SOURCE_FORMAT=docbook}
	SOURCE_FORMAT="fo"
	SOURCE_FORMAT="xhtml1"
  --stringparam)
  --stringparam paramname=paramvalue
	/*) STYLESHEET="$2" ;;
  STYLESHEET="$(${BASH} "$FORMAT" stylesheet)" || exit 1
	 *) STYLESHEET="$PWD/$2" ;;
	    STYLESHEET=${TMP_STYLESHEET} ;;
TAIL=/usr/bin/tail     # a tail that supports -n (posix)
                  the current working directory
# the Free Software Foundation; either version 2 of the License, or
    then
# The names parameter for the XSLT stylesheet
# This can be over-ridden, but really we should detect the source
# This is an array of XSL fragments specified by the user.
	# This is the cleanest method I can think of, but requires calls to
# This program is distributed in the hope that it will be useful,
# This program is free software; you can redistribute it and/or modify
  touch "$XSLT_PROCESSED"
	trap -- 'cd /; [ -z "${CLEANFILES[*]}" ] || echo "${CLEANFILES[@]}"' EXIT
trap -- 'cd /; [ -z "${CLEANFILES[*]}" ] || rm -rf "${CLEANFILES[@]}"' EXIT
# Try to setup papersize using libpaper first ...
usage () {
usage: xmlto [OPTION]... FORMAT XML
		USE_BACKEND="DBLATEX"
  USE_BACKEND=DEFAULT
USE_BACKEND=DEFAULT
		USE_BACKEND="FOP"
	##use dblatex instead of passivetex where possible
	##use fop instead of passivetex where possible
# user-defined format script.  Otherwise it's one of ours.
# Utilities that we need that aren't everywhere
# Validate the input
    VALIDATION="${XSLT_PROCESSED_DIR}/validation-errors"
	: ${VERBOSE:-0}
VERBOSE=0
    [ "$VERBOSE" -ge 1 ] && \
  [ "${VERBOSE}" -ge 1 ] && \
[ "$VERBOSE" -ge 1 ] && \
  [ "$VERBOSE" -ge 1 ] && echo >&2 "Creating output directory ${OUTPUT_DIR}"
[ "$VERBOSE" -ge 1 ] && echo >&2 "Format script: ${FORMAT}"
  [ "$VERBOSE" -ge 1 ] && echo >&2 "Real stylesheet: ${REAL_STYLESHEET}"
  [ "$VERBOSE" -ge 1 ] && echo >&2 "Stylesheet: ${STYLESHEET}"
	VERBOSE=$((${VERBOSE}+1))
  --version)
	version
version () {
                version='1.0'>
		version='1.0'>
  -v              verbose output (-vv for very verbose)
W3M_PATH=/usr/bin/w3m
WD="$(pwd)"
# We might need to create a temporary stylesheet if there are
	  # we only need a colon if more than one path is in the searchpath
  # we should enable fop.extensions for fop 0_17,0_18 and 0_20*,
while [ "$#" -gt "0" ]; do
  while [ "$i" -lt "$XSL_MOD_COUNT" ]
  --with-dblatex)
  --with-dblatex  use dblatex for formatting (if dblatex available)
  --with-fop)
  --with-fop      use fop for formatting (if fop available)
	  # wrangle relative paths into absolute ones so that the user
# Wrapper for 'varname=$(mktemp /tmp/xmlto-$filenametag.XXXXXX)'.
	# xmllint and xsltproc to be run through eval --ohnobinki
	"\"${XMLLINT_PATH}\" --noout --nonet --xinclude --postvalid --noent ${SEARCHPATH_FORMATTED} \"${INPUT_FILE}\""
XMLLINT_PATH=/usr/bin/xmllint
    xmllint_status=$?
	  XML_SEARCHPATH_SEPARATOR=":"
XMLTEX_PATH=/usr/bin/xmltex
# xmlto - apply an XSL stylesheet to an XML document
<?xml version='1.0'?>
# XSL fragments that need adding.
<xsl:import href="${REAL_STYLESHEET}"/>
<xsl:include href="${XSL_MODS[$i]}"/>
  </xsl:message>
  <xsl:message>
XSL_MOD_COUNT=0
      XSL_MOD_COUNT=$(($XSL_MOD_COUNT + 1))
	XSL_MOD_COUNT=$(($XSL_MOD_COUNT + 1))
	/* | *:/*) XSL_MODS[$XSL_MOD_COUNT]="$2" ;;
      XSL_MODS[$XSL_MOD_COUNT]="$encodingmod"
      XSL_MODS[$XSL_MOD_COUNT]="$papersizemod"
	        *) XSL_MODS[$XSL_MOD_COUNT]="$PWD/$2" ;;
<xsl:param name="chunker.output.encoding" select="'$charmap'"/>
<xsl:param name="man.charmap.use.subset" select="'0'"/>
<xsl:param name="page.height">$paperheight</xsl:param>
<xsl:param name="page.width">$paperwidth</xsl:param>
<xsl:param name="paper.type" select="'$papertype'"/>
</xsl:stylesheet>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
</xsl:template>
<xsl:template name="root.messages">
  <xsl:text>Making </xsl:text>
  <xsl:text> pages on $papername paper (</xsl:text>
  <xsl:text>)</xsl:text>
  <xsl:text>x</xsl:text>
XSLTOPTS=
    XSLTOPTS="${XSLTOPTS} --catalogs"
XSLTOPTS="$XSLTOPTS --nonet"
      XSLTOPTS="$XSLTOPTS --param $FOPVERSION.extensions '1'" ;;
      XSLTOPTS="$XSLTOPTS --param passivetex.extensions '1'" ;;
	XSLTOPTS="$XSLTOPTS --param use.extensions '1'"
    XSLTOPTS="$XSLTOPTS -v"
XSLTOPTS="$XSLTOPTS --xinclude"
  XSLTOPTS="${XSLTPARAMS} ${XSLTOPTS}"
XSLTPARAMS=""
	XSLTPARAMS="$XSLTPARAMS ${MYPARAM#*=}"
	XSLTPARAMS="$XSLTPARAMS --stringparam ${MYPARAM%=*}"
  XSLT_PROCESSED="$INPUT_FILE"
  XSLT_PROCESSED="$XSLT_PROCESSED_DIR/$(basename "${INPUT_FILE%.*}").proc"
XSLT_PROCESSOR="$XSLTPROC_PATH" # We only know about xsltproc right now.
  #xsltproc may return no file on empty input, touch it to have it for sure
XSLTPROC_PATH=/usr/bin/xsltproc
  xsltproc_status=$?
  [ ${xsltproc_status} -gt 0 ] && exit ${xsltproc_status}
  <xsl:value-of select="\$page.height"/>
  <xsl:value-of select="\$page.orientation"/>
  <xsl:value-of select="\$page.width"/>
  -x stylesheet   use the specified stylesheet instead of choosing one
# You should have received a copy of the GNU General Public License
ZIP_PATH=zip
   [ -z "`type -t $DBLATEX_PATH`" ]
