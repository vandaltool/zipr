## -----------------------------------------------------------------------
0 0 0 0 0 0 0 0 0 0 0 0 
1f 6 0 0 52 52 b4 41 bb aa 55 31 c9 30 f6 f9 cd 13 72 13 81 fb 55 aa 75 d
33 c0 fa 8e d8 8e d0 bc 0 7c 89 e6 6 57 8e c0 fb fc bf 0 6 b9 0 1 f3 a5 ea
3 40 89 de 83 c3 10 e2 f3 48 74 5b 79 39 59 5b 8a 47 4 3c f 74 6 24 7f 3c
3c a 75 f1 cd 18 f4 eb fd 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
3 e8 b6 ff 66 8b 46 1c e8 a0 ff 83 c3 10 e2 cc 66 61 c3 e8 62 0 4d 75 6c 74
50 6 53 6a 1 6a 10 89 e6 66 f7 36 f4 7b c0 e4 6 88 e1 88 c5 92 f6 36 f8 7b
5 75 22 66 8b 47 8 66 8b 56 14 66 1 d0 66 21 d2 75 3 66 89 c2 e8 ac ff 72
61 74 69 6e 67 20 73 79 73 74 65 6d 2e d a 66 60 66 31 d2 bb 0 7c 66 52 66
69 70 6c 65 20 61 63 74 69 76 65 20 70 61 72 74 69 74 69 6f 6e 73 2e d a 66
6d 20 6c 6f 61 64 20 65 72 72 6f 72 2e d a 5e ac b4 e 8a 3e 62 4 b3 7 cd 10
88 c6 8 e1 41 b8 1 2 8a 16 fa 7b cd 13 8d 64 10 66 61 c3 e8 c4 ff be be 7d
8b 44 8 66 3 46 1c 66 89 44 8 e8 30 ff 72 13 81 3e fe 7d 55 aa f 85 6 ff bc
@args = ();
##   (at your option) any later version; incorporated herein by reference.
$bcyl    = ($h > 1) ? 0 : 1;
bf be 7 b9 20 0 f3 a5 c3 66 60 89 e5 bb be 7 b9 4 0 31 c0 53 51 f6 7 80 74
$bhead   = ($h > 1) ? 1 : 0;
binmode OUTPUT;
    $BLKGETSIZE   = 0x1260;
    $BLKRRPART    = 0x125f;
	    $blksize = pack("L!", 0);
##   Boston MA 02111-1307, USA; either version 2 of the License, or
$bsect   = 1;
$c += 0;  $h += 0;  $s += 0;
    $cc = 1024;
    $c = ($c*1024*2)/($h*$s);
    $cc = $c;
    $c = cwd();
$cfgfile = $tmpdir.'/mtools.conf';
	chomp $line;
    $c = '' if ( $c eq '/' );
# Clean up in /tmp
    $c = $len/($h*$s);
close(MCONFIG);
    close($rfd) if (defined($rfd));
##   Copyright 2002-2008 H. Peter Anvin - All Rights Reserved
##   Copyright 2009-2010 Intel Corporation; author: H. Peter Anvin
# Creates a blank MS-DOS formatted hard disk image
$cylsize = $h*$s*512;
d1 e9 73 9 66 c7 6 8d 6 b4 42 eb 15 5a b4 8 cd 13 83 e1 3f 51 f b6 c6 40 f7
    die "$0: Bad MBR code\n";
die "$0: Failed to create symlink $imglink\n"
	die "$0: Failed to make temp directory: $tmpdir\n"
e1 52 50 66 31 c0 66 99 e8 66 0 e8 21 1 4d 69 73 73 69 6e 67 20 6f 70 65 72
$ecyl    = ($cc-1) & 0xff;
			  $ehead, $esect, $ecyl, $s, $psize);
$ehead   = $h-1;
    } else {
} else {
	} elsif ( $is_linux && S_ISBLK($filestat[2]) ) {
    } elsif ( $psize > 65536 ) {
} elsif ( $psize > 65536 ) {
    $emuhdr .= "\0" x (128 - length($emuhdr));
    $emuhdr = "DOSEMU\0" . pack("VVVV", $h, $s, $c, 128);
$ENV{'MTOOLSRC'} = $cfgfile;
$esect   = $s + ((($cc-1) & 0x300) >> 2);
    exit 1;
	exit 1;
fa 7b 5a 5f 7 fa ff e4 e8 1e 0 4f 70 65 72 61 74 69 6e 67 20 73 79 73 74 65
    # FAT12: adjust partition type
($file,$c,$h,$s) = @args;
flush OUTPUT;
	foreach $byte ( split(/\s+/, $line) ) {
	foreach $o ( split(//, substr($a,1)) ) {
for ( $i = 1 ; $i <= 4 ; $i++ ) {
    for ( $i = 1 ; $i < $tracks ; $i++ ) {
	$fstype = 0x01;		# FAT12
    $fstype = 0x04;
	$fstype = 0x04;		# FAT16 <= 32MB
    $fstype = 0x06;
	$fstype = 0x06;		# FAT16 > 32MB
	$fstype = 0x0b;
	$fstype = 0x0c;		# FAT32 LBA
    $fstype = 0x0e;
	$fstype = 0x0e;		# FAT16 LBA
    # Get a 32-bit random number
$header_size = ($opt{'d'} ? 128 : 0);
    $h = $h || 64;
    $id = get_random();
		$id = shift(@ARGV);
    $id = to_int($id);
    if ( $a =~ /^\-/ ) {
if ( $c == 0 && $file ne '' ) {
    if ( $c > 1024 ) {
if ( $c > 1024 ) {
if ($c > 1024) {
if (defined($id)) {
	    if ( $! != EEXIST );
if ( $file eq '' || $c < 1 || $h < 1 || $h > 256 || $s < 1 || $s > 63 ) {
	if ( (@filestat = stat(OUTPUT)) && S_ISREG($filestat[2]) ) {
    if ( $fsname eq 'FAT12   ' ) {
	    if ( ioctl(OUTPUT, $BLKGETSIZE, $blksize) == 0 ) {
    if ( $i == $pentry ) {
if ( $is_linux ) {
if ( !$is_open ) {
    if ( !$len ) {
if ( length($mbr) > 440 ) {
    if ( !mkdir($tmpdir, 0700) ) {
	    if ($o eq 'i') {
    if (open($rfd, "< /dev/urandom\0") && read($rfd, $rnd, 4) == 4) {
if ( $opt{'d'} ) {
if ( $opt{'F'} ) {
if ( $opt{'M'} && $h && $s ) {
if ( $opt{'o'} ) {
if ( $opt{'z'} ) {
# If -s is given, try to simply use truncate...
    if ( !symlink(absolute_path($file), $imglink) );
    if ( sysopen(OUTPUT, $file, O_RDWR, 0666) ) {
$imglink = $tmpdir.'/disk.img';
    # IOCTL numbers
    ioctl(OUTPUT, $BLKRRPART, 0);
$is_linux = is_linux();
$is_open = 0;
	$is_open = 1;
##   it under the terms of the GNU General Public License as published by
# Just in case this is a block device, try to flush the partition table
	last if ($line eq '*');
    $len = 0;
	    $len = $filestat[7] >> 9;
		$len = unpack("L!", $blksize); # In 512-byte sectors!
$mbr .= "\0\0";			# Offset 446: actual partition table
$mbr .= "\0" x (440 - length($mbr));
	    $mbr .= chr(hex($byte));
$mbr = get_hex_data();
$mbr .= pack("V", $id);		# Offset 440: MBR ID
# MTOOLS doesn't write the bsHiddenSecs field correctly
    my($c);
    my($f) = @_;
    my $line, $byte;
    my $mbr = '';
    my $rfd, $rnd;
    my $rid;
$offset = $s*512 + $header_size;
open(MCONFIG, "> ${cfgfile}") or die "$0: Cannot make mtools config\n";
%opt = ();
	    $opt{$o} = 1;
	or die "$0: Cannot open: $file\n";
# Output blank file
# Output the filesystem offset to stdout if appropriate
$pentry = 1;
$pentry = 2 if ( $opt{'2'} );
$pentry = 3 if ( $opt{'3'} );
$pentry = 4 if ( $opt{'4'} );
    # Print fractional track
print MCONFIG "cylinders=${c}\n";
print MCONFIG "drive z:\n";
print MCONFIG "file=\"${imglink}\"\n";
print MCONFIG "heads=${h}\n";
print MCONFIG "mformat_only\n";
print MCONFIG "offset=${offset}\n";
print MCONFIG "sectors=${s}\n";
# Print mtools temp file
    print $offset, "\n";
# Print out DOSEMU header, if requested
	print OUTPUT "\0" x 16;
    print OUTPUT "\0" x (512 * ($s-1));
    print OUTPUT $emuhdr;
print OUTPUT $mbr;
	print OUTPUT pack("CCCCCCCCVV", 0x80, $bhead, $bsect, $bcyl, $fstype,
print OUTPUT pack("C", $fstype);
print OUTPUT pack("V", ($offset-$header_size)>>9);
	print OUTPUT $track;
print OUTPUT "\x55\xaa";
# Print partition table
	print STDERR "$0: $file: don't know how to determine the size of this device\n";
    print STDERR "    -4    use partition entry 4 (standard for zipdisks)\n";
    print STDERR "    -d    add DOSEMU header\n";
    print STDERR "    -F    format partition as FAT32\n";
    print STDERR "    -i    specify the MBR ID\n";
    print STDERR "    -M    \"c\" argument is megabytes, calculate cylinders\n";
    print STDERR "Not all BIOSes will be able to boot this device.\n";
    print STDERR "    -o    print filesystem offset to stdout\n";
    print STDERR "    -s    output a sparse file (don't allocate all blocks)\n";
    print STDERR "Usage: $0 [-doFMz4][-i id] file c h s (max: 1024 256 63)\n";
    print STDERR "Warning: more than 1024 cylinders ($c).\n";
    print STDERR "    -z    use zipdisk geometry (h=64 s=32)\n";
# Print the MBR and partition table
$psize = $c*$h*$s-$s;
$pstart = $header_size + 446 + 16*($pentry-1);
	push(@args, $a);
    read(OUTPUT, $fsname, 8);
    return $c.'/'.$f;
    return !!eval '{ '.
    return $f if ( $f =~ /^\// );
    return $mbr;
    return $rid if (defined($rid));
	"return \$sysname eq \'Linux\'; }";
    return ($$+time()) & 0xffffffff;
	$rid = unpack("V", $rnd);
rmdir($tmpdir);
seek(OUTPUT, $offset + 0x1c, 0);
    seek(OUTPUT, $offset + 0x36, 0);
seek(OUTPUT, $pstart+4, 0);
# Set the partition type
    # Specify size in megabytes, not in cylinders
    $s = $s || 32;
# Start of filesystem
# Start of partition table entry
sub absolute_path($) {
sub get_hex_data() {
sub get_random() {
sub is_linux() {
	'($sysname, $nodename, $release, $version, $machine) = POSIX::uname(); '.
    sysopen(OUTPUT, $file, O_CREAT|O_RDWR|O_TRUNC, 0666)
    system('mformat', '-F', 'z:');
    system('mformat', 'z:');
##   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
##   This program is free software; you can redistribute it and/or modify
    # This sucks but is better than nothing...
    $tmpdir = "/tmp/mkdiskimage.$$.".($n++);
$totalsize = $c*$h*$s;
    $track = "\0" x (512*$s);
$tracks    = $c*$h;
	undef $tmpdir;
unless ($opt{'s'} && truncate(OUTPUT, $totalsize)) {
unlink($cfgfile);
unlink($imglink);
use bytes;
use Cwd;
use Errno;
use Fcntl;
use integer;
use IO::Handle;			# For flush()
	'use POSIX; '.
#!/usr/bin/perl
while (defined($a = shift(@ARGV))) {
while ( !defined($tmpdir) ) {
    while ( $line = <DATA> ) {
