            }
        }
##--------------------------------------------------------------------##
#  02111-1307, USA.
    1 while ($val =~ s/^(\d+)(\d{3})/$1,$2/);
#  along with this program; if not, write to the Free Software
    # arguments of -d/-e/-i are non-numeric
      $c = 0;
##---                                            callgrind_control ---##
  %calls = ();
      $calls{$ctid,$fcount{$ctid}} = $3;
                $CC_col_widths->[$i] = max($CC_col_widths->[$i], $clength); 
    (@CC <= @events) or die("Line $.: too many event counts\n");
	    # check next argument for "on" or "off"
  close LIST;
	  $cmd = $2;
	  $cmdline{$pid} = $cmd;
	  $cmd{$pid} = $cmd;
	  $cmd =~ s/^(\S*).*/$1/;
##--- Control supervision of applications run with callgrind       ---##
#  Copyright (C) 2003-2011 Josef Weidendorfer <Josef.Weidendorfer@gmx.de>
    # correspond to @CC positions.
  $ctid = 0;
	$ctid = $1;
      (defined $events{$show_event}) or
  $dist_bbs = 0;
  $dist_calls = 0;
  $dist_ctxs = 0;
  $dist_funcs = 0;
$dumpHint = "";
      $dumpHint = $arg;
	    $dumpHint = substr($2,1);
      else {
    else {
  } else {
	elsif ($2 eq "=off") {
    elsif ($arg =~ /^(-b|--back)$/) {
    elsif ($arg =~ /^(-d|--dump)(|=.*)$/) {
    elsif ($arg =~ /^-e$/) {
      elsif ($arg eq "off") {
    elsif ($arg =~ /^(-i|--instr)(|=on|=off)$/) {
    elsif ($arg =~ /^(-k|--kill)$/) {
    elsif ($arg =~ /^(-s|--stat)$/) {
    elsif ($arg =~ /^-v$/) {
    elsif ($arg =~ /^--version$/) {
    elsif ($arg =~ /^(-z|--zero)$/) {
    elsif (/calls-(\d+)-(\d+): (.+)$/) {
    elsif (/distinct-bbs: (\d+)/) { $dist_bbs = $1; }
    elsif (/distinct-calls: (\d+)/) { $dist_calls = $1; }
    elsif (/distinct-contexts: (\d+)/) { $dist_ctxs = $1; }
    elsif (/distinct-functions: (\d+)/) { $dist_funcs = $1; }
    elsif (/events-(\d+): (.+)$/) {
    elsif (/events-(\d+)-(\d+): (.+)$/) {
    elsif (/events: (.+)$/) { $events = $1; prepareEvents; }
    elsif (/executed-bbs: (\d+)/) { $exec_bbs = $1; }
    elsif (/executed-calls: (\d+)/) { $exec_calls = $1; }
    elsif (/instrumentation: (\w+)$/) { $instrumentation = $1; }
    elsif (/threads: (.+)$/) { $threads = $1; @threads = split " ", $threads; }
  @events = ();
  $events = "";
  %events = ();
      $events{$ctid,$fcount{$ctid}} = line_to_CC($3);
    $events{$event} = $n;
  @events = split(/\s+/, $events);
  $exec_bbs = 0;
  $exec_calls = 0;
    exit;
  %fcount = ();
      $fcount{$ctid}++;
	$fcount{$ctid} = 0;
	$fc = substr(" $c",-2);
                # Find length, accounting for commas that will be added
    # Find maximum width count for each column.  @CC_col_width positions
foreach $arg (@ARGV) {
  foreach $event (@events) {
    foreach my $CC (@CCs) {
    foreach my $event (@events) {
        foreach my $i (0 .. scalar(@$CC)-1) {
    foreach my $i (@show_order) {
    foreach my $i (@show_order) { 
    foreach my $show_event (@show_events) {
  foreach my $show_event (@show_events) {
foreach $pid (@pids) {
  foreach $p (@pids) {
    foreach $tid (@tids) {
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  %func = ();
      $func{$ctid,$fcount{$ctid}} = $3;
#  General Public License for more details.
getCallgrindPids;
$headerPrinted = 0;
  $headerPrinted = 1;
	if ($2 eq "=on") {
	if ($2 ne "") {
  if ($arg =~ /^-/) {
  if ($arg =~ /^[A-Za-z_]/) {
      if ($arg eq "on") {
    if ($arg =~ /^(-h|--help)$/) {
    if ($cmd{$p} =~ /$arg$/) {
	  if (!($cmd =~ /--tool=callgrind/)) { next; }
      $i = $fcount{$tid};
      if ($ctid != $1) {
      if ($ctid != $1) { next; }
            if (defined $CC->[$i]) {
  if (defined $cmd{$arg}) { $spids{$arg} = 1; next; }
  if ($dumpHint ne "") { $vgdbCommand .= " ".$dumpHint; }
    if (/function-(\d+)-(\d+): (.+)$/) {
  if ($headerPrinted) { return; }
	if ($i > 1) {
  if ($instrumentation eq "off") {
  if ($nameFound) { next; }
  #if ($? ne "0") { print " Got Error $?\n"; }
  if ($pid >0) { print $pidstr.$cmdline{$pid}; }
  if ($printBacktrace) {
  if ($printStatus) {
if ($printStatus || $printBacktrace || $requestEvents) {
if ($requestDump) {
    if ($requestDump == 1) {
    if ($requestDump == 1) { $requestDump = 2; }
      if ($requestEvents >0) {
    if ($requestEvents >0) {
  if ($requestEvents >0) {
	if ($requestEvents >0) {
    if ($requestEvents <1) {
    if ($requestEvents == 1) {
    if ($requestEvents == 1) { $requestEvents = 2; }
if ($requestKill) { $vgdbCommand = "v.kill"; }
if ($requestZero) { $vgdbCommand = "zero"; }
      if (scalar @events == 0) { next; }
if (scalar @pids == 0) {
if (scalar @spids >0) { @pids = @spids; }
  if (@show_events) {
    if ($switchInstr == 1) {
if ($switchInstr == 1) {
if ($switchInstr) { $vgdbCommand = "instrumentation ".$switchInstrMode; }
      if (/^use --pid=(\d+) for \S*?valgrind\.bin\s+(.*?)\s*$/) {
  if ($verbose>0) {
  if ($vgdbCommand eq "") {
  if (!$waitForAnswer) { print "  OK.\n"; next; }
    # Initialise with minimum widths (from event names)
#  License, or (at your option) any later version.
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  modify it under the terms of the GNU General Public License as
    my ($CC, $CC_col_widths) = @_;
    my ($CC_col_widths) = @_;
    my $CC_col_widths = [];
    my @CCs = @_;
    my @CC = (split /\s+/, $_[0]);
                my $clength = $length + int(($length - 1) / 3);
        my $col_width   = $CC_col_widths->[$i];
        my $count = (defined $CC->[$i] ? commify($CC->[$i]) : ".");
        my $event       = $events[$i];
        my $event_width = length($event);
                my $length = length $CC->[$i];
        my $space = ' ' x ($CC_col_widths->[$i] - length($count));
        my $space       = ' ' x ($col_width - $event_width);
    my ($val) = @_;
    my ($x, $y) = @_;
    $n++;
  $n = 0;
  $nameFound = 0;
      $nameFound = 1;
      next;
  open LIST, "vgdb -l|";
  open RESULT, "vgdb --pid=$pid $vgdbCommand|";
# Parts more or less copied from cg_annotate (author: Nicholas Nethercote)
	  $pid = $1;
  @pids = ();
  $pidstr = "PID $pid: ";
  print "active Callgrind runs. Default action is printing short information.\n\n";
	$printBacktrace = 1;
      print "Backtrace for Thread $tid\n";
    print "  Basic blocks: ".commify($dist_bbs);
  print "  -b --back         Show stack/back trace\n";
  print "(C) 2003-2011, Josef Weidendorfer (Josef.Weidendorfer\@gmx.de)\n\n";
  print "callgrind_control-3.7.0\n";
    print ", call sites ".commify($dist_calls).")\n";
	  print " (".$calls{$tid,$i-1}." x)";
	  print_CC($events{$tid,$i-1}, $totals_width);
      print_CC($totals{$tid}, $totals_width);
    print ", contexts ".commify($dist_ctxs).")\n";
  print "  --dump[=<s>]      Request a dump optionally using <s> as description\n";
  print "  -e [<A>,...]      Show event counters for <A>,... (default: all)\n";
  print "Error: Callgrind task with PID/name '$arg' not detected.\n";
  print "Error: need to specify 'on' or 'off' after '-i'.\n";
	  print "Error: need to specify 'on' or 'off' after '-i'.\n";
	print "Error: unknown command line option '$arg'.\n";
      print "  Events collected: $events\n";
    print_events($totals_width);
	print_events($totals_width);
    print " (executed ".commify($exec_bbs);
    print " (executed ".commify($exec_calls);
	print "   [$fc]  ";
	  #print "Found PID $pid, cmd '$cmd{$pid}', cmdline '$cmdline{$pid}'.\n";
	print $func{$tid,$i};
    print "  Functions: ".commify($dist_funcs);
  printHeader;
	printHelp;
  print "  -h --help         Show this help text\n";
  print "If no pids/names are given, an action is applied to all currently\n";
  print "  -i --instr=on|off Switch instrumentation state on/off\n";
  print "  -k --kill         Kill\n";
      print "\n";
      print("\n");
    print("\n");
  print "\n";
	print "\n";
      print "\n  Frame: ";
  print "No active callgrind runs detected.\n";
    print "  No information available as instrumentation is switched off.\n\n";
    print "\n  Totals:";
      print "  Number of running threads: " .($#threads+1). ", thread IDs: $threads\n";
  print "Observe the status and control currently active callgrind runs.\n";
  print "Options:\n";
      print " [requesting '$vgdbCommand']\n";
  print "See '$0 -h' for help.\n";
        print("$space$count ");
        print("$space$event ");
  print "  -s --stat         Show statistics\n";
	$printStatus = 1;
# Print the CC with each column's size dictated by $CC_col_widths.
      print "   Th".substr("  ".$tid,-2)."  ";
  print "Usage: callgrind_control [options] [pid|program-name...]\n\n";
	printVersion;
  print "  --version         Show version\n";
	print "Warning: Event `$show_event' is not being collected\n";
  print "  -z --zero         Zero all event counters\n";
#  published by the Free Software Foundation; either version 2 of the
        push(@$CC_col_widths, length($event));
	  push(@pids, $pid);
    push(@show_order, $events{$show_event});
	push(@tids, $ctid);
$requestDump = 0;
	    $requestDump = 1;
      $requestDump = 2;
	    $requestDump = 2;
$requestEvents = 0;
	$requestEvents = 1;
      $requestEvents = 2;
	$requestKill = 1;
	$requestZero = 1;
    return \@CC;
    return $CC_col_widths;
    return $val;
    return ($x > $y ? $x : $y);
  shortHelp;
	  shortHelp;
	shortHelp;
    @show_events = @events;
      @show_events = split(/,/, $arg);
  @show_order = ();
%spids = ();
@spids = keys %spids;
      $spids{$p} = 1;
sub commify ($) {
sub compute_CC_col_widths (@) 
sub getCallgrindPids {
sub line_to_CC ($)
sub max ($$) 
sub prepareEvents {
sub print_CC ($$) 
sub print_events ($)
sub printHeader {
sub printHelp {
sub printVersion {
sub shortHelp {
$switchInstr = 0;
	    $switchInstr = 1;
      $switchInstr = 2;
	$switchInstr = 2;
	    $switchInstrMode = "off";
	  $switchInstrMode = "off";
	    $switchInstrMode = "on";
	  $switchInstrMode = "on";
	    # take next argument as dump hint
#  This file is part of Callgrind, a cache-simulator and call graph
#  This program is distributed in the hope that it will be useful, but
#  This program is free software; you can redistribute it and/or
  @threads = ();
  $threads = "";
  @tids = ();
  %totals = ();
      $totals{$1} = line_to_CC($2);
      $totals_width = compute_CC_col_widths(values %events);
    $totals_width = compute_CC_col_widths(values %totals);
#  tracer built on Valgrind.
#! /usr/bin/perl -w
	$verbose++;
$verbose = 0;
$vgdbCommand = "";
  $vgdbCommand = "dump";
  $vgdbCommand = "status internal";
$waitForAnswer = 0;
  $waitForAnswer = 1;
	  while($cmd =~ s/^-+\S+\s+//) {}
      while($i>0 && $c<100) {
  while(<LIST>) {
  while(<RESULT>) {
#  WITHOUT ANY WARRANTY; without even the implied warranty of
#  You should have received a copy of the GNU General Public License
