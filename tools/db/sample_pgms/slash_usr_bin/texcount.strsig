      # {...}
***************************************************************
#########
###################################################
  #   0: comment
  #    0 = exclude from count
#    0: Not included
  #   -1 = float (exclude)
#   -1: Float, not included, but looks for captions
  -1            Same as -brief and -total. Ensures there is only one
  #    1 = text
#    1: Text, word included in text count
  #   1: word (or other forms of text or text components)
  #    2 = header text
#    2: Header, words included in header count
  #   -2 = strong exclude, ignore begin-end groups
  #   2: symbol (not word, e.g. punctuation)
#    3: Float caption, words included in float caption count
  #    3 = float text
  #   3: macro
  #   -3 = stronger exclude, do not parse macro parameters
#    4 and 5 are used to count number of headers and floats
  #   4: curly braces {}
  #   5: brackets []
  #   666: TeXcount instruction (%TC:instruction)
#    6: Inline mathematics, words not counted
  #   6: maths
#    7: Displayed mathematics, words not counted
  #   999: end of line or blank line
  #   9: line break in file
  #   -9 = preamble (between \documentclass and \begin{document})
     'abstract'=>1,'quote'=>1,'quotation'=>1,'verse'=>1,'minipage'=>1,'verbatim'=>1,
   ${$a->{'count'}}[$i]+=${$b->{'count'}}[$i];
# actually never used). This is copied to %TeXmacro and the
      add_count($filetotalcount,$filecount);
    add_count($listtotalcount,$filetotalcount);
  add_count($tex->{'countsum'},$tex->{'count'});
    add_subcount($tex,$label);
     '\addtocounter'=>2,'\stepcounter'=>1, '\refstepcounter'=>1, '\usecounter'=>1,
# Allows \macro{file} or \macro file. If the value is 0, the filename will
     '\alph'=>1, '\arabic'=>1, '\fnsymbol'=>1, '\roman'=>1, '\value'=>1,
# a macro.
# and after. The %TeXmacro hash gives a link from a macro
#    and are not used as states.
and displayed formulae. Similarly, the number of headers and
                and katakana) as one word, i.e. not do any form of
and published under the LaTeX Project Public License.
  Apply_Options();
# Apply options to set values
are 0 to ignore and 1 to count as text. Parsing instructions
    $arg=~s/\\/\//g;
# array values tell how each is to be interpreted (see the status
        as macro, but also counted inside floats
        as macro, but also counted inside the preamble
     '\begin'=>1,'\end'=>1,'\title'=>[2]);
      # \begin{document}
        begin-end-group handling rule
### Begin-End groups
     'beginlist'=>2, 'beginminipage'=>1, 'begintabular'=>1,
     'beginthebibliography'=>1,'beginlrbox'=>1,
# be used as is; if it is 1, the filetype .tex will be added if the
    $blankline++;
    $blankline=0;
    $blankline=-1;
body {width:auto;padding:5;margin:5;}
bold and in HTML output caption text is italicised.
### Break points
    %BreakPoints=%{$BreakPointsOptions{'default'}};
    %BreakPoints=%{$option};
$BreakPointsOptions{'chapter'}={%{$BreakPointsOptions{'part'}},'\chapter'=>'Chapter'};
$BreakPointsOptions{'default'}=$BreakPointsOptions{'subsection'};
$BreakPointsOptions{'none'}={};
$BreakPointsOptions{'part'}={%{$BreakPointsOptions{'none'}},'\part'=>'Part'};
$BreakPointsOptions{'section'}={%{$BreakPointsOptions{'chapter'}},'\section'=>'Section'};
$BreakPointsOptions{'subsection'}={%{$BreakPointsOptions{'section'}},'\subsection'=>'Subsection'};
  -brief        Only prints a brief, one line summary of counts
     'center'=>1,'flushleft'=>1,'flushright'=>1,
                chapter, section or subsection. Default (-sub) is set
  -ch, -chinese, -zhongwen  Turns on support for Chinese characters.
  Check_Arguments(@args);
# Checks arguments, exits on exit condition
     '\cite'=>1, '\citep'=>1, '\citet'=>1, '\citeauthor'=>1, '\citealt'=>1, '\nocite'=>1,
     '\cline'=>1, '\multicolumn'=>3,'\typeout'=>1, '\typein'=>1,
  close(FH);
  Close_Output();
# Close the output, e.g. adding HTML tail
# CMD specific global variables
###### CMD specific implementations
      " (".${$cnt}[4]."/".${$cnt}[5]."/".${$cnt}[6]."/".${$cnt}[7].") ".
  -codes        Display output style code overview and explanation.
colour coded. Counted text is coloured blue with headers are in
  ($colour=$STYLE{$style}) || return;
.command {color: #c00;}
            'command'=>'green','exclcommand'=>'yellow','exclgroup'=>'yellow','exclmath'=>'yellow',
.comment {color: #999; font-style: italic;}
    $comment=" .... ".$comment;
    $comment="&nbsp;&nbsp;....&nbsp;&nbsp;".$comment;
    conditional_print_help_style()
    conditional_print_help_style();
    conditional_print_total($totalcount);
Copyright 2008 Einar Andreas R
  ${$count->{'count'}}[$type]+=$value;
counted.
counted separately with separate counts for inlined formulae
    # Count float
###### Count handling routines
    # count item, exclude contents
### Count labels
  	# count macro as word (or a given number of words)
  $countsum->{'subcounts'}=\@countlist;
Count words in TeX and LaTeX files, ignoring macros, tables,
  (defined ($next=get_token($tex,'[\"\'\`:\.,\(\)\[\]!\+\-\*=/\^\_\@\<\>\~\#\&]',2))) && return $next;
  (defined ($next=get_token($tex,'\\\\[\{\}]',2))) && return $next;
  (defined ($next=get_token($tex,'[\{\}]',4))) && return $next;
  (defined ($next=get_token($tex,'[\[\]]',5))) && return $next;
  (defined ($next=get_token($tex,'\$',6))) && return $next;
  (defined ($next=get_token($tex,'\$\$',6))) && return $next;
  (defined ($next=get_token($tex,'.',999))) && return $next;
  (defined ($next=get_token($tex,'\\\\([a-zA-Z_]+|[^a-zA-Z_])',3))) && return $next;
    (defined ($next=get_token($tex,$pattern,1))) && return $next;
  (defined ($next=get_token($tex,'\%[^\r\n]*',0))) && return $next;
  (defined ($next=get_token($tex,'(\r|\n|\r\n)',9))) && return $next;
  (defined ($next=get_token($tex,'[^\s]+',999))) && return $next;
  (defined ($next=get_token($tex,'\%+TC:[^\r\n]*',666))) && return $next;
  (defined ($next=get_token($tex,'\%+TC:\s*endignore\b[^\r\n]*',666))) && return "%TC:endignore";
  defined ($substat=$TeXgroup{$1}) || ($substat=$status);
# Definition of different print styles: maps of class labels
# Definition of macros that define break points that start a new subcount.
     'description'=>1,'enumerate'=>1,'itemize'=>1,'list'=>1,
  -dir, -dir=   Specify the working directory using -dir=path.
                -dir is used, the directory of the parent file is used.
                #displayed formulae) are summed. The default sum (if
dland (2008)
dland being the current maintainer.
dl.count {background: #cfc; color: 009;}
dl.count dd.briefcount {font-weight: 700; clear: both; font-size:80%; font-weight:normal; margin-left:8pt;}
dl.count dd {font-weight: bold;}
dl.count dt {clear: both; float: left; margin-right: .5em;}
dl.count dt.header {font-weight: bold; font-style: italic; float: none;}
     '\documentclass'=>1,'\documentstyle'=>1,'\usepackage'=>1, '\hyphenation'=>1,
# Each macro is assumed to gobble up a given number of
                each of the counts (text words, header words, caption
                e.g. Korean text. Note that the TeX file must be save
                either words or macros.
    } else {
  } else {
    else {print_error("Warning: Unknown TC command: ".$instr);}
  else {print ": ".$header;}
  else {return 0;}
  else {$title="Word count";}
    elsif ($addsuffix==1 && ($fname=~/^[^\.]+$/)) {$fname.='.tex';}
  elsif ($arg=~/^-(ch|chinese|zhongwen)$/) {
  } elsif ($arg=~/^(\d+(,\d+){0,6})$/) {
  elsif ($arg=~/^-dir=(.*)$/) {$globalworkdir=$1;}
  elsif ($arg eq '-1') {$briefsum=1;$totalflag=1;$verbose=-1;}
  elsif ($arg eq '-codes') {
  elsif ($arg eq '-dir') {$globalworkdir=undef;}
  elsif ($arg eq "-htmlcore" ) {option_no_colours();$htmlstyle = 1;}
  elsif ($arg eq "-html" ) {option_no_colours();$htmlstyle = 2;}
  elsif ($arg eq '-nocodes') {$showcodes=0;}
  elsif ($arg eq '-noinc') {$includeTeX=0;}
  elsif ($arg eq '-relaxed') {
  elsif ($arg eq '-total') {$totalflag=1;}
  elsif ($arg eq "-v1") {$verbose=1;}
  elsif ($arg eq '-vv' || $arg eq '-v2') {$verbose=2;}
  elsif ($arg eq '-vvv' || $arg eq '-v3' || $arg eq '-v') {$verbose=3;}
  elsif ($arg eq '-vvvv' || $arg eq '-v4') {$verbose=3; $showstates=1;}
  elsif ($arg=~/^-(jp|japanese)$/) {
  elsif ($arg=~/^\-(nocol|nc$)/) {option_no_colours();}
  elsif ($arg =~ /^-(q|-?quiet)$/ ) {$verbose=-1;}
  } elsif ($args[0]=~/^(\-?\-(h|\?|help)|\/(\?|h))$/) {
  } elsif ($args[0]=~/^\-?\-(lic|license)$/) {
  } elsif ($args[0]=~/^\-?\-(ver|version)$/) {
  elsif ($arg =~ /^\-showstates?$/ ) {$showstates=1;}
  elsif ($arg=~/^-(sub|subcounts?)(=(.+))?$/) {option_subcount($3);}
  elsif ($arg=~/^-(utf8|unicode)$/) {$utf8flag=1;}
  } elsif ($briefsum) {
  elsif (defined $filename) {$title="FILE: ".$filename;}
  } elsif (defined (my $addsuffix=$TeXfileinclude{$next})) {
    } elsif (!defined $next) {
  } elsif (defined ($substat=$TeXmacro{$next})) {
  } elsif (defined ($substat=$TeXmacroword{$next})) {
  } elsif ($filename=~/^(.*[\\\/])[^\\\/]+$/) {
    elsif ($instr eq 'breakmacro') {$BreakPoints{$macro}=$param;}
    elsif ($instr eq 'fileinclude') {$TeXfileinclude{$macro}=$param;}
    elsif ($instr eq 'floatinclude') {$TeXfloatinc{$macro}=$param;}
    elsif ($instr eq 'group') {
    elsif ($instr eq 'header') {$TeXheader{$macro}=$param;$TeXmacro{$macro}=$param;}
  } elsif ($instr eq 'ignore') {
    elsif ($instr eq 'macroword') {$TeXmacroword{$macro}=$param;}
    elsif ($instr eq 'preambleinclude') {$TeXpreamble{$macro}=$param;}
  } elsif (my $option=$BreakPointsOptions{$arg}) {
    } elsif ($next eq '{') {
    } elsif ($next eq '$') {
    } elsif ($next eq '$$') {
  } elsif ($next eq '\(') {
  } elsif ($next eq '\[') {
  } elsif ($next eq '\def') {
  } elsif ($next =~ /^\\[^\w\_]/) {
  } elsif ($next=~/^([\\]*\w+)\s+([^\s\n]+)(\s+([0-9]+))?/) {
  } elsif (ref($status) eq 'ARRAY') {
  } elsif ($status<0) {
  } elsif (($status==-1) && ($substat=$TeXfloatinc{$next})) {
  } elsif ($status==-9 && defined ($substat=$TeXpreamble{$next})) {
    } elsif ($tex->{'type'}==1) {
    } elsif ($tex->{'type'}==3) {
    } elsif ($tex->{'type'}==3 && $status==-3) {
    } elsif ($tex->{'type'}==666) {
    } elsif ($type==9) {
      # end of unit
ensure that words in the text has been interpreted as such,
  $ENV{'ANSI_COLORS_DISABLED'} = 1;
     '\eqlabel'=>1, '\eqref'=>1,'\hspace'=>1, '\vspace'=>1, '\addvspace'=>1,
# equivalent to specifying an array [0,...,0] of N zeros.
  $errorcount++;
.error {font-weight:bold;color:#f00;font-style:italic;}
.exclcommand {color: #f99;}
.exclgroup {color:#c66;}
.exclmath {color: #6c6;}
      exit;
    exit;
explicitly recognized as text or mathematics.
     'figure'=>-1,'float'=>-1,'picture'=>-1,'table'=>-1,
.filegroup {background: #efe; margin-bottom: 8pt;}
        file include, add .tex if rule=2, not if rule=0
            'fileinclude'=>'bold green'};
.fileinclude {color: #696; font-weight:bold;}
  @filelist=($file);
# filename is without filetype; if it is 2, the filetype .tex will be added.
  # files, text words, header words, float words,
  # find group status (or leave unchanged)
    flush_next($tex);
  flush_next($tex);
    flush_style($tex,$localstyle);
  flush_style($tex,$localstyle);
     '\footnote'=>[3],'\label'=>1, '\ref'=>1, '\pageref'=>1, '\bibitem'=>1,
  foreach my $arg (@ARGV) {
  foreach my $f (@filelist) {
  foreach my $pattern (@MacroOptionPatterns) {
  foreach my $pattern (@WordPatterns) {
    foreach my $subcount (@{$subcounts}) {
  foreach (@WordPatterns) {
# For macros not specified here, the default value is 0: i.e.
    formatprint($countlabel[0].': ','dt');
    formatprint($countlabel[$i].': ','dt');
    formatprint("File: ".$filename."\n",'h2');
      formatprint("File not found or not readable: ".$f."\n","p","error");
  formatprint("Format/colour codes of verbose output:","h2");
    formatprint(get_count($count,0)."\n",'dd');
    formatprint(get_count($count,$i)."\n",'dd');
    formatprint($header."\n",'dt','header');
    formatprint("Subcounts: text+headers+captions (#headers/#floats/#inlines/#displayed)\n",'dt');
    formatprint('Sum count: ','dt');
    formatprint(total_count($count)."\n",'dd');
        formatprint("Total word count",'h2');
    # Format = TC:word macro
For more information about the script, e.g. news, updates, help,
formulae, etc.
  for my $file (<@filelist>) {
  for (my $i=0;$i<8;$i++) {
  for (my $i=1;$i<8;$i++) {
  for (my $i=scalar(@sumweights);$i-->0;) {
  for (my $j=0;$j<$i;$j++) {
    $fpath=~s/^((.*[\\\/])?)[^\\\/]+$/$1/;
# Global variables
    # gobble group type
      gobble_macro_parms($tex,1);
      gobble_macro_parms($tex,$substat);
    gobble_macro_parms($tex,$substat);
    gobble_macro_parms($tex,$substat,1);
    gobble_macro_parms($tex,$substat,$status);
    gobble_options($tex);
  gobble_options($tex);
      gobble_option($tex);
    gobble_option($tex);
  gobble_option($tex);
.grouping, .document {color: #900; font-weight:bold;}
            'grouping'=>'red','document'=>'red','mathgroup'=>'magenta',
    $groupname=$1;
groups have been correctly interpreted.
# Groups that are not defined will be counted as the surrounding text.
<h1>LaTeX word count</h1>
      $header;
        header macro rule, as macro but counts as one header
  # headers, floats, math-inline, math-display;
headers/titles or words in floats (figure/table captions).
###### Help routines
  help_style_line('\begin{group}  \end{group}',"exclgroup","begin/end group in excluded region");
  help_style_line('\begin{group}  \end{group}',"grouping","begin/end group");
  help_style_line('Caption text and footnotes',"word3","counted as caption words");
  help_style_line('% Comments',"comment","not counted");
  help_style_line('\documentclass',"document","document start, beginning of preamble");
  help_style_line("ERROR","error","TeXcount error message");
  help_style_line('$  $',"exclmath","equation in excluded region");
  help_style_line("File to include","fileinclude","not counted but file may be counted later");
  help_style_line('Header and title text',"word2","counted as header words");
  help_style_line("Ignored text or code","ignore","excluded or ignored");
  help_style_line('\macro',"command","macro not counted, but parameters may be");
  help_style_line('\macro',"exclcommand","macro in excluded region");
  help_style_line("[Macro options]","option","not counted");
  help_style_line('$  $',"mathgroup","counted as one equation");
    help_style_line('[state]',"state","internal TeXcount state");
    help_style_line('[sumcount]',"sumcount","cumulative sum count");
  help_style_line('%TC:TeXcount instructions',"tc","not counted");
  help_style_line('Text which is counted',"word1","counted as text words");
here to describe anything defined in a begin-end group unless
  -h, -?, --help, /?   Help
### How many tokens to gobble after macro
  -htmlcore     Only HTML body contents
  -html         Output in HTML format
###### HTML routines
    html_tail();
    http://folk.uio.no/einarro/Comp/texwordcount.html
    http://folk.uio.no/einarro/Services/texcount.html
    http://www.latex-project.org/lppl.txt
# Identified as begin-end groups, and define =>state. The
                i.e. allows more general cases to be counted as
(i.e. \macro{...}) are counted or ignored depending on the
    if ($addsuffix==2) {$fname.='.tex';}
    if ($arg=~/^\-/) {
  if ($arg eq '-brief') {$briefsum=1;}
  if ($arg eq '-inc') {$includeTeX=1;}
  if ($arg eq "-v0") {$verbose=0;}
  if (!@args) {
  if ($arg=~/^-sum(=(.+))?$/) {option_sum($2);}
  if ($blank>$blankline) {
  if ($break) {print "\n";}
  if ($briefsum && @sumweights) {
  if ($briefsum && $totalflag) {print " ";}
    if ($class) {print " class='".$class."'";}
  if (($colour) && !($colour eq '-')) {
  if (!defined $arg) {
    if (defined $end) {
      if (!(defined $end && $end eq '$')) {
    if ((defined $end) && ($end eq $next)) {
    if (!defined $end) {return;}
  if (!defined $filename) {
  if (defined $header) {
  if (!defined $header) {$header="";}
  if (!defined $header) {$header=$count->{'title'};}
    if (defined (my $substat=$TeXmacro{$next})) {
  if (!defined $old) {return $substat;}
  if (!defined $regexp) {print_error("ERROR in get_token: undefined regex.");}
  if (!defined $status) {
    if (!defined $tex) {
  	if (defined $TeXheader{$next}) {inc_count($tex,4);}
  if (!defined $tex->{'line'}) {print_error("ERROR in get_token: undefined tex-line. ".$tex->{'next'});}
  if (defined $tex->{'next'}) {
  if (defined $tex->{'next'}) {print_style($tex->{'next'}.' ',$tex->{'style'});}
    if ((defined $tex) && @sumweights) {
  if (defined $title) {}
  if (!defined $value) {$value=1;}
  if (!defined $workdir) {
  if ($errorcount==0) {return;}
  if (get_count($count,0)>1) {
      if ($htmlstyle) {
  if ($htmlstyle) {
  if ($htmlstyle>1) {
  if ($htmlstyle>1) {html_head();}
  if ($htmlstyle && defined $tag) {
  if ($htmlstyle) {print "<br>\n";} else {print "\n";}
      if ($htmlstyle) {print "</dd>";}
      if ($htmlstyle) {print "<dd class='briefcount'>";}
  if ($htmlstyle) {print "</div>\n\n";}
  if ($htmlstyle) {print "<dl class='count'>\n";}
  if ($htmlstyle) {print "</dl>\n";}
  if ($htmlstyle) {print "\n<div class='filegroup'>\n";}
  if ($htmlstyle) {print "</p>";}
    if ($htmlstyle) {print "<p class='briefcount'>";}
  if ($htmlstyle) {print "<p class='count'>".$header;}
  if ($htmlstyle) {print "<p class='stylehelp'>";}
    if ($htmlstyle) {print "</p>\n";}
  if ($htmlstyle) {print "</p>\n";}
  if ($htmlstyle && $verbose) {print "<p class=parse>\n";}
  if ($htmlstyle && $verbose) {print "</p>\n";}
  if ($i>0) {gobble_macro_modifier($tex);}
    if ($includeTeX) {add_file_to_list($fname);}
  if ($instr=~/^(break)$/) {
    if ($instr eq 'break') {add_subcount($tex,$next);}
    if (($instr eq 'macro') || ($instr eq 'exclude')) {$TeXmacro{$macro}=$param;}
  if (my $label=$BreakPoints{$next}) {
  if ($next eq '\begin' && $status!=-2) {
    if ($next eq '\documentclass') {
  if (!($next=~s/^\%+TC:\s*(\w+)\s*// )) {
  if ($old==0 || $substat==0) {return 0;}
  if ($old==-2 || $substat==-2) {return -2;}
  if ($old==-3 || $substat==-3) {return -3;}
  if ($old==-9 || $substat==-9) {return -9;}
  if ($old>$substat) {return $old;}
    if ($param=~/^\[([0-9,]+)\]$/) {$param=[split(',',$1)];}
    if (Parse_Option($arg)) {next;}
  if (print_style($text,$style)) {
  if (ref($parm) eq 'ARRAY') {
  if (scalar(@toplevelfiles)==0) {
  if ($showcodes) {print_help_style();}
  if ($showstates) {
  if ($showsubcounts && defined $subcounts && scalar(@{$subcounts})>1) {
    if ($state) {
      if ($status>0) {
  if ($status>0) {
  if ($status>0 and $substat>3) {
  if ($status>0) {inc_count($tex,$substat);}
  if ($status<=0 && $status<$substat) {$substat=$status;}
  if (($status>0) && ($substat==-1)) {
    if ($status==-9 && $next eq '\begin' && $tex->{'line'}=~/^\{\s*document\s*\}/) {
  if (@sumweights) {
  if ($tex->{'line'} =~ s/^\*//) {
    if ($tex->{'line'}=~s/^($pattern)//) {
  if ( $tex->{'line'} =~ s/^($regexp)[ \t\r\f]*// ) {
    if ($tex->{'line'}=~ /^[*]?(\s*\[.*?\])*\s*\{(.+?)\}/ ) {
  if ($tex->{'line'} =~ s/^\{\s*([^\{\}]+)\s*\}[ \t\r\f]*//) {
  if ($tex->{'line'} =~ s/^\{\s*([^\{\}]+)\s*\*?\}[ \t\r\f]*//) {
  if (!(($tex->{'style'}) && ($tex->{'style'} eq '-'))) {$tex->{'style'}=$style;}
      if (!$totalflag) {
    if ($totalflag && $briefsum && @sumweights) {
  if ($totalflag || get_count($sumcount,0)>1) {
    if ($type==0) {
  if ($utf8flag) {
  if ($utf8flag) {binmode STDOUT,':utf8';}
  #if ($utf8flag || $htmlstyle) {utf8::encode($text);}
  if ($verbose>=0) {
  if ($verbose>0) {
      if ($verbose>0) {line_return(1,$tex);}
  if ($verbose<=0) {return;}
    if ($verbose==0) {$verbose=3;}
  	# ignore
.ignore {color: #999;}
            'ignore'=>'cyan'};
ignored and treated as \'floats\', though some (e.g. center) are
    # ignore \def...
  inc_count(\%TeX,0);
    inc_count($tex,5);
        inc_count($tex,$status);
    inc_count($tex,$status,$substat);
    inc_count($tex,$substat);
  -inc          Include tex files included in the document
  	# include file: queue up for parsing
indicating how the text has been interpreted. Check this to
### In floats: include only specific macros
     '\input'=>1, '\include'=>1, '\includeonly'=>1,'\includegraphics'=>1,
in the LaTeX files on the format
                in UTF-8 format (not e.g. GB2312 or Big5), or the
    $i=$parm;
                is automatic with -chinese, and is required to handle
    $i=scalar @{$parm};
# {...} is counted as header. The =>[2] indicates transition to
# is not clear if they will be in inlined or displayed math.
                is the number one, not the letter L.)
is [#,#,...,#] with one number for each parameter, and main rules
  -jp, -japanese Turns on support for Japanese characters. TeXcount
      $label=$label.': '.$2;
# Labels used to describe the counts
    $latexcode =~ s/^\x{feff}//;
    $LetterPattern=$LetterPatternRelaxed;
  --license     License information
License (LPPL)
    linebreak();
                line of output. If used in conjunction with -sum, the
    line_return(1);
# List of regexp patterns that should be analysed as words.
# List of regexp patterns to be gobbled as macro option in and after
macro, but by default counted. Begin-end groups are by default
      # macro call
        macro causing subcount break point
        macro counted as a given number of words
    # macro: exclude options
        macro handling rule, no. of and rules for parameters
    @MacroOptionPatterns=@MacroOptionPatternsRelaxed;
### Macro option regexp list
Macro options (i.e. \marco[...]) are ignored; macro parameters
### Macros for headers
### Macros for including tex files
### Macros that are counted within the preamble
# Macros that identify headers: i.e. following token or
# Macros that represent text may be declared here. The value gives
### Macros that should be counted as one or more words
# Macros used to identify caption text within floats.
MAIN(@ARGV);
# MAIN ROUTINE: Handle arguments, then parse files
######### Main routines
###### Main script
# Make TeXcode handle
     'math'=>6,'displaymath'=>7,'equation'=>7,'eqnarray'=>7,'align'=>7,
    # math display
      # math display (unless already in inlined math)
Mathematical formulae are not counted as words, but are instead
.mathgroup {color: #090;}
      # math inline
    # math inline
  my ($a,$b)=@_;
  my @args=@_;
  my $arg=shift @_;
my $blankline=0;
  my ($blank,$tex)=@_;
my %BreakPoints=%{$BreakPointsOptions{'none'}};
my %BreakPointsOptions;
  my $break=($text=~s/\n$//);
my $briefsum=0;
  my @cnt=(0,0,0,0,0,0,0,0);
  my $cnt=$count->{'count'};
  my $colour;
  my ($count)=@_;
  my %count=('count'=>\@cnt,'title'=>$title);
  my ($count,$header)=@_;
  my ($count,$header)=print_count_with_header(@_);
my @countlabel=('Files','Words in text','Words in headers',
  my @countlist=();
  my $count=new_count("_top_");
  my $countsum=new_count($title);
  my $count=$tex->{'count'};
  my ($count,$type)=@_;
my $errorcount=0;
      my $filecount=add_subcount($tex);
  my @filelist=@_;
my @filelist;
  my $filename=shift @_;
  my $file=read_file($filename) || return undef;
  my @files;
  my $file=shift @_;
  my $filetotalcount=new_count("SUM COUNT FOR ".$file);
    my $filetotalcount=parse_file($file);
    my $fname=$1;
  my $fname=shift @_;
    my $fpath=$f;
my $globalworkdir="";
  my $groupname;
my $htmlstyle=0;
  my $i;
my $includeTeX=0;
  my $instr=$1;
  my $latexcode=join('',@text);
my $LetterPatternRelaxed='([\w\-\']|'.$modifiedchars.'|'.$specialchars.'(\{\})?|\{'.$specialchars.'\}|\{\w\})';
my $LetterPattern='\w';
  my $listtotalcount=new_count("TOTAL COUNT");
  my $localstyle=$status>0 ? 'grouping' : 'exclgroup';
  my $localstyle=$status>0 ? 'mathgroup' : 'exclmath';
    my $macro=$1;
my @MacroOptionPatternsRelaxed=('\[[^\[\]\n]*\]');
my @MacroOptionPatterns=('\[(\w|[,\-\s\~\.\:\;\+\?\*\_\=])*\]');
my $modifiedchars='\\\\[\'\"\`\~\^\=](\w|\{\w\})';
my %NamedWordPattern;
  my $next;
    my $next='begin'.$1;
  my $next=$tex->{'next'};
  my ($next,$type);
      my $num=total_count($tex->{'count'});
    my $option=$4;
    my $param=$2;
my $showcodes=1;
my $showstates=0;
my $showsubcounts=0;
my $specialchars='\\\\(ae|AE|o|O|aa|AA)';
my %STYLE;
my @STYLES=();
  my $subcounts=$count->{'subcounts'};
  my $substat;
  my ($substat,$old)=@_;
  my $sum=0;
  my $sumcount=shift @_;
my @sumweights;
  my ($tex)=@_;
  my %TeX=();
  my ($texcode,$filename,$title)=@_;
my %TeXfileinclude=('\input'=>1,'\include'=>2);
my %TeXfloatinc=('\caption'=>[3]);
my %TeXgroup=('document'=>1,'letter'=>1,'titlepage'=>0,
my %TeXheader=('\title'=>[2],'\part'=>[2],'\chapter'=>[2],
my %TeXmacro=(%TeXheader,
my %TeXmacroword=('\LaTeX'=>1,'\TeX'=>1);
  my ($tex,$next,$status,$substat)=@_;
  my ($tex,$parm,$oldstat)=@_;
my %TeXpreamble=('\title'=>[2],
  my ($tex,$regexp,$type)=@_;
  my $tex=shift @_;
  my ($tex,$status)=@_;
  my ($tex,$status,$addsuffix)=@_;
  my ($tex,$status,$end)=@_;
  my ($tex,$status,$substat,$end)=@_;
  my ($tex,$style)=@_;
    my $tex=TeXfile($f);
  my @text=<FH>;
  my ($tex,$title)=@_;
  my $text=shift @_;
  my ($text,$style,$colour)=@_;
  my ($text,$style,$comment)=@_;
  my ($text,$style,$state)=@_;
  my ($text,$tag,$class)=@_;
  my ($tex,$type,$value)=@_;
  my ($title)=@_;
  my @toplevelfiles=Parse_Arguments(@args);
    my $totalcount=parse_file_list(@toplevelfiles);
my $totalflag=0;
my $utf8flag=0;
my $verbose=0;
my $versiondate="2009 Apr 30";
my $versionnumber="2.2";
my @WordPatterns=('(@+\.)+@+\.?','@+([\-\']@+)*');
my $workdir;
$NamedWordPattern{'chinese'}='\p{script=Han}';
$NamedWordPattern{'japanese'}='(\p{script=Han}|\p{script=Hiragana}|\p{script=Katakana})';
name or use other technical means to avoid confusion.
  -nc, -nocol   No colours (colours require ANSI)
     '\newcommand'=>[-3,-3],'\renewcommand'=>[-3,-3],
     '\newenvironment'=>[-3,-3,-3], 'renewenvironment'=>[-3,-3,-3],
     '\newfont'=>2,'\newtheorem'=>2,'\bibliographystyle'=>1, '\bibliography'=>1,
     '\newlength'=>1, '\setlength'=>2, '\addtolength'=>2,'\settodepth'=>2,
     '\newsavebox'=>1, '\sbox'=>1, '\savebox'=>2, '\usebox'=>1,'\rule'=>2,
# N is the number of tokens to be read with the macro and the
  -nocodes      Do not display output style code overview. 
  -noinc        Do not include included tex files (default)
# Note that only the first unit (token or {...} block) is counted.
# Note that some environments may only exist within math-mode, and
# no tokens are excluded, but [...] options are. Header macros
      'Number of math inlines','Number of math displayed');
# of headers is incremented by one.
# only role of defining it here is that the counter for the number
                only -sum is used) is the same as -sum=1,1,1,0,0,1,1.
    open(FH,"<".$filename) || return undef;
    open(FH,"<:utf8",$filename) || return undef;
.option {color: #cc0;}
###### Option handling
                option name is -subcount.)
Options:
# Options and states
options or the output will be riddled with colour codes. Instead,
# (or beginNAME for begin-end groups without the backslash)
or errors can be reported to einarro@ifi.uio.no.
or go to
# or to an array (specified as [num,num,...]) of length N where
                output will only be the total number. (NB: Character
     '\pagestyle'=>1,'\thispagestyle'=>1, '\pagenumbering'=>1,'\markboth'=>1, '\markright'=>1,
               '\paragraph'=>[2],'\subparagraph'=>[2]);
     '\parbox'=>1, '\marginpar'=>[3],'\makebox'=>0, '\raisebox'=>1, '\framebox'=>0,
    $parm=[0,0,0,0,0,0,0,0,0];
 	parse_begin_end($tex,$status);
.parse {border-bottom:none;}
.parse, .count, .stylehelp, .filegroup {border: solid 1px #999; margin: 0pt; padding: 4pt;}
# Parse file and included files, and return total count
# Parse file list and return total count
.parse {font-size: 80%; background: #eef;}
  	parse_include_file($tex,$status,$addsuffix);
# Parse individual option parameters
# Parse LaTeX document
      parse_macro($tex,$next,$status,$substat);
      parse_math($tex,$status,6,'$');
    parse_math($tex,$status,6,'\)');
        parse_math($tex,$status,7,'$$');
    parse_math($tex,$status,7,'\]');
    # parse next token; or tokens until match with $end
# Parse one block or unit
  || parse_options_format($arg)
  || parse_options_output($arg)
  || parse_options_sums($arg)
  	# parse preamble include macros
# Parses arguments, sets options (global) and returns file list
      # parse TC instructions
      parse_tc($tex);
      parse($tex);
  parse_unit($tex,0,$end);
    parse_unit($tex,1);
    parse_unit($tex,-2);
  parse_unit($tex,-3,"%TC:endignore");
       parse_unit($tex,-9);
    parse_unit($tex,new_status($parm->[$j],$oldstat));
      parse_unit($tex,$status,'}');
  parse_unit($tex,$substat,'\end');
Parsing instructions may be passed to TeXcount using comments
###### Parsing routines
  print '
  print '</body></html>';
  print ${$cnt}[1]."+".${$cnt}[2]."+".${$cnt}[3].
    print $comment;
    print_count_brief($count,$header);
      print_count_brief($subcount);
    print_count_details($count,$header);
        print_count($filecount);
      print_count($sumcount);
    print_count_total($count,$header);
# Print count (total) if conditions are met
    print_error("CRITICAL ERROR: Invalid parser status!");
    print_error("CRITICAL ERROR: Undefined parser status!");
      print_error("ERROR: End of file while waiting for ".$end);
    print_error("Errors:".$errorcount,"p","error");
    || print_error("No files specified.","p","error");
    print "(errors:".$errorcount.")";
    print_error("Warning: BEGIN group without type.");
    print_error("Warning: END group without type while waiting to end ".$groupname.".");
    print_error("Warning: Invalid TC command format: ".$instr);
    print_error('Warning: TC command should have format %TC:instruction [macro] [parameters]');
    print_help();
  print "<html>\n<head>";
###### Printing routines
      print 'Invalid opton '.$arg."\n";
    print_license();
        print "\n";
      print "\n";
    print "\n<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">";
  print "\n\n";
# Print output style codes if conditions are met
    print_reference();
  print_reference();
    print "<span class='".$style."'>".$text."</span>";
      print STDERR "File not found or not readable: ".$f."\n";
    print STDERR "Warning: Option value ".$arg." not valid, ignoring option.\n";
    print STDERR "Warning: Option value ".$arg." not valid, using default instead.\n";
    print_style($1.' ','ignore');
    print_style('{'.$1.'}',$localstyle);
      print_style($1,'option');
    print_style($1,'option');
    print_style($&,'fileinclude');
    print_style($&,'ignored');
      print_style($next,'comment');
      print_style(" [".$num."]","sumcount");
### Print styles
      print_style($state,'state');
    print_style($tex->{'next'}.' ',$tex->{'style'},$tex->{'printstate'});
    print_style("!!!  ".$text."  !!!",'error');
      print_syntax();
    print_syntax();
  print_syntax();
    print '<'.$tag;
    print Term::ANSIColor::colored($text,$colour);
  print 'TeXcount version '.$versionnumber.'
  print "TeXcount version ".$versionnumber.", ".$versiondate.'.';
    print $text;
    print '>'.$text.'</'.$tag.'>';
  print total_count($count);
      print total_count($sumcount);
    print_version();
    print_with_style($text,$style,$colour);
  push @filelist,$workdir.$fname;
    push @files,$arg;
  push @{$tex->{'countlist'}},$tex->{'count'};
  -q, -quiet    Quiet mode, no error messages (use is discouraged!)
  -relaxed      Uses relaxed rules for word and option handling:
                Remember that the path must end with \ or /. If only
  Report_ErrorCount();
# Report if there were any errors occurring during parsing
                result will be unpredictable.
      return;
    return;
    return 0;
      return $1;
    return $1;
    return 1;
  return 1;
  return \%count;
  return ${$count->{'count'}}[$type];
  return $count,$header;
  return @files;
  return $filetotalcount;
  return $latexcode;
  return $listtotalcount;
      return $next;
  return $next;
  return parse_options_parsing($arg)
  return $showcodes;
  return $substat;
  return $sum;
  return \%TeX;
  return TeXcode($file,$filename);
  return $tex->{'countsum'};
  return undef;
               '\section'=>[2],'\subsection'=>[2],'\subsubsection'=>[2],
See the documentation for more details.
set at the start of the document (applies globally), are:
###### Set CMD specific settings and variables
###### Set global settings and variables
setlocale(LC_CTYPE,"no_NO");
    set_style($tex,'command');
      set_style($tex,'document');
      set_style($tex,'ignore');
    set_style($tex,"ignore");
  set_style($tex,'ignore');
  set_style($tex,$localstyle);
  set_style($tex,$status>0?'command':'exclcommand');
  set_style($tex,$style);
  set_style($tex,'tc');
        set_style($tex,'word'.$status);
    set_style($tex,'word'.$status);
     '\settoheight'=>2, '\settowidth'=>2,'\newcounter'=>1, '\setcounter'=>2,
    $showcodes=2;
  -showstate    Show internal states (with verbose)
  $showsubcounts=1;
    s/\@/$LetterPattern/g;
# specified in %TeXheader are automatically included here.
      # starts preamble
# state 2 which is used within headers (although the value is
.state {color: #990; font-size: 70%;}
            'state'=>'cyan underline','sumcount'=>'yellow'};
# states used corresponds to the elements of the count array, and
  # Status:
      $status=1;
</style>
.stylehelp {font-size: 80%; background: #ffc; margin-bottom: 8pt;}
$STYLES[0]={'error'=>'bold red'};
$STYLES[1]={%{$STYLES[0]},
$STYLES[2]={%{$STYLES[1]},
$STYLES[3]={%{$STYLES[2]},
$STYLES[4]={%{$STYLES[3]}};
  %STYLE=%{$STYLES[$verbose]};
sub add_count {
sub add_file_to_list {
sub add_subcount {
sub Apply_Options {
sub Check_Arguments {
sub Close_Output {
sub conditional_print_help_style {
sub conditional_print_total {
sub flush_next {
sub flush_style {
sub formatprint {
sub get_count {
sub get_next_token {
sub get_token {
sub gobble_macro_modifier {
sub gobble_macro_parms {
sub gobble_option {
sub gobble_options {
sub help_style_line {
sub html_head {
sub html_tail {
sub inc_count {
sub linebreak {
sub line_return {
sub MAIN {
sub new_count {
sub new_status {
sub next_token {
sub option_no_colours {
sub option_subcount {
sub option_sum {
sub parse {
sub Parse_Arguments {
sub parse_begin_end {
sub parse_file {
sub parse_file_list {
sub parse_include_file {
sub parse_macro {
sub parse_math {
sub Parse_Option {
sub parse_options_format {
sub parse_options_output {
sub parse_options_parsing {
sub parse_options_sums {
sub parse_tc {
sub parse_unit {
sub print_count {
sub print_count_brief {
sub print_count_details {
sub print_count_total {
sub print_count_with_header {
sub print_error {
sub print_help {
sub print_help_style {
sub print_license {
sub print_reference {
sub print_style {
sub print_syntax {
sub print_version {
sub print_with_style {
sub read_file {
sub Report_ErrorCount {
###### Subroutines
sub set_style {
    $substat=0;
  -sub, -sub=   Generate subcounts. Option values are none, part,
sub tc_ignore_input {
sub TeXcode {
sub TeXfile {
sub total_count {
.sumcount {color: #999; font-size: 80%;}
    $sum+=get_count($count,$i+1)*$sumweights[$i];
  -sum, -sum=   Make sum of all word and equation counts. May also
    @sumweights=(1,1,1,0,0,1,1);
    @sumweights=split(',',$1);
Syntax: TeXcount.pl [options] files
     'tabbing'=>0,'tabular'=>0,'thebibliography'=>0,'lrbox'=>0);
            'tc'=>'bold yellow','comment'=>'yellow','option'=>'yellow',
  %TC:breakmacro [macro] [label]
  %TC:break [title]    add subcount break point here
.tc {color: #999; font-weight:bold;}
  %TC:endignore        end block to ignore
  %TC:fileinclue [macro] [rule]
  %TC:floatinclude [macro] [param.states]
  %TC:group [name] [parsing-state]
  %TC:header [macro] [param.states]
    tc_ignore_input($tex);
  %TC:ignore           start block to ignore
  %TC:instruction arguments
  %TC:macro [macro] [param.states]
  %TC:macroword [macro] [number]
  %TC:preambleinclude [macro] [param.states]
###### TeX code handle
  $TeX{'count'}=$count;
  $TeX{'countlist'}=\@countlist;
  $tex->{'count'}=new_count($title);
*   TeXcount.pl '.$versionnumber.', '.$versiondate.'
  $TeX{'countsum'}=$countsum;
                TeXcount will then count each Chinese character as a
  $TeX{'eof'}=0;
  $tex->{'eof'}=1;
  $TeX{'filename'}=$filename;
    $TeX{'filepath'}='';
    $TeX{'filepath'}=$1;
      $TeXgroup{$macro}=$option;
    $tex->{'line'} =~ s/^([^\{]*)\{/\{/;
  $tex->{'line'} =~ s/^\{([^\{\}\s]+)\}// ||
    $tex->{'line'} =~ s/^\s*([^\{\}\%\\\s]+)// ||
  $TeX{'line'}=$texcode;
      $TeXmacro{'begin'.$macro}=$param;
    $tex->{'next'}=$1;
  $TeX{'next'}=undef;
      $tex->{'printstate'}=':'.$status.':';
      $tex->{'printstate'}=':'.$status.':'.$end.':';
  $tex->{'printstate'}=undef;
  $TeX{'printstate'}=undef;
  $tex->{'style'}='-';
  $tex->{'style'}=undef;
  $TeX{'style'}=undef;
# Text and macros in the preamble is ignored unless specified here. The
    # text included from float
    $tex->{'type'}=$type;
  $TeX{'type'}=undef;
the number of \'floats\' are counted. Note that \'float\' is used
# the number of words the macro represents.
     'theorem'=>1,'lemma'=>1,'definition'=>1,'corollary'=>1,'example'=>1,
The [param.states] is used to indicate the number of parameters
# The preamble is the text between \documentclass and \begin{document}.
# therefore need not be defined here: in fact, they should not as it
the \'-r\' option makes less treat text formating codes properly.
The script counts words as either words in the text, words in
The script has LPPL status "maintained" with Einar Andreas
the script. However, if the script is modified, you must change its
The TeXcount script is copyright of Einar Andreas R
The TeXcount script is published under the LaTeX Project Public
# The values given are used as labels.
The verbose options (-v1, -v2, -v3, showstate) produces output
                This is on by default.
to access the script as a web service. Feedback such as problems
# to ANSI codes. Class labels are as used by HTML styles.
# to either an integer giving the number of tokens to ignore
  # Token (or token group) category:
# tokens (or {...} groups), as well as options [...] before, within
                to subsection, whereas unset is none. (Alternative
  -total        Do not give sums per file, only total sum.
    $type=$tex->{'type'};
Unix hint: Use \'less -r\' instead of just \'less\' to view output:
Unless -nocol (or -nc) has been specified, the output will be
usage tips, known issues and short-comings, go to
used by the macro and the rules of handling each of these: format
use Encode;
use locale;
use POSIX qw(locale_h);
use strict;
                use -sum=#[,#] with up to 7 numbers to indicate how
use Term::ANSIColor;
# Use @ to represent a letter, will be substituted with $LetterPattern.
use warnings;
#! /usr/bin/env perl
    $utf8flag=1;
  -utf8, -unicode  Turns on Unicode (UTF-8) for input and output. This
  -v0           Do not present parsing details
  -v1           Verbose: print parsed words, mark formulae
  -v2           More verbose: also print ignored text
  -v3           Even more verbose: include comments and options
  -v4           Same as -v3 -showstate
# value is the status (1=text, 2=header, etc.) they should be interpreted as.
# values: 0=ignore, 1=count, etc.). Thus specifying a number N is
  (($verbose>=0) && (defined $text) && (defined $style)) || return 0;
  --version     Print version number
view with your favourite browser.
  -v            Verbose (same as -v3)
.warning {color: #c00; font-weight: 700;}
whereas mathematical formulae and text/non-text in begin-end
where valid instructions for setting parsing rules, typically
which grants you, the user, the right to use, modify and distribute
which may be used anywhere are:
  while (defined (my $next=next_token($tex))) {
  while (defined ($next=get_next_token($tex))) {
  while (gobble_option(@_)) {}
      while (!($tex->{'eof'})) {
  while (!($tex->{'eof'})) {
                will count each Japanese character (kanji, hiragana,
Windows hint: If your Windows interprets ANSI colour codes, lucky
      # word
            'word1'=>'blue','word2'=>'bold blue','word3'=>'blue',
.word1,.word2,.word3 {color: #009;}
.word2 {font-weight: 700;}
.word3 {font-style: italic;}
                word. Automatically turns on -utf8.
    @WordPatterns=($NamedWordPattern{'chinese'},@WordPatterns);
    @WordPatterns=($NamedWordPattern{'japanese'},@WordPatterns);
### Word regexp pattern list
                word segmentation. Automatically turns on -utf8.
                words, #headers, #floats, #inlined formulae,
      'Words in float captions','Number of headers','Number of floats',
    $workdir=$file;
  $workdir=$globalworkdir;
    $workdir =~ s/^((.*[\\\/])?)[^\\\/]+$/$1/;
you can use -html to produce HTML code, write this to file and
you! Otherwise, use the -nocol (or -nc) option with the verbose
