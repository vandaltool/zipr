        }
        };
	            $., 0 + @data);
 1999 Roderick Schertler
 2002 Wichert Akkerman <wakkerma@debian.org>
 2006-2009 Guillem Jover <guillem@debian.org>
    # A directory field will be inserted just before the files field.
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
            $a->{Package} cmp $b->{Package}
    @ARGV >= 1 && @ARGV <= 3 or usageerr(_g("one to three arguments expected"));
	} @binary;
    # binary. Modify the maintainer if necessary.
    # binary packages it produces.
# but WITHOUT ANY WARRANTY; without even the implied warranty of
    $checksums->add_from_control($fields, use_files_for_md5 => 1);
    $checksums->add_from_file($file, key => $basename);
    $checksums->export_to_control($fields, use_files_for_md5 => 1);
    	chomp;
    close($comp_file);
    close FIND or error(close_msg, 'find');
# Copyright 
    'debug!'		=> \$Debug,
    debug "source override file $file";
      --debug              turn debugging on.
    delete $fields->{Source};
    $dir = '.' if $dir eq '';
    $dir = "$prefix$dir";
    $dir =~ s-/+$--;
	    # do nothing
  -e, --extra-override <file>
        } else {
    else {
    elsif (defined $regular_file) {
	elsif ($maintainer =~ /^(.*\S)\s*=>\s*(.*)$/) {
    error(_g("no binary packages specified in %s"), $file) unless (@binary);
# Errors with a single package are warned about but don't affect the
        eval {
    exit;
$Exit = 1 if $Exit and not $Exit % 256;
# exit code. Only errors which affect everything cause a non-zero exit.
exit $Exit;
$Exit = main || $Exit;
     'extra'		=> 1,
    'extra-override|e=s' => \$Extra_override_file,
        $Extra_Override{$p}{$field} = $value;
    $fields->{Directory} = $dir;
            $fields->{$field} = $value;
    $fields->load($file);
            $fields->{Maintainer} = $maintainer_override->[O_MAINT_TO];
            $fields->output(\*STDOUT);
    $fields->{Package} = $fields->{Source};
    $fields->{Priority} = $priority if defined $priority;
            $fields = process_dsc($prefix, $_);
    $fields->{Section} = $section if defined $section;
    $fields->set_options(type => CTRL_INDEX_SRC);
	    $file = $regular_file;
	    $file = "$regular_file.src";
            $file =~ s/\.$ext$/.src.$ext/;
	$file = $user_file;
        # FIXME: Fix it instead to not die on syntax and general errors?
    # For the maintainer override, use the override record for the first
    # For the section override, first check for a record from the source
    # Get checksums
    GetOptions(@Option_spec) or usage;
# Given PREFIX and DSC-FILE, process the file and returns the fields.
# GNU General Public License for more details.
            grep { $fields->{Maintainer} eq $_ }
      --help               show this help message.
    'help!'		=> \&usage,
        if ($@) {
        if (defined($comp)) {
	if (!defined $maintainer) {
        if (!defined $maintainer_override->[O_MAINT_FROM] ||
    if (defined $user_file) {
    if (exists $Extra_Override{$source}) {
	if (exists $Override{$key}) {
	if (exists $Override{$package}) {
    if ($maintainer_override && defined $maintainer_override->[O_MAINT_TO]) {
	if ($No_sort) {
    if (@out) {
	if (!$Priority{$priority}) {
     'important'	=> 4,
                           is regular override file with .src appended.
# it under the terms of the GNU General Public License as published by
    load_override_extra $Extra_override_file if defined $Extra_override_file;
    load_override $override if defined $override;
    load_src_override $Src_override, $override;
    local $_;
                @{ $maintainer_override->[O_MAINT_FROM] }) {
        map {
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    my $basename = $file;
    my @binary_by_priority = sort {
    my @binary = split /\s*,\s*/, $fields->{Binary};
    my $checksums = Dpkg::Checksums->new();
        my $comp = compression_guess_from_filename($regular_file);
    my $comp_file = Dpkg::Compression::FileHandle->new(filename => $extra_override);
    my $comp_file = Dpkg::Compression::FileHandle->new(filename => $file);
	my @data = split ' ', $_;
	my @data = split ' ', $_, 4;
my $Debug	= 0;
    my $dir = ($basename =~ s{^(.*)/}{}) ? $1 : '';
    my ($dir, $override, $prefix) = @ARGV;
my $Exit = 0;
	    my $ext = compression_get_property($comp, "file_ext");
my %Extra_Override;
my $Extra_override_file = undef;
    my $extra_override = shift;
        my $fields;
    my $fields = Dpkg::Control->new(type => CTRL_PKG_SRC);
        my ($field, $value);
    my ($file);
    my $file = shift;
	my $key = "source/$package";
    my $maintainer_override = $Override{$binary[0]};
    my $name = shift;
my $No_sort	= 0;
my @Option_spec = (
    my (@out);
my %Override;
	my ($package, $priority, $section, $maintainer) = @data;
	my ($package, $section) = @data;
	my ($p, $field, $value) = split(/\s+/, $_, 3);
    my ($prefix, $file) = @_;
my %Priority = (
    my $priority_override = $Override{$binary_by_priority[-1]};
    my $priority = $priority_override
    my $section_override = $Override{"source/$source"} || $Override{$source};
    my $section = $section_override
    my $source = $fields->{Source};
my $Src_override = undef;
    my ($user_file, $regular_file) = @_;
                   $name, $?, $!)."\n";
            next;
	    next;
	next if /^\s*$/;
	next unless $_;
  -n, --no-sort            don't sort by package before outputting.
    'no-sort|n'		=> \$No_sort,
    open FIND, "find -L \Q$dir\E -name '*.dsc' -print |"
     'optional'		=> 2,
Options:
        or syserr(_g("cannot fork for %s"), "find");
        } @out;
            $_->output(\*STDOUT);
	    ($Override{$a} ? $Priority{$Override{$a}[O_PRIORITY]} : 0)
	    ($Override{$b} ? $Priority{$Override{$b}[O_PRIORITY]} : 0)
    # override file, else use the regular override file.
# %Override is a hash of lists.  The subs following describe what's in
	$Override{$key} = [];
	$Override{$key}[O_SECTION] = $section;
	$Override{$package} = [];
	    $Override{$package}[O_MAINT_FROM] = [split m-\s*//\s*-, $1];
	    $Override{$package}[O_MAINT_TO] = $2;
	    $Override{$package}[O_MAINT_TO] = $maintainer;
	$Override{$package}[O_PRIORITY] = $priority;
	$Override{$package}[O_SECTION] = $section;
	            $package, $.);
	            $package, $priority);
    # Parse 
    printf _g(
    printf _g("Debian %s version %s.\n"), $progname, $version;
            print "\n";
    print @_, "\n" if $Debug;
			? $priority_override->[O_PRIORITY]
    # Process extra override
"), $progname;
    push @ARGV, ''		if @ARGV < 3;
    push @ARGV, undef		if @ARGV < 2;
            push @out, $fields;
    # Rename the source field to package.
     'required'		=> 5,
	return;
    return 0;
    return $fields;
    return sprintf(_g("error closing %s (\$? %d, \$! `%s')"),
        return unless -e $file;
    	s/#.*//;
	s-^\./+--;
	s/\#.*//;
			? $section_override->[O_SECTION]
See the man page for the full documentation.
        } sort {
    'source-override|s=s' => \$Src_override,
	s/\s+$//;
  -s, --source-override <file>
     'standard'		=> 3,
sub close_msg {
sub debug {
sub load_override {
sub load_override_extra
sub load_src_override {
sub main {
sub O_MAINT_FROM	() { 2 } # undef for non-specific, else listref
sub O_MAINT_TO		() { 3 } # undef if there's no maint override
sub O_PRIORITY		() { 0 }
sub O_SECTION		() { 1 }
sub process_dsc {
sub usage {
sub version {
# Switches
textdomain("dpkg-dev");
# the Free Software Foundation; either version 2 of the License, or (at
# the lists.
    # The priority for the source package is the highest priority of the
# This program is distributed in the hope that it will be useful,
# This program is free software; you can redistribute it and/or modify
			: undef;
	unless (@data == 2) {
	unless (@data == 3 || @data == 4) {
"Usage: %s [<option> ...] <binarypath> [<overridefile> [<pathprefix>]] > Sources
use Dpkg;
use Dpkg::Checksums;
use Dpkg::Compression;
use Dpkg::Compression::FileHandle;
use Dpkg::Control;
use Dpkg::ErrorHandling;
use Dpkg::Gettext;
                           use extra override file.
                           use file for additional source overrides, default
use Getopt::Long qw(:config posix_default bundling no_ignorecase);
use strict;
use warnings;
#!/usr/bin/perl
      --version            show the version.
    'version'		=> \&version,
            warn $@;
	    warning(_g("ignoring duplicate override entry for %s at line %d"),
	    warning(_g("ignoring duplicate source override entry for %s at line %d"),
	    warning(_g("ignoring override entry for %s, invalid priority %s"),
	    warning(_g("invalid override entry at line %d (%d fields)"),
	    warning(_g("invalid source override entry at line %d (%d fields)"),
    while (<$comp_file>) {
        while(($field, $value) = each %{$Extra_Override{$source}}) {
    while (<FIND>) {
# your option) any later version.
# You should have received a copy of the GNU General Public License
