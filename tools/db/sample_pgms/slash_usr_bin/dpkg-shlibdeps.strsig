                            }
                        {
                }
            {
            }
        }
		    # 1/ when the lib and the binary are in the same
		    # 2/ when the lib is not versioned and can't be
		    # 3/ when we have been asked to do so
		    add_shlibs_dep($soname, $pkg, $lib)) {
	# Adjust minimal version of dependencies with information
	$admindir = $1;
  --admindir=<directory>   change the administrative directory.
	    # Affect the binary to the most important field
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
                # Also count usage on alternate soname
		    # Also count usage on alternate soname
	    $altlibfiles{$reallib} = $soname;
		    $alt_soname{$id} = $soname;
			and check_files_are_the_same($root_file, $root_lib);
                # and only if the dependency is not provided by shlibs.local
		# and public libraries
# (at your option) any later version.
# binaries)
# binaries that we have inspected)
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# By increasing importance
	    $cached_pkgmatch{$2} = $pkgmatch->{$2} = [ split(/, /, $1) ];
	    $cached_pkgmatch{$_} = [""]; # placeholder to cache misses too.
             "Cannot continue due to the errors listed above.",
		  check_files_are_the_same get_control_path);
	# Child process running dpkg --search and discarding errors
	chomp($_);
    close(DPKG);
    close($fh) || syserr(_g("cannot close %s"), "$varlistfile.new");
	close(OLD);
    close(SHLIBS);
	close STDERR;
    close(SYM_FILE);
		# Complain about missing symbols only for executables
Copyright (C) 1996 Ian Jackson.
Copyright (C) 2000 Wichert Akkerman.
Copyright (C) 2006 Frank Lichtenheld.
Copyright (C) 2007 Raphael Hertzog.
    # Create real RPATH in case $ORIGIN is used
    $cur_field = $exec{$file};
	-d $admindir ||
  -d<dependencyfield>      next executable(s) set shlibs:<dependencyfield>.
	$debug++;
	    defined($dependencies{$cur_field}{$subdep}))
	    defined($dep->{relation}) &&
	defined($depstrength{$dependencyfield}) ||
	    # Define dep and end here if the package type explicitly
                defined(extract_from_shlibs($soname, $shlibslocal)))
		    $dep = $depread;
		$dep = $depread unless defined $dep;
		$dependencies{$cur_field}{$_} = Dpkg::Version->new('');
				         $dependencies{$cur_field}{$subdep}))
			$dependencies{$cur_field}{$subdep} = Dpkg::Version->new($minver);
	    $dependencies{$cur_field}{$subdep} = $minver;
		$dependencies{$cur_field}{$subdep} = $minver;
                                          $dependencies{$field}{$dep})) {
    # dependency
	$dependencyfield = field_capitalize($1);
Dependency fields recognised are:
	$dep = join ", ",
	    (($dep->{relation} eq REL_GE) ||
	     ($dep->{relation} eq REL_GT)))
	$depseen{$dep} = $dependencies{$field}{$dep};
	$depseen{$dep} = $dependencies{$field}{$dep} if $stronger;
	$dir_checked{$builddir} = 1;
		"directory could not be identified due to lack of DEBIAN " .
    # Disable warnings about missing symbols when we have not been able to
    # Don't include dependencies if they are already
               "%d other similar warnings have been skipped (use -v to see " .
# dpkg-shlibdeps
                        Dpkg::Shlibs::SymbolFile->new(file => $symfile_path);
		    # Drop the default suffix for readability
  -e<executable>           (use -e if <executable> starts with \`-')
                            } else {
        } else {
    } else {
} else {
	    } else {
	} else {
		} else {
			} else {
	} elsif ($dependencies{$field}{$dep} eq '') {
	} elsif ($depseen{$dep} eq '') {
	} elsif (!$existing_only) {
    } elsif (m/^-/) {
    } elsif (m/^--admindir=(.*)$/) {
	} elsif (m/^([-a-z0-9+.:, ]+): (\/.*)$/) {
    } elsif (m/^-d(.*)$/) {
    } elsif (m/^-e(.*)$/) {
    } elsif (m/^-(h|-help)$/) {
    } elsif (m/^--ignore-missing-info$/) {
    } elsif (m/^-L(.*)$/) {
    } elsif (m/^-O$/) {
    } elsif (m/^-p(\w[-:0-9A-Za-z]*)$/) {
    } elsif (m/^-S(.*)$/) {
    } elsif (m/^-t(.*)$/) {
    } elsif (m/^-v$/) {
    } elsif (m/^--version$/) {
    } elsif (m/^--warnings=(\d+)$/) {
    } elsif (m/^-x(.*)$/) {
    } elsif ($soname =~ /^(.*)-(\d.*)\.so$/) {
	} elsif (version_compare_relation($depseen{$dep}, REL_GT,
	    # Empty package name will lead to consideration of symbols
	$ENV{'DPKG_ADMINDIR'} = $admindir;
	$ENV{LC_ALL} = "C";
		$error_count++;
             $error_count) . "\n" . $note);
	    error(_g("administrative directory '%s' does not exist"), $admindir);
        error(_g("invalid dependency got generated: %s"), $dep) unless defined $obj;
		    error(_g("no dependency information found for %s " .
		errormsg($msg, $soname, $file, $obj->{format}, join(":", @{$obj->{RPATH}}));
    error(P_("Cannot continue due to the error above.",
	    "/etc/dpkg/symbols/$pkg.symbols";
	    $exec{$1} = $dependencyfield;
		$exec{$1} = $dependencyfield;
	    $exec{$_} = $dependencyfield;
		$exec{$_} = $dependencyfield;
	exec("dpkg", "--search", "--", @files)
  <executable>             include dependencies for <executable>,
	# extracted from build-dependencies
    # Fallback in the root directory if we have not found what we were
	# Fallback to other shlibs files but it shouldn't be necessary
	# Fallback to other symbols files but it shouldn't be necessary
    $fh = \*NEW;
    $fh = \*STDOUT;
		    $fields->{"Build-Depends"} : "";
	    $file2pkg->{$lib} = [""];
		$file2pkg->{$lib} = $file2pkg->{$reallib};
    $file = find_library($lib, \@RPATH, $format, "");
	$file = find_library($lib, \@RPATH, $format, $builddir);
	    # file from the package being built only
                                        $file, $print_name);
    # find all libs
# find_library ($soname, \@rpath, $format)
	"find private libraries, you might need to set LD_LIBRARY_PATH.");
    foreach (@_) {
foreach (@ARGV) {
    foreach my $builddir (@builddirs) {
		foreach my $dep ($symfile->get_dependencies($soname)) {
	foreach my $entry (grep { not m/^\Q$varnameprefix\E:/ } (<OLD>)) {
    foreach my $exc (@exclude) {
foreach my $field (reverse @depfields) {
    foreach my $file (@files) {
foreach my $file (keys %exec) {
    foreach my $file (@shlibs) {
    foreach my $lib (keys %libfiles) {
    foreach my $path (@{$rpath}) {
	foreach my $pkg (@{$file2pkg->{$lib}}) {
foreach my $soname (keys %global_soname_needed) {
    foreach my $soname (@sonames) {
	foreach my $subdep ($dep->get_deps()) {
    foreach my $subdep (split /\s*,\s*/, $dep) {
		foreach my $subdep (split /\s*,\s*/, $dep) {
    foreach my $sym ($obj->get_undefined_dynamic_symbols()) {
    foreach (@sonames) {
	    foreach (split(/,\s*/, $dep)) {
			 "format: '%s'; RPATH: '%s').");
## Functions
            $global_soname_needed{$_} = [ $file ];
	    $global_soname_notfound{$soname} = 1;
        $global_soname_used{$_} = 0 unless exists $global_soname_used{$_};
                $global_soname_used{$alt_soname{$symdep{soname}}}++;
		    $global_soname_used{$alt_soname{$syminfo->{soname}}}++;
	    $global_soname_used{$symdep{soname}}++;
		$global_soname_used{$syminfo->{soname}}++;
# GNU General Public License for more details.
	    } grep { filter_deps($_, $field) }
                 grep(/^libstdc\+\+\.so\.\d+/, keys %global_soname_needed)));
		    # handled by shlibs
                $haslocaldep = 1;
  -h, --help               show this help message.
		if ($1 eq $packagetype) {
	    # If both versions are the same (possibly unversionned)
if (-d "debian") {
			if ($debug or ($in_public_dir and $nb_warnings < 10)
	    if (defined($1)) {
	if (defined($dep)) {
	if (defined $dev_pkg) {
    if (defined $libdir) {
	    if (defined $minver) {
	    if (defined $origin) {
	if (defined $pkg_root) {
	    if (defined $res) {
            if (defined($symfile_path)) {
	    if (defined($symfile_path) && $symfile->has_object($soname)) {
    if ($dep) {
	    if ($dependencies{$cur_field}{$subdep} eq '' or
		if ($dependencies{$field}{$_}) {
    if ($dep->isa('Dpkg::Deps::Simple')) {
	if (($dep->{package} eq $pkg) &&
	if ($depseen{$dep} eq $dependencies{$field}{$dep}) {
	    if ($depstrength{$dependencyfield} > $depstrength{$exec{$_}}) {
	    if ($depstrength{$dependencyfield} > $depstrength{$exec{$1}}) {
	if (-e $file and symfile_has_soname($file, $soname)) {
if ($error_count >= 1) {
            if (-e $shlibslocal and
    if (-e $varlistfile) {
            if (exists $alt_soname{$symdep{soname}}) {
		if (exists $alt_soname{$syminfo->{soname}}) {
	if (exists $cached_pkgmatch{$_}) {
	if (exists $dependencies{$cur_field}{$subdep} and
    if (exists $dependencies{$field} and scalar keys %{$dependencies{$field}}) {
	if (exists $exec{$_}) {
	if (exists $exec{$1}) {
	    if (exists $file2pkg->{$reallib}) {
        if (exists $global_soname_needed{$_}) {
    if (exists $symfile_has_soname_cache{$file}{$soname}) {
		if (($id ne $soname) and ($id ne $lib)) {
                            if ($in_public_dir) {
	if (keys %symdep) {
	if (($libname eq $2) && ($libversion eq $3)) {
		if ($libobj->is_public_library() and not
	if (m/^local diversion |^diversion by/) {
	if (!m/^\s*(?:(\S+):\s+)?(\S+)\s+(\S+)(?:\s+(\S.*\S))?\s*$/) {
    if (m/^-T(.*)$/) {
    if (my $relname = relative_to_pkg_root($file)) {
        if $nb_skipped_warnings;
	    if (not defined($syminfo)) {
		    if (not exists $dependencies{$cur_field}{$subdep}) {
    if (not exists($depseen{$dep})) {
	if (not scalar(grep { $_ ne '' } @{$file2pkg->{$lib}})) {
		if ($obj->is_executable() or $obj->is_public_library()) {
            if ($packagetype eq "deb" and not $haslocaldep) {
	if ($path =~ /\$ORIGIN|\$\{ORIGIN\}/) {
    if (!$pid) {
    if ($pkg eq "") {
	if (/^\Q$soname\E /) {
	if ($reallib ne $lib) {
	    if (scalar(split_soname($soname))) {
    if ($soname =~ /^(.*)\.so\.(.*)$/) {
if (!$stdout) {
if ($stdout) {
	if ($sym->{version}) {
If the file is not packaged, try to find out the shlibs file in
If the file is not packaged, try to find out the symbols file in
	    # If the library is really not available in an installed package,
		if (version_compare_relation($minver, REL_GT, $res)) {
		    $ignore++ if defined $root_file and defined $root_lib
		    $ignore++ if $ignore_missing_info;
	$ignore_missing_info = 1;
  --ignore-missing-info    don't fail if dependency information can't be found.
		    $ignore++ unless scalar(split_soname($soname));
	    # Ignore warning for libm.so.6 if also linked against libstdc++
		    # ignoring as many cases that can be safely ignored
		# Initialize dependencies with the smallest minimal version
        # Initialize statistics
        $in_public_dir = (grep { $parent_dir eq $_ } @librarypaths) ? 1 : 0;
                   "installed in their package's directory."));
	    # it's because it's in the process of being built
# it under the terms of the GNU General Public License as published by
                   join(" ", @{$global_soname_needed{$soname}}));
	    keys %{$dependencies{$field}};
	    last;
		    last;
later for copying conditions. There is NO warranty.
	$libfiles{$lib} = $soname;
				           "libraries."), $print_name, $file);
                # library might not have always been available in the
	    # line
  -L<localshlibsfile>      shlibs override file, not debian/shlibs.local.
                # Load symbol information
    # Load symbols files for all needed libraries (identified by SONAME)
	# Load symbols/shlibs files from packages providing libraries
    # looking for in the packages
    # Look into the packages we're currently building in the following
	    map {
	    # matches. Otherwise if the packagetype is not specified, use
    # mentionned in a higher priority field
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    $minver = Dpkg::Version->new($minver);
    my %altlibfiles;
    my %alt_soname;
my $build_depends = defined($fields->{"Build-Depends"}) ?
my $build_deps = deps_parse($build_depends, reduce_arch => 1);
    my @builddirs;
my %cached_pkgmatch = ();
my $control = Dpkg::Control::Info->new();
	my $control_file = get_control_path($pkg, "shlibs");
	my $control_file = get_control_path($pkg, "symbols");
my $cur_field;
my $debug = 0;
    my $dep = "";
    my $dep;
my %dependencies;
my $dependencyfield = 'Depends';
	    my $depends = $symfile->get_dependency($symdep{soname},
	my $dep = extract_from_shlibs($soname, $file);
    my ($dep, $field) = @_;
my @depfields = qw(Suggests Recommends Depends Pre-Depends);
    my ($dep, $minver, $existing_only) = @_;
    my ($dep, $pkg) = @_;
	my $depread = defined($4) ? $4 : '';
my %depseen;
		my $dep = $symfile->get_dependency($soname);
	my $dev_pkg = $symfile->get_field($soname, 'Build-Depends-Package');
    my %dir_checked;
    my $disable_warnings = scalar(keys(%soname_notfound));
    my $dumplibs_wo_symfile = Dpkg::Shlibs::Objdump->new();
my $error_count = 0;
my @exclude = ();
my $fields = $control->get_source();
    my $file;
    my $file2pkg = find_packages(keys %libfiles, keys %altlibfiles);
    my @files;
    my ($file, $soname) = @_;
my %global_soname_needed;
my %global_soname_notfound;
my %global_soname_used;
            my $haslocaldep = 0;
my $host_arch = get_host_arch();
my $i = 0; my %depstrength = map { $_ => $i++ } @depfields;
                my $id = $dumplibs_wo_symfile->add_object($libobj);
		    my $ignore = 0;
my $ignore_missing_info = 0;
    my $in_public_dir = 1;
    my $libdir = relative_to_pkg_root($execfile);
    my %libfiles;
	my $lib = my_find_library($soname, $obj->{RPATH}, $obj->{format}, $file);
    my ($libname, $libversion) = split_soname($soname);
                my $libobj = $objdump_cache{$lib};
    my ($lib, $rpath, $format, $execfile) = @_;
	    my $minver = get_min_version_from_deps($build_deps, $dev_pkg);
	    my $minver = get_min_version_from_deps($subdep, $pkg);
		my $minver = $symfile->get_smallest_version($soname) || '';
	    my $msg = _g("couldn't find library %s needed by %s (ELF " .
	my $name = $sym->{name};
    my $nb_skipped_warnings = 0;
    my $nb_warnings = 0;
    my $note = _g("Note: libraries are not searched in other binary packages " .
        my $obj = deps_parse($dep);
    my $obj = Dpkg::Shlibs::Objdump::Object->new($file);
my %objdump_cache;
    my $origin;
my $packagetype = 'deb';
        my $parent_dir = "/" . dirname($relname);
    my $pid = open(DPKG, "-|");
my @pkg_dir_to_search = ();
    my $pkgmatch = {};
    my $pkg_root = guess_pkg_root_dir($execfile);
	my $pkg_root = guess_pkg_root_dir($libfile);
my (@pkg_shlibs, @pkg_symbols, @pkg_root_dirs);
    my ($pkg, $soname, $libfile) = @_;
		    my $print_name = $name;
	    my $reallib = realpath($lib);
	my $reallib = realpath($lib);
	my $res;
    my $result = 0;
		    my $root_file = guess_pkg_root_dir($file);
		    my $root_lib = guess_pkg_root_dir($lib);
    my @RPATH = ();
my %shlibs;
my $shlibsdefault = '/etc/dpkg/shlibs.default';
my $shlibslocal = 'debian/shlibs.local';
my $shlibsoverride = '/etc/dpkg/shlibs.override';
    my @shlibs = ($shlibslocal, $shlibsoverride);
	my $soname = $libfiles{$lib};
    my %soname_notfound;
    my ($soname, $pkg, $libfile) = @_;
    my $soname = shift;
    my ($soname, $shlibfile) = @_;
    my @sonames = $obj->get_needed_libraries;
    my %soname_used;
    my @soname_wo_symfile;
my ($stdout, %exec);
	my $stronger;
	my %symdep = $symfile->lookup_symbol($name, \@sonames);
my %symfile_cache;
    my $symfile = Dpkg::Shlibs::SymbolFile->new();
my %symfile_has_soname_cache;
	    my $symfile_path;
	    my $syminfo = $dumplibs_wo_symfile->locate_symbol($name);
    my %uniq = map { guess_pkg_root_dir($_) => 1 } (@pkg_symbols, @pkg_shlibs);
my $varlistfile = 'debian/substvars';
my $varnameprefix = 'shlibs';
my $warnings = 3;
	    $name .= "\@Base";
	    $name .= "\@$sym->{version}";
			    $nb_skipped_warnings++;
			    $nb_warnings++;
	    next;
	next if defined($dir_checked{$builddir});
		next if $disable_warnings;
	next if m/^\#/;
	    next if not defined $minver;
	next if not -e $file;
	    next if ($soname =~ /^libm\.so\.\d+$/ and
        next if ($soname =~ /^libm\.so\.\d+$/ and scalar(
        next unless ($warnings & WARN_DEP_AVOIDABLE);
            next unless ($warnings & WARN_NOT_NEEDED);
                next unless ($warnings & WARN_SYM_NOT_FOUND);
		# No symbol file found, fall back to standard shlibs
    # Note: ld.so also supports $PLATFORM and $LIB but they are
		# Note: the value is empty for shlibs based dependency
                    $objdump_cache{$lib} = Dpkg::Shlibs::Objdump::Object->new($lib);
        $obj->sort();
                # of all symbols (unversioned dependency is not ok as the
	    # official path of a packaged file, try to fallback on
		# Only try to generate a dependency for libraries with a SONAME
	    # on the realpath() first, maybe this one is part of a package
    open(NEW, ">", "$varlistfile.new") ||
	open(OLD, "<", $varlistfile) ||
    # Open shlibs file
    open(SHLIBS, "<", $shlibfile) ||
	open STDERR, ">", "/dev/null";
# Open substvars file
    open(SYM_FILE, "<", $file) ||
  -O                       print variable settings to stdout.
Options:
    # order:
	$origin = "/$libdir";
	$origin =~ s{/+[^/]*$}{};
                            or (!$in_public_dir and $nb_warnings < 1))
    # - other package build trees that contain either a shlibs or a
		    # package
                # package and we really need it)
                           package build directory first.
    # - package build tree given on the command line (option -S)
    # - package build tree of the binary which is analyzed
	$packagetype = $1;
		$path =~ s/\$\{ORIGIN\}/$origin/g;
		$path =~ s/\$ORIGIN/$origin/g;
	    $pkgmatch->{$_} = $cached_pkgmatch{$_};
	    $pkgmatch->{$_} = [""];        # might be replaced later on
Positional options (order is significant):
	# previously seen one
    print "Analyzing all undefined symbols\n" if $debug > 1;
    printf _g(
    printf _g("
    printf _g("Debian %s version %s.\n"), $progname, $version;
	print $fh "$varnameprefix:$field=$obj\n";
	    print " Found $dep in $file\n" if $debug;
            print " Found in symbols file of $symdep{soname} (minver: " .
                print " Found in $syminfo->{soname} ($syminfo->{objid})\n" if $debug > 1;
    print " Found nothing\n" if $debug;
                        print " Initialize dependency ($subdep) with minimal " .
	print "Library $soname found in $lib\n" if $debug;
    print " Looking up shlibs dependency of $soname provided by '$pkg'\n" if $debug;
        print " Looking up symbol $name\n" if $debug > 1;
                    print " Minimal version of $dep updated with $minver\n" if $debug;
		    $print_name =~ s/\@Base$//;
	    print(NEW $entry) ||
	    print "No associated package found for $lib\n" if $debug;
                print " No minimal version found in $dev_pkg build-dependency\n" if $debug;
                print " Not found\n" if $debug > 1;
    print ">> Scanning $file (for $cur_field field)\n" if $debug;
	    print(STDERR " $_\n")
            print "Updating dependencies of $soname with build-dependencies\n" if $debug;
                print "Using shlibs+objdump for $soname (file $lib)\n" if $debug;
                print "Using symbols file $symfile_path for $soname\n" if $debug;
"), $progname, join("/",@depfields);
    push @builddirs, @pkg_dir_to_search;
    push @builddirs, @pkg_root_dirs;
    push @builddirs, $pkg_root if defined $pkg_root;
	push @exclude, $1;
	    push @files, $_;
	push @files, $control_file if defined $control_file;
	push @files, "/etc/dpkg/symbols/$pkg.symbols.$host_arch",
	    push @files, "$pkg_root/DEBIAN/symbols";
	push @files, @pkg_symbols;
            push @{$global_soname_needed{$_}}, $file;
	push @pkg_dir_to_search, $1;
    push @pkg_root_dirs, keys %uniq;
    push @pkg_shlibs, <debian/*/DEBIAN/shlibs>;
    push @pkg_symbols, <debian/*/DEBIAN/symbols>;
	push @RPATH, $path;
	push @shlibs, $control_file if defined $control_file;
	    push @shlibs, "$pkg_root/DEBIAN/shlibs";
	push @shlibs, @pkg_shlibs;
    push @shlibs, $shlibsdefault;
		push @soname_wo_symfile, $soname;
  -p<varnameprefix>        set <varnameprefix>:* instead of shlibs:*.
# Quit now if any missing libraries
    rename("$varlistfile.new",$varlistfile) ||
# Replace old file by new one
		    $res = $minver;
		$res = $minver;
	    $result = 1;
	return;
    return 0;
	return 0 if $dep =~ /^\s*\Q$exc\E\b/;
	    return 1;
	return 1;
    return $dep;
	    return $dep->{version};
	    return $file;
    return $file if defined($file);
	return $file if defined($file);
    return if not defined($minver);
    return $pkgmatch;
    return $pkgmatch unless scalar(@files);
	return $res;
    return $result;
	return $stronger;
        return $symfile_has_soname_cache{$file}{$soname};
    return undef;
	return undef;
	return wantarray ? () : 0;
	return wantarray ? ($1, $2) : 1;
		     scalar grep(/^libstdc\+\+\.so\.\d+/, @sonames));
scalar keys %exec || usageerr(_g("need at least one executable"));
    # Scan all undefined symbols of the binary and resolve to a
	            $shlibfile, $., $_);
    $shlibfile = "./$shlibfile" if $shlibfile =~ m/^\s/;
	$shlibslocal = $1;
	# Since dependencies can be versionned, we have to
    # Skip dependencies on excluded packages
		    s/#MINVER#/(>= $dependencies{$field}{$_})/g;
		    s/#MINVER#//g;
	        $soname);
	    $soname_notfound{$soname} = 1;
        $soname_used{$_} = 0;
                $soname_used{$alt_soname{$symdep{soname}}}++;
		    $soname_used{$alt_soname{$syminfo->{soname}}}++;
	    $soname_used{$symdep{soname}}++;
		$soname_used{$syminfo->{soname}}++;
  -S<pkgbuilddir>          search needed libraries in the given
    # Split soname in name/version
		s/\s+/ /g;
	s/\s*\n$//;
# Statictics on soname seen in the whole run (with multiple analysis of
	$stdout = 1;
	    $stronger = 0;
	    $stronger = 0; # If the dep is unversionned
	    $stronger = 1;
	    $stronger = 1; # If the dep seen is unversionned
sub add_shlibs_dep {
		"sub-directory in the root of package's build tree"), $execfile);
sub extract_from_shlibs {
sub filter_deps {
sub find_packages {
sub find_symbols_file {
sub get_min_version_from_deps {
sub my_find_library {
sub split_soname {
sub symfile_has_soname {
sub update_dependency_version {
sub usage {
sub version {
		# symbol based dependency will put a valid version as value
    # symbols file
	               "symbols)."), $file, $soname);
                                           "symbol %s: it's probably a plugin."),
                   "symbols)."), $soname,
		$symdep{symbol}{dep_id});
                  "$symdep{symbol}{minver}, dep: $depends)\n" if $debug > 1;
# Symfile and objdump caches
                    $symfile_cache{$symfile_path} =
    $symfile_has_soname_cache{$file}{$soname} = $result;
                $symfile->merge_object_from_symfile($symfile_cache{$symfile_path}, $soname);
		$symfile_path = find_symbols_file($pkg, $soname, $lib);
    syserr(_g("cannot fork for %s"), "dpkg --search") unless defined($pid);
        syserr(_g("cannot open file %s"), $file);
	        syserr(_g("copy old entry to new varlist file \`%s'"),
	syserr(_g("install new varlist file \`%s'"), $varlistfile);
	syserr(_g("open new substvars file \`%s'"), "$varlistfile.new");
	    syserr(_g("open old varlist file \`%s' for reading"), $varlistfile);
	    || syserr(_g("unable to execute %s"), "dpkg");
        syserr(_g("unable to open shared libs info file \`%s'"), $shlibfile);
		|| syserr(_g("write diversion info to stderr"));
textdomain("dpkg-dev");
	"that do not have any shlibs or symbols file.\nTo help dpkg-shlibdeps " .
	    # the dep only as a default that can be overriden by a later
# the Free Software Foundation; either version 2 of the License, or
               "them all).", $nb_skipped_warnings), $nb_skipped_warnings)
	# the package being built where the lib has been found
	    # The path of the library as calculated is not the
	    # The version of the dep seen is stronger...
		    # This failure is fairly new, try to be kind by
This is free software; see the GNU General Public License version 2 or
# This program is distributed in the hope that it will be useful,
# This program is free software; you can redistribute it and/or modify
		# Translate dependency templates into real dependencies
  -t<type>                 set package type (default is deb).
  -T<varlistfile>          update variables here, not debian/substvars.
	unless (defined $lib) {
    unless (defined $libname) {
                unless (exists $objdump_cache{$lib}) {
                unless (exists $symfile_cache{$symfile_path}) {
    unless ($global_soname_notfound{$soname} or $global_soname_used{$soname}) {
		        unless $ignore;
	unless ($soname_notfound{$soname} or $soname_used{$soname}) {
		    unless ($sym->{weak}) {
	    update_dependency_version($depends, $symdep{symbol}{minver});
		    update_dependency_version($dep, $minver, 1);
	usageerr(_g("unknown option \`%s'"), $_);
	usage(); exit(0);
"Usage: %s [<option> ...] <executable>|-e<executable> [<option> ...]
use constant {
use Cwd qw(realpath);
		             "(used by %s)."), $lib, $file)
    # used in real case (yet)
use Dpkg;
use Dpkg::Arch qw(get_host_arch);
use Dpkg::Control::Fields;
use Dpkg::Control::Info;
use Dpkg::Deps;
use Dpkg::ErrorHandling;
use Dpkg::Gettext;
use Dpkg::Path qw(relative_to_pkg_root guess_pkg_root_dir
use Dpkg::Shlibs::Objdump;
use Dpkg::Shlibs qw(find_library @librarypaths);
use Dpkg::Shlibs::SymbolFile;
use Dpkg::Version;
# Used to count errors due to missing libraries
use File::Basename qw(dirname);
		# Use fine-grained dependencies only on real deb
                   "uselessly linked against it (they use none of its " .
use POSIX qw(:errno_h :signal_h);
use strict;
use warnings;
#!/usr/bin/perl
	$varlistfile = $1;
	               "$varlistfile.new");
	$varnameprefix = $1;
  -v                       enable verbose mode (can be used multiple times).
	# verify if the dependency is stronger than the
		version_compare_relation($minver, REL_GT,
	version(); exit(0);
                              "version ($minver)\n" if $debug > 1;
      --version            show the version.
	# Warn about un-NEEDED libraries
    WARN_DEP_AVOIDABLE => 2,
        warning(_g("binaries to analyze should already be " .
	warning(_g("Can't extract name and version from library name \`%s'"),
        warning(_g("dependency on %s could be avoided if \"%s\" were not " .
	    warning(_g("diversions involved - output may be incorrect"));
		warning(_g("\$ORIGIN is used in RPATH of %s and the corresponding " .
			        warning(_g("%s contains an unresolvable reference to " .
	    warning(_g("shared libs info file \`%s' line %d: bad line \`%s'"),
		    warning(_g("%s has an unexpected SONAME (%s)"), $lib, $id);
	    warning(_g("%s shouldn't be linked with %s (it uses none of its " .
			        warning(_g("symbol %s used by %s found in none of the " .
	    warning(_g("unknown output from dpkg --search: '%s'"), $_);
	    warning(_g("unrecognised dependency field \`%s'"), $dependencyfield);
		warning($msg, $soname, $file, $obj->{format}, join(":", @{$obj->{RPATH}}));
    warning(P_("%d similar warning has been skipped (use -v to see it).",
	$warnings = $1;
  --warnings=<value>       define set of active warnings (see manual page).
    WARN_NOT_NEEDED => 4,
# Warn of unneeded libraries at the "package" level (i.e. over all
    WARN_SYM_NOT_FOUND => 1,
    while(defined($_ = <DPKG>)) {
    while (<SHLIBS>) {
    while (<SYM_FILE>) {
# Write out the shlibs substvars
  -x<package>              exclude package from the generated dependencies.
# You should have received a copy of the GNU General Public License
