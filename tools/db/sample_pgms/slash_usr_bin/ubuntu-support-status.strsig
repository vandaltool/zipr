        
            
                
                      action="store_true", default=False,
    # analyize
    # based on this
    # build dict for the argument string
    cache = apt.Cache()
    # calculation because the "Release" file time for that gets
    # check if the support has ended
    # check the release date and show support information
CODENAME = subprocess.Popen(["lsb_release","-c","-s"],
                continue
    #       correctly, see http://bugs.python.org/issue4391
    #      currently this is why it will just display a end
def get_maintenance_status(cache, pkgname, supported_tag):
    # dict with pkgname : support time
    # dict with supporttime : set of packagenames
    d = { 'support_tag' : supported_tag,
    elif supported_tag.endswith("m"):
    else:
    enc = locale.getpreferredencoding()
    except:
        (False, "%(support_end_month_str)s %(support_end_year)s (%(support_tag)s)" % d)
        field_width = len(pkg.name)
    #FIXME: Workaround a bug in optparser which doesn't handle unicode/str
        format_str = "%-"+str(field_width)+"s  %s"
    for pkg in cache:
        for pkg in sorted(cache, cmp=lambda a,b: cmp(a.name, b.name)):
        for (time, tset) in supported_by_time.iteritems():
    for (time, tset) in supported_by_time.iteritems():
from apt.utils import *
from gettext import gettext as _
from optparse import OptionParser
from UpdateManager.Core.utils import twrap
            # get support time
    gettext.bindtextdomain("update-manager", "/usr/share/locale")
    gettext.textdomain("update-manager")
                      help=_("Show all packages in a list").decode(enc))
                      help=_("Show all packages with their status").decode(enc))
                      help=_("Show supported packages on this machine").decode(enc))
                      help=_("Show unsupported packages on this machine").decode(enc))
if __name__ == "__main__":
    if not (options.show_unsupported or
            if not pkg.candidate or not pkg.candidate.downloadable:
    if not releasef:
            if not still_supported:
            if not "Supported" in pkg.candidate.record:
            if not support_str in supported_by_time:
    if not time_t:
    if options.list:
    if options.show_supported or options.show_all:
    if options.show_unsupported or options.show_all:
            if pkg.is_installed:
        if pkg.is_installed:
    if supported_tag.endswith("y"):
    if support_ended:
import apt
import datetime
import gettext
import locale
import os
import subprocess
        locale.setlocale(locale.LC_ALL, "")
    # mvo: we do not define the end date very precisely
                no_candidate.add(pkg.name)
    no_candidate = set()
    now = datetime.datetime.now()
                     now.month > support_end_month)
        'num' : len(no_candidate),
            'num' : len(tset),
        'num' : len(unsupported),
    (options, args) = parser.parse_args()
            options.show_all):
            options.show_supported or
    # output
    # packages that are not downloadable
    # packages that we have no support information
    parser.add_option("", "--list",
    parser.add_option("", "--show-all",
    parser.add_option("", "--show-supported",
    parser.add_option("", "--show-unsupported",
    parser = OptionParser()
        pass
        'percent' : len(no_candidate) * 100.0 / total}
            'percent' : len(tset) * 100.0 / total,
        'percent' : len(unsupported) * 100.0 / total}
        pkg = max(cache, key=lambda pkg: pkg.is_installed and len(pkg.name))
    print
        print
                print format_str % (pkg.name, support)
        print _("No longer downloadable:")
        print _("Run with --show-unsupported, --show-supported or --show-all to see more details")
            print _("Supported until %s:") % time
    print _("Support status summary of '%s':") % os.uname()[1]
        print twrap(" ".join(sorted(no_candidate)))
            print twrap(" ".join(sorted(tset)))
        print twrap(" ".join(sorted(unsupported)))
        print _("Unsupported: ")
        print _("You have %(num)s packages (%(percent).1f%%) supported until %(time)s") % { 
    print _("You have %(num)s packages (%(percent).1f%%) that are unsupported") % {
    print _("You have %(num)s packages (%(percent).1f%%) that can not/no-longer be downloaded") % {
        raise Exception("No date tag found")
        raise Exception("Unsupported tag '%s'" % supported_tag)
    #      range
    release_date = datetime.datetime.fromtimestamp(time_t)
        releasef = get_release_filename_for_pkg(cache, pkgname, 
    releasef = get_release_filename_for_pkg(cache, pkgname, 
    return (True, "%(support_end_month_str)s %(support_end_year)s (%(support_tag)s)" % d)
    #       Should be resolved by Python3
                            stdout=subprocess.PIPE).communicate()[0].strip()
            (still_supported, support_str) = get_maintenance_status(cache, pkg.name, support_tag)
    supported_by_time = {}
            supported_by_time[support_str].add(pkg.name)
                supported_by_time[support_str] = set()
        supported_for_n_month = 12*int(supported_tag.rstrip("y"))
        supported_for_n_month = int(supported_tag.rstrip("m"))
    supported_time_for_pkgname = {}
            supported_time_for_pkgname[pkg.name] = support_tag
    support_ended = (now.year >= support_end_year and 
    support_end_month_str = locale.nl_langinfo(getattr(locale,"MON_%d" % support_end_month))
          'support_end_month_str' : support_end_month_str,
    (support_end_year, support_end_month) = get_maintenance_end_date(release_date, supported_for_n_month)
          'support_end_year' : support_end_year }
                support =  supported_time_for_pkgname.get(pkg.name, _("Unsupported"))
            support_tag = pkg.candidate.record["Supported"]
    # sure to look only for stuff in "Ubuntu" and "distro_codename"
    time_t = get_release_date_from_release_file(releasef)
            'time' : time}
    # (to exclude stuff in ubuntu-updates for the support time 
    total = 0
            total += 1
    # total count, for statistics
    try:
    # try to figure out the support dates of the release and make
                                            "Ubuntu", CODENAME)
                                            "Ubuntu", CODENAME + "-updates")
                unsupported.add(pkg.name)
    unsupported = set()
    # updated regularly)
#!/usr/bin/python
