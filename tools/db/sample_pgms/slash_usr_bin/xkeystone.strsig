				     });
 *   0                                 = m21*((q2x - q3x)*(q1y - q2y) - (q2y - q3y)*(q1x - q2x))*h + (stuff)
 *  | ------------- , ------------- , 1 | = | q1x, q1y, 1 |
 2008 Keith Packard
 * about the suitability of this software for any purpose.  It is provided "as
		arc (cr, quad.p[i].x, quad.p[i].y,
			   argv[0], argv[1]);
 * as the rectangle has some nice simple properties. Invert
 * a transform that maps the rectangle to q. That's easier
autoload Nichrome;
autoload Nichrome::Box;
autoload Nichrome::Button;
autoload Nichrome::Label;
autoload Process;
		    best_dist2 = dist2;
		    best = i;
	    bool	    down;
    bool m_available = true;
	    bool	    started;
				Box::box_item (&hbox),
				 Box::glue_item (1));
    &box_t	box = Box::new (Box::dir_t.vertical,
    &box_t	hbox = Box::new (Box::dir_t.horizontal,
				 Box::widget_item (&doit, 0),
				Box::widget_item (label[0], 0),
				Box::widget_item (label[1], 0),
				Box::widget_item (label[2], 0),
				Box::widget_item (&quad, 1));
				 Box::widget_item (&quit, 0),
				 Box::widget_item (&show, 0),
				Box::widget_item (&space, 0),
		break;
    &button_t	doit = Button::new (&nichrome, "doit", doit_func);
    &button_t	quit = Button::new (&nichrome, "quit",
    &button_t	show = Button::new (&nichrome, "show", show_func);
Cairo::point_t[*] scale(Cairo::point_t[*] p, real w, real h)
	    case press:
	    case release:
	} catch divide_by_zero (real a, real b) {
	    close_path (cr);
		close_path (cr);
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * Copyright 
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
	    default:
    det = 0;
    det = 1/det;
	det += p;
 * documentation for any purpose is hereby granted without fee, provided that
 * done.
    else
	    enum switch (event.type) {
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
	    exit (1);
	exit (1);
extend namespace Nichrome {
					false, "xrandr", "xrandr");
			     "--fb",
	   File::close (randr))
	    File::fprintf (stderr, "%s: no enabled output \"%s\"\n",
	File::fprintf (stderr, "%s: No enabled outputs\n", argv[0]);
		File::sscanf (words[2], "%dx%d+%d+%d", 
	    fill (cr);
		fixed (m[i,0]), fixed (m[i,1]), fixed (m[i,2]));
fixed (real x)
    for (i = 0; i < 3; i++) {
	for (i = 0; i < 3; i++) {
	for (i = 0; i < dim (outputs); i++)
    for (int i = 0; i < 3; i++)
    for (int i = 0; i < 3; i++) {
	    for (int i = 0; i < 3; i++)
	for (int i = 0; i < 3; i++)
		for (int i = 0; i< 4; i++) {
    for (int i = 0; i < dim (outputs); i++)
    for (int i = 0; i < dim (p); i++) {
	    for (int i = 0; i < dim (quad.p); i++)
	    for (int i = 0; i < dim (quad.p); i++) {
    for (int j = 0; j < 3; j++)
    for (j = 0; j < 3; j++) {
		    geometry = { 
	    if (argv[1] == outputs[i].name) {
    if (dim (argv) > 1) {
    if (dim (outputs) == 0) {
	    if (dim (words) >= 3 && words[1] == "connected" &&
		if (i == 0 || dist2 < best_dist2) {
	if (i == 1)
	if (i == dim (outputs)) {
	    if (((i + j) & 1) != 0)
	if (m_available)
    if (q1x != q2x)
	    if (quad.down) {
	    if (quad.geometry.width > 0 && quad.geometry.height > 0)
	    if (!quad.started) {
	    if ((real v = abs (m[j,i])) > max)
import Cairo;
import Nichrome;
import Nichrome::Box;
import Nichrome::Button;
import Nichrome::Label;
import Nichrome::Quad;
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
	    init (&quad, &nichrome, callback);
	    int		    active;
	    int	    ai = a[i];
	int	ai = a[i];
	    int	    aj = a[j];
	    int	    best = 0;
	    int	    bi = b[i];
	int	bi = b[i];
	    int	    bj = b[j];
    int	    i, j;
	int nearest (&quad_t quad, point_t p) {
			&(int width), &(int height), 
			&(int x), &(int y)) == 4)
invert (m_t m)
 * is" without express or implied warranty.
	label[i]->font = "sans-9";
	label[i] = Label::new (&nichrome, "matrix");
	    Label::relabel (label[i], text[i]);
    (*label_t)[3]	label;
    &label_t	space = Label::new (&nichrome, "");
		line_to (cr, quad.p[i].x, quad.p[i].y);
 *  m [ 0 0 1 ] = q[0]
 *  m00 = f(m20)
 *  | m00 m01 m02 |
	{ m00, m01, m02 },
		    m[0,0],m[0,1],m[0,2],
    m00 = m20 * q1x + (q1x - q0x) / w;
 *   m00 = m20*q1x + (q1x - q0x) / w;
 *   m00*w +                 m01*h +                 q0x = q2x*(m20*w + m21*h + 1)
 *  | m00 * w + q0x   m10 * w + q0y     |
 *   m00*w + q0x = q1x*(m20*w + 1)
 *  m01 = f(m21)
 *   m01*h + q0x = q3x*(m21*h + 1)
    m01 = m21 * q3x + (q3x - q0x) / h;
 *   m01 = m21*q3x + (q3x - q0x) / h;
 *  |     m02       ,     m12       , 1 | = | q0x, q0y, 1 |
    m02 = q0x;
 *  m10 = f(m20)
 *  | m10 m11 m12 |
	{ m10, m11, m12 },
		    m[1,0],m[1,1],m[1,2],
    m10 = m20 * q1y + (q1y - q0y) / w;
 *   m10 = m20*q1y + (q1y - q0y) / w;
 *   m10*w +                 m11*h +                 q0y = q2y*(m20*w + m21*h + 1)
 *   m10*w + q0y = q1y*(m20*w + 1)
 *  m11 = f(m21)
 *   m11*h + q0y = q3y*(m21*h + 1)
    m11 = m21 * q3y + (q3y - q0y) / h;
 *   m11 = m21*q3y + (q3y - q0y) / h
    m12 = q0y;
 *   m20 = f(m21)
 *  | m20 m21 m22 |
	{ m20, m21, m22 } };
		    m[2,0],m[2,1],m[2,2]);
	m20 = (m21 * (q2x - q3x) * h + q2x - q1x - q3x + q0x) / ((q1x - q2x) * w);
	m20 = (m21 * (q2y - q3y) * h + q2y - q1y - q3y + q0y) / ((q1y - q2y) * w);
 *   m20*(q1x - q2x)*(q1y - q2y)*w     = m21*(q2x - q3x)*(q1y - q2y)*h     + (q2x - q1x - q3x + q0x)*(q1y - q2y)
 *   m20*(q1x - q2x)*w     = m21*(q2x - q3x)*h     + q2x - q1x - q3x + q0x
 *   m20*q1x*w - m20*q2x*w = m21*q2x*h - m21*q3x*h + q2x - q1x + q0x - q3x + q0x - q0x
 *   m20*q1x*w + q1x - q0x + m21*q3x*h + q3x - q0x + q0x = m20*q2x*w + m21*q2x*h + q2x
 *   m20*(q1y - q2y)*(q1x - q2x)*w     = m21*(q2y - q3y)*(q1x - q2x)*h     + (q2y - q1y - q3y + q0y)*(q1x - q2x)
 *   m20*(q1y - q2y)*w     = m21*(q2y - q3y)*h     + q2y - q1y - q3y + q0y
 *   m20*q1y*w - m20*q2y*w = m21*q2y*h - m21*q3y*h + q2y - q1y + q0y - q3y + q0y - q0y
 *   m20*q1y*w + q1y - q0y + m21*q3y*h + q3y - q0y + q0y = m20*q2y*w + m21*q2y*h + q2y
 *  |  m20 * w + 1     m20 * w + 1      |
 *                                     = m21 * a + b;
    m21 = - b / a;
 *   m21 = -(stuff) / (other stuff)
    m22 = 1;
main ();
	    m_available = false;
	    m_available = true;
		max = v;
	    m_i = invert (m);
	    m[j,i] *= scale;
		motion.x = max (0, min (quad.geometry.width, motion.x));
		motion.y = max (0, min (quad.geometry.height, motion.y));
	    move_to (cr, p.x, p.y);
	    m_print_fix (m_i);
m_print_fix (m_t m)
			     m_print (m_r));
m_print (m_t m)
		    m[row,0],m[row,1],m[row,2]);
m_row (m_t m, int row)
	    m_r = rescale (m_i, 16384);
	    m = solve (scale (quad.p, target_width / w, target_height / h),
    m_t	m = { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 } }, m_i, m_r;
    m_t	r;
m_t solve (q_t q, real w, real h)
		    name = words[0],
    Nichrome::main_loop (&nichrome);
    Nichrome::set_box (&nichrome, &box);
			     &nichrome_t nichrome,
    &nichrome_t	nichrome = Nichrome::new ("Keystone Correction", 400, 350);
 * notice and this permission notice appear in supporting documentation, and
 * OF THIS SOFTWARE.
 * Ok, given an source quad and a dest rectangle, compute
	    outline (cr, &quad);
			     "--output",
		outputs[dim(outputs)] = (output_t) {
			    outputs[i].geometry.height);
			    outputs[i].geometry.width);
			    outputs[i].geometry.x +
			    outputs[i].geometry.y +
} output_t;
output_t[*] get_outputs () {
    output_t[...]   outputs = {};
    output_t[*]	outputs = get_outputs ();
    output_t	target_output;
 * Permission to use, copy, modify, distribute, and sell this software and its
	p[i].x *= w;
	p[i].y *= h;
	    p = m[ai,aj] * m[bi,bj] - m[ai,bj] * m[bi,aj];
	p = m[i,0] * (m[ai,2] * m[bi,1] - m[ai,1] * m[bi,2]);
	    point_t[4]	    p;
	    p = -p;
		p = -p;
	printf (" { 0x%08x, 0x%08x, 0x%08x },\n",
	    printf ("fixed:\n");
	    printf ("inverse: %s\n", m_print (m_i));
	    printf ("normal:  %s\n", m_print (m));
	    printf ("scaled:  %s\n", m_print (m_r));
	    Process::system ("xrandr",
	protected *quad_t new (&nichrome_t nichrome, void(&quad_t) callback) {
	protected void button (&quad_t quad, &button_event_t event) {
	protected void configure (&quad_t quad,
	protected void draw (cairo_t cr, &quad_t quad) {
	protected void init (&quad_t quad,
	protected void motion (&quad_t quad, &motion_event_t motion) {
	protected void outline (cairo_t cr, &quad_t quad) {
 * publicity pertaining to distribution of the software without specific,
    public namespace Quad {
	public typedef quad_t;
	public typedef widget_t + struct {
	    p.x = p.x - e.width / 2 - e.x_bearing;
	    p.y = p.y - e.height / 2 - e.y_bearing;
			      (p.y - quad.p[i].y) ** 2);
 *  q0    q1
 *  q3    q2
	    quad.active = -1;
		quad.active = nearest (&quad, event);
	    quad.button = button;
	    quad.callback = callback;
	    quad.callback (&quad);
		quad.callback (&quad);
	    quad.configure = configure;
			     quad.corner_color.blue, quad.corner_color.alpha);
	    quad.corner_color = (rgba_color_t) {
	    quad.corner_diameter = 20;
		     quad.corner_diameter / 2, 0, 2 * pi);
	    quad.down = false;
		quad.down = false;
		quad.down = true;
	    quad.draw = draw;
			     quad.line_color.blue, quad.line_color.alpha);
	    quad.line_color = (rgba_color_t) {
	    quad.line_width = 10;
	    quad.motion = motion;
	    quad.outline = outline;
		quad.p[2].x = quad.p[1].x = quad.geometry.width;
		quad.p[3].y = quad.p[2].y = quad.geometry.height;
		    quad.p[i].x *= x_scale;
		    quad.p[i].y *= y_scale;
	    quad.p = (point_t[4]) {
		quad.p[quad.active].x = motion.x;
		quad.p[quad.active].y = motion.y;
	    quad.started = false;
		quad.started = true;
	} quad_t;
	    quad_t  quad;
    &quad_t	quad = Quad::new (&nichrome, callback);
    real    a = ((q2x - q3x)*(q1y - q2y) - (q2y - q3y)*(q1x - q2x)) * h;
	    real    best_dist2 = 0;
    real    b = (q2x - q1x - q3x + q0x) * (q1y - q2y) - (q2y - q1y - q3y + q0y) * (q1x - q2x);
	    real	    corner_diameter;
    real  det;
		real dist2 = ((p.x - quad.p[i].x) ** 2 +
	real	h = quad.geometry.height;
	    real	    line_width;
    real    m00, m01, m02;
    real    m10, m11, m12;
    real    m20, m21, m22;
    real    max = 0;
	    real  p;
	real	p;
    real    q0x = q[0].x, q0y = q[0].y;
    real    q1x = q[1].x, q1y = q[1].y;
    real    q2x = q[2].x, q2y = q[2].y;
    real    q3x = q[3].x, q3y = q[3].y;
    real scale = limit / max;
    real screen_height = 0;
    real screen_width = 0;
    real target_height = target_output.geometry.height;
    real target_width = target_output.geometry.width;
	real	w = quad.geometry.width;
		real    x_scale = geometry.width / quad.geometry.width;
		real    y_scale = geometry.height / quad.geometry.height;
	    rectangle (cr, 0, 0, quad.geometry.width, quad.geometry.height);
    rect_t  geometry;
				  rect_t geometry)
		red = 0, green = 0, blue = 1, alpha = 0.75
		red = 1, green = 0, blue = 0, alpha = .5
rescale (m_t m, real limit)
	    return best;
    return floor (x * 65536 + 0.5) & 0xffffffff;
    return m;
    return (m_t) {
    return outputs;
    return p;
	    return &quad;
    return r;
    return sprintf ("%10.5f %10.5f %10.5f",
    return sprintf ("%.8f,%.8f,%.8f,%.8f,%.8f,%.8f,%.8f,%.8f,%.8f",
    return sprintf ("%v,%v,%v,%v,%v,%v,%v,%v,%v",
	    rgba_color_t    corner_color;
	    rgba_color_t    line_color;
	    r[j,i] = det * p;
	screen_height = max (screen_height, 
	screen_width = max (screen_width, 
	    set_line_join (cr, line_join_t.ROUND);
	    set_line_width (cr, quad.line_width);
 * Set m22 to 1, and solve:
	    set_source_rgba (cr, 0, 0, 0, .25);
	    set_source_rgba (cr, 1, 1, 1, 1);
	    set_source_rgba (cr, quad.corner_color.red, quad.corner_color.green,
	    set_source_rgba (cr, quad.line_color.red, quad.line_color.green,
	    show_text (cr, text);
			     sprintf ("%dx%d", screen_width, screen_height),
    static int[3]	a = { 2, 2, 1 };
    static int[3]	b = { 1, 0, 0 };
	string[3]	text;
    string  name;
	    string[*] words = String::wordsplit (File::fgets (randr), " ");
	    stroke (cr);
			     target_output.name,
	target_output = outputs[0];
		target_output = outputs[i];
		       target_width, target_height);
		text_at (cr, quad.p[i], sprintf ("%d", i));
	    text_extents_t  e = text_extents (cr, text);
		text[i] = m_row (m_i,i);
	    text = (string[3]) { "no solution", "" ... };
 * that the name of the copyright holders not be used in advertising or
 * the above copyright notice appear in all copies and that both that copyright
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * the matrix to find the opposite mapping
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
			     "--transform",
    twixt (file randr = Process::popen (Process::popen_direction.read,
typedef point_t[4]  q_t;
typedef real[3,3]   m_t;
typedef struct {
#!/usr/bin/env nickle
    void callback (&quad_t quad) {
    void doit_func (&widget_t widget, bool state)
				     void func (&widget_t w, bool state) {
void main ()
	    void(&quad_t)   callback;
			     void (&quad_t) callback) {
    void show_func (&widget_t widget, bool state)
	void text_at (cairo_t cr, point_t p, string text) {
	while (!File::end (randr)) {
	    Widget::configure (&quad, geometry);
	    Widget::init (&nichrome, &quad);
		Widget::redraw (&quad);
		Widget::reoutline (&quad);
					w.nichrome.running = false;
 * written prior permission.  The copyright holders make no representations
		{ x = 0, y = 0 } ...
			     "xrandr",
			x = x, y = y, width = width, height = height 
