###############################################################################
$0 [-f|--force] [-w|--wrapping] [--nopwcheck] [-n|--no-fnek]
 1. Obtain your Private directory mountpoint
 2. Ensure that you have moved all relevant data out of your \$PRIVATE directory
 3. Unmount your encrypted private directory
 4. Make your Private directory writable again
 5. Remove \$PRIVATE, ~/.Private, ~/.ecryptfs
 6. Uninstall the utilities (this is specific to your Linux distribution)
# Add the passphrase to current keyring
	# and convert to a string of hex digits
	# And ensure that $USER owns the files/dirs we've created as root
	# and the calling 'adduser' is about to copy over /etc/skel
# Backup any existing wrapped-passphrase or sig files; we DO NOT destroy this
		-b|--bootstrap)
 -b, --bootstrap  Bootstrap a new user's entire home directory
   Be sure to properly escape your parameters according to your
#!/bin/sh
			BOOTSTRAP=1
			break
				break
					break
# but this would be VERY hard to do safely.
	bytes=$1
	case "$1" in
# Check for active mounts
# Check for previously setup private directory
# Check if the ecryptfs group exists, and user is member of ecryptfs group
# Check that the mount point and encrypted directory are empty (skip symlinks).
chmod 500 "$MOUNTPOINT"
   $ chmod 700 \$PRIVATE
	# chooses a password.  Until that happens (hopefully soon), standard
	chown -R $USER:$GROUP $ECRYPTFS_DIR/$USER
	chown -R $USER:$GROUP $MOUNTPOINT
	chown $USER:$GROUP "$CRYPTDIR" /dev/shm/.ecryptfs-$USER
CIPHER="aes"
	# config dir elsewhere, but linked into the homedir
			continue
				continue
# Copyright (C) 2007-2008 International Business Machines
# Copyright (C) 2008 Canonical Ltd.
count=`ls -Al "$CRYPTDIR" 2>/dev/null | egrep -c "^[dlrwx-]{10}"`
count=`ls -Al "$MOUNTPOINT" 2>/dev/null | egrep -c "^[drwx-]{10}"`
	CRYPTDIR="$ECRYPTFS_DIR/$USER/.$PRIVATE_DIR"
	CRYPTDIR="$HOME/.$PRIVATE_DIR"
                  defaults to randomly generated $KEYBYTES bytes
                  defaults to yourself
                  different from the login passphrase
                  directory is not automatically mounted on login
                  directory is not automatically unmounted at
	# Do the mount, and provide some helpful symlinks
echo "************************************************************************"
echo "  ecryptfs-unwrap-passphrase ~/.ecryptfs/wrapped-passphrase"
echo "$(gettext 'Done configuring.')"
	echo "$(gettext 'ERROR: ')" "$@" 1>&2
				echo "$(gettext 'ERROR: ')" "$(gettext 'Mount passphrases do not match')"
				echo "$(gettext 'ERROR: ')" "$(gettext 'User does not exist')" " [$USER]"
				echo "$(gettext 'ERROR: ')" "$(gettext 'Wrapping passphrases must match')"
			echo "$(gettext 'ERROR: ')" "$(gettext 'You must provide a login passphrase')"
			echo "$(gettext 'ERROR: ')" "$(gettext 'You must provide a username')"
					echo "$(gettext 'ERROR: ')" "$(gettext 'Your login passphrase is incorrect')"
				echo "$(gettext 'INFO:')" "$(gettext 'Skipping password verification')"
	echo "$(gettext 'INFO:')" "$HOME/$PRIVATE_DIR" "$(gettext 'will not be mounted on login')"
	echo "$(gettext 'INFO:')" "$HOME/$PRIVATE_DIR" "$(gettext 'will not be unmounted on logout')"
echo "$(gettext 'Logout, and log back in to begin using your encrypted directory.')"
echo "$(gettext 'Testing mount/write/umount/read...')"
	echo "$(gettext 'Testing succeeded.')"
echo "$(gettext 'THIS WILL BE REQUIRED IF YOU NEED TO RECOVER YOUR DATA AT A LATER TIME.')"
echo "$(gettext 'YOU SHOULD RECORD YOUR MOUNT PASSPHRASE AND STORE IT IN A SAFE LOCATION.')"
echo "$MOUNTPOINT" > "$temp" || error "$(gettext 'Could not create mountpoint file')" "[$HOME/.ecryptfs/$PRIVATE_DIR.mnt]"
		echo -n "$(gettext 'Enter the username: ')"
			echo -n "$(gettext 'Enter your mount passphrase (again): ')"
		echo -n "$(gettext 'Enter your mount passphrase [leave blank to generate one]: ')"
		echo -n "$MESSAGE [$USER]: "
			echo -n "$MESSAGE [$USER] (again): "
echo "$random_data" > "$temp" || error_testing "$temp" "$(gettext 'Could not write encrypted file')"
echo "$sig" > "$temp" || error "$(gettext 'Could not create signature file')" "[$HOME/.ecryptfs/$PRIVATE_DIR.sig]"
ECRYPTFS_DIR="/home/.ecryptfs"
   $ ecryptfs-umount-private
ecryptfs-umount-private || error_testing "$temp" "$(gettext 'Could not unmount private ecryptfs directory (2)')"
				else
                  encrypted private setup
                  encryption, then filenames will be encrypted
	error "$@"
error() {
	error "$CRYPTDIR" "$(gettext 'must be empty before proceeding')"
	error "$(gettext 'Could not add passphrase to the current keyring')"
	error "$(gettext 'Could not obtain the key signature')"
	error "$(gettext 'Testing failed.')"
		error "$(gettext 'Too many incorrect passphrase attempts, exiting')"
		error "$(gettext 'Too many incorrect password attempts, exiting')"
	error "$(gettext 'User home directory does not exist')" "[$HOME]"
	       error "$(gettext 'User needs to be a member of ecryptfs group')"
	error "$(gettext 'wrapped-passphrase file already exists, use --force to overwrite.')"
	error "$MOUNTPOINT" "$(gettext 'must be empty before proceeding')"
	error "$PRIVATE_DIR.sig" "$(gettext 'file already exists, use --force to overwrite.')"
error_testing() {
			exit 0
		-f|--force)
 -f, --force      Force overwriting of an existing setup
filename_encryption_available() {
filename_encryption_available && FNEK="--fnek"
	# file permissions (600) are all that's protecting it.  Write it to
			FNEK=
		fnek_sig=`tail -n 1 "$HOME/.ecryptfs/$PRIVATE_DIR.sig"`
			FORCE=1
	# Force the mount here, since the root user has the key loaded,
for i in "$HOME/.ecryptfs/wrapped-passphrase" "$HOME/.ecryptfs/$PRIVATE_DIR.sig"; do
                  Generates a random mount passphrase, which
GREP_OPTIONS=
grep -qs "$CRYPTDIR " /proc/mounts && error "[$CRYPTDIR]" "$(gettext 'is already mounted')"
grep -qs "$MOUNTPOINT " /proc/mounts && error "[$MOUNTPOINT]" "$(gettext 'is already mounted')"
GROUP=$(id -g $USER)
# homedir mounted
HOME=`getent passwd "$USER" | awk -F: '{print $6}'`
	id "$USER" >/dev/null || error "$(gettext 'User does not exist')" "[$USER]"
if [ "$BOOTSTRAP" = "1" ]; then
if [ "$count" != "0" ]; then
if [ ! -d "$HOME" ]; then
if ! echo "$sig" | egrep -qs "^[0-9a-fA-F]{$KEYBYTES,$KEYBYTES}$"; then
	if [ "$FNEK" = "--fnek" ]; then
if grep -qs "^ecryptfs:" /etc/group; then
			if ! id "$USER" >/dev/null; then
	if ! id "$USER" | grep -qs "\(ecryptfs\)"; then
			if [ "$LOGINPASS" != "$LOGINPASS2" ]; then
if [ "$md5sum1" != "$md5sum2" ]; then
			if [ "$MOUNTPASS" != "$MOUNTPASS2" ]; then
if [ $? -ne 0 ]; then
if [ "$NOAUTOMOUNT" = "1" ]; then
if [ "$NOAUTOUMOUNT" = "1" ]; then
			if [ "$NOPWCHECK" = "1" ]; then
				if printf "%s\0" "$LOGINPASS" | /sbin/unix_chkpwd "$USER" nullok; then
if [ -s "$HOME/.ecryptfs/$PRIVATE_DIR.sig" -a "$FORCE" != "1" ]; then
if [ -s "$HOME/.ecryptfs/wrapped-passphrase" -a "$FORCE" != "1" ]; then
	if [ -s "$i" ]; then
	if [ $tries -ge $PW_ATTEMPTS ]; then
			# If we can't check the accuracy of the user's entered
	# If we want to encrypt the entire homedir, we need the .ecryptfs
		if [ $WRAPPING_PASS != "LOGIN" -o ! -x /sbin/unix_chkpwd ]; then
if [ "$WRAPPING_PASS" = "LOGIN" ]; then
if [ -z "$LOGINPASS" ] && ( [ "$BOOTSTRAP" != "1" ] || [ "$ECRYPTFS_MIGRATE" = "1" ] ); then
if [ -z "$LOGINPASS" ] && [ "$BOOTSTRAP" = "1" ]; then
		if [ -z "$LOGINPASS" ]; then
		if [ -z "$MOUNTPASS" ]; then
if [ -z "$MOUNTPASS" ]; then
if [ ! -z "$SUDO_USER" ]; then
		if [ -z "$USER" ]; then
if [ -z "$USER" ]; then
In the event that you want to remove your eCryptfs Private Directory setup,
		  is set. SHOULD ONLY BE CALLED FROM 'adduser'.
KEYBYTES="16"
		-l|--loginpass)
 -l, --loginpass  Login/Wrapping passphrase for USER,
	ln -sf $ECRYPTFS_DIR/$USER/.ecryptfs $HOME/.ecryptfs
	ln -sf $ECRYPTFS_DIR/$USER/.ecryptfs $MOUNTPOINT/.ecryptfs
	ln -sf $ECRYPTFS_DIR/$USER/.$PRIVATE_DIR $HOME/.$PRIVATE_DIR
	ln -sf $ECRYPTFS_DIR/$USER/.$PRIVATE_DIR $MOUNTPOINT/.$PRIVATE_DIR
ln -sf /usr/share/ecryptfs-utils/ecryptfs-mount-private.desktop "$MOUNTPOINT"/Access-Your-Private-Data.desktop
ln -sf /usr/share/ecryptfs-utils/ecryptfs-mount-private.txt "$MOUNTPOINT"/README.txt
			LOGINPASS="$2"
			LOGINPASS2=`head -n1`
		LOGINPASS=`head -n1`
                  login password (useful for LDAP user accounts)
                  logout
md5sum1=`md5sum "$temp"` || error_testing "$temp" "$(gettext 'Could not read encrypted file')"
md5sum2=`md5sum "$temp"` || error_testing "$temp" "$(gettext 'Could not read encrypted file (2)')"
MESSAGE="$(gettext 'Enter your login passphrase')"
			MESSAGE="$(gettext 'Enter your wrapping passphrase')"
mkdir -m 700 -p "$CRYPTDIR" || error "$(gettext 'Could not create crypt directory')" "[$CRYPTDIR]"
mkdir -m 700 -p "$MOUNTPOINT" || error "$(gettext 'Could not create mount directory')" "[$MOUNTPOINT]"
	mkdir -p -m 700 $ECRYPTFS_DIR/$USER/.ecryptfs 
	mkdir -p -m 700 $HOME/.ecryptfs
		-m|--mountpass)
  [-m|--mountpass MOUNTPASS]
 -m, --mountpass  Passphrase for mounting the ecryptfs directory,
	mount -i -t ecryptfs -o "rw,$sig_opt,ecryptfs_cipher=$CIPHER,ecryptfs_key_bytes=$KEYBYTES" "$CRYPTDIR" "$MOUNTPOINT" || error "Could not mount"
			MOUNTPASS="$2"
			MOUNTPASS2=`head -n1`
		MOUNTPASS=`head -n1`
			MOUNTPASS=`random_passphrase $KEYBYTES`
	MOUNTPOINT="$HOME"
	MOUNTPOINT="$HOME/$PRIVATE_DIR"
		mv -f "$i" "$i.$timestamp" || error "(gettext 'Could not backup existing data')" "[$i]"
	mv -f -T "$temp" "/dev/shm/.ecryptfs-$USER" || error "Could not create passphrase file"
mv "$temp" "$HOME/.ecryptfs/$PRIVATE_DIR.mnt"
mv "$temp" "$HOME/.ecryptfs/$PRIVATE_DIR.sig"
		-n|--no-fnek)
 -n, --no-fnek    Do not encrypt filenames; If this flag is
		--noautomount)
			NOAUTOMOUNT=1
 --noautomount    Setup this user such that the encrypted private
		--noautoumount)
			NOAUTOUMOUNT=1
 --noautoumount   Setup this user such that the encrypted private
		--nopwcheck)
			NOPWCHECK=1
 --nopwcheck      Do not check the validity of the specified
	# NOTE: it is the responsibility of 'adduser' to unmount!
    Note: THIS IS VERY PERMANENT, BE VERY CAREFUL
# Now let's perform some basic mount/write/umount/read sanity testing...
# Obtain the user's home directory
# Obtain USER's primary group
	od -x -N $bytes --width=$bytes /dev/urandom | head -n 1 | sed "s/^0000000//" | sed "s/\s*//g"
                  omitted, and the kernel supports filename
# On subsequent logins, this should be handled by "pam_ecryptfs.so unwrap"
# Originally ecryptfs-setup-pam-wrapped.sh by Michael Halcrow, IBM
# out of the keyring
   parameters by double quotes, if necessary.
			# passphrase, force them to type it twice (matching)
# Perhaps one day we could provide a migration mode (using rsync or something),
# Ported for use on Ubuntu by Dustin Kirkland <kirkland@ubuntu.com>
printf "%s" "$MOUNTPASS" | ecryptfs-add-passphrase $FNEK -
	printf "%s" "$MOUNTPASS" > "$temp"
	printf "%s\n%s" "$MOUNTPASS" "$LOGINPASS" | ecryptfs-wrap-passphrase "$HOME/.ecryptfs/wrapped-passphrase" - || error "$(gettext 'Could not wrap passphrase')"
   $ PRIVATE=\`cat ~/.ecryptfs/Private.mnt 2>/dev/null || echo \$HOME/$PRIVATE_DIR\`
PRIVATE_DIR="Private"
# Prompt for the LOGINPASS, if not on the command line and not in the env
# Prompt for the MOUNTPASS, if not on the command line and not in the env
# Prompt for the USER name, if not on the command line and not in the env
	# Pull $1 of random data from /dev/urandom,
PW_ATTEMPTS=3
	# ramdisk, to keep it from leaking to the hard-drive.
random_data=`head -c 16000 /dev/urandom | od -x` || error_testing "$temp" "$(gettext 'Could not generate random data')"
			RANDOM_MOUNTPASS=1
random_passphrase () {
response=`printf "%s" "$MOUNTPASS" | ecryptfs-add-passphrase $FNEK -`
	return 0
	rm -f "$1" >/dev/null
	rm -f $HOME/.ecryptfs/wrapping-independent || error "$(gettext 'Could not remove ecryptfs wrapping-independent')"
rm -f "$temp"
   $ rm -rf \$PRIVATE ~/.Private ~/.ecryptfs
/sbin/mount.ecryptfs_private || error "$(gettext 'Could not mount private ecryptfs directory')"
/sbin/mount.ecryptfs_private || error_testing "$temp" "$(gettext 'Could not mount private ecryptfs directory (2)')"
	/sbin/umount.ecryptfs_private >/dev/null
/sbin/umount.ecryptfs_private || error_testing "$temp" "$(gettext 'Could not unmount private ecryptfs directory')"
# Setup ~/.ecryptfs directory
# Setup private directory in home
# Setup wrapped-passphrase file
   shell's special character nuances, and also surround the
			shift 1
			shift 2
sig=`echo "$response" | grep "Inserted auth tok" | sed "s/^.*\[//" | sed "s/\].*$//"`
		sig=`head -n 1 "$HOME/.ecryptfs/$PRIVATE_DIR.sig"`
		sig_opt="ecryptfs_sig=$sig"
		sig_opt="ecryptfs_sig=$sig,ecryptfs_fnek_sig=$fnek_sig"
# Skip the tests if we're in bootstrap mode, but exit with the encrypted
			stty -echo
		stty -echo
stty_orig=`stty -g`
			stty $stty_orig
		stty $stty_orig
   $ sudo apt-get remove ecryptfs-utils libecryptfs0
temp=`mktemp`
	temp=`mktemp /dev/shm/.ecryptfs-XXXXXX`
temp=`mktemp "$MOUNTPOINT/ecryptfs.test.XXXXXX"` || error_testing "$temp" "$(gettext 'Could not create empty file')"
TEXTDOMAIN="ecryptfs-utils"
# This script sets up an ecryptfs mount in a user's ~/Private
	# This will be wrapped by pam_ecryptfs's chauthtok as soon as the user
timestamp=`date +%Y%m%d%H%M%S`
	touch $HOME/.ecryptfs/auto-mount || error "$(gettext 'Could not setup ecryptfs auto-mount')"
	touch $HOME/.ecryptfs/auto-umount || error "$(gettext 'Could not setup ecryptfs auto-umount')"
	touch $HOME/.ecryptfs/wrapping-independent || error "$(gettext 'Could not setup ecryptfs wrapping-independent')"
	tries=0
					tries=$(($tries + 1))
				tries=$(($tries + 1))
			tries=$(($tries + 1))
umask 377
umask $u
		--undo)
			undo_msg
undo_msg() {
 --undo           Provide instructions on how to undo an
			usage
usage() {
                  used to wrap MOUNTPASS
# Use ecryptfs-umount-private on the final run, to clear the used keys
                        USER="$2"
		USER=`head -n1`
	USER="$SUDO_USER"
u=`umask`
		-u|--username)
  [-u|--username USER] [-l|--loginpass LOGINPASS]
 -u, --username   Username for encrypted private mountpoint,
	# Verify that the user exists
			# Verify that the user exists
	[ $(($version & 0x100)) -eq 0 ] && return 1
	version=$(cat /sys/fs/ecryptfs/version 2>/dev/null)
which restorecon 2>/dev/null && restorecon "$HOME/.ecryptfs/$PRIVATE_DIR.mnt" > /dev/null 2>&1
which restorecon 2>/dev/null && restorecon "$HOME/.ecryptfs/$PRIVATE_DIR.sig" > /dev/null 2>&1
	while [ $tries -lt $PW_ATTEMPTS ]; do
	while [ true ]; do
while [ ! -z "$1" ]; do
			[ `whoami` = "root" ] || error "$(gettext 'You must be root to bootstrap encrypt a home directory')"
		  will be wrapped when the new login passphrase
			WRAPPING_PASS="INDEPENDENT"
WRAPPING_PASS="LOGIN"
		-w|--wrapping)
 -w, --wrapping   Use an independent wrapping passphrase,
you will need to very carefully perform the following actions manually:
# Zero out user-defined GREP_OPTIONS, such as --line-number
	[ -z "$version" ] && error "$(gettext 'Cannot get ecryptfs version, ecryptfs kernel module not loaded?')"
