         );
        }
and common aliases work, such as "latin1" for "ISO-8859-1", or "ibm850"
Applies PERLQQ, HTMLCREF, XMLCREF, respectively.  Try
are as follows:
@ARGV or push @ARGV, \*STDIN;
a technology demonstrator for Perl 5.8.0, but you can use piconv in the
        binmode $ifh;
        binmode $ifh => "raw:encoding($from)";
    binmode STDOUT;
    binmode STDOUT => "raw:encoding($to)";
B<piconv> is perl version of B<iconv>, a character encoding converter
         'c',
         'check|C=i',
Check the validity of the stream if I<N> = 1.  When I<N> = -1, something
  -C N | -c           check the validity of the input
  -D,--debug          show debug information
         'debug|D',
defined $Opt{resolve} and resolve_encoding($Opt{resolve});
            die "$name: unknown scheme: $scheme";
    } else {
    else {
	    }else{
	} else {
	else {                                    # won't reach
        elsif ( $scheme eq 'decode_encode' ) {    # step-by-step
		    Encode::from_to( $_, $from, $to, $Opt{check} );
		Encode::from_to( $_, $from, $to, $Opt{check} );
    eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
exist.  For example, the names are case-insensitive, and many standard
    exit;
        exit 0;
    exit 0;
        exit 1;
  -f,--from from_encoding  
for a full discussion.
    for my $argv (@ARGV) {
From:   $from => $cfrom
         'from|f=s',
	    'from_to';
	'from_to';
      GetOptions(\%Opt,
=head1 DESCRIPTION
=head1 NAME
=head1 SEE ALSO
=head1 SYNOPSIS
         'help',
Here is the list of options.  Each option can be in short format (-f)
         'htmlcref',
  --htmlcref
# $Id: piconv,v 2.4 2009/07/08 13:34:15 dankogai Exp $
    if (defined $Opt{scheme}) {
	if (!exists $Scheme{$Opt{scheme}}) {
		$_ = <$ifh>;
        $ifh or open $ifh, "<", $argv or next;
	$ifh or open $ifh, "<", $argv or warn "Can't open $argv: $!" and next;
    if ( my $alias = Encode::resolve_alias( $_[0] ) ) {
	    if ($need2slurp){
if ($Opt{debug}){
	if $running_under_some_shell;
        if ( $scheme eq 'from_to' ) {    # default
implementation.
Input strings are decode()d then encode()d.  A straight two-step
instead of "cp850", or "winlatin1" for "cp1252".  See L<Encode::Supported>
interesting happens when it encounters an invalid character.
Invokes debugging mode.  Primarily for Encode hackers.
=item -c
=item -C,--check I<N>
=item -D,--debug
=item decode_encode
=item -f,--from from_encoding
=item from_to
=item -h,--help
=item --htmlcref
=item -l,--list
=item perlio
=item -p,--perlqq
=item -S,--scheme scheme
=item -s,--string I<string>
=item -t,--to to_encoding
=item --xmlcref
L<Encode>
L<Encode::Alias>
L<Encode::Supported>
L<iconv(1)>
like B<cat>.
Like the I<-D> option, this is also for Encode hackers.
linefeed is not $/.
         'list|l',
     lists all available encodings
Lists all available encodings, one per line, in case-insensitive
  -l,--list
L<locale(3)>
		local $/;
L<PerlIO>
    $message and print STDERR "$name error: $message\n";
    my $cfrom = Encode->getEncoding($from)->name;
    my $cto   = Encode->getEncoding($to)->name;
                my $decoded = decode( $from, $_, $Opt{check} );
		    my $decoded = decode( $from, $_, $Opt{check} );
                my $encoded = encode( $to, $decoded );
		    my $encoded = encode( $to, $decoded );
my $from = $Opt{from} || $locale or help("from_encoding unspecified");
        my $ifh = ref $argv ? $argv : undef;
my $locale = $ENV{LC_CTYPE} || $ENV{LC_ALL} || $ENV{LANG};
    my $message = shift;
my $name = basename($0);
    my $need2slurp = $use_bom{ find_encoding($to)->name };
my %Opt;
my $scheme = do {
my %Scheme =  map {$_ => 1} qw(from_to decode_encode perlio);
my $to   = $Opt{to}   || $locale or help("to_encoding unspecified");
my %use_bom = map { $_ => 1 } qw/UTF-16 UTF-32/;
$name [-f from_encoding] [-t to_encoding] [-s string] [files...]
$name -l
$name -r encoding_alias
    # NI-S favorite
$Opt{check} ||= $Opt{c};
$Opt{from} || $Opt{to} || help();
$Opt{help} and help();
$Opt{htmlcref} and $Opt{check} = Encode::HTMLCREF;
$Opt{list} and list_encodings();
$Opt{perlqq}   and $Opt{check} = Encode::PERLQQ;
	    $Opt{scheme};
$Opt{string} and Encode::from_to($Opt{string}, $from, $to) and print $Opt{string} and exit;
$Opt{xmlcref}  and $Opt{check} = Encode::XMLCREF;
order.  Note that only the canonical names are listed; many aliases
or long (--from).
#!./perl
         'perlqq|p',
  piconv [-C N|-c|-p]
piconv converts the character encoding of either STDIN or files
  piconv -D ...
  piconv [-f from_encoding] [-t to_encoding] [-s string] [files...]
  piconv -f utf8 -t ascii --perlqq
  piconv -h
piconv -- iconv(1), reinvented in perl
  piconv -l
  piconv -r encoding
  piconv -S scheme ...
place of iconv for virtually any case.
  -p,--perlqq
		    print;
		print;
        print $alias, "\n";
                print $encoded;
		    print $encoded;
    print <<"EOT";
    print join( "\n", Encode->encodings(":all") ), "\n";
    print STDERR <<"EOT";
        print while (<$ifh>);
    resolve encoding to its (Encode) canonical name
         'resolve|r=s',
  -r,--resolve encoding_alias
Same as C<-C 1>.
Scheme: $scheme
         'scheme|S=s',
Selects which scheme is to be used for conversion.  Available schemes
Show usage.
specified in the argument and prints out to STDOUT.
Specifies the encoding you are converting from.  Unlike B<iconv>,
Specifies the encoding you are converting to.  Unlike B<iconv>,
  -S,--scheme scheme  use the scheme for conversion
  -s,--string string         
         'string|s=s',
     "string" will be the input instead of STDIN or files
sub help {
sub list_encodings {
sub resolve_encoding {
The following are mainly of interest to Encode hackers:
The new perlIO layer is used.  NI-S' favorite.
Therefore, when both -f and -t are omitted, B<piconv> just acts
this option can be omitted.  In such cases, the current locale is used.
Those are handy when you can only see ascii characters:
To see what it does.
To:     $to => $cto
         'to|t=s',
  -t,--to to_encoding    
    unless
unless ( $scheme eq 'perlio' ) {
use 5.8.0;
use Encode ;
use Encode::Alias;
use File::Basename;
use Getopt::Long qw(:config no_ignore_case);
Uses Encode::from_to for conversion.  This is the default.
uses I<string> instead of file for the source of text.
use strict;
#!/usr/bin/perl
        warn "$name: $_[0] is not known to Encode\n";
	    warn "Unknown scheme '$Opt{scheme}', fallback to 'from_to'.\n";
# we do not use <> (or ARGV) for the sake of binmode()
     when omitted, the current locale will be used
		while (<$ifh>) {
widely available for various Unixen today.  This script was primarily
         'xmlcref',
  --xmlcref
You should use this option if you are using UTF-16 and others which
