            );
          }
        }
       ) {
      }        
      # }
      #}
                        : 0;
(0,0), removes binary junk from the beginning of the EPS etc.
    $!=0; # clean up error code
  $_[0]==int($_[0]) ? $_[0] : $_[0] < 0 ? -int(1-$_[0]) : int($_[0])
  $_[0]==int($_[0]) ? $_[0] : 1+ ($_[0] < 0 ? -int(-$_[0]) : int($_[0]));
  ($@ || 0x602)
              $1==0 ? "{}def\n" :
              $1==1 ? "/pop load def\n" :
  { /11x17/a3/a4/a4small/b5/ledger/legal/letter % GS 7.04
    1 if exec $progname, @extra, @_;
        1 index userdict exch undef
  1 pdffindpageref 0 get
        1 while length($_=readIN) and !/\S/;
    1 while length($S=readIN())!=0 and substr($S,0,4)ne'%!PS';
        1 while read PIPE, $line, 4096;
# 2.54 cm == 1 in
      2 copy exch 0 exch put exch pop % change /get to {...}
      2 copy exch 2 exch put % change /pop to /a4
  #  2 dict dup /Duplex false /Tumble false put setpagedevice % simplex  HP PCL5e "\033&l0S"
  #  2 dict dup /Duplex true  /Tumble false put setpagedevice % long     HP PCL5e "\033&l1S"
  #  2 dict dup /Duplex true  /Tumble true  put setpagedevice % short    HP PCL5e "\033&l2S"
        % 3 copy pop undef
        4 2 roll exch undef
# 72 bp == 1 in
#** 8.5bp
    /a10/b0/b1/b2/b3/b4/b5/b6
# a2ping.pa created at Sun Apr 20 22:25:47 2003
#      a2ping.pl 2.77p, 2004-04-28 -- Written by <pts@fazekas.hu> from April 2003.
a2ping.pl -- convert between PS, EPS and PDF and other page description
# a2ping.pl -- convert between PS, EPS and PDF and other page description formats
#      $ a2ping.pl -v debrecen-hyph.ps de                                                                                                                                   brecen-hyph.pdf
 * a2ping.pl -v --papersize=50,60 --bboxfrom=compute-gs t.ps t2.ps
% /a4{(hehehe\n) ..print} def % doesn"t work, has to be put into userdict
# a4small should be a4 with an ImagingBBox of [25 25 570 817].},
    # Active policy:
 * added --antialias=
 * added --doc
 * added FileFormat PBM, PGM, PPM
 * added --gsextra=
 * added PS and sam2p support, renamed to a2ping
 * adds all 3 BoundingBox DSC comments
 * adds DSC ``%%DocumentMedia: plain 612 792 0 () ()''
 * adds %%EndComments and proper %!PS-Adobe-?-? EPSF-?.? header
(add-showpage==1\n) ..print
 * adds invocation syntax: a2ping <infile.eps> <outfile.eps|pdf>
 * adds %%Pages:
  #     % ADL: 694 194 112
 * after `a2ping -pa4', file out.pcl says: `HP PCL printer data - A4 page
      $after_code.=("pop\n"x$pop_count).("end\n"x$end_count);
  $after_code.="showpage\n";
         ) { $after_comments.="$_\n"; last }
      $after_comments.="$_\n"; last
      $after_comments.=$undefs; # after our precious setpagedevice calls
        $after_correct.="1 dict dup /PageSize [".myceil($papersize_x)." ".myceil($papersize_y)."] put setpagedevice\n";
    $after_correct.="2 dict dup /TextAlphaBits 4 put dup /GraphicsAlphaBits 4 put setpagedevice\n" if
      $after_correct.="$_\n" if !$doing_atend; # before `gsave'
#      all fonts with dff.pl has fixed the problem
        $allow_adsc_bb=0;
      $allow_adsc_bb=0 if ($::opt_bboxfrom eq 'compute-gs') ? ($bbc!=0)
# all units are measured in Big Points (bp)
    $already_read=0; $bytes_left=-1;
	  $already_read=0; $bytes_left=-1;
	$already_read=0; $bytes_left=-1;
    $already_read+=30-4;
    $already_read--; $bytes_left++ if $bytes_left>=0; # BUGFIX at Fri May 14 00:21:18 CEST 2004
    $already_read=length($preprint);
  $already_read+=length($S);
    #      and a2ping.pl: PNG XWD BMP TIFF JPEG GIF XPM
  and $after_correct!~m@/PageSize\s*\[@) { # Imp: m@/Pagesize ugly
and better embeddable than its input.
(and EPS files with option B<--bboxfrom> other than B<=guess>), GS is
  and $::opt_papersize ne'force-unknown'
  and $::opt_resolution ne'force-unknown';
  and $::opt_resolution ne 'force-unknown' and $::opt_resolution!~/\A(\d+)+[,x](\d+)\Z(?!\n)/;
       and substr($_,0,5)ne'%EPS ') # epsincl.mp
and TGA. To read sampled input formats, B<sam2p> is used. B<sam2p> is
and the value of B<--threshold> determines the minimum intensity for white in
    # Another possible policy:
/AntiAliasColorImages false\n$imagesopts";
/AntiAliasGrayImages false
/AntiAliasMonoImages false
{% anti-Windows-printer-driver `%%[ ProductName:` etc.
#** Applies %%*BoundingBox, %%EndComments, special setpagedevice, gsave..translate
#      * Applying BoundingBox from ADSC T-: 0 0 596 842
#      * Applying BoundingBox from Compute-GS T-: 71 81 539 769
#      * Applying HiResBoundingBox from Compute-GS T-H: 71.837998 81.971997 538.235984                                                                                                                                    768.113977
    approx 1 lossy 1 keepoldmediabox 1); # boolean arg
a raster image converter written in C++ by the author of B<a2ping.pl>.
    /archE/archD/archC/archB/archA/flsa/flse/halfletter
# --- @ARGV parsing
as big, and then scales it back down. B<=scale3no> turns on both 3x3
      #    (Ascending) comment from the ADSC header
  # assume: use integer;
 * (atend) supported.
	# at Wed Nov 15 17:19:23 CET 2006
/AutoFilterColorImages false
/AutoFilterColorImages true
/AutoFilterGrayImages false
/AutoFilterGrayImages true
/AutoFilterMonoImages false
/AutoFilterMonoImages true
/AutoPositionEPSFiles false
/AutoRotatePages /None
B<a2ping> delegates the low-level work to
B<a2ping> does antialiasing (B<--antialias=scale3no>) of glyphs and
B<a2ping> doesn't produce the desired result.
B<a2ping> is a UNIX command line utility written in Perl that
B<a2ping> is inspired by and historically based on the B<epstopdf> Perl
 B<a2ping.pl> [B<-->]B<doc>
 B<a2ping.pl> [I<options>] <I<inputfile>> [[I<outformat>:] I<outputfile>]
B<a2ping> respects B<--Duplex> for FileFormat PCL5, even though GS doesn't.
B<--antialias=scale3no> or B<--antialias=scale3yes>, GS will render a PGM file,
B<--bboxfrom=compute-gs> option to make GS recompute the bounding box.
(bbox-begin\n) ..print
          "BBox discovery was not successful";
 * --bboxfrom=adsc: %%BoundingBox overrides -sDEVICE=bbox
--bboxfrom=     adsc|compute-gs|pagesize          (def: guess)
#** --bboxfrom=adsc sets %%BoundingBox from the 1st page if no ADSC comment in non-EPS ps
 * --bboxfrom=compute-gs option to fix PS -> EPS bbox (gs -sDEVICE=bbox), tuzv.eps
      (bbox-success\n) ..print
  $BBprint = "%%ExactBoundingBox:" if $::opt_exact;
  $BBprint = "%%HiResBoundingBox:" if $::opt_hires;
      $bbtype='-';
        ($bbtype,$llx,$lly,$urx,$ury)=($T,$2+0,$3+0,$4+0,$5+0);
    $bbx.="%%BoundingBox: ".myfloor($llx)." ".myfloor($lly)." ".
    $bbx.="%%DocumentMedia: plain $px $py 0 () ()\n". # like pdftops(1)
  $bbx.$fontsdefs."%%EndComments\n".$bsetup.$setpagesize.$markpagedevices.$pagedev_mark.$after_correct.$save.$translate
    $bbx.="%%HiResBoundingBox: $llx $lly $urx $ury\n".
because B<a2ping> copies them to a temporary file automatically.
been removed from B<a2ping>, and also B<a2ping> and B<epstopdf> do not
BEGIN { $Htex::a2ping::VERSION="2.77p" }
BEGIN{$  INC{'Htex/a2ping.pm'}='Htex/a2ping.pm'}
BEGIN{$ INC{'Htex/dimen.pm'}='Htex/dimen.pm'} {
BEGIN{$ INC{'Htex/papers.pm'}='Htex/papers.pm'} {
BEGIN{$ INC{'integer.pm'}='integer.pm'} {
BEGIN{$ INC{'Pts/string.pm'}='Pts/string.pm'} {
BEGIN{$ INC{'strict.pm'}='strict.pm'} {
BEGIN{ $just::VERSION=2 }
=begin man
<</BeginPage { % <PageCount> BeginPage -
  #     %%BeginResource: font SKPOPP+LMRoman12-Regular
  #     %%BeginSetup..%%EndSetup pair just before our code doing
binmode IN;
    binmode IN; $bytes_left=-1;
#! /bin/sh
  'BMP'=> [FL_PAGE1_STOP|FL_SET_PAGESIZE_OK|FL_NEED_SHOWPAGE|FL_SAMPLED|FL_HAS_ANTIALIAS|FL_VIA_SAM2P],
   %%*BoundingBox
      #      `%%BoundingBox: 0 0 paperwidth paperheight', but the figure
      #: %%BoundingBox: 56 41 539 783
   BoundingBox of an included file.
 * BoundingBox precedence for EPS input: --PageSize, %%*BoundingBox,
      ### BoundingBox with (atend)
  'bp'=>1, # 1 bp = 1 bp (big point)
B<--Resolution>. The default is B<--Resolution=72>. If your sampled output file
#      but -sDEVICE=pgmraw depends on it
# by pts@fazekas.hu at Sat Dec 21 21:26:15 CET 2002
# by pts@fazekas.hu at Sat Dec 21 21:32:18 CET 2002
# by pts@fazekas.hu at Sun Dec 22 00:30:58 CET 2002
# by pts@fazekas.hu at Tue Jan 16 18:21:59 CET 2001
# by pts@fazekas.hu at Tue Jan 16 19:13:16 CET 2001
# by pts@fazekas.hu at Wed Jan 10 12:42:08 CET 2001
# by pts@fazekas.hu et al. at Wed Apr 16 14:54:13 CEST 2003
    $bytes_left=0;
    $bytes_left=-1; # unlimited, since readIN() has copied only part
      $bytes_left=4096;
        $bytes_left=$cut_offset-$already_read;
    # $bytes_left++ if $bytes_left>=0; # ungetc($c)
    $bytes_left=($ps_end>$wmf_end and $ps_end>$tif_end) ? -1 : $ps_len;
    $bytes_left=$saved_bytes_left;
      #     by the file itself (??)
C<a2ping.pl -v --bboxfrom=compute-gs thefile.eps -->
    .callbeginpage
Call with the B<-v> option to see progress and debug messages.
 * can convert PDF to EPS (by calling pdftops(1)) and PDF to PDF
    # Cannot exec() right now, because we have to unlink some temporary files
  'cc'=>12*1238/1157*72/72.27, # 1 cc = 12*1238/1157*72/72.27 bp (cicero)
      $C=($C eq "\r") ? readIN(1) : "NONE";
    c compression  compress compression  h hires  b below  e exact  x extra);
#$CGS.=" -dSAFER"; # -dWRITESYSTEMDICT
$CGS=$::opt_gs_ccmd if defined $::opt_gs_ccmd;
  #     chance to override its settings.) So we emit a fake
 * changed first comment from '%!PS' to '%!';
      # -- change the ADSC magic `%!PS-Adobe-...' to `%!PS-Adobe-3.0 EPSF-3.0'
  chomp $offset;
  ("cleartomark restore\n"x$is_restored),
### close files
    close IN;
	close IN;
        close IN; # after fix_pipe_in()
        close OUT; close IN;
  'cm'=>72/2.54, # 1 cm = 72/2.54 bp (centimeter)
          $cmd=join('  ',map{fnq$_}@args1)." | convert - GIF:- | ".
          $cmd=join('  ',map{fnq$_}@args1)." | pnmquant 256 | ".
    $cmd.=' | $PAGER';
  #     % CM sources: copyright (C) 1997 AMS, all rights reserved; METATYPE1/Type 1 ver
       $C ne "\n" and $C ne "\r") { $S.=$C }
/ColorImageFilter /DCTEncode
/ColorImageFilter /LZWEncode
/CompatibilityLevel 1.3 %PDF-1.3
#      * Compression: zip
#      * Computing BBox info from non-EPS PS file
 * consistent bbox, --PageSize, /PageSize handling
 * consistent --Resolution and --Duplex handling
#**   constant in the C language (without the LU etc. modifiers) -- or undef
# "Contains modifications by pts\@fazekas.hu";
# contains paper size information
        # !! continue only if MetaPost output?
Conversion from EPS to EPS: fixes various glitches, moves (llx,lly) to
Conversion from EPS to PDF: fixes glitches etc., calls gs
Conversion from PDF to EPS: calls pdftops -eps (of the xpdf package)
Conversion from PDF to PDF: keeps the file intact
Conversion from PS to EPS: keeps 1st page only, removes setpagedevice etc.
converted to the output format.
/ConvertImagesToIndexed false
#** Converts a numeric paper size to a well-defined paper name. Tolerance is
converts many raster image and vector graphics formats to EPS or PDF and
coordinate. C<--below>, C<--hires> and C<-v> are recommended options.
      #: Copyright (C) 2000 Aladdin Enterprises, Menlo Park, CA.  All rights reserved.
 * corrected (atend) pattern: '\s*\(atend\)'
 * corrected first line (one line instead of two before 'if 0;';
   correct the first white space to '...Box:\s*$bb...'
      countdictstack DICTCOUNT sub (end-count==) ..print ===
count /OPCOUNT exch def
      count OPCOUNT sub 1 sub (pop-count==) ..print ===
  #     %%CreationDate: 4th August (Monday) 2003
      $creator[-1]=~s@, a2ping .*@@; # remove old
      $creator[-1]=~s@\s+\Z(?!\n)@@;
        $creator_adobeps_p=1;
        $creator_metapost_p=1;
cropping, and the PDF MediaBox is correct.
  currentdict pdfclose end end end
.currentglobal true .setglobal
curves when emitting a sampled image (FileFormats such as PGM and PPM).
        $cut_offset=-1;
      #: cut-offset==81898
  # Dat: 1mm == 720/254bp; 3mm =~ 8.5bp
"); # Dat: assumes new, patent-free LZW
        # ^^^ Dat: both PS and markedPS would benefit from /PaperSize
# Dat: calling ``showpage'' is not required for -sDEVICE=pdfwrite with gs 6.50,
    # Dat: CompatibilityLevel 1.3 is required for font embedding & all /FlateDecode
  # !! Dat: /CompatibilityLevel 1.3 %PDF-1.2 -- Dat: 1.2 won't embed Courier
  # ^^^ Dat: CUPS inserts its setpagedevice calls for /Duplex and /PageSize
        # ^^^ Dat: cutting after `showpage' makes PS -> EPS conversion easy
# ^^^ Dat: default does only harm; user should specify on command line
      # Dat: don't `$do_atend=1' only for %%Pages
    # Dat: don't do $do_bb_line=sub{};# same as $allow_bb=0;
      # Dat: don't unlink $tifn yet, we'll continue scanning it
    # Dat: emit /PageSize even for PDF1
        # Dat: EPSI created by ImageMagick has BeginDefaults+EndDefaults+BeginPreview
# Dat: example: a2ping.pl --extra=-c:ijg:50 -r86 nn1.eps nn1.jpg
[ % Dat: fixed at Mon May 19 14:32:31 CEST 2003
#** Dat: force-unknown is forced by /setpagedevice/load def
    # Dat: fortunately the following file format names are commin in sam2p(1)
    # Dat: Ghostscript 6.70 rounds /PageSize down, but we need up when creating /MediaBox for PDF
# Dat: gs 7.04 gdevdjet.[ch], gdevdljm.[ch]
          # ^^^ Dat: HiRes has priority
          # ^^^ Dat: ignore llx and lly coordinates
Dat: `=item * foo' is wrong, puts big space between `*' and `foo'
  # Dat: it is inherently impossible to tell GS that it shouldn't
        # Dat: limitation: markedEPS and EPS are treated the same
# Dat: markedEPS: include pdfmarks
      # Dat: markedPS and contains pdfmark!
  % ^^^ Dat: may be {/a4 STRICT {(%END SIZES) .skipeof} if /a5}
      # ^^^ Dat: may be seekable anyway, omit warning
    # ^^^ Dat: mpost outputs "%!PS\n"
        # Dat: no $do_bb_line here, because we've done it with $bbc++, and we'll also do it later
  # ^^^ Dat: no FL_HAS_ANTIALIAS -- would need lj5gray, which is loonger
  # ^^^ Dat: no FL_SAMPLED, because cannot set resolution
# Dat: no more @ARGV
  # Dat: --noverbose --nocompress
	# Dat: no way to use $::opt_approx, because it doesn't remove extra pages
    # Dat: now $offsets is a file position containing our /Page object
# Dat: Now we are converting from PS|EPS to EPS|markedEPS|PDF|PCL5|PGM
    # Dat: $optname and $optval are now correct
      # ^^^ Dat: $::opt_resolution and $::opt_duplex are already 'force-unknown' if $FileFormat is appropriate
    # ^^^ Dat: $OutputFilename eq '-' should be OK
        # Dat: PDF to GIF conversion
# Dat: pdftops -eps writes negative bbox correctly
  # Dat: Perl int() rounds towards zero
    # ^^^ Dat: PLRM.pdf doesn't forbid a non-integer /PageSize
        # Dat: PS output by ADOBEPS4.DRV has BeginDefaults+PageBoundingBox+ViewingOrientation+PageFeatures+EndDefaults
# Dat: .ps will be unmarked PS
  # ^^^ Dat: rather not lie !! go to (atend) if command line
        # Dat: reduce palette to 8-bit
      # Dat: reduce palette to 8-bit if necessary
          # Dat: Safe, restorable, EPS-wise: /setpagedevice {pop} def
  # Dat: -sDEVICE=pgm is ASCII, pgmraw is binary
          # Dat: Smart, documentwise /a4 dup where{dup wcheck{exch{}put}{pop{}def}ifelse}{pop}ifelse
    # ^^^ Dat: syntax already ok for $::opt_resolution
    # Dat: ^^^ test seekability instead of $InputFilename eq '-'
# Dat: the functionality of pdfboxes.pl cannot be provided here with a shorter
    # ^^^ Dat: these cannot handle underline/bold backspace directly
    # ^^^ Dat: this must be the last call to fix_force_out()
      # Dat: This only applies when converting fron non-EPS PS:
# Dat: to be undeffed in setpagedevice: /.MarginsHWResolution /PageSize
    # Dat: true for FileFormat PGM
        # Dat: unneeded: $allow_adsc_bb=0 if $FileFormat eq 'PDF'; # force this into /CropBox (otherwise only /MediaBox)
#** Dat: uses $FileFormat, $InputFileName, $OutputFileName
        # Dat: we rather use a temp file here for safety and early error detection
        # ^^^ Dat: will be put after CorrectBoundingBox
  # ^^^ Dat: [xX] is xdvi-style, [,] is dvips-style spec
  'dd'=>1238/1157*72/72.27, # 1 dd = 1238/1157*72/72.27 bp (didot point) [about 1.06601110141206 bp]
      ## debug $_;
        debug "Applying ${E1}BoundingBox$from T-$bbtype: $llx $lly $urx $ury";
      debug "At end $1BoundingBox";
  debug "Compression: $::opt_compression";
      debug "Computing BBox info from non-EPS PS file";
      # debug "cut_offset=$cut_offset;";
        debug "Cutting after showpage at $cut_offset -> $bytes_left";
        debug "Doing a bit-by-bit copy";
debug "Doing --AntiAlias=$::opt_antialias" if $::opt_antialias ne 'no';
debug "Doing --Duplex $::opt_duplex" if $::opt_duplex ne 'force-unknown';
debug "Doing --PaperSize $::opt_papersize" if $::opt_papersize ne 'force-unknown';
debug "Doing --Resolution $::opt_resolution" if $::opt_resolution ne 'force-unknown';
  debug "Done OK, created $FileFormat file $OutputFilename (".(-s _)." bytes)";
  debug "Done OK, stdout is $FileFormat"
      # debug "end_count=$end_count;";
    debug "Execing: $progname  @extra @_";
      debug "Final corrected (HiRes)BoundingBox: $new_bbox";
      debug "Final (HiRes)BoundingBox: $new_bbox";
    debug "fixed /Tumble true (short).";
      debug "Ghostscript compute pipe: $gs3";
  debug "Ghostscript dup pipe: $gs2";
  debug "Ghostscript ps2ljet command: $GS  $GSOPTS";
  debug "Ghostscript ps2ljet pipe:", $pipe;
  debug "Ghostscript ps2pdf command: $GS  $GSOPTS";
  debug "Ghostscript ps2pdf pipe:", $pipe;
  debug "Ghostscript ps2raster pipe:", $pipe;
  debug "Ghostscript ps2sampled command: $GS  $GSOPTS";
        debug "Got PaperSize: @L";
      debug "Ignoring ${E1}BoundingBox$from T-$bbtype: @L";
  debug "Input filename:", $InputFilename;
  debug "Input file: standard input";
        debug "MAC \\r detected";
	debug "new /MediaBox destroyed.";
    debug "no need to fix to /Tumble.";
      # debug "Offset:", $xoffset, $yoffset; # no new information, see -$llx, -$lly
      debug "Old (HiRes)BoundingBox: $old_bbox";
	debug "old /MediaBox destroyed.";
debug "Output FileFormat: $FileFormat";
  debug "Output filename: $OutputFilename";
  debug "Output file: standard output";
      debug "PaperSize wd=${papersize_x}bp ht=${papersize_y}bp" if defined $papersize_x;
        debug "pdftops bbox pipe: $cmd";
      # debug "pop_count=$pop_count;";
      debug "Running: @args";
        debug "Running pipe: $cmd";
      #debug "Running: $progname  @extra @_";
  debug "Running: $progname  @extra @_";
  debug "Scaling down PNM by 3x3";
  debug "Scanning header for BoundingBox";
  debug "Strongest BoundingBox comment:", $BBprint;
    debug "Temp input file: $InputFilename";
  debug "Temp output file: $temp_out_fn";
    # debug "Trying BoundingBox T-$bbtype: $llx $lly $urx $ury";
#   --debug:          verbose debug informations       (default: $bool[$::opt_verbose])
	debug "warning: double /MediaBox not found at $offset";
    debug "warning: /Duplex /Tumble settings not found"
    debug "warning: gs failed to locate double /MediaBox";
    # Decreasing precedence of various BoundingBoxes:
### default option values
  !defined $FileFormat and ($OutputFilename!~m@[.]([^/.]+)\Z(?!\n)@ or
  !defined($FileFormat=$fmt_exts{lc$1}));
  !defined $::opt_antialias;
        !defined $OutputFilename and $opts_ok;
      def % overwrite it in systemdict
    delete $tmpfiles{$_[0]};
 * Detecting of cygwin perl
/DICTCOUNT countdictstack def
      die "$0: error showing doc\n" unless close PIPE;
  die "$0: exec ($cmd) failed: $!\n" if !exec $cmd;
      die "$0: $!\n" unless print F "% this is temporary gs command file created by $program".'
  # die $after_correct;
      # die $cmd;
  ##die $cmd;
        #die defined $L[1];
  # die defined $urx;
      die "full row expected1\n" if $wd3!=read FIN, $l1, $wd3;
	die "full row expected2\n" if $wd3!=read FIN, $l2, $wd3;
	  die "full row expected3\n" if $wd3!=read FIN, $l3, $wd3;
        die if is_page1_stop();
    #die if length($S)<OVERLAP_LENGTH; # happens sometimes
    die if !print F $phd;
      die if !print F $ret;
    die if ($saved_pos=tell IN)<0;
    die "$InputFilename: premature HP PJL UEL header" if length($S)==0;
  # die is_set_pagesize_ok();
        #die "NOR";
    #die $no_translate;
  #die $offset;
      ## die "$papersize_x;;"; # PDF -sPAPERSIZE=a4
  die "PNMraw expected\n" if read(FIN,$hd,2)!=2 or $hd!~/\AP[456]/;
      ## die $res;
  die "$s$0: @_\n";
#die $to_OUT;
    die "unexpected EOF" if !defined($C=getc($fh));
    die unless 32<read F, $pageobj, 4096;
  die unless 32<read F, $pageobj, 4096;
      die unless $allow_adsc_bb==1;
    die unless binmode F;
  die unless binmode F;
die unless binmode OUT;
      die unless close F;
    die unless close F;
  die unless close F;
    die unless close FCO;
    die unless close TI;
        die unless close TP;
    die unless close TP;
	  die unless close TP;
    die unless open FCO, "< $temp_out_fn";
    die unless open F, "+< ".fix_pipe_out(undef);
  die unless open F, "+< ".fix_pipe_out(undef);
  die unless open FIN, "< ".fix_pipe_out(undef);
  die unless open F, "> $scale3_pnm_fn";
    die unless open IN, "< $tifn";
      die unless open PIPE, "$cmd|";
    die unless print F $pageobj;
	die unless print F $pageobj;
  die unless print F "% this is temporary gs command file created by $program".'
    die unless print TI $preprint, $c;
    die unless seek F, 0, 0;
	die unless seek F, $offset, 0;
    die unless seek F, $offset+=0, 0;
      die unless seek(IN, -4096, 2) or seek(IN, 0,0); # Dat: 0,0 for short files
      die unless seek(IN, $bytes_left-4096, 1);
    die unless seek IN, length($preprint), 0;
die $usage if !@ARGV or (1==@ARGV and $ARGV[0] eq '-h' or $ARGV[0] eq '--help'
  die "$usage\U!\E!\U!\E Error: @_\n";
    # die "$xoffset $yoffset $::opt_below";
        do {
      $do_atend=1
        $do_bb_line->($_," from ADSC");
	  $do_bb_line->("%%HiResBoundingBox: $force_hiresbbox_value"," from ADSC");
        # $do_bb_line->("set 0 0 $papersize_x $papersize_y"," from /PageSize");
        $do_bb_line->("set 0 0 $papersize_x $papersize_y"," from /PageSize"); # does ($llx,$lly,$urx,$ury)=(0,0,$papersize_x,$papersize_y);
      DOCUT { (cut-offset==) ..print MAINFILE fileposition === flush } if
/DOCUT false def
/DOCUT true def
Doesn't depend on the filename or extension of the input file.
#** Does overwrite $temp_out_fn. Fine.
          do_exec 'pdftops', '-paperw', myfloor($L[0]+0.5), '-paperh', myfloor($L[1]+0.5), $InputFilename, $OutputFilename;
          do_exec qw(pdftops -f 1 -l 1 -eps --), $InputFilename, $OutputFilename;
    do_exec('sam2p', ("$tfmt:", '--', $InputFilename, $OutputFilename));
       do_force_papersize:
.do if '\*[pts-dev]'tty' \{\
.do if '\*[.T]'ascii8' .ds pts-dev tty
.do if '\*[.T]'ascii'  .ds pts-dev tty
.do if '\*[.T]'cp1047' .ds pts-dev tty
.do if '\*[.T]'latin1' .ds pts-dev tty
.do if '\*[.T]'nippon' .ds pts-dev tty
.do if '\*[.T]'utf8'   .ds pts-dev tty
    $doing_atend=1; goto read_again;
#      * Doing --PaperSize unchanged
       do_input_pdftops: # come from EPS: and markedEPS:
#      * Done OK, created PDF file debrecen-hyph.pdf (338451 bytes)
      # Do not translate (set (0,0) to the origin) with --below or multi-page
# Don't touch/remove any lines above; http://www.inf.bme.hu/~pts/justlib
  $do_scale3_pnm=($::opt_antialias eq'scale3no' or $::opt_antialias eq 'scale3yes');
          do_system 'pdftops', '-paperw', myfloor($L[0]+0.5), '-paperh', myfloor($L[1]+0.5), $InputFilename, $tpfn;
  do_system @pnm2sampled_cmd; # Dat: uses @extra -- really share that?
    do_system $progname, @_;
        do_system qw(pdftops -f 1 -l 1 -eps -- ), $InputFilename, $tpfn;
    do_system('sam2p', ("$tfmt:", '--', $InputFilename, $tpfn));
/DownsampleColorImages false
/DownsampleGrayImages false
/DownsampleMonoImages false
.ds pts-dev \*[.T]
    % dup ===
      dup 0 3 getinterval (%%[) eq{
        dup 0 get type dup /integertype eq exch /realtype eq or {
    dup 1 eq {
          dup 1 get type dup /integertype eq exch /realtype eq or {
dup/= exch def /print exch def
      dup length 2 ge {
    dup length 3 ge{
      dup length array copy cvx % make a copy for subsequent invocations
#     duplexing psnup -2)
          $duplexi ||= $::opt_duplex eq 'default-simplex' ? 2 : 1;
  /Duplex { % [. .] PageSize -
    dup ..paper.redef exch known {pop} {
      dup ..paper.redef exch null put
    dup type /arraytype eq {
    dup type /booleantype eq {
  dup type /nametype eq { dup xcheck not { % Dat: fixed
  dup type/stringtype eq{
      dup userdict exch 2 copy known { 2 copy get
during the EPS to EPS conversion, so its output is often more compatible
        " -dWRITESYSTEMDICT -dNOPAUSE -sDEVICE=bbox -sFN=".fnq($InputFilename)." ".fnq($tfn)." 2>&1";
        else {
      } else {
      else {
    } else {
  } else {
  else {
} else {
	} else {
    else { $after_correct.="1 dict dup /HWResolution [@{[split/[x,]/,$::opt_resolution]}] put setpagedevice\n" }
} else { # BUGFIX for `a2ping.pl -v --antialias=no negyzet.eps negyzet.png' at Wed Jul 20 21:34:29 CEST 2005
  } else { $bytes_left-=length($S) }
        else { debug "unknown line ($line)" }
    } else { die } # unreachable    
  else { error "sam2p doesn't support our FileFormat $FileFormat" }
      else { errorUsage "--Resultion expects unchanged | force-unknown | DPI | XDPIxYDPI" }
    else { errorUsage "Too many arguments (multiple input/output files?)" }
      else { errorUsage "Unknown FileFormat tag: $fmtag" }
	} else { goto do_input_pdftops }
    } else { $headEPSF=" $1" }
	else { $ht--;
      } else { $in_mac_p=0 }
} else { open_OUT() }
  } else { $::opt_duplex='force-unknown' }
  } else { $::opt_papersize='force-unknown' }
      else { $optval=$2 }
    else { $S.=$C }
    } else { $S=<IN> }
  } else { # source file is in some raster graphics format
                   else { $translate="gsave "; $need_grestore=1 }
      } elsif ($? !=0) { die $res }
    } elsif (/^%(?:ADO_DSC_|AI\d_)/) { # Dat: example: %ADO_DSC_Encoding: MacOS Roman
    } elsif (/^$BBregex$BBValues/oi) { ### BoundingBox with values
    } elsif (/^$BBregex\s*\(atend\)/oi) {
    } elsif ($bytes_left<0) {
      } elsif ($C eq "\n") { # Dat: \r\n, DOS CRLF
      } elsif (/^%%Creator:\s*ADOBEPS/i) { # ADOBEPS4.DRV
    } elsif (/^%%Creator:\s*(.*)/i) {
      } elsif (/^%%Creator:\s*MetaPost\b/i) {
    elsif ($C=~y@ \n\r\t@@) { last if length($S)!=0 }
} elsif (!defined $InputFilename) {
    } elsif (!defined $InputFilename) { $InputFilename=$ARGV[$I]; next }
} elsif (!defined $OutputFilename) {
    elsif (!defined $OutputFilename) { $OutputFilename=$ARGV[$I]; next }
  } elsif ($do_atend) { # seek to near EOF and try again
    } elsif (/^%%(?:DocumentPaperSizes|PageOrder|DocumentMedia):/i) {
    } elsif ($doing_atend or /^%%End/) {
      } elsif (/^%%EndDefaults\b/i) { # EPSI created by ImageMagick
    } elsif (!exists $argopt1{$optname} and !exists $argnone{$optname} and !exists $argmaybe{$optname}) {
      elsif (exists $fmt_aliases{$fmtag}) { $FileFormat=$fmt_aliases{$fmtag} }
      } elsif ($FileFormat eq 'EPS' or $FileFormat eq 'markedEPS') { # convert PDF to EPS
} elsif ($FileFormat eq 'PBM' or $FileFormat eq 'PGM' or $FileFormat eq 'PPM'
} elsif ($FileFormat eq 'PCL5') {
      } elsif ($FileFormat eq 'PDF1') { # Dat: remove extra pages by running pdftops and gs -sDEVICE=pdfwrite
      } elsif ($FileFormat eq 'PS' or $FileFormat eq 'markedPS') {
    } elsif (/^%\*Font:\s+(\S+)\s+/) { # mpost(1) output
} elsif (-f $OutputFilename) {
        } elsif ($have_convert_p) {
  } elsif ($hd eq 'P5') {
  } elsif ($hd eq 'P6') {
  } elsif ($iff eq "?") {
  } elsif ($iff eq "P") {
  } elsif ($iff eq "UEL") { # HP PJL UEL, untested
      elsif (index(":=",substr($2,0,1))>=0) { $optval=substr($2,1) }
      } elsif (is_ok_sam2p() or is_via_sam2p()) {
      #} elsif (!is_page1_stop() and defined $papersize_x and defined $papersize_y) {
} elsif (is_sampled()) {
  elsif (is_via_sam2p() or is_ok_sam2p()) {$tfmt=$FileFormat; $::opt_approx=1}
        elsif (length($line)==0 or $line=~/^(?:Copyright |This software )/) {}
  } elsif (length($S)>=$bytes_left) {
        elsif ($line=~/^add-showpage==\d+$/) { } # !!
        elsif ($line=~/^cut-offset==(\d+)$/) { $cut_offset=$1+0 }
        elsif ($line=~/^end-count==(\d+)$/) { $end_count=$1+0 }
        elsif ($line=~/^Loading (\S+) font from.*[.][.][.]/) { debug "GS builtin font used: $1" }
        elsif ($line=~m@^set-called-(\d+)==/(\S+)$@) {
        elsif ($line=~/^papersize-x==([-+0-9eE.]+)$/) { no integer; $papersize_x=$1+0 }
        elsif ($line=~/^papersize-y==([-+0-9eE.]+)$/) { no integer; $papersize_y=$1+0 }
        elsif ($line=~/^pop-count==(\d+)$/) { $pop_count=$1+0 }
        elsif ($line=~/^resolution-x==([-+0-9eE.]+)$/) { no integer; $resolution_x=$1+0 }
        elsif ($line=~/^resolution-y==([-+0-9eE.]+)$/) { no integer; $resolution_y=$1+0 }
        elsif ($line=~/^sides-dumplex==false$/) { $duplexi=2 }
        elsif ($line=~/^sides-duplex==true$/) { $duplexi=1 }
        elsif ($line=~/^sides-tumble==false$/) { $tumblei=2 }
        elsif ($line=~/^sides-tumble==true$/) { $tumblei=1 }
} elsif ($::opt_antialias ne 'no' and !is_has_antialias()) {
    } elsif ($::opt_below) {
} elsif ($::opt_duplex eq'default') { $::opt_duplex='force-unknown' }
        elsif ($::opt_duplex eq 'force-long' ) { do_long: $after_correct.="2 dict dup /Duplex true put dup /Tumble false put setpagedevice\n" }
        elsif ($::opt_duplex eq 'force-short') { do_short: $do_fix_tumble=1; $after_correct.="2 dict dup /Duplex true put dup /Tumble true put setpagedevice\n" }
        elsif ($::opt_duplex eq 'force-simplex') { do_simplex: $after_correct.="1 dict dup /Duplex false put setpagedevice\n" }
    } elsif ($optname eq "antialias") {
    elsif ($optname eq "approx") { $::opt_approx=$optval }
    } elsif ($optname eq "bboxfrom") {
    elsif ($optname eq "below")  { $::opt_below =$optval }
    elsif ($optname eq "compression") {
    elsif ($optname eq "duplex") {
    elsif ($optname eq "exact")  { $::opt_exact =$optval }
    } elsif ($optname eq "extra") { push @extra, $optval }
    elsif ($optname eq "filter") {
    } elsif ($optname eq "gs-ccmd") {
    } elsif ($optname eq "gs-cmd") {
    elsif ($optname eq "gsextra") { push @gsextra, $optval }
    elsif ($optname eq "gs")     { $FileFormat=$optval ? 'PDF1' : 'markedEPS' }
    elsif ($optname eq "help") { show_doc() }
    elsif ($optname eq "hires")  { $::opt_hires =$optval }
    elsif ($optname eq "keepoldmediabox")  { $::opt_keepoldmediabox=$optval }
    elsif ($optname eq "lossy")  { $::opt_lossy =$optval }
    } elsif ($optname eq "noantialias") {
    elsif ($optname eq "nocompress") { $::opt_compression='none' }
    elsif ($optname eq "noverbose") { $::opt_verbose=0 }
    } elsif ($optname eq "outputfile") {
    } elsif ($optname eq "papersize" or $optname eq"paper") {
    } elsif ($optname eq "resolution") {
    elsif ($optname eq "threshold")  { $::opt_threshold=$optval+0 } # Imp: accept only int 0..256
    } elsif ($optname eq "tmpunlink") { $tmpunlink_p=$optval }
    elsif ($optname eq "verbose") { $::opt_verbose++ }
} elsif ($::opt_papersize eq'default') { $::opt_papersize='unchanged' }
      elsif ($::opt_papersize ne 'unchanged') {
    } elsif ($opts_ok and $ARGV[$I]=~/\A--+(\w[\w-]*)(?:[:=](.*))?\Z(?!\n)/s) {
    } elsif ($opts_ok and $ARGV[$I]=~/\A-(\w)(.*)\Z(?!\n)/s) {
    } elsif ($opts_ok and !defined $FileFormat and defined $InputFilename and $ARGV[$I]=~s@\A(\w+):@@) {
      elsif ($optval=~/^(\d+(?:[.]\d+)?[x,]\d+(?:[.]\d+)?)\Z(?!\n)/) { }
      elsif ($optval=~/^(\d+(?:[.]\d+)?)\Z(?!\n)/) { $optval="$1x$1" }
    } elsif (/^%%Page:/i and !$creator_metapost_p) { # at Thu Sep 25 15:59:52 CEST 2003
  } elsif ($pageobj=~m@\033&l0S@) {
    } elsif (/^%%Pages:/i) {
    } elsif (/^%%Pages:\s+(\d+)\s*/i and !$had_pages) { # Not `%%Pages: (atend)'
  elsif ($S=~/\A\12[\0-\005]\001[\001-\10]/) { $iff="PCX" }
  elsif ($S=~/\A[\36-\77](?:\001[\001\11]|\0[\002\12\003\13])\0/) { $iff="TGA" }
  elsif ($S=~/\A(\377+\330)\377/) { $iff="JPEG" }
  elsif ($S=~/\ABM/) { $iff="BMP" }
  elsif ($S eq "\033%-1") { $iff="UEL" }
  elsif ($S eq "\305\320\323\306") { $iff="DOS-EPSF" }
  elsif ($S eq "FORM") { $iff="LBM" }
  elsif ($S eq "GIF8") { $iff="GIF" }
  elsif ($S eq "MM\000\052" or $S eq "II\052\000") { $iff="TIFF" }
  elsif ($S eq "/* X" or $S eq "/*XP") { $iff="XPM" }
  elsif ($S=~m@\AP([1-6])[\s#]@) { $iff="PNM" }
      } elsif ((substr($_,0,2)ne'%%' and substr($_,0,7)ne'%*Font:' and
    } elsif (substr($_,0,5) eq '%EPS ') { # epsincl.mp
  elsif (substr($S,0,1)eq'%') { $iff="P" } # PS, EPS or PDF
/EmbedAllFonts true
        # Emits ``%%BoundingBox 1 1 ...' instead of `0 0'
 * emulates work for PDF input
/EncodeColorImages true
/EncodeGrayImages true
/EncodeMonoImages true
  #     %%EndComments
      #: end-count==1
# End of Adobe-defined page sizes
    ### end of header
end % systemdict
      # -- `end' the dictionary stack after the 1st page
END { unlink keys %tmpfiles; }
END { unlink $unlink_OutputFilename if defined $unlink_OutputFilename }
  $ENV{LESS}="$ENV{LESS}R"; # show ANSI escapes
  $ENV{LESS}="" if !defined $ENV{LESS};
  $ENV{PAGER}=$pager;
  "%%EOF\n";
  'EPS'=>[FL_PAGE1_STOP],
#      (epstopdf 2.7 Copyright 1998-2001 by Sebastian Rahtz et al.)
(epstopdf 2.7 Copyright 1998-2001 by Sebastian Rahtz et al.)\n";
      error $?==11 ? "segmentation fault in $GS" : "not a GS output from $GS ($?)"
error "Bad --Resolution=$::opt_resolution" if $::opt_resolution ne 'unchanged'
error "--below=0 invalid for FileFormat $FileFormat" if !$::opt_below and
error "--below=1 invalid for FileFormat $FileFormat" if $::opt_below and
        error "BoundingBox not found in pdftops output" if !@L;
      error "cannot create from PDF: FileFormat $FileFormat";
    # error "Cannot leave line `: (atend)'" if ($saved_pos=tell IN)<0 or !seek(IN,0,1);
    error "Cannot open temp input: $tifn" unless open TI, "> $tifn";
  error "Cannot open temp output: $temp_out_fn" unless open OUT, "> $temp_out_fn";
        error "Cannot open temp pipe dest: $tpfn" unless open TP, "> $tpfn";
    error "Cannot open temp pipe dest: $tpfn" unless open TP, "> $tpfn";
	  error "Cannot open temp pipe dest: $tpfn" unless open TP, "> $tpfn";
        error "Cannot open temp pipe src: $tpfn" unless open IN, "< $tpfn";
    error "Cannot open temp pipe src: $tpfn" unless open IN, "< $tpfn";
	  error "Cannot open temp pipe src: $tpfn" unless open IN, "< $tpfn";
  # error "Cannot save output: $!" unless open SAVEOUT, ">&OUT"; # always STDOUT; maybe not open yet
    error "Cannot set --Duplex for FileFormat $FileFormat (must be markedPS or PCL5)"
    error "Cannot set --PaperSize for FileFormat $FileFormat"
error "Cannot set --Resolution for FileFormat $FileFormat (must be markedPS or sampled)"
  error "Cannot write outfile '$OutputFilename'" unless
  # error "closing filter out: $? $!" unless close OUT;
error "closing gs filter: $? $!" unless close OUT;
error "closing IN: $?" unless close IN;
        error "closing PIPE: $?" unless close PIPE;
      error "couldn't find end of PS/PDF header line in $max bytes\n" if
    error "exec failed: $!";
        error "expected PS document" if !defined($line=<PIPE>) or $line!~/^%!PS-Adobe-\d.*EPSF-\d/;
          error "input error: $!" unless print OUT;
    error "$InputFilename: bad DOS EPS" if $eheader ne "\305\320\323\306" or $ps_ofs<30;
    error "$InputFilename: bad HP PJL UEL header: ".(~chomp($S)&&$S)
  error "$InputFilename: empty file" if 0==length($S);
    error "$InputFilename: EPS DSC must be %!PS-Adobe" if substr($S,0,4)ne'%!PS';
      # error "$InputFilename: won't read a PDF file";
        error "Missing EPSI %%EndPreview" if !length($_=readIN);
  error "missing $OutputFilename"
  #error "$OutputFilename: won't overwrite input file with itself"
        error "pipe: $!" unless open PIPE, "$cmd |";
      #error "prog $progname failed: $? $!"
  error "prog $progname failed: $? $!"
    # error "same input and output file: $InputFilename";
      error "temp open $tfn: $!" unless open F, "> $tfn";
  error "temp open $tfn: $!" unless open F, "> $tfn";
    error "unknown input image format: $InputFilename";
      errorUsage "Argument expected for --$optname" if $I==@ARGV;
  errorUsage "Input filename missing"
      # errorUsage "invalid FileFormat tag: $fmtag" if $fmtag!~s@:\Z(?!\n)@@;
        errorUsage "invalid or unknown for --papersize" if !@L;
      errorUsage "Multiple --gs-ccmd" if defined $::opt_gs_ccmd;
      errorUsage "Multiple --gs-cmd" if defined $::opt_gs_cmd;
      # errorUsage "Multiple input filenames" if defined $InputFilename;
        errorUsage "Multiple output filenames" if defined $OutputFilename;
      errorUsage "Multiple output filenames" if defined $OutputFilename;
      errorUsage "No argument expected for no --no$optname=$optval" if defined $optval;
    errorUsage "No argument expected for --$optname=$optval" if exists $argnone{$optname} and defined $optval;
      errorUsage "--$optname expects one of: @{[keys%vals_antialias]}" if !exists $vals_antialias{$optval};
      errorUsage "--$optname expects one of: @{[keys%vals_bboxfrom]}" if !exists $vals_bboxfrom{$optval};
      errorUsage "--$optname expects one of: @{[keys%vals_compression]}" if !exists $vals_compression{$optval};
      errorUsage "--$optname expects one of: @{[keys%vals_duplex]}" if !exists $vals_duplex{$optval};
errorUsage "please specify <outformat>" if
  errorUsage "Too many arguments (multiple input/output files?)" if $I!=@ARGV;
      errorUsage "Unknown option --$optname, see --help"
error "write OUT" if !print OUT $to_OUT;
      #      etc. ADSC comment override the bbox computed by -sDEVICE=bbox.
  #     etc. just after the %%BeginSetup line (or, if missing, puts it in
eval '(exit $?0)' && eval 'PERL_BADLANG=x;export PERL_BADLANG;: \
eval 'setenv PERL_BADLANG x;exec perl -x -S -- "$0" $argv:q;#'.q+
          "%%ExactBoundingBox: $llx $lly $urx $ury\n" if myfloor($llx)!=$llx
    #   --exact mode: ExactBoundingBox BoundingBox HiResBoundingBox
    #   --exact mode: ExactBoundingBox HiResBoundingBox BoundingBox
# Examined: dvips, gs, libpaperg
Example: look for HiResBoundingBox and produce corrected PostScript:
Examples for producing 'test.pdf':
    exch dup ..sdict exch known { % run all keys known in ..sdict
      } { exch pop pop {} } ifelse
        exec($cmd);
;exec perl -x -S -- "$0" ${1+"$@"};#'if 0;
        exit 0;
      exit 0;
  exit(0);
  exit 125;
    # $ext=$1 if $InputFilename=~/[.](\w+)\Z(?!\n)/; # never true
  # $ext=$1 if $InputFilename=~/[.](\w+)\Z(?!\n)/; # never true
extension of the output file determines the FileFormat (I<outformat>).
--extra=        extra arg to external prg (i.e pdftops)
Extra output formats are PNG, XWD, BMP, TIFF, JPEG, GIF and XPM. To
    $extra_trailer="";
feed crap in, you get crap. But you can supply the
    f filter  d verbose  v verbose  debug verbose  p papersize
         : $FileFormat eq'markedPS' || $FileFormat eq 'PS' ? 'PS' # Dat: emits no /PageSize
    $FileFormat eq 'PBM' && $::opt_antialias eq 'no' ? 'pbmraw' : 'pgmraw';
         : $FileFormat eq'PDF1' || $FileFormat eq 'PDF' ? 'PDF'
  $FileFormat ne 'markedEPS';
  $FileFormat='PDF1' if !defined $FileFormat;
      # file formats.
file matters if I<outformat> is missing from the command line: then the
#      * Final BoundingBox: 0 0 596 842
      # -- find the end of the 1st page in the code, and remove everything after it
  # -f $InputFilename or error "input file missing: $InputFilename"; # Imp: named pipe?
first converted to PS or EPS, then processed by B<a2ping.pl>, then
  fix_close_out();
    fix_pipe_in($ext, "", 1); # Dat: defined later
  fix_pipe_in ".img", $S, 0;
      fix_pipe_in 'i.ps', "%!$headPS\n", 0;
    fix_pipe_in "j.ps", $to_OUT, 0;
        fix_pipe_in ".pdf", $S, 0;
        fix_pipe_in ".pdf", $S, 0; # in case of stdin
  FN (r) file pdfopen begin
  $fn=~s@'@\\'@g if $quote eq "'";
  #     FontDirectory/LMRoman12-Regular known{/LMRoman12-Regular findfont dup/UniqueID
      $fontsdefs.="$_\n"; # put in front (before `gsave ... translate')
      $fontsnames{$1}=1;
  } forall
}forall} forall
	$force_hiresbbox_value="0 0 @L";
 * forces BoundingBox to be an integer
  force-short unchanged default-simplex default-long default-short);
#** Force this value for %%HiResBoundingBox if a %BoundingBox is read
for Elsevier Science. B<epstopdf> contained extra tricks from Hans Hagen's
  for ($I=0; $I<@ARGV; $I++) {
format based on the first few bytes of the file. The name of the output
          for my $dir (split/:/,$ENV{PATH}) {
        for my $dir (split/:/,$ENV{PATH}) {
    for (my $I=0; $I<@papers; $I+=3) {
  for (my $I=0; $I<@papers; $I+=3) {
      for my $line (split/\n/, $res) {
  for my $pageri ((defined $ENV{PAGER} ? $ENV{PAGER}: ''),'less','most','more','view -  ','vim -R -  ','vi -  ','joe -rdonly -asis -','pager') {
  for my $p (@_ ? @_ : qw{get_bits_msb c_floatval c_numval c_intval}) { *{$package."::$p"}=\&{$p} }
  #     front of the first %%Page). We'd like this execution order: CUPS,
 * fully supports filtering (stdin and/or stdout), PDF and PCL5 output to
  #     % Generated by MetaType1 (a MetaPost-based engine)
      { /get exec /pop (\nset-called-0==) ..print === flush } % dump
### get input and output filename
# !! Ghostcript compute pipe too slow
### ghostscript command name
#      * Ghostscript compute pipe: gs -dSAFER -dWRITESYSTEMDICT -dNOPAUSE -sDEVICE=bbox                                                                                                                                    -sFN=debrecen-hyph.ps /tmp/a2ping_pl-16977-298938572-c.tgs 2>&1
Ghostscript (GS), B<pdftops> and B<sam2p>. B<a2ping> fixes many glitches
#      * Ghostscript ps2pdf command: gs -dSAFER  
#      * Ghostscript ps2pdf pipe: gs -dSAFER -q -dBATCH -sDEVICE=pdfwrite  -sOutputFile                                                                                                                                   =debrecen-hyph.pdf -
  'GIF'=> [FL_PAGE1_STOP|FL_SET_PAGESIZE_OK|FL_NEED_SHOWPAGE|FL_SAMPLED|FL_HAS_ANTIALIAS|FL_VIA_SAM2P], # Imp: disable antialias for few colors?
        goto do_force_papersize
          goto do_long if $tumblei!=1;
          goto do_short;
          goto do_simplex if $duplexi!=1;
        goto SCAN_AGAIN
    goto SCAN_AGAIN
	  goto SCAN_AGAIN
        goto SKIP_BBOX_DISC;
/GrayImageFilter /DCTEncode
/GrayImageFilter /LZWEncode
	# ^^^ grayscale>=$::opt_threshold will be white
  (grep{'refs'eq$_}@_ && 2)|
  (grep{'subs'eq$_}@_ && 0x200)|
  (grep{'vars'eq$_}@_ && 0x400)|
  ("grestore\n"x$need_grestore),
    gs-ccmd 1
--gs-ccmd=      path to Ghostscript, 4 bbox calc  (def: gs or gswin32c)
--gs-cmd=       path to Ghostscript               (def: gs or gswin32c)
#$GS.= " -dSAFER"; # -dWRITESYSTEMDICT
--gsextra=      extra arg to gs
$GS=$::opt_gs_cmd if defined $::opt_gs_cmd;
# $GSOPTS.=" -r72 -sPAPERSIZE=a4 "; # default -- will be overridden by `setpagedevice'
  GS_PDF_ProcSet begin
  # ^^^ GS raster default
            $H{$2}=1;
          $have_convert_p=0;
      : ($hd eq 'P6' ? 'P6' : 'P5')."\n# reduced-3x3\n".
=head1 AUTHORS
=head1 DESCRIPTION
=head1 EXTERNAL PROGRAMS
=head1 HISTORY
=head1 MISC
=head1 NAME
=head1 SYNOPSIS
=head1 TIPS AND TRICKS
=head2 1999/05/06 v2.5 (Heiko Oberdiek)
=head2 2000/11/05 v2.6 (Heiko Oberdiek)
=head2 2001/03/05 v2.7 (Heiko Oberdiek)
=head2 2003/02/02 (Szab
=head2 2003/04/16 (Szab
=head2 2003/04/26 (Szab
=head2 2003/09/25 (Szab
=head2 2003/12/02 (Szab
=head2 2004/02/10 v2.77 (Szab
      $headEPSF=" EPSF-3.0";
    $headEPSF="" if $FileFormat ne 'EPS' and $FileFormat ne 'markedEPS';
  $_=$header="";
  $header=$S;
  $header=~s@\r\n?\Z(?!\n)@@;
    $headPS=$1 if $header=~s/(PS-Adobe-[.\d]+)$//;
# --- help functions
    #   -hi -ex mode: ExactBoundingBox==HiResBoundingBox BoundingBox
    #   -hi -ex mode: ExactBoundingBox HiResBoundingBox BoundingBox
      #: %%HiResBoundingBox: 56.645998 41.849999 538.811984 782.351976
 * %%HiresBoundingBox corrected to %%HiResBoundingBox
    #   --hires mode: HiResBoundingBox BoundingBox ExactBoundingBox
    #   --hires mode: HiResBoundingBox ExactBoundingBox BoundingBox
  # HP PCL5e gs header "\033E\033&l2A\033&l1S\033&l0o0l0E\033&l-180u36Z"
  /HWResolution { % [. .] PageSize -
          } if
        } if
      } if
    } if
      if (0!=length($ARGV[$I])) {
      #if 0!=system $progname, @extra, @_; # Dat: non-zero exit() or not found
    if 0!=system $progname, @extra, @_; # Dat: non-zero exit() or not found
if (1<length($header)) {
  if ($_[2] or (length($c=readIN(1))!=0 and !seek IN,-1,1)) { # we cannot seek back
      if ($allow_adsc_bb) {
      # if ($allow_bb) {
  if ($approx_p) {
    if ($ARGV[$I]eq '--') {
        if (!/^%%BeginDefaults\b/i) { y@\r@@d; chomp; $after_comments.="$_\n"; last }
    if (/^%%BeginPreview\b/i) { # remove EPSI preview ballast ****pts****
  if ($bytes_left<0) { # unlimited
    if ($bytes_left>4096) {
    if ($C eq'#') { <$fh> } # ignore rest of line
  if ($cmd!~/[|] man -l -\Z(?!\n)/) {
      if ($cut_offset>=0 and ($bytes_left==-1 or $cut_offset<$bytes_left)) {
  if (defined $_[0] and exists $tmpfiles{$_[0]}) {
  if (defined $_[0]) { read_error if 0>dem1 read IN, $S, $_[0] }
      if (!defined$C or ($C ne "\n" and $C ne "NONE")) {
if (!defined $InputFilename and defined $OutputFilename) { # --filter
  if (defined $llx) {
      if (defined $papersize_x and ($::opt_bboxfrom eq 'papersize' or ($::opt_bboxfrom eq 'guess' and is_set_pagesize_ok()))) {
        if !defined $res # BUGFIX at Sun Mar  7 18:51:34 CET 2004
  if (!defined $temp_out_fn) {
  if (defined $temp_out_fn) {
  if (defined $tfmt) {}
  if (defined $urx and is_set_pagesize_ok()
    if (!$doing_atend) {
  if ($doing_atend) { # already read (atend); restore file position
  if ($do_scale3_pnm) {
if ($do_scale3_pnm) {
    } ifelse
      if (/^%%EndComments\b/i) {
        if (!/^%%EndDefaults\b/i) { y@\r@@d; chomp; $after_comments.="%%BeginDefaults\n$_\n"; last }
    if (exists $argbool{$optname}) {
    if (exists $argopt1{$optname} and !defined $optval) {
      if (exists $fmts{$fmtag}) { $FileFormat=$fmtag }
            if ((-f"$dir/convert")) { $have_convert_p=1 }
          if ((-f"$dir/pnmquant")) { $have_pnmquant_p=1 }
      if ($FileFormat eq 'PBM') {
if ($FileFormat eq 'PBM' and ($::opt_antialias eq 'scale3yes' or
if ($FileFormat eq 'PCL5' and $do_fix_tumble) {
  if ($FileFormat eq 'PDF1' or $FileFormat eq 'PDF') {
      if ($FileFormat eq 'PDF') { # convert PDF to PDF
if ($FileFormat eq 'PDF' or $FileFormat eq 'PDF1') {
      # if ($FileFormat ne 'EPS' and $FileFormat ne 'PS') { # device-specific (marked)
if ($FileFormat ne 'markedPS' and $FileFormat ne 'PCL5') {
  if $FileFormat ne 'markedPS' and !is_sampled()
  if (%fontsnames) { # !! save .. restore
	if ($force_hiresbbox_value) {
    if ((!grep { -x "$_/man" } @path) or qx(man -l 2>&1)=~/\binvalid option\b/) {
      if (!grep { -x "$_/nroff" } @path) { $man='' } # just write it
    if (grep { -x $_.$pagert } @path) { $pager=$pageri; last }
    if !grep { -x "$_/pod2man" } @path;
  # if (!$had_pages) { debug "Lying %%Pages: 1"; $to_OUT.="%%Pages: 1\n" }
        if (!$have_pnmquant_p) {
        if ($have_pnmquant_p) {
  if ($hd eq 'P4') {
  if ($hd ne 'P4') {
    if ($header!~s/\s+(EPSF-[.\d]+)$// or $::opt_bboxfrom ne 'guess') { # a PS not an EPS already
      if (--$ht==0) { $l2=$l1 }
	if (--$ht==0) { $l3=$l2 } # Imp: adjust 2/3 weight
  } if } if
  if ($iff eq "DOS-EPSF") { # DOS EPSF header
  }if}if}if
If I<inputfile> and I<outputfile> are the same, B<a2ping> copies the
    if ($in_mac_p) {
if ($InputFilename eq '-') {
  if ($InputFilename eq $OutputFilename) {
if (is_need_showpage() and is_page1_stop()) {
      if (!is_page1_stop()) {
  if (is_pdfmark()) {
      if ($is_restored) { $translate="" } # save..restore does gsave..grestore
if (!is_set_pagesize_ok()) {
  if (is_via_sam2p()) {
      if (length($2)==0) { $optval=undef }
      if length($pagedev_mark)!=0;
    if (!length $pager) {
    #if (length($S)<OVERLAP_LENGTH) { $S="$overlap$S"; $overlap=""; }
        if ($line=~/^$BBregex$BBValues/oi) { $do_bb_line->($line," from Compute-GS"); $bbc++ }
if (!$ll_zero and ($FileFormat eq 'PDF' or $FileFormat eq 'PDF1')) { # correct /MediaBox if not (0,0)-based
          if (not exists $H{$2}) {
  if ($offset=~/\A\d+\Z(?!\n)/) {
    if ($old_bbox eq $new_bbox) {
if ($::opt_antialias eq 'scale3no' or $::opt_antialias eq 'scale3yes') {
	if ($::opt_approx) {
	if ($::opt_duplex eq 'force-unknown' or ($::opt_duplex eq 'unchanged' and $duplexi==0)) { $do_fix_tumble=($duplexi==1 && $tumblei==1) }
  if ($::opt_duplex ne'default' and $::opt_duplex ne'force-unknown') {
    if ($::opt_keepoldmediabox) {
       if ($optname eq "help") { die $usage }
      if ($::opt_papersize eq 'force-unknown' or ($::opt_papersize eq 'unchanged' and !defined $papersize_x)) {}
  if ($::opt_papersize ne'default' and $::opt_papersize ne'force-unknown') {
      #if ($::opt_papersize ne 'force-unknown' and $::opt_papersize ne 'unchanged') {
if ($::opt_resolution eq'default') { $::opt_resolution='force-unknown' }
    if ($::opt_resolution eq 'force-unknown' or $::opt_resolution eq 'unchanged') {}
      if ($optval eq "unchanged" or $optval eq "force-unknown") { }
      if ($optval eq "unchanged" or $optval eq "force-unknown") { $::opt_papersize=$optval }
if ($OutputFilename eq '-') {
  #  if $OutputFilename eq $InputFilename;
    if (($OutputFilename=$InputFilename) ne '-') {
  if ($overlap=~s@\r?\n%%Trailer\r?\n(.*?)\Z(?!\n)@\n%%Trailer\n@s) {
      if ($pageobj=~m@\A(.*?/Type\s*/Page\b.*?/MediaBox\s*\[0 0 [^\]]*\].*?)((?:/CropBox\s*\[[^\]]+\]\s*)?/MediaBox\s*\[[^\]]+\])@s) {
      if ($pageobj=~m@\A(.*?/Type\s*/Page\b.*?)(/MediaBox\s*\[0 0 [^\]]*\]).*?/MediaBox\b@s) {
  if ($pageobj=~s@\033&l1S.*@\033&l2S@s) {
if (@pnm2sampled_cmd) { # $scale3_pnm_fn -> $OutputFilename
      if ($res=~/\binvalid combination, no applicable OutputRule\b/) {
      if ($res!~s/\nbbox-success\n\Z(?!\n)/\n/) {
  if ($S=~/\A[a-z]\w+\Z(?!\n)/) {
      if $S!~/\A\\e?%-12345X\@PJL ENTER LANGUAGE\s*=\s*POSTSCRIPT\s*\r?$/i;
  if (scalar keys %tmpfiles) {
    if (!seek IN, $ps_ofs, 1) {
  if ($S eq "\211PNG") { $iff="PNG" }
    if (substr($optname,0,2)eq"no" and exists $argbool{substr($optname,2)}) {
    if substr($pager,-2)eq'  ' or $pager=~/\A(?:view|vim?|joe|emacs|mcedit|nano|nano-tiny|ae)\b/;
  if (substr($pod2man_,0,5)ne 'perl ') {
  if (substr($S,0,1) eq '%') {
    if (substr($S,0,4)eq'%PDF') {
    if ($T eq 'S'
    if ($tfmt eq 'GIF') {
If the bounding box is not right, of course, you have problems. If you
  if ($tmpsig) {
    if ($xoffset==0 and $yoffset==0) { #**** pts ****
If you have an incompatible PS that GS can read but your printer cannot print,
If you have a PS coming from Win32 (often with extension C<.prn>), run
If you need a bigger sampled output file, specify a larger
If your EPS contains a wrong bounding box, you can fix it by running
If you specify B<--> as I<outputfile>, it will be the same as I<inputfile>.
      # -- ignore calls to = setpage setpagemargin setpageparams .setpagesize
I<inputfile> to a temporary location first. However, this usage is
#      /ImagingBBox /HWResolution /HWSize /.MediaSize (we undef all)
# Imp: `a2ping.pl -v jf.eps pdf1: t.pdf' PDF1: must be forced to have --below
        # !! Imp: add full dvips %* font comment when prologues:=1 (design sizes missing :-()
# Imp: also save+restore /pdfmark ??
# Imp: better help and docs
    # ^^^ Imp: can DocumentMedia be non-integer? As of us, it can.
# Imp: careful distinction between PDF and PDF1
# Imp: detect error messages from GS, abort...
# Imp: direct PDF to PCL5 conversion with gs
# Imp: /DocumentMedia seems to screw up sub-pt placement in gv(1)
# Imp: fix bug a2ping -v ~/a2ping_bug.ps a2ping_bug.pdf; running type1fix on
# Imp: fix completely bogus margin and papersize handling:
# Imp: fix /MediaBox an all PDF pages if !$ll_zero
# Imp: gs(704?!) sometimes finds too small bbox, see Univers.eps
# Imp: $header_remove_p ??
# Imp: Htex/a2ping.pa -v ../image/tuzv.ps t.pdf  (1st and second page different)
# Imp: idempotent PS -> PS, add other header
# Imp: --leftright option instead of --below
#      implementation, because gs always outputs the content stream of the PDF
# Imp: --ll x,y command line option
# !! Imp: merge back to a2ping.pa
# Imp: option to `clip' an EPS to the specified bbox -- does file size decrease?
# Imp: option to ignore `%%Orientation: Portrait', which gs respects and rotates by 90 degrees if necessary
        # Imp: option to open pdftops pipe instead of temp file
# Imp: pdfboxes.pl, get offset from gs
# Imp: PDF -> PDF1 conversion with gs -sDEVICE=pdfwrite
# Imp: possibly accept /PageSize from %%DocumentMedia
  # Imp: possibly call an external C program that is faster
# Imp: possibly disable compute-pipe
        # !! Imp: possibly Run MetaPost output through full dvips (texc.pro) when prologues:=0
# Imp: post-process PNG etc. written by sam2p
# Imp: psnup support (-1 -2 -3 -4 ...)
# Imp: remove %%BeginDefaults | %%PageMedia: plain | %%EndDefaults (pdftops(1))
# Imp: respect bbox in METAPOST %! (not EPS), don't use Compute-GS T-
# Imp: respect full /MediaBox for a PDF -> EPS|PDF1 conversion
 * improved bbox discovery
  # Imp: scale down the file in place, ovoid early overwrite
# Imp: sometimes markedEPS for .eps?
# Imp: -sPDFPassword=...
# Imp: use all pdftops + gs + acroread
# Imp: use convert(1) etc.
      # Imp: verify EPS created
  # Imp: why is it lighter than: convert -scale '33.3333%' a3.pbm a3r.pgm
  # Imp: why isn't sam2p(1) PNG -> PNG idempotent?
  'in'=>72, # 1 in = 72 bp (inch)
        $in_mac_p=0; $S.="\r";
        $in_mac_p=1;
      # $InputFilename='-';
  $InputFilename='-';
#      * Input filename: debrecen-hyph.ps
    $InputFilename=$tifn;
        $InputFilename=$tpfn; # '-'
    $InputFilename=$tpfn; # '-'
	  $InputFilename=$tpfn; # '-'
 * input support for PNG JPEG TIFF PNM BMP GIF LBM XPM PCX TGA via sam2p
internal antialiasing, but it usually doesn't improve much. B<=scale3no>
#**   in the C language (without the LU etc. modifiers) -- or undef. Returns
	IN->ungetc(ord($C)) if defined $C;
  is_any_origin_ok();
  !is_any_origin_ok() and $FileFormat ne 'PDF1' and $FileFormat ne 'EPS' and
is going to be really big, you should specify B<--AntiAlias=yes> instead of
  # is missing from some Debian sites that have pod2man.
    /isob0/isob1/isob2/isob3/isob4/isob5/isob6
        is_pdfmark(); # $FileFormat eq 'markedEPS' or $FileFormat eq 'markedPS';
      $is_restored=1 if $FileFormat eq'EPS' or $FileFormat eq'markedEPS';
  (is_sampled() ? 'scale3no' : 'yes') : 'no' if
is used.
      #      itself is smaller.
it through B<a2ping>. It will remove the resolution changes and the
    /jisb0/jisb1/jisb2/jisb3/jisb4/jisb5/jisb6
                  join('  ',map{fnq$_}@args2);
  'JPEG'=>[FL_PAGE1_STOP|FL_SET_PAGESIZE_OK|FL_NEED_SHOWPAGE|FL_SAMPLED|FL_HAS_ANTIALIAS|FL_VIA_SAM2P],
  jpg JPEG  gif GIF  xpm XPM);
just::end}
just::end __END__
 * justlib2
#      ../justlib2/Htex/a2ping.pa --duplex=force-short -v -p:a3 -r force-unknown tuzv.ps t.pdf
 * justlib2-ified doesn't depend on Getopt::Long anymore
just::main;
just run C<a2ping.pl foo.ps PDF: - | a2ping.pl - PS: foo.ps>
  { % <key> <val>
  $L[0]*=3; $L[1]*=3;
        $L[0]=myceil $L[0]; $L[1]=myceil $L[1]; # Dat: pdftops expects integer papersize :-( )
          @L=($1,$2) if /^%%BoundingBox:\s*\S+\s*\S+\s*(\S+)\s*(\S+)\s*$/i and !@L;
          @L=($1,$2) if /^%%(?:Hires|Exact)BoundingBox:\s*\S+\s*\S+\s*(\S+)\s*(\S+)\s*$/i;
      $l1.=substr($l1,-3+length($l1)%3) if length($l1)%3!=0;
      $l1.=substr($l1,-9+length($l1)%9) if length($l1)%9!=0;
      $l1=unpack("B$wd",$l1); $l1=~y@10@\000\377@;  $l1.=substr($l1,-3+length($l1)%3) if length($l1)%3!=0;
	$l2.=substr($l2,-3+length($l2)%3) if length($l2)%3!=0;
	$l2.=substr($l2,-9+length($l2)%9) if length($l2)%9!=0;
      $l2=unpack("B$wd",$l2); $l2=~y@10@\000\377@;  $l2.=substr($l2,-3+length($l2)%3) if length($l2)%3!=0;
	  $l3.=substr($l3,-3+length($l3)%3) if length($l3)%3!=0;
	  $l3.=substr($l3,-9+length($l3)%9) if length($l3)%9!=0;
      $l3=unpack("B$wd",$l3); $l3=~y@10@\000\377@;  $l3.=substr($l3,-3+length($l3)%3) if length($l3)%3!=0;
          last if /^%%EndComments/ or !/^%/;
        last if /^%%EndPreview\b/;
    # later.
    $len-=3;
    $len-=6 if 0==--$len%3;
        length($S)>=$max or !defined($C);
    /lettersmall/note/a0/a1/a2/a5/a6/a7/a8/a9/c0/c1/c2/c3/c4/c5/c6
# lettersmall should be letter with an ImagingBBox of [25 25 587 767].
  #     lines leaving `false' on the stack:
  @L=(@L,@L); # Imp: ..
  @L ? @L : (undef,Htex::dimen::dimen2bp($w),Htex::dimen::dimen2bp($h))
      #  ($llx,$lly)=(0,0);
    ($llx,$lly,$urx,$ury)=(0,0,$urx-$llx,$ury-$lly) if !$::opt_below;
      $ll_zero=0;
      $ll_zero=0; # fix /MediaBox because it become non-(0,0)-based
      $ll_zero=1; # Dat: we do not insert extra /MediaBox here, gs -sDEVICE=pdfwrite will do
      local $/="\r";
MAINFILE cvx exec
/MAINFILE FN (r) file def
    $man=' | man -l -'; # calls $PAGER
      $man=' | nroff -Tlatin1 -mandoc'; # Linux, no need for eqn(1), tbl(1) etc.
 * many bugfixes
 * Many cosmetics: title, usage, ...
  'markedEPS'=>[FL_PAGE1_STOP|FL_PDFMARK], # Imp: should we have FL_SET_PAGESIZE_OK?
  'markedPS'=>[FL_SET_PAGESIZE_OK|FL_PDFMARK|FL_ANY_ORIGIN_OK],
    $markpagedevices="
    $markpagedevices.="1 dict dup /ImagingBBox null put setpagedevice\n";
    $markpagedevices.="1 dict dup /Policies 1 dict dup /PageSize 3 put put setpagedevice\n"; # ripped from pdftops(1)
    $markpagedevices=(length($markpagedevices)!=0 ? "<< $markpagedevices >> setpagedevice\n" : "");
 * MetaPost EPS input fixes for prologues:=0;
  'mm'=>7.2/2.54, # 1 mm = 7.2/2.54 bp (millimeter)
    /monarchenvelope/c5envelope/dlenvelope/folio/quarto
/MonoImageFilter /CCITTFaxEncode                                              
/MonoImageFilter /LZWEncode
  $mul=$bp_mul{$1} if $S=~s/\s*([a-z][a-z0-9]+)\Z(?!\n)// and exists $bp_mul{$1};
 * multi-page output with PS:, PDF:, PCL5:
my $after_code="";
  my $after_comments=""; # after %%EndComments
  my $after_correct="";
  my $allow_adsc_bb=1;
my $already_read=0;
  my($approx_p,$S)=@_;
  my %argbool=qw(hires 1 exact 1 below 1 gs 1 filter 1 tmpunlink 1
  my %argmaybe=qw();  # 0 or 1 arg
  my %argnone=qw(help 1 verbose 1 noverbose 1 nocompress 1 noantialias 1); # 0 arg
  my %argopt1=qw(outputfile 1 duplex 1 resolution 1 extra 1 compression 1 gs-cmd 1
          my @args1=('sam2p','PPM:','--',$InputFilename,'-');
          my @args2=('sam2p',@extra,"$tfmt:",'--','-',$OutputFilename);
      my @args=('sam2p',@extra,"$tfmt:",'--',$InputFilename,$OutputFilename);
      my $bbc=0; # required
{ my $BBprint = "%%BoundingBox:";
my $BBregex='%%(Hi[Rr]es|Exact|)BoundingBox:';
  my($bbtype)='-'; # None
my $BBValues = "\\s*($bbxpatt+)\\s+($bbxpatt+)\\s+($bbxpatt+)\\s+($bbxpatt+)"; # protect backslashes: "\\" gets '\'
  my $bbx="";
my $bbxpatt = '[0-9eE\.\-]';
my %bp_mul;
  my $bsetup=is_page1_stop()?"":"%%BeginSetup\n%%EndSetup\n";
    my $buf;
my $bytes_left=-1; # -1==unlimited
  my $c="";
      my $C;
                             myceil($urx)." ". myceil($ury)."\n";
my $CGS=$GS;
        my $cmd;
      my $cmd=join('  ',map{fnq$_}@args)." 2>&1";
        my $cmd="pdftops -f 1 -l 1 -eps ".fnq($InputFilename)." -";
  my $cmd=$pod2man_.fnq(__FILE__).$man;
my $copyright = "Written by <pts\@fazekas.hu> from April 2003.
  my $count=$_[2];
  my @creator;
  my $creator_adobeps_p=0;
  my $creator_metapost_p=0; # HiResBoundingBox: after EndProlog
      my $cut_offset=-1;
  my $device=$FileFormat eq 'PPM' || is_via_sam2p() ? 'ppmraw' :
my @div9=(0,0,0,0,0,map { $_, $_, $_, $_, $_, $_, $_, $_, $_ } 1..255, 255);
  my $do_atend=0;
  my $do_bb_line=sub { # sub do_bbline($$)
my $do_fix_tumble=0;
  my $doing_atend=0;
my $do_scale3_pnm=0;
      my $duplexi=0;
    my $E1=defined$1 ? $1 : "+";
    my ($eheader,$ps_ofs,$ps_len,$wmf_ofs,$wmf_len,$tif_ofs,$tif_len,$checksum)=
      my $end_count=0;
  my($ext)=$_[0];
    my $ext=$InputFilename=~m@([.][^./]+)\Z(?!\n)@ ? $1 : "";
    my($ext,$preprint)=@_;
my @extra=();
my $extra_trailer="%%Trailer\n";
  my ($fh,$S,$C)=($_[0],"");
my $filedate="2006-11-15"; # my $filedate="2001/03/05";
my $FileFormat=undef;
      my $fmtag=uc$1;
my %fmt_aliases=qw(MARKEDPS markedPS  MARKEDEPS markedEPS  PCL PCL5
my %fmt_exts=qw(eps EPS  epsi EPS  epsf EPS  eps2 EPS  ps PS  ps2  PS
my %fmts=( # Name=>[flags]
  my $fn=$_[0];
  my $fontsdefs="";
  my %fontsnames;
my $force_hiresbbox_value;
  my $gs2="$GS -dNODISPLAY -dBATCH -sFN=".fnq(fix_pipe_out(undef))." -q ".fnq($tfn);
      my $gs3=$CGS. # "-dPAGE1QUIT=".($FileFormat eq 'EPS' or $FileFormat eq 'markedEPS' ? 'quit' : '{}').
my @gsextra=();
my $GSOPTS=join("  ",map{fnq$_}@gsextra);
      my %H;
  my $had_pages=is_page1_stop(); # Dat: don't put `Pages:' to target EPS
        my $have_convert_p;
        my $have_pnmquant_p=0;
  my $hd;
  { my $headEPSF;
my $header;
    my $headPS="PS-Adobe-3.0";
  my $ht=pnm_gettok(*FIN); die "height expected\n" if $ht!~/\A(\d+)\Z(?!\n)/;
  my $iff="?"; # Input File Format
        my $I=length($ret);
  my $imagesopts=($::opt_lossy ? "
my $in_mac_p=0; # 0: "\n" or "\r\n" is line terminator; 1: "\r" is line terminator
my $InputFilename;
{ my($I,$optname,$optval);
my $is_restored=0;
  my($l1,$l2,$l3);
      my @L=($2+0,$3+0,$4+0,$5+0); # convert 0.00 to 0
  my $len=length($_[0]);
        my @L=Htex::papers::any($optval);
        my $line;
  my($llx,$lly,$urx,$ury);
  my ($llx, $lly, $urx, $ury, $after_correct, $fontsdefs, $is_restored) = @_;
my $ll_zero=0; # ($llx,$lly)==(0,0) in the output file
  my $loop=$_[1];
        my @L; # $papersize_x, $papersize_y
  my @L=split/[,x]/,$::opt_resolution;
  my @L=valid_bp($w,$h);
  my $man='';
  my $markpagedevices="";
    { my $max=128;
  my $mul;
    my $mx=pnm_gettok(*FIN); die "max==255 expected, got: $mx\n" if $mx ne '255';
my $need_grestore=0; # 0 v 1
  my $neg=1;
    my $new_bbox="$llx $lly $urx $ury";
    # my $no_translate=$::opt_below;
  my $offset=`$gs2`;
  my $ofn=$do_fix_tumble ? fix_pipe_out('.pcl5') : $OutputFilename;
  my $ofn=$ll_zero ? $OutputFilename : fix_pipe_out('.pdf');
  my $ofn=$OutputFilename;
    my $old_bbox="$llx $lly $urx $ury"; # debug "Old BoundingBox: $old_bbox";
  my $olen=$len/3;
  my %optmap=qw(o outputfile  outfile outputfile  r resolution  h help
  my $opts_ok=1;
my $OutputFilename;
{ my $overlap=""; # keeps OVERLAP_LENGTH chars
  my $package = (caller())[0];
  my $pagedev_mark="";
    my $pageobj;
  my $pageobj;
  my $pager='';
    my $pagert="/$1";
    my @paper=Htex::papers::any("$px,$py");
my @papers=(
      my $papersize_x=undef; # page_width
      my $papersize_y=undef; # page_height
  my @path=split/:+/,$ENV{PATH};
    my $phd=($hd eq 'P5' and $FileFormat eq 'PBM') ? "P4 ".(($wd+2)/3)." ".(($ht+2)/3)."\n"
  my $pipe ="$GS -q -dBATCH -sDEVICE=$device ";
  my $pipe = "$GS -q -dBATCH -sDEVICE=ljet4d $GSOPTS -sOutputFile=".fnq($ofn)." -";
  my $pipe = "$GS -q -dBATCH -sDEVICE=pdfwrite $GSOPTS -sOutputFile=".fnq($ofn)." -";
my @pnm2sampled_cmd;
  my $pod2man_='pod2man --center="a2ping: advanced PS, PDF, EPS converter" ';
      my $pop_count=0;
  my $prog0=$program;
  my($progname)=splice@_,0,1;
my $program = "a2ping.pl";
    my($ps_end, $wmf_end, $tif_end)=($ps_ofs+$ps_len, $wmf_ofs+$wmf_len, $tif_ofs+$tif_len);
    my($px,$py)=($urx,$ury);
my($quote,$GS)=("'","gs");
  # my $res;
      my $res=`$gs3`;
      my $resolution_x=undef;
      my $resolution_y=undef;
      my $res=readpipe($cmd);
  my $ret="";
  my $ret=0;
  my $S;
  my $S=$_[0];
#  my $S=$_[0];
    my $S=$1;
  my $saved_bytes_left;
  my $saved_pos;
  my $save=$is_restored?"save mark\n":"";
my $scale3_pnm_fn;
  my $setpagesize="";
    my($S,$from)=@_;
  my $S=lc$_[0];
  my $s=$title; $title="";
    my $T=!defined($1) ? 'S' : uc substr $1,0,1; # '' || 'H' || 'E'
my $temp_out_fn;
  my $tfmt=$FileFormat eq'markedEPS' || $FileFormat eq 'EPS' ? 'EPS'
      my $tfn=temp_prefix()."c.tgs";
  my $tfn=temp_prefix()."p.tgs";
    my $tifn;
my $title = "$program $Htex::a2ping::VERSION, $filedate -- $copyright\n";
my $tmpdir=exists $ENV{TMPDIR} ? $ENV{TMPDIR} : '/tmp';
my %tmpfiles;
my $tmpsig=1;
my $tmpunlink_p=1;
my $to_OUT="";
	my $tpfn=temp_prefix()."Peps";
	  my $tpfn=temp_prefix()."Pps";
    my $tpfn=temp_prefix()."Psimg";
  my $translate="";
      my $tumblei=0;
      my $undefs="";
my $unlink_OutputFilename;
    # my ($urxh,$uryh)=($urx,$ury);
my $usage=
  my $val=c_numval($S);
my %vals_antialias=map{$_=>1} qw(no yes scale3yes scale3no);
my %vals_bboxfrom=map{$_=>1} qw(adsc compute-gs guess pagesize);
my %vals_compression=map{$_=>1} qw(best none flate zip);
my %vals_duplex=map{$_=>1} qw(force-unknown force-simplex force-long
  my ($W1,$H1)=(defined$_[2]?$_[2]:0,defined$_[3]?$_[3]:0);
  my $wd3=$hd eq 'P4' ? ($wd+7)>>3 : $hd eq 'P5' ? $wd : $wd*3; # bw/grayscale/RGB
  my $wd=pnm_gettok(*FIN); die "width expected\n"  if $wd!~/\A(\d+)\Z(?!\n)/;
  my($w,$h)=($1.$3, $4.$6);
    # my ($width, $height) = ($urx - $llx, $ury - $lly);
  my ($WW,$HH)=(Htex::dimen::dimen2bp($_[0])-$W1, Htex::dimen::dimen2bp($_[1])-$H1);
    my ($xoffset, $yoffset) = (0, 0);
      $need_grestore=0;
  $neg=-1 if $S=~s@\A([+-])@@ and '-'eq$1;
 * New code for debug, warning, error
 * Newline before grestore for the case that there is no
 * New options: --hires, --exact, --filter, --help.
      next
        next
    next if length($overlap.=$S)<OVERLAP_LENGTH;
    next if $pageri!~/^(\S+)/;
  } # NEXT opt
    next unless /\S/;
--(no)antialias render shades at outlines (def: scale3no) (=scale3yes =no =yes)
--(no)below     allow below+left_from baseline    (def: no)
--(no)compress  use compression                   (def: best)
--(no)exact     scan ExactBoundingBox             (def: no)
#   --(no)filter:     d. read standard input           (default: false)
#   --(no)gs        d. run Ghostscript to create PDF
--(no)hires     scan HiResBoundingBox             (def: yes)
    no integer;
  no integer;
{ no integer; %bp_mul=(
  no integer; #### BUGFIX at Wed Nov 15 17:23:29 CET 2006
  no integer; # very important; has local scope
--(no)keepoldmediabox keep only old, [0 0]-based MediaBox in PDF (def: no)
--(no)lossy     allow lossy image filters (EPS->PDF) (def: yes)
 * no more option defaults :-(
    # no-op yet, see later
    #   normal mode : BoundingBox ExactBoundingBox HiResBoundingBox
    #   normal mode : BoundingBox HiResBoundingBox==ExactBoundingBox
  no strict 'refs';
# note should be letter (or some other size) with the ImagingBBox
--(no)tmpunlink unlink temporary files            (def: yes)
 * --noverbose --nocompress supported differently
--(no)verbose   verbose debug informations        (def: no)
  # Now come the FileFormats supported via sam2p
  # now deal with PS, EPS and PDF
            (\npapersize-x==) ..print dup 0 get ===
            (\npapersize-y==) ..print dup 1 get === (\n) ..print
            (\nresolution-x==) ..print dup 0 get ===
            (\nresolution-y==) ..print dup 1 get === (\n) ..print
.nr IN 2n
        (\nset-called-1==/=\n) ..print flush
        (\nset-called-1==/print\n) ..print flush
  (\nset-called-1==/setpagedevice\n) ..print flush
      (\nsides-duplex==) ..print dup === (\n) ..print
      (\nsides-tumble==) ..print dup === (\n) ..print
  Objects 0 OFT put
#      objects first
      #   off false no  nein nem  non disable 0 false faux? wrong nope disallowed
    $ofn=fix_force_out('S3.pnm') if $do_scale3_pnm;
    $ofn=fix_force_out('SS.pnm');
  /OFT Objects 0 get dup length array copy def
     OK:
 * omit the unnecessary setpagedevice calls when creating normal eps
      #   on  true  yes ja   igen oui enable  1 true  vrai? right sure allowed
  open(IN,"< $InputFilename") or error "cannot open input file: $InputFilename";
### open input file
  open(IN, "<&STDIN") or error "cannot open standard input";
        open_OUT();
    open(OUT, $OutputFilename eq '-' ? ">-" : "> $OutputFilename")
  open(OUT, "| $pipe") or error "Cannot open Ghostscript pipe";
### open output file or pipe (do this as late as possible)
  $::opt_antialias eq 'scale3no')) {
      $::opt_antialias eq 'yes' or $::opt_antialias eq 'scale3yes';
$::opt_antialias=is_has_antialias() ?
      $::opt_antialias='no'
  $::opt_antialias='no';
      $::opt_antialias=$optval
$::opt_antialias=undef; # render shades at path outlines for better readability
	$::opt_bboxfrom='adsc' if $::opt_bboxfrom eq 'guess';
                        : ($::opt_bboxfrom eq 'guess') ? ($bbc!=0 and is_page1_stop()) # Imp: is is_page1_stop() OK here?
$::opt_bboxfrom="guess";
      $::opt_bboxfrom=$optval
    # $::opt_below=0 if $lly>=0; # always move to (0,0)
$::opt_below=is_any_origin_ok() if !defined $::opt_below;
$::opt_below=undef;
$::opt_compression='best';
      $::opt_compression=$optval;
      $::opt_compression='zip' if $::opt_compression eq 'flate';
$::opt_compression='zip' if $::opt_compression ne 'none';
$::opt_duplex="default";
      $::opt_duplex=$optval
$::opt_exact=0;
$::opt_extra="";
# $::opt_filter=0; # deprecated
      $::opt_gs_ccmd=$optval;
      $::opt_gs_cmd=$optval;
$::opt_gs_cmd=undef;
$::opt_help=0;
$::opt_hires=1;
/Optimize true % ignored by gs-6.70
 * option --below
### option BoundingBox types
### option compress
### option gs
### option outfile
Options: --help print this help message
  #** Options that have a mandatory argument
$::opt_keepoldmediabox=0;
$::opt_lossy=1;
      $optname=lc$1;
      $optname=lc$1; $optval=$2;
    $optname=$optmap{$optname} if exists $optmap{$optname};
      $optname=substr($optname,2);
# $::opt_outputfile=undef; # deprecated
$::opt_papersize="default"; # unchanged force-unknown 600bpx600cm (bp)
        $::opt_papersize="$L[1],$L[2]" # width, height
  $::opt_resolution="72,72" if $::opt_resolution eq 'unchanged' or $::opt_resolution eq 'force-unknown' or $::opt_resolution eq 'default';
$::opt_resolution="default"; # unchanged force-unknown 600x600 (DPI)
	  $::opt_resolution eq 'unchanged' and defined $resolution_x and defined $resolution_y;
  $::opt_resolution="$L[0],$L[0]";
      $::opt_resolution=$optval
	$::opt_resolution=$resolution_x.','.$resolution_y if
      $opts_ok=0;
$::opt_threshold=128;
      $optval=$ARGV[++$I];
      $optval=(!defined($optval) or 0==length($optval)
      $optval="no";
$::opt_verbose=0;
  or $ARGV[0] eq 'help');
       or /^%%Begin(?:Prolog|Setup)\b/i
       or !$creator_metapost_p and substr($_,0,5)eq'%%End'
  or is_via_sam2p()) {
      or myfloor($lly)!=$lly or myceil($urx)!=$urx or myceil($ury)!=$ury;
     or  $::opt_exact and  $::opt_hires and ($T eq 'E' or ($bbtype ne 'E' and ($T eq 'H' or $bbtype ne 'H')))
     or  $::opt_exact and !$::opt_hires and ($T eq 'E' or ($bbtype ne 'E' and ($T eq '' or $bbtype ne '')))
     or  $::opt_hires and !$::opt_exact and ($T eq 'H' or ($bbtype ne 'H' and ($T eq '' or $bbtype ne '')))
     or !$::opt_hires and !$::opt_exact and ($T eq '' or ($bbtype ne '' and ($T eq 'E' or $bbtype ne 'E')))
               or $optval=~/\Ao[nu]/i or $optval!~/\A[fndw0]/i) ? 1 : 0;
        or $res!~s/\A(?:\w+ Ghostscript \d|Copyright .* artofcode ).*\n// # AFPL Ghostscript 6.50 (2000-12-02)
        or $res!~s/.*?^bbox-begin\n//m;
other page description formats. Accepted input file formats are: PS
  #     ours, PStoPS (or psnup). (When we come after CUPS, we'll have a
#   --outfile=<file>: write result to <file>
#      * Output FileFormat: PDF
#** Output file format (string)
      $OutputFilename='-';
        $OutputFilename=$ARGV[$I];
#      * Output filename: debrecen-hyph.pdf
      $OutputFilename=$InputFilename if defined $InputFilename and
      $OutputFilename=$optval;
      $OutputFilename .= ".pdf";
      $OutputFilename =~ s/\.[^\.]*$//;
    $OutputFilename = '-'; # standard output
  # $OutputFilename=$temp_out_fn;
    $overlap.=$S;
  $overlap=~s@(?:[\n\r\0\f]+%%EOF)?[\n\r\0\f]*\Z(?!\n)@@;
  # $overlap=~s@(?:[\n\r\0\f]+%%Trailer)?(?:[\n\r\0\f]+%%EOF)?[\n\r\0\f]+\Z(?!\n)@@;
    $overlap=substr($overlap,-OVERLAP_LENGTH());
    #$overlap=substr($S,-OVERLAP_LENGTH(),OVERLAP_LENGTH);
      #  # override bbox
	# ^^^ overwrite first buggy /MediaBox definition with spaces
      p5_avg_lines($l1, $l2, $l3, $ret);
      p6_avg_lines($l1, $l2, $l3, $ret);
package Htex::a2ping;
package Htex::a2ping;  $0=~/(.*)/s;unshift@INC,'.';do($1);die$@if$@;__END__+if !1;
package Htex::dimen;
package Htex::papers;
package integer;
package just; BEGIN{$INC{'just.pm'}='just.pm'}
package Pts::string;
package strict;
    $pagedev_mark.="mark /CropBox [$llx $lly $urx $ury] /PAGE pdfmark\n" if is_pdfmark();
      $pagedev_mark.="mark /MediaBox [$llx $lly $urx $ury] /PAGE pdfmark\n" if
      $pagedev_mark.="mark /MediaBox [$llx $lly $urx $ury] /PAGE pdfmark\n" if is_pdfmark();
    $pagedev_mark="/pdfmark where{pop}{/pdfmark/cleartomark load def}ifelse\n$pagedev_mark"
      # $pagedev_mark=~s@/PageSize\s*\[[^\]]*]@/PageSize [$urx $ury]@; # BUGFIX at Tue Apr 22 10:08:17 CEST 2003
  $pager=q~perl -pe 's@\010_@@g;s@.\010@@gs' | ~.$pager
  /PageSize { % [. .] PageSize -
          "$paper[0]";
    $paper[0]=defined $paper[0] ? "%%DocumentPaperSizes: $paper[0]\n" : "";
# papername	width	height
/..paper.redef<< >>def
    papersize 1 paper 1 bboxfrom 1 antialias 1 gsextra 1 threshold 1); # 1 arg
--papersize=    unchanged|force-unknown|600bpx5cm (def: default) (bp)
        ($papersize_x,$papersize_y)=split/,/,$::opt_papersize;
# paper.txt
#** @param $_[0] a (real or integer) number, optionally postfixed by a
#** @param $_[0] a string
#** @param $_[0] length always divisible by 3
#** @param $_[0] length always divisible by 9
#** @param $_[0] llx, may be undef to signify that bbox is undetected
#** @param $_[0] number of bytes to read, or undef to read a line
#** @param $_[0] temp file extension (e.g ".img")
#** @param $_[0] width, in bp
#** @param $_[0] (width width_unit "," height height_unit)
#** @param $_[0] (width width_unit? ("," || "x") height height_unit?) || (papername)
#** @param $_[1] height, in bp
#** @param $_[1] index of first bit to return. Bit 128 of byte 0 is index 0.
#** @param $_[1] lly
#** @param $_[1] preprint
#** @param $_[2] bool: force pipe even if seekable?
#** @param $_[2] number of bits to return (<=32)
#** @param $_[2] urx
#** @param $_[3] ury
#** @param $_[4] after_correct PostScript code (resolution, page size)
#** @param $S prepend to pipe
  'PBM'=> [FL_PAGE1_STOP|FL_SET_PAGESIZE_OK|FL_NEED_SHOWPAGE|FL_SAMPLED|FL_OK_SAM2P], # Dat FL_HAS_ANTIALIAS produces obscure image
  'pc'=>12*72/72.27, # 1 pc = 12*72/72.27 bp (pica)
  'PCL5'=>[FL_SET_PAGESIZE_OK|FL_ANY_ORIGIN_OK],
  pcl PCL5  pcl5 PCL5  pbm PBM  pgm PGM  pnm PPM  ppm PPM  pdf PDF  png PNG
  'PDF1'=>[FL_PAGE1_STOP|FL_SET_PAGESIZE_OK|FL_PDFMARK],
  pdfdict begin
  'PDF'=>[FL_SET_PAGESIZE_OK|FL_PDFMARK|FL_ANY_ORIGIN_OK],
        # !! PDF->PS->PDF
#!perl -w
  'PGM'=> [FL_PAGE1_STOP|FL_SET_PAGESIZE_OK|FL_NEED_SHOWPAGE|FL_SAMPLED|FL_HAS_ANTIALIAS|FL_OK_SAM2P],
  # $pipe.="-dTextAlphaBits=4 -dGraphicsAlphaBits=4 " if $::opt_antialias; # Dat: already done
  $pipe.="$GSOPTS -sOutputFile=".fnq($ofn)." -";
   pipe (!$$ll_zero)
.pl 33333v
  'PNG'=> [FL_PAGE1_STOP|FL_SET_PAGESIZE_OK|FL_NEED_SHOWPAGE|FL_SAMPLED|FL_HAS_ANTIALIAS|FL_VIA_SAM2P],
   # PNG JPEG TIFF PNM BMP GIF LBM XPM PCX TGA
    @pnm2sampled_cmd=('sam2p',"$FileFormat:",'--'); # Imp: use convert(1) if no sam2p(1)
PNM output formats are PGM, PGM and PPM. To write PNM output formats, GS
# --- PNM scaling routines for --antialias=scale3*
  $pod2man_=q~perl -ne 'if($a>1){print}elsif($a&&/^=head1/){$a=2}else{$a=!/\S/}' ~
      #: pop-count==0
        $pop_count=$end_count=0; # assume PS is correct
      # -- `pop' off the execution stack after the 1st page
    } {pop pop} ifelse
                      "{".("pop "x$1)."}bind def\n"
Possible input formats: PS EPS PDF JPEG GIF TIFF PNG PNM PCX BMP LBM XPM TGA
Possible output formats: @{[sort keys %fmts]}
      # -- possibly ignore calls to showpage [showpage is forced]
      # -- possibly remove the `%%Page' ADSC comment [no]
(PostScript), EPS, PDF, PNG, JPEG, TIFF, PNM, BMP, GIF, LBM, XPM, PCX,
  'PPM'=> [FL_PAGE1_STOP|FL_SET_PAGESIZE_OK|FL_NEED_SHOWPAGE|FL_SAMPLED|FL_HAS_ANTIALIAS|FL_OK_SAM2P],
#** Prefer %%HiResBoundingBox over %%BoundingBox, but emit both
print OUT "\n$extra_trailer$after_code",
  print OUT $overlap;
    #print OUT $overlap, substr($S,0,length($S)-OVERLAP_LENGTH());
    print OUT substr($overlap,0,length($overlap)-OVERLAP_LENGTH());
  # print OUT while length($_=readIN 4096);
/..print/print load def
### print rest of file
  print STDERR "$0: warning: @_\n";
    #print STDERR "(($_))\n";
  print STDERR "* @_\n" if $::opt_verbose;
  ## print STDERR "READ($_[0])\n";
      ## print STDERR $res;
    # print STDERR "($S)\n";
print STDERR $title if $::opt_verbose;
    print STDOUT $buf while sysread FCO, $buf, 4096;
        ##print tell(IN)." ar=$already_read\n";
  ##print tell(IN)." bar=$already_read\n";
      ##print tell(IN)." car=$already_read\n";
    print TI or die while length($_=readIN 4096);
      print while sysread PIPE, $_, 4096;
  %print_xref
  * produce postscript | $program -v - test.pdf
  $prog0=~y@a-zA-Z0-9@_@c;
  * $program -d --nogs -hires test.ps>testcorr.ps
### program identification
  * $program test.eps
progress text printed to the terminal (which confuses gv(1) and makes
  #     %!PS-AdobeFont-1.0: LMRoman12-Regular 0.86
  'PS'=>[FL_SET_PAGESIZE_OK|FL_ANY_ORIGIN_OK],
PS, markedEPS, markedPS, PNG, XWD, BMP, TIFF, JPEG, GIF, XPM.
    $ps_ofs-=30;
  'pt'=>72/72.27, # 1 pt = 72/72.27 bp (point)
#**** pts ****
  ### ****pts**** remove incorrect /MediaBox produced by gs
      push @creator, $1;
  push @creator, "$program $Htex::a2ping::VERSION"; # if "@creator"!~/\ba2ping\b/;
    push @pnm2sampled_cmd, $ofn, $OutputFilename;
    ($px,$py)=($1+0,$2+0) if $after_correct=~m@/PageSize\s*\[(\S+)\s+(\S+)+\]@;
quality, so it is switched off by default. But if you set
      quit
  $quote.$fn.$quote
($quote,$GS) = ("\"","gswin32c") if $^O eq 'MSWin32' or $^O =~ /cygwin/i;
qw{10x13	720	936},
qw{10x14	720	1008},
qw{17x22	1224	1584},	# ANSI C 17x22
qw{22x34	1584	2448},	# ANSI D 22x34
qw{34x44	2448	3168},	# ANSI E 34x44
qw{7x9		504	648},
qw{9x11		648	792},
qw{9x12		648	864},
qw{a0		2380	3368},
qw{a0Land	3368	2380},
qw{a10		74	105},
qw{a10Land	105	74},
qw{a1		1684	2380},
qw{a1Land	2380	1684},
qw{a2		1190	1684},
qw{a2Land	1684	1190},
qw{a3		842	1190},	# defined by Adobe
qw{a3Land	1190	842},
qw{a4		595	842},	# defined by Adobe; must precede a4small
qw{a4Land	842	595},
qw{a4small	595	842},
qw{a5		421	595},
qw{a5Land	595	421},
qw{a6		297	421},
qw{a6Land	421	297},
qw{a7		210	297},
qw{a7Land	297	210},
qw{a8		148	210},
qw{a8Land	210	148},
qw{a9		105	148},
qw{a9Land	148	105},
qw{archA	648	864},
qw{archB	864	1296},
qw{archC	1296	1728},
qw{archD	1728	2592},
qw{archE	2592	3456},
qw{b0		2836	4008},
qw{b0Land	4008	2836},
qw{b1		2004	2836},
qw{b1Land	2836	2004},
qw{b2		1418	2004},
qw{b2Land	2004	1418},
qw{b3		1002	1418},
qw{b3Land	1418	1002},
qw{b4		709	1002},
qw{b4Land	1002	709},
qw{b5		501	709}, # defined by Adobe
qw{b5Land	709	501},
qw{c0		2600	3677},
qw{c1		1837	2600},
qw{c2		1298	1837},
qw{c3		918	1298},
qw{c4		649	918},
qw{c5		459	649},
qw{c6		323	459},
qw{C7		230	323},
qw{Comm10	297	684},
qw{csheet	1224	1584},	# ANSI C 17x22
qw{DL		312	624},
qw{dsheet	1584	2448},	# ANSI D 22x34
qw{esheet	2448	3168},	# ANSI E 34x44
qw{Executive	540	720},
qw{flsa		612	936},	# U.S. foolscap
qw{flse		612	936},	# European foolscap
qw{Folio	612	936},
qw{halfexecutive 378	522},
qw{halfletter	396	612},
qw{ISOB0	2835	4008},
qw{ISOB10	 88	 125},
qw{ISOB1	2004	2835},
qw{ISOB2	1417	2004},
qw{ISOB3	1001	1417},
qw{ISOB4	 709	1001},
qw{ISOB5	 499	 709},
qw{ISOB6	 354	 499},
qw{ISOB7	 249	 354},
qw{ISOB8	 176	 249},
qw{ISOB9	 125	 176},
qw{jisb0	2916	4128},
qw{jisb1	2064	2916},
qw{jisb2	1458	2064},
qw{jisb3	1032	1458},
qw{jisb4	 729	1032},
qw{jisb5	 516	 729},
qw{jisb6	 363	 516},
qw{Ledger	1224	792},
qw{Legal	612	1008},
qw{letter	612	792},	# must precede lettersmall
qw{letterLand	792	612},
qw{lettersmall	612	792},
qw{Monarch	279	540},
qw{note		612	792},
qw{Quarto	610	780},
qw{Statement	396	612},
qw{Tabloid	792	1224},
  read_again: while (length($_=readIN)) {
  read_error if 0>read IN, $S, 4;
    read_error if 30-4>read IN, $S, 30-4, 4;
    read_error if !defined($S) and $!;
      read_in $ps_ofs if $ps_ofs>0;
 * reads all 3 BoundingBox DSC comments, and picks the best
  { readxrefentry } stopped { Objects exch lget } if
recommended only if there is a backup of the file to be restored in case
  #      recompress
  #      recompress the images already compressed in the EPS file, but keep
 * remove PJL UEL header from the beginning
 * removes DOS EPSF binary junk correctly
# !! remove setpagedevice from EPS->EPS, but keep EPS->PGM
 * removes ^L (form feed) from end of EPS file
      # -- remove the `%%Pages', `%%DocumentPaperSizes', `%%PageOrder:'
require 5.002;
        $ret=pack"B".length($ret),$ret;
  ($ret+=$ret+(1&(vec($_[0],$loop>>3,8)>>(7-($loop&7)))), $loop++) while $count--!=0;
  return 0.0+$S if $S=~/\A[+-]?(?:[0-9]*\.[0-9]+|[0-9]+\.])(?:[eE][+-]?[0-9]+)?\Z(?!\n)/;
  return 0+$S if $S=~/\A[+-]?(?:[0-9]*\.[0-9]+(?:[eE][+-]?[0-9]+)?|[0-9]+\.?)\Z(?!\n)/;
#** @return an integer (negative on overflow), bit at $_[1] is its MSB
#** @return arg rounded down to int
#** @return arg rounded up to int
    return fix_force_out($_[0]);
  return $fn if $fn!~y@-a-zA-Z0-9/.+_@@c;
  ## return "" if $bytes_left==0;
    return if $S!~/^(?:$BBregex|set)$BBValues/oi;
  return () if $S!~/^\s*(\d+(\.\d+)?)\s*((?:[a-z][a-z0-9]+)?)\s*[,xX]\s*(\d+(\.\d+)?)\s*((?:[a-z][a-z0-9]+)?)\s*\Z(?!\n)/;
  return $neg*$1     if $S=~/\A([0-9]+)\Z(?!\n)/;
  return $neg*hex $1 if $S=~/\A0[xX]([0-9a-fA-F]+)\Z(?!\n)/;
  return $neg*oct $1 if $S=~/\A0([0-7]+)\Z(?!\n)/;
#** @return new output filename
#** @return () or ("papername", ret.paper.width.bp, ret.paper.height.bp)
#** @return () or ("papername", width.bp, height.bp)
#** @return () or ("papername"?, width.bp, height.bp)
    return $OutputFilename if $OutputFilename ne '-';
    return @papers[$I,$I+1,$I+2] if abs($papers[$I+1]-$WW)<=8.5 and abs($papers[$I+2]-$HH)<=8.5;
      return @papers[$I,$I+1,$I+2] if lc($papers[$I]) eq $S;
#** @return PostScript code to be printed after the header
#  return "'$S'"
#  return $S if $S!~y@A-Za-z0-9_,:./-@@c and length($S)>0;
  return $temp_out_fn;
#** @return the integer value of $_[0] in C -- or undef
#** @return the number in bp, or undef
#** @return the string read
  return "$tmpdir/$prog0-$$-".int(rand(1<<30))."-"; # 30: nonnegative
#** @return value if $_[0] represents a floating point numeric constant
#** @return value if $_[0] represents a floating point or integer numeric
  # run `pod2man __FILE__ | man -l -', same as `perldoc __FILE', but perldoc(1)
  # !! ?? run pstops first, and then a2ping.pl
        run_sam2p(1,$S);
    run_sam2p($::opt_approx,$S);
Run with --doc to read documentation as a UNIX man(1) page.
        $_=$S;
 * sam2p and pdftops if $InputFilename eq '-';
      # same as sam2p GenBuffer::parseBool, understands:
Sampled input formats are PNG, JPEG, TIFF, PNM, BMP, GIF, LBM, XPM, PCX
    $saved_bytes_left=$bytes_left;
  #     {save true}{false}ifelse}{false}ifelse
      s@($BBregex)\s*1\s+1\s+@$1 0 0 @ if $creator_adobeps_p;
    $scale3_pnm_fn=$ofn;
scaling and GS internal antialiasing, which results in thicker lines and
{ SCAN_AGAIN:
# scan all of them and find the best
### scan first line, check for DOS EPSF (and remove DOS headers)
### scan header
 * Scanning for %%{Hires,Exact,}BoundingBox.
#      * Scanning header for BoundingBox
 * Scanning only the header in order not to get a wrong
script modified by Thomas Esser, Sept. 1998, but his modifications have
-sDEVICE=pdfwrite
/..sdict <<
      ..sdict exch get exec
    seek(IN, $saved_pos, 0) or error "Input unseekable, cannot go back to line `: (atend)'";
# See revision history at end of this file.
 * separated FileFormat features to FL_* constants
      #: set-called-0==/a4
.setglobal
>> setpagedevice
  #     `setpagedevice'.
/setpagedevice{
/setpagedevice{pop (\nset-called-1==/setpagedevice\n) ..print flush}def
   setpagedevice. Precedence for other inputs: --PageSize, setpagedevice,
      #    setpagedevice setpagetype setprintername setresolution a4 letter ...
/setpagemargin{pop (\nset-called-1==/setpagemargin\n) ..print flush}def
/setpageparams{pop pop pop pop (\nset-called-4==/setpageparams\n) ..print flush}def
/setpage{pop pop pop (\nset-called-3==/setpage\n) ..print flush}def
    $setpagesize="2 dict dup /PageSize [".myceil($urx)." ".myceil($ury)."] put setpagedevice\n";
%/.setpagesize{pop pop (hehehe\n) print} def
/.setpagesize{pop pop (\nset-called-2==/.setpagesize\n) ..print flush}def
/setpagesize{pop pop (\nset-called-2==/setpagesize\n) ..print flush}def
/setpagetype{pop (\nset-called-1==/setpagetype\n) ..print flush}def
/setprintername{pop (\nset-called-1==/setprintername\n) ..print flush}def
/setresolution{pop (\nset-called-1==/setresolution\n) ..print flush}def
      #      Setting $allow_adsc_bb=0|1 now would disallow/allow the %%BoundingBox
share common code anymore.  B<epstopdf> is written by Sebastian Rahtz,
  shift; # my package
# ^^^ short: duplex printing, will bind short edge of paper (ideal for
show_doc() if 1==@ARGV and $ARGV[0] eq '--doc' or $ARGV[0] eq 'doc';
showpage quit
# shrunk by 25 units on all 4 sides.
    $S="" if !defined $S; # EOF
    $SIG{INT}=$SIG{TERM}=$SIG{HUP}=$SIG{QUIT}=\&cleanup;
      # silently ignore these -- not significant for EPS
      # silently ignore these -- will be recalculated
   size', instead of `US letter'
   SKIP_BBOX_DISC:
        # sleep 1000;
      $S.="\n";
some filters in the print queue emit incorrect output).
	#     so we force it here
#      So we're converting from PS|EPS with Ghostscript 
  'sp'=>72/72.27/65536, # 1 sp = 72/72.27/65536 bp (scaled point)
  # splice @ARGV, 0, $I;
    } # $S.=readIN;
    $S.=readIN;
    $S=readIN(1);
  $S=~/^\s*(\d+(\.\d+)?)\s*([a-z][a-z0-9]+)\s*,\s*(\d+(\.\d+)?)\s*([a-z][a-z0-9]+)\s*\Z(?!\n)/ ?
#  $S=~s@'@'\\''@g;
    $S=~s@\n%%TrailerLength:.*$@@m; # ADOBEPS4.DRV
      $S=~s@\r\Z(?!\n)@\n@ if defined($S=<IN>);
    $S=substr($S, 0, $bytes_left);
    $S=substr($S,1);
      % Stack: /a4 {595 842 //.setpagesize --exec--}
      % Stack: /a4 {595 842 {/statusdict --.systemvar-- --begin-- .setpagesize --end--} --exec--}
        % Stack: /a4 userdict /a4 {...}
  statusdict /.pagetypenames 2 copy known {get}{pop pop{}}ifelse
#      * Strongest BoundingBox comment: %%HiResBoundingBox:
  # stupid Ghostscript ignores /Tumble true with -sDEVICE=ljet4
sub any($) {
sub bits {
sub c_floatval($) {
sub c_intval($) {
sub cleanup() {
sub c_numval($) {
sub CorrectBoundingBox($$$$$$$) {
sub debug {
sub dem1($){defined$_[0]?$_[0]:-1}
sub dimen2bp($) {
sub do_exec {
sub do_system {
sub end(){1}
sub error {
sub errorUsage {
sub fix_close_out() {
sub fix_force_out($) {
sub fix_pipe_in($$$) {
sub fix_pipe_out($) {
sub FL_ANY_ORIGIN_OK(){32} # (llx,lly) may be anything, not just (0,0)
sub FL_HAS_ANTIALIAS(){64}
sub FL_NEED_SHOWPAGE(){8} # does gs -sDEVICE=... need showpage?
sub FL_OK_SAM2P(){256} # sam2p(1) can convert PNM to such a format
sub FL_PAGE1_STOP(){1} # is file format single-page?
sub FL_PDFMARK(){4}
sub FL_SAMPLED(){16} # is it a sampled (raster, pixel-based)
sub FL_SET_PAGESIZE_OK(){2}
sub FL_VIA_SAM2P(){128} # sam2p(1) should convert PNM to such a format
sub fnq($) {
sub get_bits_msb($$$) {
sub import {
sub import   { $^H |= 1 }
sub import { shift; $^H |= bits @_ }
sub is_any_origin_ok() { 0!=($fmts{$FileFormat}[0]&FL_ANY_ORIGIN_OK) }
sub is_has_antialias() { 0!=($fmts{$FileFormat}[0]&FL_HAS_ANTIALIAS) }
sub is_need_showpage() { 0!=($fmts{$FileFormat}[0]&FL_NEED_SHOWPAGE) }
sub is_ok_sam2p() { 0!=($fmts{$FileFormat}[0]&FL_OK_SAM2P) }
sub is_page1_stop() { 0!=($fmts{$FileFormat}[0]&FL_PAGE1_STOP) }
sub is_pdfmark() { 0!=($fmts{$FileFormat}[0]&FL_PDFMARK) }
sub is_sampled() { 0!=($fmts{$FileFormat}[0]&FL_SAMPLED) }
sub is_set_pagesize_ok() { 0!=($fmts{$FileFormat}[0]&FL_SET_PAGESIZE_OK) }
sub is_via_sam2p() { 0!=($fmts{$FileFormat}[0]&FL_VIA_SAM2P) }
sub main(){}
sub myceil($) {
sub myfloor($) {
sub open_OUT() {
sub OVERLAP_LENGTH(){4096} # `%%TrailerLength: 1162' by ADOBEPS4.DRV
sub p5_avg_lines($$$$) {
sub p6_avg_lines($$$$) {
sub pnm_gettok($) {
sub read_error() { error "read $InputFilename: $!" }
sub readIN(;$) {
sub run_sam2p($$) {
sub show_doc() {
#sub shq($) {
       substr($_,0,5)ne'%ADO_' and !/^%AI\d_/ # Dat: %ADO_DSC_..., %AI7_Thumbnail
	substr($pageobj, length($1), length($2))=" "x length($2);
sub temp_prefix() {
sub temp_unlink($) {
sub unimport { $^H &= ~1 }
sub unimport { shift; $^H &= ~ bits @_ }
sub valid_bp($$;$$) {
sub valid($) { # valid_papersize
sub warning {
      # -- surround the code by save ... pop* end* restore (implies gsave ... grestore)
# ^^^ SUXX: gs always exit(0), if exists
    $S=~y@\r@@d;
systemdict begin
systemdict readonly pop
    /tabloid/csheet/dsheet/esheet/executivepage/com10envelope
  $temp_out_fn
  $temp_out_fn=temp_prefix()."O$ext";
  temp_unlink $scale3_pnm_fn;
    temp_unlink $temp_out_fn;
  temp_unlink $temp_out_fn;
  # temp_unlink $temp_out_fn; # do it later (at END{})
      temp_unlink $tfn;
  temp_unlink $tfn;
    # temp_unlink $tifn; # do it later (at END{})
ter <F<pts@fazekas.hu>>.
#**        TeX dimension specifier (default=bp)
texutil.
    $tfmt='EPS' if $tfmt eq 'PDF'; # Imp: PDF1<->PDF
TGA. Accepted output formats are: EPS, PCL5, PDF, PDF1, PBM, PGM, PPM,
The author of B<a2ping> is Szab
 * the compute-pipe routine is now run unless --bboxfrom=guess with EPS
the default B<--AntiAlias=scale3no> to speed up conversion.
the final PBM.
The internal file format of B<a2ping.pl> is PS/EPS. Everything read is
    # The last valid *bbox entry has effect.
  #      them in their original, compressed form. So we rather instruct GS to
The name of the input file doesn't matter -- B<a2ping> detects the file
The page size is set exactly corresponding to the BoundingBox.
 * there is no default FileFormat (PDF) anymore
      #     the stack (see the `LMRoman' example above)
# This file contains perldoc(1) documentation. Search for `=head1'.
This improves readability of the glyphs. B<=yes> instructs GS to do
#      This is free software, GNU GPL >=2.0. There is NO WARRANTY.
This is free software, GNU GPL >=2.0. There is NO WARRANTY.
      # This is the compute-pipe routine.
This means that when Ghostscript renders it, the result needs no
# This Perl script was generated by JustLib2 at Wed Apr 23 09:14:13 2003.
# This program is free software, licensed under the GNU GPL, >=2.0.
# This software comes with absolutely NO WARRANTY. Use at your own risk!
      #: This software comes with NO WARRANTY: see the file PUBLIC for details.
--threshold=    min color for 1 in 8->1 bit conv  (def: 128)
  'TIFF'=>[FL_PAGE1_STOP|FL_SET_PAGESIZE_OK|FL_NEED_SHOWPAGE|FL_SAMPLED|FL_HAS_ANTIALIAS|FL_VIA_SAM2P],
    $tifn=temp_prefix()."M$ext";
$title="";
"${title}Usage:  $program [options] <inputfile> [[<outformat>:] <outputfile>]
$tmpdir="." if (!-d $tmpdir or !-w $tmpdir) and -w '.';
  $tmpfiles{$temp_out_fn}=1;
      $tmpfiles{$tfn}=1;
  $tmpfiles{$tfn}=1;
    $tmpfiles{$tifn}=1;
        $tmpfiles{$tpfn}=1;
    $tmpfiles{$tpfn}=1;
	  $tmpfiles{$tpfn}=1;
    $tmpsig=0;
To analyse the bounding box and other properties of non-EPS PS files
      # To convert an [E]PS to an EPS:
to get stdout. This works even for PDF files (which must be seekable),
$to_OUT="";
  $to_OUT.=$after_comments;
  $to_OUT.=CorrectBoundingBox $llx, $lly, $urx, $ury, $after_correct, $fontsdefs, $is_restored;
  $to_OUT.="%%Creator: ".join(", ",@creator)."\n"; # before CorrectBoundingBox to be before `gsave' etc.
    $to_OUT.="/fshow where{pop}{/fshow{exch findfont exch scalefont setfont show}bind def}ifelse\n";
    $to_OUT.="%!$headPS$headEPSF\n";
      $to_OUT.="$_\n"
      $to_OUT.="%$_\n";
      $to_OUT.="$_\n"; $had_pages=1
  $to_OUT.="/showpage{showpage quit}bind def\n"; # don't call showpage twice
    $to_OUT.="{@{[sort keys%fontsnames]}}{\ndup where{pop pop}{cvlit dup def}ifelse}forall\n";
To read PDF files, B<pdftops> from the B<xpdf> package is used.
To write PDF files, GS is used.
      $translate.="$xoffset $yoffset translate\n"
    true
          $tumblei ||= $::opt_duplex eq 'default-short'   ? 1 : 2;
  /Tumble { % [. .] PageSize -
turns off GS internal antialiasing, but makes it render everything 3x3
         : undef;
#**   undef for integer constants
      undef $papersize_y if !defined $papersize_x;
            $undefs.="/$2".(
    undef $temp_out_fn;
  undef $temp_out_fn;
undef $unlink_OutputFilename;
##undef $unlink_OutputFilename; die;
  #     /UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
    unlink $_[0] if $tmpunlink_p;
  unlink keys %tmpfiles;
$unlink_OutputFilename=$OutputFilename;
# unlink temporary files?
  UNMARKEDPS PS  UNMARKEDEPS EPS  EPDF PDF1  MEPS markedEPS);
      unpack"A4VVVVVVv", $S;
    $urx=1 if $urx<=0; # Dat: GS dislikes empty image; fix also negative image
      #  ($urx,$ury)=split/,/,$::opt_papersize;
    $ury=1 if $ury<=0;
### usage
used. Converting PS to EPS involves this analysis.
/UseFlateCompression ".($::opt_compression ne 'none'?"true":"false")."
use Htex::dimen;
use Htex::papers;
  { use integer;
  use integer;
use integer;
        use IO::Handle; # Dat: needed for ungetc
use just;
use just +1; # a JustLib application
use Pts::string qw(c_numval);
 * uses strict; (earlier error detecting).
use strict;
 * using of $bbxpat in all BoundingBox cases,
    valid_bp("$1$3","$4$6") : ();
  $val*=$mul if defined $val and defined $mul;
### variables and pattern for BoundingBox search
      vec($_[0],$len-1,8)+vec($_[0],$len-2,8)+vec($_[0],$len-3,8)+
      vec($_[0],$len-1,8)+vec($_[0],$len-4,8)+vec($_[0],$len-7,8)+
      vec($_[1],$len-1,8)+vec($_[1],$len-2,8)+vec($_[1],$len-3,8)+
      vec($_[1],$len-1,8)+vec($_[1],$len-4,8)+vec($_[1],$len-7,8)+
      vec($_[2],$len-1,8)+vec($_[2],$len-2,8)+vec($_[2],$len-3,8)];
      vec($_[2],$len-1,8)+vec($_[2],$len-4,8)+vec($_[2],$len-7,8)];
    vec($_[3],--$olen,8)=$div9[
    # vvv application-specific
      # vvv $bbtype may be possibly already set by compute-gs
  # vvv be permissive, since we have only 4 chars
      # vvv BUGFIX (only EPS) at Tue Feb  8 21:40:11 CET 2005
# vvv Dat: $after_code is pop+end
  # vvv Dat: $bbtype ne'-' would be a bad idea
          # vvv Dat: `convert - GIF:-' does quantize (and emits GIF)
  # vvv Dat: doesn't work with gs 8.53: Error: /undefined in readxrefentry
	  # vvv Dat: even pdftops 3.01 accepts only integer for -paperw and paperh
  # vvv Dat: `mark' is necessary, because pstops 1.17 from xpdf(1) emits lines
  % vvv Dat: modifies Objects[0]
      # vvv Dat: now with PS output it is possible that garbage is left on
    # vvv Dat: old version of Ghostscript insisted on an integer /CropBox (??).
	# vvv Dat: pdftops(1) can emit to stdout
        # vvv Dat: pdftops(1) is part of the xpdf package
	# vvv Dat: pdftops without -eps doesn't report HiResBoundingBox,
      # vvv Dat: save...restore is _always_ necessary to undo the changes made
  % vvv Dat: the generation number is assumed to be 0
  # vvv Dat: would move %%Trailer after dvips output `end userdict /end-hook known{end-hook}if'
# vvv deprecated options:
% vvv do these after our call to /setpagedevice
    # vvv get the very last *BoundingBox entry from the last 4096 bytes
  # vvv Imp: `<<' -> `dict'
      # vvv Imp: make it work on Win32 (no >&1 redirection)
        # vvv Imp: move down like $::opt_resolution
    # vvv Imp: run this correction even w/o input EPS header
  % vvv keep file offsets, because `pdffindpageref` overrides it with contents
  # vvv ljet4 cannot do duplex, ljet4d can
        # vvv ($llx,$lly,$urx,$ury)=(0,0,$papersize_x,$papersize_y);
# vvv needed by EPS->PGM conversion !!
# vvv SUXX: (r) file doesn't work with gs 8.5x -DSAFER
      # vvv the /MediaBox is different from what gs dumps
# vvv U.S. CAD standard paper sizes
        # vvv we must query the BoundingBox first
    # vvv we output a second /MediaBox here, and we'll remove the first one
  warning "--AntiAlias ignored for FileFormat $FileFormat"
  warning "BoundingBox not found, try --bboxfrom=compute-gs" if !defined $llx; # !! compute-gs
      # warning "Cannot look for BoundingBox in the trailer with option --filter" if $::opt_filter;
    warning "$InputFilename: no PS ADSC header, BoundingBox not found\n"
        warning # not `error', mpost(1) `prologues:=0; ... btex fonts' output won't compile 
    warning "post-processing of sam2p PDF output increases file size" if $tfmt eq 'PDF';
  $wd+=0; $ht+=0;
      (($wd+2)/3)." ".(($ht+2)/3)." 255\n";
    #          we do not force it now
      # we might be in mid-line
      #      When converting PS -> EPS, the PS file usually contains
When creating a PBM file, antialiasing usually doesn't improve the
      while (1) {
  while (1) {
    while ($ht>0) {
	while ($I--) { vec($ret,$I,8)=vec($ret,$I,8)<$::opt_threshold } # [\0\1]
  while ($len>0) {
        } while (length($_=readIN 4096));
      while (length($S)<$max and defined($C=readIN(1)) and
  while (length($S=readIN 4096)) { # Dat: 4096>=OVERLAP_LENGTH
        while (<PIPE>) {
      while ($ps_ofs>4096) { $ps_ofs-=4096; readIN 4096 }
   whitespace at the end of the eps file.
  # !! why does a PDF -> PS conversion need $is_restored?
Without the C<--below> option, it is guarenteed to start at the 0,0
 * works for PS non-EPS files for input
worse quality in general.
write extra output formats, B<sam2p> and GS are used.
    #     (written by GS) later
 * -x=-c:rle to add sam2p options
      $xoffset=0 if $xoffset==0; # get rid of `-0'
    ($xoffset, $yoffset) = (-$llx, -$lly);
  'XPM'=> [FL_PAGE1_STOP|FL_SET_PAGESIZE_OK|FL_NEED_SHOWPAGE|FL_SAMPLED|FL_HAS_ANTIALIAS|FL_VIA_SAM2P], # Imp: disable antialias for few colors?
  'XWD'=> [FL_PAGE1_STOP|FL_SET_PAGESIZE_OK|FL_NEED_SHOWPAGE|FL_SAMPLED|FL_HAS_ANTIALIAS|FL_VIA_SAM2P],
  xwd XWD  bmp  BMP  rle BMP  tif TIFF  tiff TIFF  jpg JPEG  jpe JPEG
      $yoffset=0 if $yoffset==0; # get rid of `-0'
You can specify B<-> as I<inputfile> to get stdin and as I<outputfile>
        y@\r@@d; chomp
    y@\r@@d; chomp;
Z<> B<a2ping.pl> [B<-->]B<help>
