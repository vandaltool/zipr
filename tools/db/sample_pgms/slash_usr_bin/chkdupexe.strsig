#     - Added more checks
  chdir($dir) || die "Could not chdir $dir: $!\n";
#	check for $execdirs and $PATH consistency instead
# Check if the users PATH contains something I've not checked. The site admin
# chkdupexe version 2.1.1
#  chop($dir=`pwd`);
#     Cleanups.
  closedir(DIR);
close(LS);
# configuration
# Copyright 1993 Nicolai Langfeldt. janl@math.uio.no
      $count{$_}++;
      $count{$_}=1;
  ($device,$inode)=stat($dir);
  ($device,$inode)=stat($dir); 
%didthis=();
  $didthis{$device,$inode}=1;
    die "NUTS! Personaly I think your perl or filesystem is broken.\n".
#  Distribute under gnu copyleft (included in perl package) 
  # Does this directory have any real exstence outside the ravings of
#     Don't break if there are duplicates in $PATH.
#     Don't depend on GNU ls.
    ($dum)=lstat($dir);
      ($dum)=stat($_);
    } else {
$ENOENT=2;
$execdirs='/bin /sbin /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin '.
foreach $dir (split(/:/,$ENV{'PATH'})) {
foreach $dir (split(/\s+/, "$execdirs"), "\0", split(/:/, $ENV{PATH})) {
  foreach $_ (readdir(DIR)) {
  # If a symlink points to a directory we already checked that directory
  if (!-d _) {
    if (defined($count{$_})) {
  if (!defined($device)) {
  if ($dir eq "\0") { $checkingpath = 1; next; }
    if (!$dum) {
    if (-l _) {
    if ($#unchecked>=$[);
  # It's like this: One directory corresponds to one $device,$inode tuple
      "I've done all sorts of checks on $dir, and now I can't open it!\n";
#     I was thinking admins would edit the $execdirs list to suit their
    lstat($_);
#     machine(s) when I wrote this.  This is ofcourse not the case, thus
#     - Made it possible to run with perl -w
#     Merge together $ENV{'PATH'} and $execdirs.
#     Michaels fixes.  And my fixes to his :-)
# might want to know about inconsistencies in user PATHs and chkdupexec 
# Modified 1995-07-04 Michael Shields <shields@tembel.org>
# Modified 1996-02-16 Nicolai Langfeldt (janl@math.uio.no).
      next;
    next;
  next if defined($didthis{$device,$inode});
    next if $! == $ENOENT;
  next unless defined($device);
    next unless -f _ && -x _;	# Only handle regular executable files
    # Nonexistant directory, or dangling symlink?
  ".\nPlease review the execdirs list in chkdupexe.\n"
  opendir(DIR,".") || 
open(LS,"| xargs -r ls -ldU");
      print "Dangling symlink: $dir\n";
      print "Dangling symlink: $dir/$_\n" unless defined($dum);
  print LS "$paths\n" if ($count{$prog}>1);
    print "Not a directory: $dir\n";
print "Warning: Your path contains these directories which chkdupexe has not checked:\n",join(',',@unchecked),
      $progs{$_}="$dir/$_";
      $progs{$_}.=" $dir/$_";
  push(@unchecked,$dir);
# Simple script to look for and list duplicate executables and dangling
# something to count on... :-(
# symlinks in the system executable directories.
  # symlinks pointing hither and dither?
# This would give us the true directory name, do we want that?
#     - Took out $PATH from the list of checked directories and added a
# Turn off buffering for the output channel.
@unchecked=();
#!/usr/bin/perl -w
  '/usr/local/games';
  '/usr/TeX/bin /usr/tex/bin /usr/games '.
  '/usr/X11/bin /usr/bin/X11 /usr/local/X11/bin '.
# Values from /usr/include/linux/errno.h.  Existence of linux/errno.ph is not
    warn "Nonexistent directory: $dir\n" if ($checkingpath);
while (($prog,$paths)=each %progs) {
  # will have the same $device,$inode tuple.
#     - Working duplicate dirs detection.
