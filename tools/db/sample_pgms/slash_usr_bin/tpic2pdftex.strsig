########################################################################
#   02 Dec. 2002 - Experimental pic (groff > 1.18.1) with improved
#   02 May  2003 - Lines starting with \ allow TeX insertions,
#   04 Dec. 2002 - Experiment with modified pic (\vtop -> \vbox),
        0.5 * (x[i] + x[i + 1]) * wscale, -0.5 * (y[i] + y[i + 1]) * wscale));
     -0.5 * (y[0] + y[1]) * wscale)); # start straight, see cstr116.ps
#   09 Apr. 2004 - Locale check: Decimal point in float numbers?
#   11 Nov. 2002 - Spline drawing improved: First half of first and last
#   14 Jan. 2007 - make it executable shell script, calling awk
#   16 Dec. 2004 - Replaced // {print} by {print} (some AWKs did choke)
#   16 Mar. 2003 - Bug corrected: Dashed lines shorter than minimum
#   28 Nov. 2002 - Arc and circle drawing cleaned up. Full circle is now
#   29 Apr. 2003 - Changed for pic of groff 1.19
#   30 Oct. 2003 - Replaced print statements by printf to avoid
  a = 0.68; # fudge, visually optimized
#   Addison-Wesley, 1997, pp. 464.
# all specials handling
# along with this program; if not, write to the
# <ar> draw arc
AWK=${AWK:-gawk}
$AWK "$AWKPROG" "$@"
AWKPROG='
        (a * x[i] + (1 - a) * 0.5 * (x[i] + x[i - 1])) * wscale, \
        (a * x[i] + (1 - a) * 0.5 * (x[i] + x[i + 1])) * wscale, \
       -(a * y[i] + (1 - a) * 0.5 * (y[i] + y[i - 1])) * wscale, \
       -(a * y[i] + (1 - a) * 0.5 * (y[i] + y[i + 1])) * wscale, \
# begin of awk input file
#   Bezier curves, to minimize max. error.
#!/bin/sh -
#   Bounding box does not care for line thickness (groff pic feature).
# by (groff-)pic into pdfTeX \pdfliteral sections for further processing
# by pdftex.
  c = 4 * (1 - cos(0.5 * phi)) / (3 * sin(0.5 * phi));
# Copyright (C) 2002--2004 by Hartmut Henkel
  curvespercircle = 4; # max. number Bezier curves per circle
# <da> print path as straight dashed lines
#   dash-pause length now drawn solid.
  defaultlinethickness = 8;
    dl = int (len / dt + 0.5);
      doff = loff / noff;
  don = ($3 + 0) * 1000;
  drawarc = 0;
  drawarc = 1;
#   drawn by 4 Bezier curves, as is common use. Arcs split evenly into
  dt = ($3 + 0) * 1000;
      dtl = len;
      dtl = len / dl;
# <dt> print path as straight dotted lines
    dx = x[i] - x[i - 1];
    dy = y[i] - y[i - 1];
  e = $8 + 0;
#   e. g. of pdfTeX \pdfliteral{}
    else
    } else {
  } else {
  else {
# end of awk input file
    exit 1;
/^\\expandafter\\setbox\\csname graph\\endcsname/ {
# Experimental awk-script for conversion of tpic \specials as produced
export LANG="C"
  filled = 0;
  filled = 1;
  fillval = 0;
  fillval = $3 + 0;
  for (i = 0; i < imax; i++) {
    for (i = 1; i < pointbuf - 1; i++)
    for (i = 1; i < pointbuf; i++)
  for (i = 1; i < pointbuf; i++)
  for (i = 1; i < pointbuf; i++) {
#   Formula for Bezier constant c reduced.
# <fp> print path as straight lines
# Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
function qprintf(a) {
function startpdfliteral() {
function stoppdfliteral() {
#   Goossens, Rahtz, Mittelbach: The LaTeX Graphics Companion,
/^  *\\graphtemp|^  *\\rlap|^  *\\advance|^\\|^  *\\hbox/ {
  gsub(/[{}]/, " ");
  gsub(/-0 /,"0 ", a);  # correct -0 to 0
  gsub(/0*]/,"]", a);   # trailing zeroes in brackets
  gsub(/0* /," ", a);   # trailing zeroes in %f
  gsub(/0X/,"0", a);    # guard integer zeroes
  gsub(/\. /," ", a);   # orphaned decimal dots
#   half of last spline segments are drawn by straight lines.
#         hartmut_henkel@gmx.de
# <ia> like <ar>, but arc actually not drawn
# $Id: tpic2pdftex,v 1.94 2007/01/14 19:05:32 hahe Exp $
    if (!dl)
  if (don < 0)
  if (don > 0)
  if (don != 0)
  if(drawarc == 1) {
  if (e > s)
  if (e - s > 2 * pi) e = s + 2 * pi;
    if (filled == 1) {
  if (filled == 1)
  if (filled == 1) {
  if (match(sprintf("%f", 0.5), /\./) == 0) {
    if(noff > 0) {
  if (pdfliteral == 0) {
  if (pdfliteral == 1) {
  if(pointbuf < 3)
  if (s - e > 2 * pi) e = s - 2 * pi;
  if(tpicmode == 1)
    imax = int ((e - s) / phi_max) + 1;
    imax = int ((s - e) / phi_max) + 1;
# <ip> like <fp>, but path actually not drawn
# it under the terms of the GNU General Public License as published by
    len = sqrt(dx * dx + dy * dy);
  linecap = 1;
  linejoin = 1;
  linethickness = $3 + 0;
  linethickness = defaultlinethickness;
    loff = len - lon;
    lon = don * non;
# MA  02111-1307  USA
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    noff = non - 1;
    non = int(0.5 * len / don + 0.75);
# <pa> add point to path
  # parameter for Bezier control vectors, c(90 deg.) = 0.55228...:
  pdfliteral = 0;
  pdfliteral = 1;
  phi = (e - s) / imax;
  phi_max = 1.001 * 2 * pi / curvespercircle;
  pi = atan2(0, -1);
#   $ pic -t somefile.pic | tpic2pdftex > somefile.tex
# <pn> set pen size
  pointbuf++;
  pointbuf = 0;
    print "}%";
  print a;
    print "before calling awk."
    print "before calling awk." > "/dev/stderr"
      print "B Q";
    print "B Q";
    print "ERROR: Floating point numbers miss decimal point. Do"
    print "ERROR: Floating point numbers miss decimal point. Do" > "/dev/stderr"
    print "  export LANG=\"C\""
    print "  export LANG=\"C\"" > "/dev/stderr"
      print "f";
    print "f";
      print "f Q";
    print "f Q";
    printf("q [] 0 d %d J %d j\n", linecap, linejoin);   # no qprintf!
    print "\\pdfliteral{";
    print "Q";
      print "q [] 0 d";
      print "S";
    print "S";
    print "S Q";
#   Process somefile.tex by pdftex/pdflatex.
      qprintf(sprintf("%f %f %f %f %f %f c", \
    qprintf(sprintf("%f %f %f %f %f %f c", x1 * wscale, -y1 * wscale, \
    qprintf(sprintf("%f %f l", 0.5 * (x[0] + x[1]) * wscale, \
      qprintf(sprintf("%f %f l", x[i] * wscale, -y[i] * wscale));
    qprintf(sprintf("%f %f l", x[i] * wscale, -y[i] * wscale));
    qprintf(sprintf("%f %f l", x[pointbuf - 1] * wscale, -y[pointbuf - 1] * wscale));
    qprintf(sprintf("%f %f m", x[0] * wscale, -y[0] * wscale));
  qprintf(sprintf("%f %f m", x[0] * wscale, -y[0] * wscale));
  qprintf(sprintf("%f %f m", x0 * wscale, -y0 * wscale));
    qprintf(sprintf("%f %f m", x[i - 1] * wscale, -y[i - 1] * wscale));
    qprintf(sprintf("%f w", linethickness * wscale));
  qprintf(sprintf("%f w", linethickness * wscale));
      qprintf(sprintf("h q %f g", 1 - fillval));
    qprintf(sprintf("q [0X %f] 0X d", -don * wscale));
    qprintf(sprintf("q [0X %f] 0X d", dtl * wscale));
    qprintf(sprintf("q [%f] 0X d", don * wscale));
      qprintf(sprintf("q [%f %f] 0X d", don * wscale, doff * wscale));
    qprintf(sprintf("q %f g", 1 - fillval));
  rx = $5 + 0;
  ry = $6 + 0;
  s = $7 + 0;
# section end \pdfliteral
# See the GNU General Public License for more details.
/^\\setbox\\graph=\\vtop{/ {
# <sh> prepare shading of object interior
/^  *\\special/ {
/^  *\\special{ar/ {
/^  *\\special{ar|^  *\\special{ia/ {
/^  *\\special{da/ {
/^  *\\special{dt/ {
/^  *\\special{fp/ {
/^  *\\special{ip/ {
/^  *\\special{pa/ {
/^  *\\special{pn/ {
/^  *\\special{sh/ {
/^  *\\special{sp/ {
# <sp> like <fp>, but path printed as splines
#   Spline curve shapes not fully authentic (unknown algorithm).
#   Splines might be outside bounding box.
    startpdfliteral();
    stoppdfliteral();
# TeX parts end \pdfliteral, and also TeX parts embedded in .PS ... .PE
# The author may be contacted via the e-mail address
# the following expression triggers tpic processing for pic <= 1.18.1
# the following expression triggers tpic processing for pic = 1.19
# the Free Software Foundation; either version 2 of the License, or (at
# This program is distributed in the hope that it will be useful, but
# This program is free software; you can redistribute it and/or modify
    tpicmode = 0;
  tpicmode = 0;
  tpicmode = 1;
# tpic \special desciption see e. g.:
#   underflow numbers like 1e-14 in \pdfliterals. Remove trailing
# Usage:
#   vertical picture positioning supported.
# WITHOUT ANY WARRANTY; without even the implied warranty of
  wscale = 72.0 / 1000;
  x0 = rx * cos(s) + xc;
    x0 = x3;
    x1 = x0 - rx * c * sin(s + i * phi);
      x2 * wscale, -y2 * wscale, x3 * wscale, -y3 * wscale));
    x2 = x3 + rx * c * sin(s + (i + 1) * phi);
    x3 = rx * cos(s + (i + 1) * phi) + xc;
  xc = $3 + 0;
  x[pointbuf] = $3 + 0;
  x[pointbuf] = x[pointbuf - 1];
  y0 = ry * sin(s) + yc;
    y0 = y3;
    y1 = y0 + ry * c * cos(s + i * phi);
    y2 = y3 - ry * c * cos(s + (i + 1) * phi);
    y3 = ry * sin(s + (i + 1) * phi) + yc;
  yc = $4 + 0;
# your option) any later version.
# You should have received a copy of the GNU General Public License
  y[pointbuf] = $4 + 0;
  y[pointbuf] = y[pointbuf - 1];
#   zeroes of floating point numbers.
