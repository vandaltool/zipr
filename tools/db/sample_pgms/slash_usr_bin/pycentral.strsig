        
        )
                            abs_link = os.path.normpath(os.path.join(os.path.dirname(f2), link))
                                abs_link = os.path.normpath(os.path.join(os.path.dirname(fn2), link))
                        abs_link = os.path.normpath(os.path.join(os.path.dirname(fn2), link))
    action = known_actions[action_name]()
    action_name = args[0]
        action_name = matching_actions[0]
        action_names = known_actions.keys()
        action_names.sort()
              % (action_name, str(list(matching_actions))))
    action_options, action_names = action.parse_args(args)
                         action='store_true', dest='dryrun')
                      action='store_true', dest='help')
                      action='store_true', dest='verbose')
                # a little convoluted, but we need to get the current architecture
        # a little convoluted, but we need to get the current architecture
            all_chunks = []
                    all_chunks.append(chunk)
                all_chunks.append(chunk)
        all_chunks = chunks(links)
                # already removed, but /var/lib/dpkg/status not yet updated
              "ambiguous action `%s', matching actions: %s"
           and not os.path.exists('/var/lib/dpkg/info/%s/%s.list' % (arch, self.pkgname)):
               and not os.path.exists('/var/lib/dpkg/info/%s:%s.list' % (pkgname, arch)):
           and not os.path.exists('/var/lib/dpkg/info/%s:%s.list' % (self.pkgname, arch)):
           and self.has_private_module or self.has_private_extension:
    Any additional directory arguments are ignored (only files
                arch = fd.readline().strip()
        arch = fd.readline().strip()
        arch = self.get_arch()
        arg_list = all_chunks[0]
    # ask dpkg what it knows about the files in question
        assert self.oldstyle
                              'attribute XS-Python-Version not in Source section'
    bccompile is a replacement for the current byte compilation
        bc_option = config.get('DEFAULT', 'byte-compile')
    bc_option = config.get('DEFAULT', 'byte-compile')
                                              bc_option, exclude_regex, force=True)
        bc_option = get_debian_config().get('DEFAULT', 'byte-compile')
    bc_unknown = bc_values - set(['standard', 'optimize'])
    bc_values = set([v.strip() for v in bc_option.split(',')])
            break
                break
                    break
                            break
                                break
                buffer = cStringIO.StringIO()
        buffer = None
                buffer.write(line)
                   '--by-package=%s' % os.environ.get('DPKG_MAINTSCRIPT_PACKAGE', 'python'),
                byte_compile_default=True, ignore_errors=False):
        # byte compile files inside prefix
                            byte_compile_for_default,
        byte_compile_for_default = (self.runtime == default_runtime)
        """byte compiles all files not handled by pycentral"""
    """byte compile the *.py files in <package> using the the
        # byte-compile with default python version
        # byte compile with the default runtime for the package
        """call compileall.py -x <exclude regexp> <dirs> according
        # called with directories as arguments
# call the main routine
            # cannot install yet; remove the symlinked files and byte code files from the old
        # check if these belong to packages
    # check if the specified action really exists
    # checks
    # check the arguments according to the action called
                    chunk = []
            chunk = []
                chunk.append(i)
                chunk_max = 16384
            chunk_max -= 20
                chunk_max = os.sysconf('SC_ARG_MAX')
            chunk_max -= reduce(lambda x,y: x+y,
class Action:
class ActionBCRemove(Action):
class ActionByteCompile(Action):
class ActionCleanupPkgPrepareUpdates(Action):
class ActionDebhelper(Action):
class ActionList(Action):
class ActionPkgInstall(Action):
class ActionPkgList(Action):
class ActionPkgPrepare(Action):
class ActionPkgRemove(Action):
class ActionPyCentralDir(Action):
class ActionRuntimeInstall(Action):
class ActionRuntimeRemove(Action):
class ActionShowDefault(Action):
class ActionShowSupported(Action):
class ActionShowVersions(Action):
class ActionUpdateDefault(Action):
class ActionVersion(Action):
class DebPackage:
class Logging:
        class MyDircmp(filecmp.dircmp):
class PyCentralConfigParser(SafeConfigParser):
class PyCentralError(Exception):
class PyCentralVersionMissingError(PyCentralError):
class PythonRuntime:
        # cleanup after failed pkgprepare upgrades, see #552595.
                   'cleanup-pkgprepare-updates'],
                cmd[1:1] = ['-O']
        cmd.append('-')
            cmd.append('-f')
            cmd.append('-i')
        cmd.extend(dirs)
            cmd.extend(['-x', exclude])
        cmd_list = ["dpkg","-S"]
        cmd = [self.interp, self.prefix + '/compileall.py', '-q']
          cmd = [self.interp, '/usr/bin/py3_compilefiles', '-q']
          cmd = [self.interp, '/usr/bin/py_compilefiles', '-q']
                cmd = ['/usr/bin/dpkg', '--print-architecture']
        cmd = ['/usr/bin/dpkg', '--print-architecture']
                cmd = ['/usr/bin/dpkg-query', '-L', self.name]
            cmd = ['/usr/bin/dpkg-query', '-s', self.name]
            cmd = ['/usr/bin/dpkg-query', '-W', '-f', '${Status}\n', pkgname]
            conf = get_debian_config()
            config_file = '/usr/share/pyshared-data/%s' % self.name
        config = get_debian_config()
            config.readfp(open(fn))
    config = SafeConfigParser()
    config.set('DEFAULT', 'byte-compile', ', '.join(bc_values))
        config.set('DEFAULT', 'byte-compile', 'standard')
    config.set('DEFAULT', 'overwrite-local', overwrite_local and '1' or '0')
                continue
                    continue
                        continue
                            continue
                            continue # raise PyCentralError, msg at end of loop
                                continue # raise PyCentralError, msg at end of method
        cv = pyversions.default_version(version_only=True)
                    d = '.'
                d2 = rt.prefix + d1[ppos:]
        dangling = []
                    dangling.append(link)
        dangling = self.check_dangling_links()
                dco.differs = False
                dco = MyDircmp(site1, site2)
                dco.report_full_closure()
    debian_config = config
debian_config = None
                # debian_defaults is not up-to-date (LP: #354228)
            debug_files.append('...')
        debug_files = files2[:min(2, len(files2))]
    DEBUG, INFO, WARN, ERROR = range(4)
def action_matches(action, actions):
    def add_shared_links(self):
                         default='add-provides' in envvar, action='store_true', dest='provides')
                         default='current', action='store', dest='version')
                         default=('dry-run' in envvar) or ('no-act' in envvar),
                         default='include-links' in envvar, action='store_true', dest='includelinks')
                         default='no-move' in envvar or 'nomove' in envvar, action='store_true', dest='nomove')
                         default=None, action='store', dest='exclude')
                         default=None, action='store', dest='ignore')
    default python version (or use the version specified with -v.
        default_rt = get_default_runtime()
default_runtime = None
                    default_runtime.remove_byte_code(files)
                    default_runtime.remove_byte_code(linked_files)
                    default_runtime.remove_byte_code(removed_fs)
                default_runtime.remove_byte_code(removed_fs)
                default_runtime.remove_byte_code(self.private_files)
                default_runtime = rt
                              default_runtime=self.runtime)
                         default='stdout' in envvar, action='store_true', dest='stdout')
                         default=substvars_default, dest='substvars')
        default_version = pyversions.default_version(version_only=True)
def build_relative_link(tgt, link):
    def byte_compile_dirs(self, dirs, bc_option, exclude=None):
    def byte_compile(self, files, bc_option, exclude=None, ignore_errors=False, force=False):
    def byte_compile(self, runtimes, bc_option, exclude_regex, ignore_errors=False):
    def check_args(self, global_options):
    def check_dangling_links(self):
        def chunks(l):
    def debug_list(self, tab, s, l, n=4):
    def debug(self, s):
    def error(self, msg, stream=sys.stderr, go_on=False):
    def error(self, s):
    def gen_substvars(self):
    def get_arch(self):
def get_debian_config():
def get_default_runtime():
def get_file_overwrite_error(existing_files):
def get_installed_runtimes(with_unsupported=True):
    def get_option_parser(self):
def get_runtime_for_version(version):
    def info(self, msg, stream=sys.stderr):
    def info(self, s):
    def __init__(self):
    def __init__(self, kind, name,
    def __init__(self, level=WARN):
    def __init__(self, name, version, interp, prefix):
    def install(self, runtimes, bc_option, exclude_regex,
    def link_shared_files(self, rt):
    def links_in_packages(self, links):
    def list_byte_code(self, files):
    def list(self, runtimes, list_script_files=True):
    def list_shared_files(self, rt):
    def locate(self, arg_list, cmd_list):
def main():
    def move_files(self):
    def msg(self, level, s):
    def parse_args(self, arguments):
def parse_options(args):
    def prepare(self, runtimes, old_runtimes, old_pkg, ignore_errors=False):
    def print_info(self, fd=sys.stdout):
    def read_control(self):
def read_dpkg_status(verbose=False):
    def read_preinst_pkgconfig(self):
    def read_pyfiles(self):
    def read_version_info(self, use_default_if_missing=False):
def register_action(action_class):
    def remove_bytecode(self):
    def remove_byte_code(self, files):
    def remove(self, runtimes, remove_script_files=True):
            def report(self):
    def run(self, global_options):
    def run(self, global_opts):
def samefs(path1, path2):
    def set_default_runtime_from_version_info(self):
def setup_logging(loglevel=Logging.WARN, verbose=False):
    def set_version_field(self, version_field):
def third_party_dir(version):
    def unlink_shared_files(self, rt):
    def update_bytecode_files(self, runtimes, rt_default, bc_option):
def usage(stream, msg=None):
def version2depends(vinfo):
    def warn(self, msg, stream=sys.stderr):
    def warn(self, s):
    del args[0]
        del l[0], t[0]
        depends = ''
                depends = line.split(':', 1)[1].strip()
        deps = 'python (>= %s), python (<< %d.%d)' % (cv, nv[0], nv[1]+1)
        deps = 'python (>= %s), python (<< %d.%d)' % (vinfo[0], nv[0], nv[1]+1)
        deps = 'python (>= %s)' % supported[0]
        dirs = []
                    dirs.append(os.path.dirname(fn))
        dirs_in_new = set([fn for fn, t in self.pkgconfig.items('files')
        dirs_in_old = set()
            dirs_in_old = set([fn for fn, t in old_pkg.pkgconfig.items('files')
            # do nothing.
                    d = os.path.dirname(f2)
                # do the same with -dbg packages (which don't have an Python-Version attribute)
                    d = root[len(self.pkgdir):]
                    d = root[len(srctop)+1:]
                    dst = os.path.join(dsttop, d, name)
        dsttop = self.pkgdir + shared_base2
        d = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
            elif fn.startswith('/etc/') or fn.startswith('/usr/share/doc/'):
            elif fn.startswith(old_shared_base):
            elif fn.startswith('/usr/lib/site-python/'):
            elif fn.startswith('/usr/share/python-support') \
            elif isinstance(self.sversion_info, list) or isinstance(self.sversion_info, set):
    elif len(matching_actions) > 1:
            elif line.startswith('Depends:'):
                elif line.startswith('Package: ' + self.name):
            elif line.startswith('Python-Version:'):
                elif line.startswith('Source:'):
            elif line.startswith('Status:'):
                elif line.startswith('XB-Python-Version:'):
                elif line.startswith('XS-Python-Version:'):
                    elif name.endswith('.pyc') or name.endswith('.pyo'):
            elif not fn.endswith('.py') and not fn.endswith('.so'):
            elif os.environ.has_key("PYCENTRAL_NO_DPKG_QUERY"):
        elif os.environ.has_key("PYCENTRAL_NO_DPKG_QUERY"):
                    elif os.path.exists(line):
                    elif os.path.isdir(srcdtop3):
                elif os.path.isdir(srctop3):
            elif os.path.isfile(config_file):
        elif pyversions.default_version(version_only=True) in versions:
            elif re.match(r'/usr/lib/python\d\.\d/', fn):
            elif re.search(r'/s?bin/', fn):
                    elif rx.search(depends):
        elif self.has_private_module or self.has_private_extension:
        elif self.options.substvars == 'file':
                elif self.pkgconfig.get('pycentral', 'include-links') == '':
                elif self.sversion_info == 'all':
            elif self.sversion_info == 'all':
            elif self.sversion_info == 'current':
            elif self.sversion_info == 'current_ext':
            elif unsupported and os.path.basename(interp) in unsupported:
    elif vinfo == 'current_ext':
    elif vinfo in ('all', 'current'):
                            else:
                        else:
                    else:
                else:
            else:
        #else:
        else:
    else:
                                 env={"LANG" : "C"},
                             env={"LANG" : "C"},
    env_level = os.environ.get('PYCENTRAL', 'warn').lower()
            envvar = os.environ.get('DH_PYCENTRAL', '')
        errors = False
                errors = p.returncode != 0
                errors = rv != None
                        errors = True
                # exact version info required, no enumeration, no relops
        except:
        except Exception, msg:
                except ImportError:
            except ImportError:
        except IOError:
except NameError:
                            except OSError:
                        except OSError:
                    except OSError:
                except OSError:
            except OSError:
        except OSError:
                    except OSError, e:
            except OSError, e:
            except PyCentralError:
        except PyCentralError:
            except PyCentralError, msg:
        except PyCentralError, msg:
        except PyCentralVersionMissingError, msg:
        except pyversions.PyCentralEmptyValueError, msg:
                except ValueError:
            except ValueError:
        except ValueError:
                                                  exclude_regex, ignore_errors)
        exclude_regex = None
        existing_files = []
                        existing_files.append(f2)
                    existing_files.append(fn2)
        existing_links = []
                        existing_links.append(link)
                f2 = rt.prefix + f1[ppos:]
        failed = []
                failed.append(pkgname)
                fd.close()
            fd.close()
        fd.close()
            fd = open('/var/lib/dpkg/info/%s.preinst' % self.name, 'r')
                    fd = os.popen(' '.join(cmd))
                fd = os.popen(' '.join(cmd))
                fd = os.popen(' '.join(cmd), 'w')
                fd = p.stdin
                    fd = p.stdout
                fd = p.stdout
            fd = p.stdout
        fd = p.stdout
                fd.write(fn + '\n')
        fd.write('Package: %s\n' % self.name)
        fd.write('    private files :%4d\n' % len(self.private_files))
            fd.write('    pylib%s files:%4d\n' % (ver, len(files)))
        fd.write('    shared files  :%4d\n' % len(self.shared_files))
        field; check that XB-Python-Version exists for the package."""
            files2 = []
                files2.append(fn)
            files2 = files
        files = [fn for fn, t in self.pkgconfig.items('files')]
        files.sort()
                # first matching runtime)
        # FIXME: run from the preinst, package may not exist
            # FIXME: undo
                fn2 = rt.prefix + fn[ppos:]
            fn2 = rt.prefix + fn[ppos:]
                fnc = fn + ext
    fn = '/etc/python/debian_config'
            fn = line
                fn = line.split(':', 1)[1][1:]
                fn = line.split(':', 1)[1][1:-11]
        for arg_list in all_chunks[1:]:
            for block in open("/var/lib/dpkg/status").read().split("\n\n"):
            for d1 in new_dirs:
            for d1 in removed_dirs:
        for d in dirs:
        for ext in ('c', 'o'):
            for f1 in new_fs:
            for f1 in removed_fs:
        for files in self.pylib_files.values():
                    for f in default_runtime.list_byte_code(files):
                for f in default_runtime.list_byte_code(linked_files):
                for f in default_runtime.list_byte_code(self.private_files):
            for f in pkg.list(runtimes, list_script_files=True):
                for f in self.list_shared_files(rt):
            for fn in files:
            for fn in files2:
                                 for fn in old_pkg.shared_files if fn[-3:] == '.py']
            for fn in packaged:
            for fn in pyfiles:
                                     for fn in self.shared_files
                                 for fn in self.shared_files
            for fn in self.shared_files:
        for fn in self.shared_files:
        for fn in shared_files:
        for fn in unowned:
            for i in l:
    for i in range(len(levels)):
        for interp in glob.glob('/usr/bin/python[0-9].[0-9]'):
                    for line in block.split("\n"):
            for line in fd:
        for line in fd.readlines():
            for line in file('debian/control'):
        for line in file('/var/lib/dpkg/status'):
                for line in lines:
        for line in lines:
            for line in map(string.strip, stderr.split("\n")):
        for line in map(string.strip, stderr.split("\n")):
            for line in map(string.strip, stdout.split("\n")):
        for line in map(string.strip, stdout.split("\n")):
            for link in existing_links:
                for name in dirs:
                    for name in files:
                for name in files:
        for n in action_names:
        for opt in ('standard', 'optimize'):
            for pkg in self.needed_packages:
        for pkgname, vstring in packages:
        for pkgname, vstring, vinfo in needed_packages:
        for pv1 in pversions:
            for pv2 in pversions[pversions.index(pv1)+1:]:
        for pversion in pversions:
        for pv in ('2.3', '2.4', '2.5'):
        for (p, v) in read_dpkg_status():
            for pyver, files in old_pkg.pylib_files.items():
            for pyver, files in self.pylib_files.items():
        for pyver, files in self.pylib_files.items():
            for root, dirs, files in os.walk(sdir, topdown=False):
            for root, dirs, files in os.walk(self.pkgdir):
        for root, dirs, files in os.walk(self.pkgdir + shared_base2, topdown=False):
            for root, dirs, files in os.walk(self.pkgdir + '/usr/lib', topdown=False):
            for root, dirs, files in os.walk(srctop):
            for root, dirs, files in os.walk(srctop, topdown=False):
            for root, dirs, files in os.walk(tgttop, topdown=True):
        for rt in get_installed_runtimes():
    for rt in get_installed_runtimes():
        for rt in get_installed_runtimes(with_unsupported=True):
            for rt in old_runtimes:
                for rt in runtimes:
            for rt in runtimes:
        for rt in runtimes:
        for ver, files in self.pylib_files.items():
                                       for ver in prversions])
                for version, dirs in self.pylib_dirs.items():
        for version in versions:
                found_base2 = True
    found in the package are byte compiled. Files in
        found_old_base = found_base2 = False
                found_old_base = True
from ConfigParser import SafeConfigParser
from optparse import OptionParser
        from subprocess import PIPE, Popen
    from subprocess import PIPE, Popen
            fs_in_new = set([fn for fn in self.private_files if fn[-3:] == '.py'])
                fs_in_new = set([fn for fn in self.pylib_files.get(pyver, []) if fn[-3:] == '.py'])
        fs_in_new = set([fn for fn, t in self.pkgconfig.items('files')
        fs_in_old = set()
                fs_in_old = set([fn for fn in files if fn[-3:] == '.py'])
            fs_in_old = set([fn for fn in old_pkg.private_files if fn[-3:] == '.py'])
            fs_in_old = set([fn for fn, t in old_pkg.pkgconfig.items('files')
        # functionality disabled starting with 0.6.9
    generated by the dh_python debhelper script.
    get_installed_runtimes()
    global debian_config
    global default_runtime
    global installed_runtimes
    global logging
    global_options, action = parse_options(sys.argv[1:])
    global_options, args = parser.parse_args()
                           go_on=True)
                # hack to make pycentral work with fakechroot
    help = ""
    help = 'byte compile .py files in a package'
                         help="byte compile using this python version",
    help = 'cleanup dangling symlinks and byte code files'
                         help="do not move files to pycentral location",
                         help="dry run",
    helper that returns a error string to be passed to the user when
                         help="generate substitution for python:Provides",
                      help='help screen',
                         help="ignore errors during byte compilations",
                         help="include links to the pycentral location",
                         help="just print substitution variables to stdout",
    help = 'List all pycentral-managed files'
    help = 'list all pycentral-managed files for <package>'
    help = 'make a package available for all supported runtimes'
    help = 'make installed packages available for this runtime'
    help = 'move files to pycentral location, variable substitutions'
    help = 'prepare a package for all supported runtimes'
    help = 'remove a package installed for all supported runtimes'
    help = 'remove packages installed for this runtime'
    help = 'remove the byte compiled .py files'
    help = 'Show default python version number'
    help = 'Show the pycentral installation directory for the package'
    help = 'Show the pycentral version'
    help = 'Show the supported python versions'
    help = 'Show version numbers of supported python versions'
                         help="skip files matching the regular expression",
    help = 'update the default python version'
                      help='verbose mode',
                         help="where to print substitution vars (no, file, stdout)",
        if 0 and self.directories:
                    if abs_link == f1 or link == f1:
                        if abs_link == fn or link == fn:
                if abs_link == fn or link == fn:
    if action.check_args(global_options):
    if action.name == 'debhelper' or action.name.startswith('show'):
            # if all existing files are found in the old package in
    if bc_unknown:
            if buffer:
        if buffer is None:
        if byte_compile_default:
            if chunk:
    if config.has_option('DEFAULT', 'overwrite-local'):
    if debian_config is not None:
        if env_level.find(levels[i]) != -1:
            if errors:
        if errors:
        if exclude:
        if existing_files:
            if existing_files and not overwrite_local:
        if existing_files and not overwrite_local:
        if existing_links:
        if failed:
        if 'file' in self.options.substvars:
                                     if fn[-3:] == '.py']
                                 if fn[-3:] == '.py']
                if fn.endswith('.py'):
                if fn.endswith('.so'):
                if fn in arg_list:
            if fn.startswith(shared_base2):
        if force:
        if found_old_base and found_base2:
        if ignore_errors:
        if isinstance(versions, list) or isinstance(versions, set):
    if isinstance(vinfo, list):
    if isinstance(vinfo, set):
                if lchunk + len(i)+1 > chunk_max:
    if len(args) == 0 or global_options.help:
        if len(files2) > 2:
        if len(l2) > 0:
        if len(l) > n:
    if len(matching_actions) == 0:
        if len(packaged) > 0:
        if len(self.args) != 0:
        if len(self.args) < 1:
        if len(self.args) != 1:
        if len(self.args) < 2:
        if len(self.args) != 2:
            if len(self.has_shared_extension):
        if (len(self.has_shared_module) or len(self.has_shared_extension)) \
        if len(self.has_shared_module) or len(self.has_shared_extension):
                if len(self.sversion_info) != 1 or not re.match(r'\d\.\d', self.sversion_info[0]):
            if len(used_runtimes) == 0:
        if len(versions) == 1:
        if level < self.level:
                if line == '':
             if line:
                if line == '': continue
            if line in ('PYEOF\n', 'EOF\n'):
            if line == '[python-package]\n':
            if lines:
            if line.startswith('Package:'):
                        if line.startswith('Python-Version:'):
                if line.startswith('Python-Version:'):
                if linked_files:
                            if link.startswith('../'):
                        if link.startswith('../'):
                    if link.startswith('../'):
        if list_script_files:
                    if m and rename:
                if mo:
if __name__ == '__main__':
        if name.startswith('python'):
                if needle in block:
    if not config.has_option('DEFAULT', 'byte-compile'):
        if not dangling:
        if not files2:
        if not go_on:
            if not_in_same_pkg == set():
            if not 'installed' in status:
    if not installed_runtimes:
                    if not interp.startswith('/usr/bin/python3'):
        if not len(self.args) in (1, 2):
                        if not link or not (abs_link.startswith(shared_base2) or abs_link.startswith(shared_base)):
                    if not link or not (abs_link.startswith(shared_base2) or abs_link.startswith(shared_base)):
                if not link or not (abs_link.startswith(shared_base2) or abs_link.startswith(shared_base)):
            if not opt in bc_option:
            if not (os.path.basename(interp) in supported
                if not os.path.dirname(fn) in dirs:
        if not os.path.exists('debian/control'):
    if not (os.path.exists(path1) and os.path.exists(path2)):
            if not os.path.exists('/var/lib/dpkg/info/%s.list' % pkgname) \
        #if not os.path.exists('/var/lib/dpkg/info/%s.list' % self.pkgname):
        if not os.path.exists('/var/lib/dpkg/info/%s.list' % self.pkgname) \
                    if not os.path.isdir(d):
            if not os.path.isdir(sdir):
                if not (os.path.isdir(site1) and os.path.isdir(site2)):
                    if not os.path.islink(link):
                    if not p in (self.rtname, self.rtname+'-minimal')]
        if not self.depends:
            if not self.name in [p for (p,v) in read_dpkg_status()]:
        if not self._option_parser:
            if not self.options.nomove:
            if not self.pkgconfig:
                if not self.pkgconfig.has_option('pycentral', 'include-links'):
#                if not self.rtname_short in requested:
        if not self.runtime:
        if not self.shared_files:
        if not self.version_field:
        if not self.version_field and use_default_if_missing:
    if not stdout and not stderr:
        if not symlinks_included and self.shared_files:
                    if not target.startswith('/usr/share/pyshared/'):
        if not versions:
            if old and os.path.basename(interp) in old:
            if old_pkg:
        if old_pkg:
        if old_pkg and old_pkg.private_files:
        if old_pkg and old_pkg.pylib_files:
        if old_pkg and old_pkg.shared_files:
            if opt == 'optimize':
                if os.path.exists(f2):
    if os.path.exists(fn):
                    if os.path.exists(fn2):
                if os.path.exists(fn2):
            if os.path.exists(fn2):
                if os.path.exists(fnc):
                    if os.path.exists(link):
                    if os.path.exists(target):
                if os.path.exists('/var/lib/dpkg/info/%s.list' % self.name):
        if os.path.exists('/var/lib/dpkg/info/%s.list' % self.pkgname) \
                if os.path.isdir(d2):
                    if os.path.isdir(fn2):
            if os.path.isdir(fn2) and not os.path.islink(fn2):
                if os.path.isdir(fn) and not os.path.islink(fn):
            if os.path.isdir(fn) and not os.path.islink(fn):
                    if os.path.isdir(line) and not os.path.islink(line):
                if os.path.isdir(pkgdbgdir):
                    if os.path.isdir(srcdtop2):
                    if os.path.isdir(srcdtop) and (os.path.isdir(srcdtop2) or os.path.isdir(srcdtop3)):
                if os.path.isdir(srctop2):
                if os.path.isdir(srctop) and (os.path.isdir(srctop2) or os.path.isdir(srctop3)):
                    if os.path.islink(f2):
                        if os.path.islink(fn2):
                if os.path.islink(fn2):
        if os.path.ismount(path1):
        if os.path.ismount(path2):
        if out:
                            if overwrite_local:
                        if overwrite_local:
            if overwrite_local:
            if p:
        if pkgdir:
                if pkg.shared_files or pkg.private_files:
        if prefix.endswith('/'):
            if prversions == '':
            if pversion in ('python2.3', 'python2.4', 'python2.5'):
        if 'python3' in self.interp:
                    if 'python-support' in depends:
                     if re.match(r'python\d\.\d', d)]
                if re.match(r'/usr/lib/python\d\.\d/', fn):
                    if re.match("/usr/lib/python\d\.\d($|/)", root.replace(self.pkgdir, "")):
        if removed:
                if removed_fs:
            if removed_fs:
        if remove_script_files:
                    if re.search(r'\.so(\.\d+)*?$', name):
                if root.endswith('DEBIAN'):
                if root != self.pkgdir:
                if root == srctop:
                if rt in runtimes:
            if rt in runtimes:
            if rt.name == self.rtname:
                if rt == rt_default:
        if rt.version == version:
            if rv:
            if rx.search(depends):
        #if samefs(rt.prefix, self.shared_files[0]):
            if 'SC_ARG_MAX' in os.sysconf_names:
                    if section == self.name:
                    if section != 'Source':
                if self.diff_files:
        if self.fd:
                if self.funny_files:
                if self.left_only:
                if self.left_only or self.right_only or self.diff_files or self.funny_files:
        if self.name.startswith('python-'):
            if self.options.includelinks:
        if self.options.nomove and self.options.includelinks:
        if self.options.stdout or self.options.substvars == 'stdout':
            if self.options.substvars!='no':
        if self.parse_versions:
            if self.pkgconfig:
        if self.pkgconfig and self.pkgconfig.has_option('python-package', 'python-version'):
        if self.pkgdir:
                if self.private_dirs:
            if self.private_files:
        if self.private_files:
        if self.pylib_files:
                if self.right_only:
        if self.rtname[-8:] == '-minimal':
            if self.runtime.short_name in requested:
            if self.shared_files:
        if self.shared_files:
        if self.sversion_field == None:
            if self.sversion_info == 'all':
            if self.sversion_info == 'current':
                if self.sversion_info in ('current', 'current_ext'):
        if self.version_field:
        if self.version_field == None:
        if shared_base2[-1] == '/':
        if stderr:
    if stderr:
        if stdout:
    if stdout:
        if 'stdout' in self.options.substvars:
        if sts != 0:
            if 'substvars=file' in envvar:
            if 'substvars=stdout' in envvar:
        if symlinks_included:
                    if target.startswith('..'):
                               if t == 'd' if fn.startswith(self.shared_prefix)])
                           if t == 'd' if fn.startswith(self.shared_prefix)])
                             if t == 'f' if fn.startswith(self.shared_prefix)])
                         if t == 'f' if fn.startswith(self.shared_prefix)])
            # if the current installed version does not use python-central
                        if verbose:
                if verbose:
    if verbose:
                    if version == 'current':
    if version == 'current':
            if version == default_version:
        if version in ('2.3', '2.4', '2.5'):
    if version in ('2.3', '2.4', '2.5'):
                if version != None and 'installed' in status:
        if version != None and 'installed' in status:
        if versions == '':
    if version.startswith('python'):
            if vstring.find('current') == -1:
                if with_unsupported:
        if with_unsupported:
                            ignore_errors = self.options.ignore != None)
        import filecmp
import glob, logging, os, re, string, sys, time, cStringIO
import pyversions
    import sets
        import shutil
                    import subprocess
                import subprocess
        import subprocess
                         " in `byte-compile option'\n"
        installed_runtimes = []
            installed_runtimes.append(rt)
installed_runtimes = None
        # install shared .py files
    # instantiate an object for the action and parse the remaining arguments
            # just "copy" it from the source field
                # keep _all_ files and directories
                # knowledge about. this causes install errors when
known_actions = {}
    known_actions[action_class.name] = action_class
    l = []
            l2.append('...')
        l2 = l[:min(n, len(l))]
        l.append("Error, can not overwrite existing files:")
                 l.append("   "+line)
                 l.append("  "+line)
        l.append("Not overwriting files owned by other packages:")
        l.append("Not overwriting local files:")
                    lchunk = 0
            lchunk = 0
                lchunk += len(i) + 1
                      % (len(files), len(files2), self.name))
                                [len(k)+len(v)+3 for k,v in os.environ.items()])
                     % (len(packages), len(needed_packages), self.rtname))
                     % (len(self.needed_packages), self.rtname))
    levels = ['debug', 'info', 'warn', 'error']
        l.extend(existing_files)
                line = line.strip()
            lines = []
                    lines.append(d)
                        lines.append(os.path.join(d, name))
                lines = [fn for fn, t in self.pkgconfig.items('files')]
                    lines = map(string.strip, open('/var/lib/dpkg/info/%s.list' % self.name).readlines())
                    lines = map(string.strip, open('/var/lib/dpkg/info/%s:%s.list' % (self.name, arch)).readlines())
                lines = [s[:-1] for s in fd.readlines()]
                lines = self.read_preinst_pkgconfig()
                lines.sort()
                        link = abs_link = None
                    link = abs_link = None
                link = abs_link = None
                        link = abs_link = os.readlink(f2)
                            link = abs_link = os.readlink(fn2)
                    link = abs_link = os.readlink(fn2)
                    link_cmd(f1, f2)
                    link_cmd(fn, fn2)
        #    link_cmd = os.link
        #    link_cmd = os.symlink
        link_cmd = os.symlink
        linked_files = []
                            linked_files.append(fn2)
                    linked_files.append(fn2)
            linked_files.reverse()
                    linked_files = [ rt.prefix + fn[ppos:]
                linked_files = [ rt.prefix + fn[ppos:]
                    linked_files = self.link_shared_files(rt)
                    link = os.path.join(linkroot, name)
                    link = os.path.join(root, name)
                linkroot = root.replace(tgttop, linktop, 1)
        """link shared files at runtime"""
            linktop = os.path.join(self.pkgdir, third_party_dir(version))
        # list byte code for script files
        # list byte compiled files inside prefix
        # list shared .py files
    l = link.split('/')
    local files are detected (and querries if they are local installs
        logging.debug('bccompile %s' % self.pkgname)
            logging.debug("bc for v%s (%d files)" % (pyver, len(files)))
            logging.debug("bc %s private (%d files)" %
        logging.debug("    byte-compile %s" % self.name)
            logging.debug("dpkg-query -s %s" % self.name)
        logging.debug_list('\t', 'new      dirs', new_dirs)
        logging.debug_list('\t', 'new     files', new_fs)
        logging.debug_list('\t', 'removed  dirs', removed_dirs)
        logging.debug_list('\t', 'removed files', removed_fs)
                logging.debug_list('\t', 'removed private', removed_fs)
                    logging.debug_list('\t', 'removed pylib', removed_fs)
                    logging.debug_list('\t', 'removed runtimes', linked_files)
                logging.debug("Not using dpkg-query as requested")
            logging.debug("Not using dpkg-query as requested")
        logging.debug('pycentral ' + ' '.join(sys.argv[1:]))
                logging.debug("reading %s" % config_file)
        logging.debug("    remove byte-code for %s" % self.name)
            logging.debug('%s    %s' % (tab, l2))
        logging.debug('\tavail=%s, pkg=%s, install=%s'
        logging.debug('\tavail=%s, pkg=%s, prepare=%s'
        logging.debug('\tbyte-compile directories')
        logging.debug('\tbyte-compile files (%d/%d) %s' \
        logging.debug('\tinstall package %s' % self.name)
        logging.debug("\tlink shared files %s/%s" % (rt.name, self.name))
        logging.debug('\tlist byte-code files (%d)' % (len(files)))
        logging.debug('\tlist package %s' % self.name)
        logging.debug('\tlist_shared_files %s/%s' % (rt.name, self.name))
        logging.debug('\tprepare package %s' % self.name)
        logging.debug('\tremove byte-code files (%d)' % (len(files)))
        logging.debug('\tremove package %s' % self.name)
        logging.debug('\t    %s' % debug_files)
        logging.debug('\tunlink_shared_files %s/%s' % (rt.name, self.name))
        logging.debug('\tupdate byte-code for %s' % self.name)
            logging.debug("Using python-version from pkgconfig: %s" % self.version_field)
            logging.error("error reading config file `%s'" % fn)
        logging.error('%s %s: %s' % (program, self.name, msg))
#                    logging.info("%s not in what requested_versions() returned, adding it anyway" % self.rtname_short)
        logging.info('%s %s: %s' % (program, self.name, msg))
                logging.info("%s: upgrade from package version not using python-central" % self.name)
                logging.info("%s: upgrade from package version with unmoved files" % self.name)
        logging.info('\t%d packages with Python-Version info installed, %d for %s'
        logging.info('\t%d pycentral supported packages installed, %d for %s'
            logging.info('\tno files to byte-compile')
            logging.info('\trtremove: remove package %s for %s' % (pkgname, self.rtname))
                logging.info('\tsupport %s for %s' % (pkgname, self.rtname))
                logging.info('\tunsupported for %s: %s (%s)' % (self.rtname, pkgname, vstring))
        logging.info('\tupdate default: update %d packages for %s'
    logging = Logging(loglevel)
            logging.warn("%s: has no Python-Version field, assuming default runtime" % self.name)
            logging.warn("%s: no matching runtime for `%s', using default"
        logging.warn('%s %s: %s' % (program, self.name, msg))
                    logging.warn('\t%s not available for %s (%s)'
            loglevel = i
        loglevel = Logging.DEBUG
                    # LP #332532, empty value in file
    main()
                    # make sure that fn2 really does not exist; this is a
# match a string with the list of available actions
    matching_actions = action_matches(action_name, known_actions.keys())
                  'missing XB-Python-Version attribute in package %s' % self.name
                mo = rx.search(fn)
        # move around
        """move files from the installation directory to the pycentral location"""
                    msg = "already exists: %s" % f2
                        msg = "already exists: %s" % fn2
                            msg = msg + " -> %s" % link
                        msg = msg + " -> %s" % link
                    m = vrx.match(name)
                # name
        # name
                        name2 = ''.join(m.group(1, 3, 4))
    name = 'bccompile'
    name = 'bcremove'
    name = 'cleanup-pkgprepare-updates'
    name = 'debhelper'
    name = 'list'
    name = None
    name = 'pkginstall'
    name = 'pkglist'
    name = 'pkgprepare'
    name = 'pkgremove'
    name = 'pycentraldir'
    name = 'rtinstall'
    name = 'rtremove'
    name = 'showdefault'
    name = 'showsupported'
    name = 'showversions'
    name = 'updatedefault'
    name = 'version'
        needed_packages = []
                needed_packages.append((pkgname, vstring, requested))
            needle = "Package: %s\n" % self.name
        # needs to be done for 2.3, 2.4 and 2.5 (2.6 packages were not built
        # never set in the preinst copy of the config file
        new_dirs = list(dirs_in_new.difference(dirs_in_old))
        new_dirs.sort()
        new_fs = list(fs_in_new.difference(fs_in_old))
        new_fs.sort()
                   '--no-await',
                not_in_same_pkg.difference_update(old_pylib_fs)
            not_in_same_pkg = set(existing_files)
                    # now needed to switch between old and new prefix
                # now needed to switch between old and new prefix
        # now verify/parse it
        nv = [int(s) for s in cv.split('.')]
        nv = [int(s) for s in vinfo[-1].split('.')]
            old_pkg = DebPackage('package', self.args[0], oldstyle=False)
            old_pkg = None
                old_pkg.read_version_info()
                old_pkg.set_version_field(version_field)
        old_pylib_fs = []
                old_pylib_fs += files
            old_pylib_fs += old_pkg.other_pylib_files
        old = pyversions.old_versions()
            old_requested = pyversions.requested_versions_for_runtime(old_pkg.version_field, version_only=True)
        old_shared_base = shared_base + self.name + '/site-packages/'
                 oldstyle=False, default_runtime=None,
            old_used_runtimes = []
            old_used_runtimes = [rt for rt in runtimes if rt.short_name in requested]
                # omit files in /etc and /usr/share/doc
                # omit files located in directories
        on python-central and having a Python-Version information field."""
    OPTCRE = re.compile(
    _option_parser = None
    optionxform = str
                     or fn.startswith('/usr/lib/python-support'):
                # original runtime is already removed, use the default for removal
            # original runtime is already removed, use the default for removal
            # original runtime may be removed, use the default
                    or (old and os.path.basename(interp) in old)
           or os.path.exists('/var/lib/dpkg/info/%s:%s.list' % (self.pkgname, arch)):
    or part of another package)
                    or (unsupported and os.path.basename(interp) in unsupported)):
                        os.makedirs(d)
                os.makedirs(d2)
            os.makedirs(dsttop)
                    os.makedirs(fn2)
                os.makedirs(linktop)
                            os.makedirs(os.path.dirname(srcdtop))
                        os.makedirs(os.path.dirname(srctop))
                        os.makedirs(os.path.join(linkroot, name))
                        os.mkdir(dst)
                    os.removedirs(fn2)
                        os.rename(os.path.join(root, name), os.path.join (root, name2))
                    os.rename(src, dst)
                        os.rename(srcdtop2, srcdtop)
                        os.rename(srcdtop3, srcdtop)
                    os.rename(srctop2, srctop)
                    os.rename(srctop3, srctop)
                os.rmdir(d)
                    os.rmdir(d2)
                        os.rmdir(root)
                os.rmdir(root)
            os.rmdir(self.pkgdir + shared_base2)
                os.rmdir(self.pkgdir + '/usr/lib')
                                os.rmdir(srcdtop3)
                            os.rmdir(srctop3)
                        os.symlink(rel_tgt, link)
    os.umask(0022)
                            os.unlink(f2)
                    os.unlink(f2)
                    os.unlink(f2 + 'c')
                    os.unlink(f2 + 'o')
                os.unlink(fn)
                                os.unlink(fn2)
                        os.unlink(fn2)
                    os.unlink(fn2)
                        os.unlink(fnc)
                os.unlink(fn + 'c')
                os.unlink(fn + 'o')
                        os.unlink(os.path.join(root, name))
            out = file('debian/%s.substvars' % pkg.name, 'a+')
        out = None
            out = sys.stdout
            out.write('python:Depends=%s\n' % pkg.depends)
            out.write('python:Provides=%s\n' % pkg.provides)
            out.write('python:Versions=%s\n' % pkg.version_field)
            overwrite_local = conf.get('DEFAULT', 'overwrite-local') == '1'
        overwrite_local = False
        overwrite_local = val in ('yes', '1', 'true')
            # Package doesn't provide support for any supported runtime
        packaged = self.links_in_packages(dangling)
        packages = []
                        packages.append((pkgname, version))
                packages.append((pkgname, version))
        packages = [(p, v) for p, v in read_dpkg_status()
        packages = [(p, v) for p, v in read_dpkg_status(verbose=True)
        packages = read_dpkg_status()
            p.add_option('-i', '--ignore-errors',
            p.add_option('--include-links',
            p.add_option('--no-act', '--dry-run',
            p.add_option('--no-move', '--nomove',
            p.add_option('-p', '--provides',
            p.add_option('--stdout',
            p.add_option('--substvars',
            p.add_option('-V', '--version',
            p.add_option('-x', '--exclude',
# parse command line arguments
    parser.add_option('-h', '--help',
    parser.add_option('-v', '--verbose',
    parser.disable_interspersed_args()
    parser = OptionParser(usage=shortusage)
        parser.print_help()
    parser.remove_option('-h')
        parser = self.get_option_parser()
        parser.set_usage(
                             parse_versions=self.options.substvars!='no')
    pass
        pass
            pass
                pass
                    pass
                        pass
                            pass
                    pass # no files in /
                        pass # should not happen
        path1 = os.path.dirname(path1)
        path2 = os.path.dirname(path2)
                pc.add_section('files')
                pc.add_section('pycentral')
                pc.add_section('python-package')
                pc.optionxform = str
                pc = PyCentralConfigParser()
                        pc.set('files', line, 'd')
                        pc.set('files', line, 'f')
                pc.set('pycentral', 'include-links', '0')
                pc.set('pycentral', 'version', req_pycentral_version)
                pc.set('python-package', 'format', '1')
                pkg.add_shared_links()
        pkgconfig.optionxform = str
        pkgconfig = PyCentralConfigParser()
        pkgconfig.readfp(sys.stdin)
                pkgdbgdir = self.pkgdir + '-dbg'
            pkg = DebPackage('package', p)
            pkg = DebPackage('package', pkgname)
                pkg = DebPackage('package', pkgname, oldstyle=False)
            pkg = DebPackage('package', self.args[0], oldstyle=False)
        pkg = DebPackage('package', self.args[0], oldstyle=False)
        pkg = DebPackage('package', self.args[0], oldstyle=False, pkgconfig=pkgconfig)
        pkg = DebPackage('package', self.args[0], oldstyle=True)
            pkg = DebPackage('package', self.args[0], pkgdir=pkgdir,
                pkg.default_runtime = get_default_runtime()
            pkg.default_runtime = get_default_runtime()
                pkg.default_runtime = get_runtime_for_version(used_runtimes[0])
            pkgdir = 'debian/' + self.args[0]
                 pkgdir=None, pkgconfig=None, parse_versions=True):
            pkgdir = self.args[1]
                pkg.gen_substvars()
                pkg.install([self.runtime], bc_option, None,
            pkg.install(used_runtimes, bc_option,
                pkg.move_files()
                pkgname = line.split(':', 1)[1].strip()
                           % (pkgname, self.rtname))
                                 % (pkgname, self.rtname, pkg.version_field))
        pkgname = version = None
            pkg.prepare(used_runtimes, old_used_runtimes, old_pkg)
            pkg.read_pyfiles()
                pkg.read_version_info()
            pkg.read_version_info()
        pkg.read_version_info()
        pkg.read_version_info(use_default_if_missing=True)
            pkg.remove_bytecode()
                pkg.remove(runtimes, remove_script_files=True)
            pkg.remove(runtimes, remove_script_files=True)
                pkg.remove([self.runtime], remove_script_files=False)
                    pkg.set_default_runtime_from_version_info()
                pkg.set_default_runtime_from_version_info()
            pkg.set_default_runtime_from_version_info()
        pkg.set_version_field(version_field)
            pkg.set_version_field(vstring)
                    pkg.update_bytecode_files(runtimes, default_rt, bc_option)
                         pkg.version_field,
                p = None
            p = OptionParser()
                ppos = len(self.shared_prefix)
            ppos = len(self.shared_prefix)
        ppos = len(self.shared_prefix)
        print ""
            print "  %-21s %s" % (n, known_actions[n].help)
                        print 'both directories site-packages and dist-packages exist.'
                        print 'both directories site-packages and dist-packages exist for %s-dbg.' % pversion
                        print "create directory %s" % d
                    print 'Differing files :', self.diff_files
                    print 'diff', self.left, self.right
                print f
            print 'Found existing files while including symlinks:'
                    print "INFO: ignoring unknown version '%s'" % interp
                #print "INFO: using old version '%s'" % interp
                        print "INFO: using unknown version '%s' (debian_defaults not up-to-date?)" % interp
                print "INFO: using unsupported version '%s'" % interp
        print ' '.join(supported)
        print ' '.join(versions)
                print '  ', link
                    #print linked_files
            print msg
        print "\nactions:"
                print '\n  '.join(["overwriting local files:"] + existing_files)
                    print 'Only in', self.left, ':', self.left_only
                    print 'Only in', self.right, ':', self.right_only
                print "overwriting local files"
            print "pycentral: required runtimes not yet installed, skip pkgprepare, call pkgremove"
        print pyversions.default_version(version_only=True)
                        print "rename: %s -> %s" % (name, name2)
                        print 'renaming %s to %s' % (srcdtop2, srcdtop)
                        print 'renaming %s to %s' % (srcdtop3, srcdtop)
                    print 'renaming %s to %s' % (srctop2, srctop)
                    print 'renaming %s to %s' % (srctop3, srctop)
                    #print self.shared_files
            print shared_base2
            print shared_base2[:-1]
                        print "Sorry", e
                            print "    %s: %s (%s)" % (pkgname, version, status)
                    print "    %s: %s (%s)" % (pkgname, version, status)
    print >>stream
    print >>stream, msg
    print >>stream, "use `%s --help' for help on actions and arguments" % program
    # Print the help screen and exit
                    print 'Trouble with common files :', self.funny_files
                    print "unable to create symlink %s" % f2
                                print "warning:", msg
                            print "warning:", msg
                         % (program, fn, ', '.join(list(bc_unknown))))
program = os.path.basename(sys.argv[0])
    prog = re.compile('[^-]*?-'.join(action.split('-')))
        prversions = ''
                    prversions = list(self.sversion_info.intersection(supported))
                prversions = list(self.sversion_info.intersection(supported))
                    prversions = supported
                prversions = supported
                prversions = versions
                    p = subprocess.Popen(cmd, bufsize=1,
                p = subprocess.Popen(cmd, bufsize=1,
            p = subprocess.Popen(cmd, bufsize=1,
        p = subprocess.Popen(cmd, bufsize=1,
        p = subprocess.Popen(['dpkg-trigger',
        pversions = list(set(pversions))
        pversions = pyversions.supported_versions() \
                p.wait()
                # pycentral used to ignore everything it has no explicit
pycentral_version = '0.6.16'
        pyfiles = []
            pyfiles.extend(files)
        pyfiles.extend(self.private_files)
    """Python Central Exception"""
    """Python Central Version Missing Exception"""
                    + pyversions.unsupported_versions() + pyversions.old_versions()
            raise
                    raise
                        raise PyCentralError, \
                raise PyCentralError
            raise PyCentralError
            raise PyCentralError, \
                    raise PyCentralError, 'both directories site-packages and dist-packages exist for %s.' % pversion
            raise PyCentralError, "debian/control not found"
                raise PyCentralError, 'error byte-compiling files (%d)' % len(files2)
            raise PyCentralError, 'error removing the byte-code files'
            raise PyCentralError, 'Found existing files while including symlinks'
            raise PyCentralError, 'missing XS-Python-Version attribute'
                    raise PyCentralError, 'no exact version for package with private modules'
            #raise PyCentralError, "no matching runtime for `%s'" % self.version_field
            raise PyCentralError, "not overwriting local files"
            raise PyCentralError, "package has no field Python-Version"
                raise PyCentralError, s
            raise PyCentralError, 'unable to determine Python-Version attribute'
                raise PyCentralError, 'version error for package with private modules'
            raise PyCentralVersionMissingError, \
        raise ValueError, 'unknown version info %s' % vinfo
        """read the debian/control file, extract the XS-Python-Version
        """Read the dpkg status file, return a list of packages depending
        """Read the Python-Version information field"""
register_action(ActionBCRemove)
register_action(ActionByteCompile)
register_action(ActionCleanupPkgPrepareUpdates)
register_action(ActionDebhelper)
register_action(ActionList)
register_action(ActionPkgInstall)
register_action(ActionPkgList)
register_action(ActionPkgPrepare)
register_action(ActionPkgRemove)
register_action(ActionPyCentralDir)
register_action(ActionRuntimeInstall)
register_action(ActionRuntimeRemove)
register_action(ActionShowDefault)
register_action(ActionShowSupported)
register_action(ActionShowVersions)
register_action(ActionUpdateDefault)
register_action(ActionVersion)
                        rel_tgt = build_relative_link(tgt, link)
                # rember dirs with removed files and try to remove these
                # remember files
        """remove all byte-compiled files not handled by pycentral"""
        # remove byte code for script files
        # remove byte compiled files inside prefix
        removed = 0
                removed += 1
        removed_dirs = list(dirs_in_old.difference(dirs_in_new))
        removed_dirs.sort()
                removed_fs = list(fs_in_old.difference(fs_in_new))
            removed_fs = list(fs_in_old.difference(fs_in_new))
        removed_fs = list(fs_in_old.difference(fs_in_new))
        removed_fs.sort()
            # remove empty dirs in /usr/lib/pythonX.Y
        # remove empty dirs in /usr/share/pyshared
        # remove shared .py files
    """remove the byte-compiled files in <package>.
        # rename .egg-info files and dirs, remove *.py[co] files
        rename = 'norename' not in os.environ.get('DH_PYCENTRAL', '')
req_pycentral_version = '0.6.15'
#                    requested.append(self.rtname_short)
                requested = list(pyversions.requested_versions_for_runtime(vstring, version_only=True))
                requested = list(pyversions.requested_versions(vstring, version_only=True))
        requested = pyversions.requested_versions_for_runtime(pkg.version_field, version_only=True)
        requested = pyversions.requested_versions_for_runtime(self.pkg.version_field, version_only=True)
            requested = pyversions.requested_versions_for_runtime(version_field, version_only=True)
        return
            return
                return
            return []
    return [a for a in actions if prog.match(a)]
            return all_chunks
        return arch
        return dangling
        return debian_config
    return debian_config
    return default_runtime
    return deps + ', python-central (>= %s)' % req_pycentral_version
        return False
        return files
        return get_default_runtime()
    return global_options, action
    return installed_runtimes
    return '/'.join(['..' for i in range(len(l)-1)] + t)
            return linked_files
    return "\n".join(l)
            return None
    return None
        return packages
    return path1 == path2
            return rt
            return self.errors_occured
        return self.errors_occured
        return self._option_parser
        return self.options, self.args
        return self.packaged
        return 'usr/lib/python' + version + '/dist-packages'
        return 'usr/lib/python' + version + '/site-packages'
        r'(?P<option>[^\s].*)'
        r'(?P<value>.*)$'
        r'\s*(?P<vi>[:=])\s*'
                    rt.byte_compile_dirs(dirs, bc_option, self.options.exclude)
                    rt.byte_compile_dirs(self.private_dirs, bc_option, self.options.exclude)
                rt.byte_compile(files, bc_option, exclude_regex)
                    rt.byte_compile(files, bc_option, exclude_regex, ignore_errors)
                    rt.byte_compile(linked_files, bc_option, exclude_regex)
                    rt.byte_compile(linked_files, bc_option, exclude_regex, ignore_errors)
                rt.byte_compile(linked_files, bc_option, exclude_regex, ignore_errors)
            rt.byte_compile(self.private_files, bc_option, exclude_regex)
                rt = get_runtime_for_version(pyver)
            rt = get_runtime_for_version(pyver)
                    rt = get_runtime_for_version(version)
            rt = PythonRuntime('python' + version,
                    rt.remove_byte_code(linked_files)
            rt = self.default_runtime
                      % ([rt.short_name for rt in runtimes],
                         [rt.short_name for rt in used_runtimes]))
    # run the action and exit
        runtimes = get_installed_runtimes()
            runtimes = get_installed_runtimes(with_unsupported=True)
        runtimes = get_installed_runtimes(with_unsupported=True)
    rv = action.run(global_options)
            rv = fd.close()
            rv = os.spawnv(os.P_WAIT, self.interp, cmd[1:])
            rx = re.compile(exclude)
        rx = re.compile(r'\bpython-central\b')
    '''SafeConfigParser allowing mixed case, `:' and `=' in keys'''
            sdir = '/usr/lib/python%s/site-packages' % pv
        # search for differences
                    section = None
            section = None
                    section = self.name
                    section = 'Source'
            self.default_runtime.byte_compile(self.private_files,
                self.default_runtime.byte_compile(self.private_files, bc_option,
        self.default_runtime = default_runtime
            self.default_runtime = get_default_runtime()
            self.default_runtime = get_runtime_for_version(versions[0])
                          (self.default_runtime.version, len(self.private_files)))
        self.depends = None
                    self.depends = version2depends(self.sversion_info)
                self.depends = version2depends(self.sversion_info)
            self.depends = version2depends(versions)
                    self.differs = True
                    self.diff_files.sort()
                self.error("error byte-compiling package `%s'" % self.pkgname)
            self.error("error byte-compiling package `%s'" % self.pkgname)
            self.error("error calling dpkg-trigger")
                self.error("error removing dangling symlink: %s" % str(e),
            self.error('failed to remove %s support for %d packages' % len(failed))
                self.error('failed to remove %s support for package %s' % (self.rtname, pkgname), go_on=True)
            self.error('installed runtime %s not found' % self.rtname)
            self.error(msg)
            self.error("options `--no-move' and `--include-links' conflict")
            self.error("package %s is not installed" % self.pkgname)
        #    self.error("package %s is not installed" % self.pkgname)
                self.error("package %s is not ready to be updated for %s"
                self.error('package %s: %s' % (pkgname, msg))
                self.error('%s needs unavailable runtime (%s)'
        self.errors_occured = 0
        self.errors_occured += 1
            self.error("unknown runtime version %s" % self.options.version)
            self.fd = file('/var/log/pycentral.log', 'a+')
            self.fd.flush()
            self.fd = None
        self.fd = None
            self.fd.write('%s %s %s\n' % (d, level, s))
                    self.funny_files.sort()
        self.has_private_extension = False
        self.has_private_extension = self.sversion_info == 'current_ext'
        self.has_private_module = False
                    self.has_private_module = True
        self.has_shared_extension = {}
                    self.has_shared_extension[version] = True
        self.has_shared_module = {}
                    self.has_shared_module['all'] = True
                    self.has_shared_module[version] = True
        self.interp = interp
        self.kind = kind
                    self.left_only.sort()
        self.level = level
            self.locate(arg_list, cmd_list)
        self.locate(arg_list, cmd_list)
        self.msg(self.DEBUG, s)
        self.msg(self.DEBUG, "%s%s (%s/%s)" % (tab, s, len(l2), len(l)))
        self.msg(self.ERROR, s)
        self.msg(self.INFO, s)
        self.msg(self.WARN, s)
        self.name = name
                         % (self.name, self.version_field))
        self.needed_packages = []
            self.needed_packages.append(pkg)
        self.notfound = 0
                self.notfound += 1
        self.oldrtname = self.args[0]
        self.oldstyle = oldstyle
        self.omitted_files = []
                self.omitted_files.append(fn)
            self._option_parser = p
            self._option_parser.print_help()
                        self.options.exclude, byte_compile_default=True)
        self.options, self.args = self._option_parser.parse_args(arguments)
            self.options.substvars = 'file'
            self.options.substvars = 'stdout'
        self.other_pylib_files = []
                    self.other_pylib_files.append(fn)
                    self.packaged.add(fn)
        self.packaged = set()
        self.parse_versions = parse_versions
            self.pkg.byte_compile(used_runtimes, bc_option, self.options.exclude)
                self.pkgconfig.optionxform = str
        self.pkgconfig.optionxform = str
                self.pkgconfig = pc
        self.pkgconfig = pkgconfig
                self.pkgconfig = PyCentralConfigParser()
        self.pkgconfig = PyCentralConfigParser()
        self.pkgconfig.readfp(cStringIO.StringIO(buffer.getvalue()))
                self.pkgconfig.readfp(file(config_file))
                    self.pkgconfig.set('pycentral', 'include-links', '0')
        self.pkgconfig.set('pycentral', 'include-links', '0')
        self.pkg = DebPackage('package', self.pkgname, oldstyle=False,
        self.pkgdir = pkgdir
                           % (self.pkgname, pkg.version_field))
        self.pkgname = self.args[0]
        self.pkg.read_version_info()
            self.prefix = prefix + sitedir
            self.prefix = prefix + '/' + sitedir
            #self.print_info()
        self.private_files = []
                self.private_files.append(fn)
            self.provides = ', '.join([self.name.replace('python-', 'python%s-' % ver)
        self.pylib_files = {}
                    self.pylib_files.setdefault(version, []).append(fn)
                self.pylib_files.setdefault(version, []).append(fn)
        self.pysupport_files = []
                self.pysupport_files.append(fn)
            self.read_control()
            self.read_pyfiles()
                    self.right_only.sort()
        self.rtname = self.args[0]
        self.rtname = self.args[1]
            self.rtname = self.rtname[:-8]
        self.rtname_short = self.rtname[6:]
        self.runtime = get_runtime_for_version(self.options.version)
        self.runtime = None
                self.runtime = rt
        self.shared_files = []
                self.shared_files.append(fn)
        self.shared_prefix = None
                self.shared_prefix = old_shared_base
                self.shared_prefix = shared_base2
            self.short_name = name
            self.short_name = name[6:]
                    self.sversion_field = line.split(':', 1)[1].strip()
        self.sversion_field = None
            self.sversion_info = 'all' # dummy
            self.sversion_info = pyversions.parse_versions(self.sversion_field)
                    self.unlink_files(rt)
                    self.unlink_shared_files(rt)
            self.version_field = get_default_runtime().version
            self.version_field = ', '.join(versions)
                            self.version_field = line.split(':', 1)[1].strip()
                        self.version_field = line.split(':', 1)[1].strip()
                    self.version_field = line.split(':', 1)[1].strip()
        self.version_field = None
            self.version_field = self.pkgconfig.get('python-package', 'python-version')
        self.version_field = version_field
            self.version_field = versions
            self.version_info = pyversions.parse_versions(self.version_field)
            self.version_info = pyversions.parse_versions(version_field)
        self.version = version
        self.warn("checking for links owned by packages (this may take some time)")
                self.warn('dangling symlink owned by package: %s' % fn)
        self.warn("found %d dangling symlinks" % len(dangling))
                self.warn(msg)
            self.warn(msg)
            self.warn('removed %d dangling symlinks not owned by any package' % removed)
    set = sets.Set
    SetType = set
    SetType = sets.Set
    setup_logging(Logging.WARN, global_options.verbose)
    # setup logging stuff
    # setup the parsers object
                s = get_file_overwrite_error(existing_files)
shared_base2 = '/usr/share/pyshared/'
shared_base = '/usr/share/pycentral/'
                  'shared files found in old (%s) and new locations (%s)' % (old_shared_base, shared_base2)
        shared_files.reverse()
        shared_files = self.shared_files[:]
            # shared modules / extensions
                                 shell=False,
                  shell=False)
                                     shell=False, stdin=subprocess.PIPE)
                                         shell=False, stdout=subprocess.PIPE)
                                     shell=False, stdout=subprocess.PIPE)
                                 shell=False, stdout=subprocess.PIPE)
                             shell=False, stdout=subprocess.PIPE)
    shortusage = 'usage: %s [<option> ...] <action> <pkgname>' % program
                        shutil.copymode(src, dst)
                site1 = os.path.join(self.pkgdir, third_party_dir(pv1))
                site2 = os.path.join(self.pkgdir, third_party_dir(pv2))
            sitedir = 'dist-packages/'
            sitedir = 'site-packages/'
    # something but we deal with it for robustness
                    # special hack to make pycentral work with fakechroot,
                    srcdtop2 = os.path.join(pkgdbgdir, 'usr/lib/debug/usr/lib', pversion, 'site-packages')
                    srcdtop2 = os.path.join(pkgdbgdir, 'usr/lib', pversion, 'site-packages')
                            srcdtop3 = os.path.dirname(srcdtop3)
                    srcdtop3 = os.path.join(pkgdbgdir, 'usr/lib/debug/usr/local/lib', pversion, 'dist-packages')
                    srcdtop3 = os.path.join(pkgdbgdir, 'usr/local/lib', pversion, 'dist-packages')
                    srcdtop = os.path.join(pkgdbgdir, 'usr/lib/debug/usr/lib', pversion, 'dist-packages')
                    srcdtop = os.path.join(pkgdbgdir, 'usr/lib', pversion, 'dist-packages')
                    src = os.path.join(root, name)
                # srctop2 and srctop3 are the old/wrong locations, move these.
                srctop2 = os.path.join(self.pkgdir, 'usr/lib', pversion, 'site-packages')
                        srctop3 = os.path.dirname(srctop3)
                srctop3 = os.path.join(self.pkgdir, 'usr/local/lib', pversion, 'dist-packages')
            srctop = os.path.join(self.pkgdir, third_party_dir(pversion))
                srctop = os.path.join(self.pkgdir, 'usr/lib', pversion, 'dist-packages')
                srctop = os.path.join(self.pkgdir, 'usr/lib', pversion, 'site-packages')
                status = []
        status = []
            status = fd.readline().strip().split()
                status = line.split(':', 1)[1].strip().split()
    # stderr has local (or maintainer script created) files
    # stdout has files that belong to packages
                                 stdout=PIPE, stderr=PIPE).communicate()
                             stdout=PIPE, stderr=PIPE).communicate()
        (stdout, stderr) = Popen(cmd_list + arg_list,
    (stdout, stderr) = Popen(["dpkg","-S"]+existing_files,
                # Still byte compile for the available runtimes (with the
        sts = os.waitpid(p.pid, 0)[1]
                substvars_default = 'file'
            substvars_default = 'no'
                substvars_default = 'stdout'
        supported = [d[6:] for d in pyversions.supported_versions()
        supported = pyversions.supported_versions()
        supported.sort()
        symlinks_included = self.pkgconfig.getboolean('pycentral', 'include-links')
            sys.exit(1)
        sys.exit(1)
    sys.exit(1)
    sys.exit(rv)
sys.path[0:0] = ['/usr/share/pycentral-data', '/usr/share/python']
        sys.stderr.write("pycentral showdefault is deprecated, use `pyversions -vd'\n")
        sys.stderr.write("pycentral showsupported is deprecated, use `pyversions -s'\n")
        sys.stderr.write("pycentral showversions is deprecated, use `pyversions -vs'\n")
        sys.stderr.write('%s\n' % s)
        sys.stderr.write("%s: `%s': unknown values `%s'"
        sys.stdout.flush()
        sys.stdout.write('pycentral: %s\n' % (s))
        sys.stdout.write("%s\n" % pycentral_version)
                        target = os.path.normpath(target)
                    target = os.readlink(link)
                    tgt = os.path.join(root, name)
        tgttop = os.path.join(self.pkgdir, shared_base2.strip('/'))
            # then having a file here is expected and harmless
        # then remove those not belonging to any package
    # this should never happen, dpkg should always give us
        to bc_options"""
                    # TODO: if dst already exists, make sure, src == dst
                            try:
                        try:
                    try:
                try:
            try:
        try:
    t = tgt.split('/')
        unowned = [link for link in dangling if not link in packaged]
            unsupported = []
            unsupported = pyversions.unsupported_versions()
        # update shared .py files
    usage = '<old runtime> <new runtime>'
    usage = "<options>"
    usage = '[<options>] <package>'
    usage = '[<options>] <package> [<dir> ...]'
    usage = '<package>'
    usage = '[-p|--provides] [--no-move|--include-links] <package> [<package directory>]'
            'usage: %s [<options> ...] %s %s' % (program, self.name, self.usage))
        usage(sys.stderr,
        usage(sys.stderr, "unknown action `%s'" % action_name)
            # use case? use the information for the shared stuff
        used_runtimes = [rt for rt in runtimes if rt.short_name in requested]
        # using python-central 0.6.8.
#! /usr/bin/python
                               '/usr/bin/python' + version,
                               '/usr/lib/python' + version)
    /usr/lib/pythonX.Y are compiled with the matching python version.
            # /usr/lib/pythonX.Y/site-packages, and moved to the shared area,
        val = config.get('DEFAULT', 'overwrite-local').strip().lower()
                               version,
                         version_field,
        version_field = pkgconfig.get('python-package', 'python-version')
                version = fn[15:18]
            version = interp[-3:]
                version = line.split(':', 1)[1].strip()
                version = None
                        version = pyversions.default_version(version_only=True)
                version = pyversions.default_version(version_only=True)
            # version, rely on the pkginstall in the postinst.
        versions = ''
                    versions = 'all'
                versions = 'all'
                    versions = 'current'
                versions = 'current'
        versions = [d[6:] for d in supported if re.match(r'python\d\.\d', d)]
                    version = self.pkg.version_field
        versions = list(pyversions.requested_versions(self.version_field, version_only=True))
                versions = [list(self.sversion_info)[0]]
                versions = [pyversions.default_version(version_only=True)]
        versions = pyversions.requested_versions(self.sversion_field, True)
                versions = pyversions.requested_versions(vstring, version_only=True)
                versions = self.has_shared_extension.keys()
                    versions = self.sversion_field
                versions = self.sversion_field
        version = version[6:]
        vinfo = list(vinfo)
        vinfo.sort()
        vinfo = vinfo[:]
        vrx = re.compile(r'(.*)(-py\d\.\d)(.*)(\.egg-info|\.pth)$')
                    # which has a slightly weird treatment of symlinks
    while l[0] == t[0]:
    while path1 != os.path.dirname(path1):
    while path2 != os.path.dirname(path2):
                        while srcdtop3:
                    while srctop3:
        # XXX not needed for an upgrade of a runtime
                        yield f
                    yield f
            yield fn2
                yield fnc
