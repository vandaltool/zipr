                 }
                ) % {
                }
             ])
        )
 [1] http://www.python.org/workshops/1997-10/proceedings/loewis.html
# 2002-11-22 J
 [2] http://www.gnu.org/software/gettext/gettext.html
    # add all *.py files to list
# Added checks that _() only contains string literals, and
            'ad:DEhk:Kno:p:S:Vvw:x:X:',
additional switches.
    --add-location
             'add-location', 'no-location', 'output=', 'output-dir=',
        # Allow iso-8859 characters to pass through so that e.g. 'msgid
and gettext_noop. But those can be a lot of text to include all over your
    a package. Return None if the name is not found, or is a builtin or
        appear on a line by itself in the file.
    # appropriate for .po files, namely much closer to C style.
    args = expanded
        # a single file
A word about marking Python strings as candidates for translation. GNU
below for how to augment this.
                        break
# by Peter Funk <pf@artcom-gmbh.de>
    # calculate all keywords
    # calculate escapes
# can now pass a filename, a module or package name, or a
                "Can't read --exclude-file: %s") % options.excludefilename
        # check for glob chars
        # check if it's indeed a package
    """Check whether 'str' contains ANY of the chars in 'set'"""
            # class docstring?
    class Options:
class TokenEater:
            closep = 0
        closep = 0
            closep = 1
        closep = 1
code. C and C++ have a trick: they use the C preprocessor. Most
# -*- coding: iso-8859-1 -*-
# command line args are resolved to module lists, i.e. you
                # comment stating so.  This is to aid translators who may wish
        conjunction with the -D option above.
        # constants
"Content-Transfer-Encoding: ENCODING\\n"
"Content-Type: text/plain; charset=CHARSET\\n"
# Copyright (C) YEAR ORGANIZATION
    def __addentry(self, msg, lineno=None, isdocstring=0):
    --default-domain=name
            default_keywords = []
default_keywords = ['_']
DEFAULTKEYWORDS = ', '.join(default_keywords)
        %(DEFAULTKEYWORDS)s
        # defaults
    def __call__(self, ttype, tstring, stup, etup, line):
def containsAny(str, set):
def escape(s):
def getFilesForName(name):
def _get_modpkg_path(dotted_name, pathlist=None):
    def __init__(self, options):
    def __keywordseen(self, ttype, tstring, lineno):
def main():
def make_escapes(pass_iso8859):
def normalize(s):
    def __openseen(self, ttype, tstring, lineno):
def safe_eval(s):
    def set_filename(self, filename):
    def __suitedocstring(self, ttype, tstring, lineno):
    def __suiteseen(self, ttype, tstring, lineno):
def usage(code, msg=''):
def _visit_pyfiles(list, dirname, names):
    def __waiting(self, ttype, tstring, lineno):
    def write(self, fp):
            del lines[-1]
                        d = {'filename': filename, 'lineno': lineno}
# directory (including globbing chars, important for Win32).
        Disable the default set of keywords (see above).  Any keywords
        # dispatch
    -d name
__doc__ = _("""pygettext -- Python equivalent of xgettext(1)
    --docstrings
        docstrings = 0
             'docstrings', 'no-docstrings',
        # Do docstring extractions, if enabled
        Do not write filename/lineno location comments.
    # don't recurse into CVS directories
                dotted_name, pathlist)
                    e[0], filename, e[1][0], e[1][1])
        each msgid.  The style of comments is controlled by the -S/--style
            eater.set_filename(filename)
    eater = TokenEater(options)
        eater.write(fp)
        elif opt in ('-a', '--extract-all'):
        elif opt in ('-d', '--default-domain'):
        elif opt in ('-D', '--docstrings'):
        elif opt in ('-E', '--escape'):
        elif opt in ('-k', '--keyword'):
        elif opt in ('-K', '--no-default-keywords'):
        elif opt in ('-n', '--add-location'):
        elif opt in ('--no-location',):
        elif opt in ('-o', '--output'):
        elif opt in ('-p', '--output-dir'):
        elif opt in ('-S', '--style'):
        elif opt in ('-v', '--verbose'):
        elif opt in ('-V', '--version'):
        elif opt in ('-w', '--width'):
        elif opt in ('-x', '--exclude-file'):
        elif opt in ('-X', '--no-docstrings'):
                elif options.locationstyle == options.GNU:
                elif options.locationstyle == options.SOLARIS:
    elif os.path.exists(name):
        elif ttype not in [tokenize.COMMENT, token.INDENT, token.DEDENT,
                elif ttype not in (tokenize.COMMENT, tokenize.NL):
        elif ttype not in (tokenize.NEWLINE, tokenize.INDENT,
        elif ttype == tokenize.STRING:
                        else:
        else:
    else:
EMPTYSTRING = ''
Enter pygettext, which uses Python's standard tokenize module to scan
            entry = (self.__curfile, lineno)
    --escape
        escape = 0
        # escape any character outside the 32..126 range.
escapes = []
            escapes.append("\\%03o" % i)
            escapes.append(chr(i))
    escapes[ord('\"')] = '\\"'
    escapes[ord('\\')] = '\\\\'
    escapes[ord('\n')] = '\\n'
    escapes[ord('\r')] = '\\r'
    escapes[ord('\t')] = '\\t'
    except getopt.error, msg:
        except ImportError:
except ImportError:
        except IOError:
            except tokenize.TokenError, e:
            except ValueError:
    --exclude-file=filename
        excludefilename = ''
    expanded = []
            expanded.append(arg)
            expanded.extend(getFilesForName(arg))
        explicitly added with the -k/--keyword option are still recognized.
    extension module.
    --extract-all
        extractall = 0 # FIXME: currently this option has no effect at all.
            ['extract-all', 'default-domain=', 'escape', 'help',
        Extract all strings.
        extracted from the input files.  Each string to be excluded must
        extracted string is found in the source.  These lines appear before
        Extract module, class, method, and function docstrings.  These do
                file.close()
                            '# File: %(filename)s, line: %(lineno)d') % d
                # file name and then by line number.
        filename is `-' then the output is sent to standard out.
            file, pathname, description = imp.find_module(
            file, pathname, description = imp.find_module(parts[0], pathlist)
                'file': self.__curfile,
            files = glob.glob(name)
                '*** %(file)s:%(lineno)s: Seen unexpected token "%(token)s"'
            finally:
        finally:
    finally:
        # find all python files in directory
    _ = fintl.gettext
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
                    # fit as many locations on one line, as long as the
    for arg in args:
            for file in files:
    for filename in args:
                    for filename, lineno in v:
    # for holding option values
    for i in range(256):
        for i in range(len(lines)):
    for i in range(len(s)):
            for k, v in rentries:
        for k, v in self.__messages.items():
    for opt, arg in opts:
        for rkey in rkeys:
# for selftesting
                fp.close()
            fp.close()
            fp = open(arg)
            fp = open(filename)
            fp = open(options.excludefilename)
        fp = open(options.outfile, 'w')
            fp = sys.stdin
        fp = sys.stdout
"Generated-By: pygettext.py %(version)s\\n"
        # generated by xgettext...
generates for C and C++ code. From there, the standard GNU tools can be
    """Get a list of module files for a filename, a module or package name,
    # get extension for python source files
    gettext("Translatable String")
    """Get the filesystem path for a module or a package.
    global default_keywords
    global escapes
        global _py_ext
        GNU = 1
        GNU      #: filename:line
        # "H
    --help
    """Helper for getFilesForName()."""
he"' would result not result in 'msgid "H\366he"'.  Otherwise we
        if 32 <= (i % mod) <= 126:
        if arg == '-':
            if closep:
        if closep:
        if containsAny(name, "*?[]"):
    if 'CVS' in names:
        if description[2] == imp.PKG_DIRECTORY:
            if description[2] not in [imp.PY_SOURCE, imp.PKG_DIRECTORY]:
            if file:
            if file: file.close()
        if filename == '-':
If `inputfile' is -, standard input is read.
                if isdocstring:
    if len(lines) == 1:
                    if len(locline) > 2:
                        if len(locline) + len(s) <= options.width:
    if len(parts) > 1:
        if lineno is None:
    if msg:
if __name__ == '__main__':
    if not globals().has_key('_py_ext'):
                    if not line:
        if not lines[-1]:
        if not msg in self.__options.toexclude:
        if not name:
                if not options.writelocations:
    if not os.path.exists(name):
        if opt in ('-h', '--help'):
    if options.excludefilename:
            if options.locationstyle is None:
    if options.outfile == '-':
        if options.outpath:
            if options.verbose:
        if opts.docstrings and not opts.nodocstrings.get(self.__curfile):
    if os.path.isdir(name):
         if os.path.splitext(file)[1] == _py_ext]
    if pass_iso8859:
                if reduce(operator.__add__, v.values()):
            if self.__data:
            if self.__freshmodule:
                # If the entry was gleaned out of a docstring, then add a
                   if triple[2] == imp.PY_SOURCE][0]
            if ttype == tokenize.NAME and tstring in ('class', 'def'):
        if ttype == tokenize.NAME and tstring in opts.keywords:
        if ttype == tokenize.OP and tstring == ':':
        if ttype == tokenize.OP and tstring == '(':
        if ttype == tokenize.OP and tstring == ')':
                if ttype == tokenize.STRING:
        if ttype == tokenize.STRING:
        # ignore any intervening noise
        # ignore anything until we see the colon
    import fintl
import getopt
import glob
import imp
import operator
import os
import sys
import time
##        import token
import token
import tokenize
    # initialize list of strings to exclude
internationalization of C programs. Most of these tools are independent of
internationalized C source includes a #define for gettext() to _() so that
introduces a few wrinkles, such as dual quoting characters, triple quoted
                isdocstring = 0
                    isdocstring = 1
            keys.sort()
            keys = v.keys()
             'keyword=', 'no-default-keywords',
        keywords = []
        Keywords to look for in addition to the default set, which are:
    --keyword=word
                # k is the message string, v is a dictionary-set of (filename,
    -k word
    _ = lambda s: s
"Language-Team: LANGUAGE <LL@li.org>\\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n"
                    line = fp.readline()
                'lineno': self.__lineno
            lineno = self.__lineno
                # lineno) tuples.  We want to sort the entries in v first by
            # line number of the first line of the strings and update the list
            lines[-1] = lines[-1] + '\n'
            lines[i] = escape(lines[i])
    lines = s.split('\n')
        lineterm = '\\n"\n"'
            list = []
        list = []
    list.extend(
                list.extend(getFilesForName(file))
                # location comments are different b/w Solaris and GNU:
    locations = {'gnu' : options.GNU,
        locationstyle = GNU
                    locline = '#:'
                            locline = locline + s
                            locline = "#:" + s
looking for message strings, but it groks only C (or C++). Python
# Made docstring fit in 80 chars wide displays using pydoc.
    main()
    make_escapes(options.escape)
Many systems (Solaris, Linux, Gnu) provide extensive tools that ease the
Martin von Loewis' work[1] helps considerably in this regard.
"MIME-Version: 1.0\\n"
# Minimally patched to make it even more xgettext compatible
        mod = 128
        mod = 256
            # module docstring?
    _('more' 'than' 'one' 'string')
msgid ""
msgstr ""
        name = _get_modpkg_path(name)
        names.remove('CVS')
    --no-default-keywords
        nodocstrings = {}
    --no-docstrings=filename
    --no-location
NOTE: pygettext attempts to be option and feature compatible with GNU
not fully implemented. Also, xgettext's use of command line switches with
        not need to be wrapped in _() markers, and in fact cannot be for
    -o filename
            # of messages seen.  Reset state for the next batch.  If there
option arguments is broken, and in these cases, pygettext just defines
Options:
            options.docstrings = 1
            options.escape = 1
            options.excludefilename = arg
            options.extractall = 1
            options.keywords.append(arg)
    options.keywords.extend(default_keywords)
            options.locationstyle = locations.get(arg.lower())
                    options.nodocstrings[line[:-1]] = 1
    options = Options()
            options.outfile = arg
            options.outfile = arg + '.pot'
            options.outfile = os.path.join(options.outpath, options.outfile)
            options.outpath = arg
        options = self.__options
        options.toexclude = []
            options.toexclude = fp.readlines()
            options.verbose = 1
                options.width = int(arg)
            options.writelocations = 0
            options.writelocations = 1
        option.  This is the default.
        opts, args = getopt.getopt(
        opts = self.__options
    or a directory.
# Originally written by Barry Warsaw <barry@zope.com>
        [os.path.join(dirname, file) for file in names
        os.path.walk(name, _visit_pyfiles, list)
        outfile = 'messages.pot'
        outpath = ''
    --output-dir=dir
    --output=filename
        Output files will be placed in directory dir.
    # parse options
    parts = dotted_name.split('.', 1)
                    pass
            pathname = _get_modpkg_path(parts[1], [pathname])
                pathname = None
            pathname = None
    -p dir
        # plain name
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n"
"POT-Creation-Date: %(time)s\\n"
pot_header = _('''\
                        print >>fp, _(
                    print >> fp, '#, docstring'
                            print >> fp, locline
                        print >> fp, locline
                print >> fp, 'msgid', normalize(k)
                print >> fp, 'msgstr ""\n'
        print >> fp, pot_header % {'time': timestamp, 'version': __version__}
            print _('pygettext.py (xgettext for Python) %s') % __version__
                print _('Reading standard input')
            print >> sys.stderr, _(
    print >> sys.stderr, __doc__ % globals()
        print >> sys.stderr, msg
                print >> sys.stderr, '%s: %s, line %d, column %d' % (
##        print >> sys.stderr, 'ttype:', token.tok_name[ttype], \
        Print the names of the files being processed.
        Print the version of pygettext and exit.
        Print this help message and exit.
                print _('Working on %s') % filename
"Project-Id-Version: PACKAGE VERSION\\n"
        _py_ext = [triple[0] for triple in imp.get_suffixes()
pygettext searches only for _() by default, but see the -k/--keyword flag
Python of course has no preprocessor so this doesn't work so well.  Thus,
Python source code, generating .pot files identical to what GNU xgettext[2]
        Python to consider them docstrings. (See also the -X option).
            # recursively handle the remaining name parts
        Rename the default output file from messages.pot to filename.  If
        Rename the default output file from messages.pot to name.pot.
            rentries = reverse[rkey]
            rentries.sort()
        Replace non-ASCII characters with octal escape sequences.
    # resolve args to module lists
                    # resulting line length doesn't exceeds 'options.width'
                return
            return []
    return []
    return 1 in [c in str for c in set]
    return EMPTYSTRING.join(s)
    return eval(s, {'__builtins__':{}}, {})
            return list
        return list
        return [name]
            return None
    return pathname
    return s
    Return the file system path to a file for a module, and to a directory for
        reverse = {}
            reverse.setdefault(tuple(keys), []).append((k, v))
rgen Hermann <jh@web.de>
        rkeys = reverse.keys()
        rkeys.sort()
    _('*** Seen unexpected token "%(token)s"') % {'token': 'test'}
                self.__addentry(EMPTYSTRING.join(self.__data))
                    self.__addentry(safe_eval(tstring), lineno, isdocstring=1)
            self.__addentry(safe_eval(tstring), lineno, isdocstring=1)
        self.__curfile = filename
        self.__curfile = None
            self.__data = []
        self.__data = []
            self.__data.append(safe_eval(tstring))
                    self.__freshmodule = 0
        self.__freshmodule = 1
        self.__lineno = -1
            self.__lineno = lineno
        self.__messages = {}
            self.__messages.setdefault(msg, {})[entry] = isdocstring
        self.__options = options
            self.__state = self.__keywordseen
            self.__state = self.__openseen
            self.__state = self.__suitedocstring
                self.__state = self.__suiteseen
            self.__state = self.__waiting
        self.__state = self.__waiting
        self.__state(ttype, tstring, stup[0])
        s = '"' + escape(s) + '"'
        Set width of output to columns.
                        s = _(' %(filename)s:%(lineno)d') % d
        should not have their docstrings extracted.  This is only useful in
        s[i] = escapes[ord(s[i])]
    s = list(s)
    # slurp through all the files
        s = '""\n"' + lineterm.join(lines) + '"'
        SOLARIS = 2
        Solaris  # File: filename, line: line-number
                 'solaris' : options.SOLARIS,
# SOME DESCRIPTIVE TITLE.
    # some more test strings
        # sort all the entries by their first item.
        # Sort the entries.  First sort each particular entry's keys, then
        Specify a file that contains a list of files (one per line) that
        Specify a file that contains a list of strings that are not be
        Specify which style to use for location comments.  Two styles are
    # split off top-most name
    -S stylename
strings, and raw strings. xgettext understands none of this.
    --style stylename
             'style=', 'verbose', 'version', 'width=', 'exclude-file=',
        supported:
            sys.argv[1:],
            sys.exit(0)
            sys.exit(1)
    sys.exit(code)
# The normal pot-file header. msgmerge and Emacs's po-mode work better if it's
the programming language and can be used from within Python programs.
# there.
There's one problem though; xgettext is the program that scans source code
            # there was no class docstring
        The style name is case insensitive.  GNU style is the default.
        # The time stamp in the header doesn't have the same format as that
    # This converts the various Python string types into a format that is
    # this one creates a warning
        timestamp = time.strftime('%Y-%m-%d %H:%M+%Z')
                           tokenize.COMMENT):
                tokenize.tokenize(fp.readline, eater)
                           token.NEWLINE, tokenize.NL]:
                'token': tstring,
                # to skip translating some unimportant docstrings.
    _("Translatable String")
translatable strings:
            try:
        try:
    try:
        # try to find module or package
##              'tstring:', tstring
    _(u'a unicode string')
    # unwrap quotes, safely
            usage(0)
                usage(1, _('Invalid value for --style: %s') % arg)
        usage(1, msg)
                usage(1, _('--width argument must be an integer: %s') % arg)
Usage: pygettext [options] inputfile ...
#! /usr/bin/python2.7
    --verbose
        verbose = 0
    --version
__version__ = '1.5'
                v.sort()
                v = v.keys()
            # warn if we see anything else than STRING or whitespace
    -w columns
        # we have a dotted path, import top-level package
            # were no strings inside _(), then just ignore this entry.
            # We've seen the last of the translatable strings.  Record the
what has to be written in the source is much less. Thus these are both
                while 1:
        width = 78
    --width=columns
        Write filename/lineno location comments indicating where each
        writelocations = 1
    # write the output
    -x filename
xgettext recognizes the following keywords: gettext, dgettext, dcgettext,
xgettext where ever possible. However some options are still missing or are
        You can have multiple -k flags on the command line.
