       >>>
        
                        )
            )
            ]
        '''
        """
        """ 
        ]
# -------
# ---------
#---------------------------------------------------------------------------
        1.2.3.4."""
    1. Check execution:
        1. Copy the default parameters (self.*) to self.parameters.
        2. Copy attrs to self.attributes. self.attributes are used for template
        3. If a style attribute was specified update self.parameters with the
        4. Set named positional attributes in self.attributes if self.posattrs
        5. Finally self.parameters is updated with any corresponding parameters
            a0 = d.get('0')
                     'A': 1}   # Ambiguous (s/b wide in East Asian context,
            'a:b:cd:ef:hno:svw:',
        AbstractBlock.dump(self)
        AbstractBlock.__init__(self)
        AbstractBlock.load(self,name,entries)
        AbstractBlocks.dump(self)
        AbstractBlocks.__init__(self)
        AbstractBlocks.load(self,sections)
        AbstractBlocks.validate(self)
        AbstractBlock.translate(self)
        AbstractBlock.validate(self)
        abswidth = float(config.pagewidth)
                    abswidth = float(v[:-1])/100 * config.pagewidth
                action = mo.group('action')
                action = mo.group('name')
        """Add attribute list to the dictionary 'd' and reset the
        # Add command-line and header attributes.
        # Add custom conf file arguments.
        # Add global and calculated configuration parameters.
        # Add next callout index to listindex map entry. Return the callout id.
        """Add pattern and replacement to replacements dictionary."""
        # Add relevant globals to table substitutions.
                        after = '\n'.join(after)
    ALIGN = {'<':'left', '>':'right', '^':'center'}
    ALIGNMENTS = {'`':'left', "'":'right', '.':'center'}
                align = mo.groupdict().get('align')
        align = None
        all fatal errors finishing with a non-zero exit code.
# Allowed substitution options for List, Paragraph and DelimitedBlock
                allow_name_only, escape_delimiter):
        allow_name_only=False, escape_delimiter=True):
        allow_name_only=False,escape_delimiter=True):
                allow_name_only=True)
        # allow the CSV reader to handle multi-line rows.
                all_styles_have_template = False
        all_styles_have_template = True
        # already substituted inline passthroughs) unique placeholders are used
                      and AttributeList.style() != 'float')
                    and attr.name not in ('trace','numbered'):
                and 'basebackend-docbook' in document.attributes \
                    and document.level == 0 \
                # and first section title).
                and 'id' not in AttributeList.attrs:
    and is not for public use.
                and prev_sectname in ('colophon','abstract', \
                    and prev_sectname in ('preface','appendix'):
        and tag substitution in the current block.
            # and the output markup is HTML. It's also a bit dubious in that it
                    and Title.level == 2 \
        and vertical span counts. Set default values (1,1) if not
APP_DIR = None              # This file's directory.
        APP_DIR = os.path.dirname(APP_FILE)
                append_cell(data, span, op, align, style)
        append_cell(data, span, op, align, style)
        appended to each line."""
    Append list or tuple of strings 'lines2' to list 'lines1'.  Join the last
                        # Append section.
                # Append section.
        # Append the coindex to a list in the comap dictionary.
APP_FILE = None             # This file's full path.
        APP_FILE = os.path.realpath(cmd)
# Application code.
            arcname = os.path.basename(src)
                    arcname = os.path.join(arcroot, f)
                arcroot = os.path.abspath(root)[len(srcdir):]
            # are meant to be out of sequence.
        args = ''
    args = {}
        args[0] is plugin name.
        args[0] is plugin zip file path.
        args[0] is Zip file name.
        args[1] is optional destination plugins directory.
        args[1] is optional plugin directory (defaults to ~/.asciidoc/<plugin_name>).
        args[1] is plugin directory.
        args = args[i:]
        args = ast.parse("d(" + val + ")", mode='eval').body.args
        args = ast.parse("d(" + val + ")", mode='eval').body.keywords
                args += ' --attribute "%s"' % k
                args += ' --attribute "%s=%s"' % (k,v)
        args = compiler.parse("d(" + val + ")", mode='eval').node.args
            args += ' --conf-file "%s"' % f
        args = s
    args.update(mo.groupdict()) # Add other named match groups to the arguments.
    args['words'] = mo.group()  # The full match string is argument 'words'.
        # argument. Has no effect when set to None.
    # A safe file must reside in directory directory (defaults to the source
        asciidoc(backend, doctype, confiles, infile, outfile, options)
asciidoc - converts an AsciiDoc text file to HTML or DocBook
        # a second attribute substitution (which would interfere with any
            assert b.__class__ is self.BLOCK_TYPE
        assert cursor
            assert False
        assert False
                        assert False, 'illegal attribute: %s' % attr
    assert is_array(lines1)
    assert is_array(lines2)
    assert len(d) > 0
        assert Lex.next() in (Title,FloatingTitle)
        assert Lex.next() is AttributeEntry
        assert Lex.next() is AttributeList
        assert Lex.next() is BlockTitle
        assert Lex.next() is FloatingTitle
        assert Lex.next() is Title
        assert Lex.next() is Title and Title.level == 0
        assert os.path.isdir(directory)
    assert os.path.isfile(fname)
            assert re.match(self.delimiter,delimiter)
        assert re.match(self.delimiter,ruler)
        assert section is not None
        assert self.doctype in ('article','manpage','book'), 'illegal document type'
        assert self.level == 0
            assert self.name
        assert self.prefix == '#'
        assert self.prefix != '+'
        assert self.type in ('numbered','callout')
        assert self.type == 'labeled'
        assert(tags and tags in tables.tags)
        assert text[start] == '{'
            assert True,'illegal table format'
    """Assign all attributes from 'src' object to 'dst' object."""
                assign(parent,self)
                assign(self,self.parent)    # Restore parent reader.
            # assumes the user has not modified the shipped line break pattern.
            # A @ suffix denotes don't override existing document attributes.
    # Attempt to convert the localtime to the output encoding.
    <attr1>+<attr2>+... Return True if all the attributes are defined.
    <attr1>,<attr2>,... Return True if one or more attributes are defined.
            attr = attr[:-1]
        attr = AttributeEntry    # Alias for brevity.
            attr.attributes[attr.name] = attr.value
            ['attribute=','backend=','conf-file=','doctype=','dump-conf',
            # Attribute entry formatted like :<name>[.<name2>]:[ <value>]
                AttributeEntry.name2 = mo.group('attrname2')
                AttributeEntry.name = mo.group('attrname')
            AttributeEntry.pattern = pat
                    AttributeEntry.translate()
                AttributeEntry.value = AttributeEntry.value.strip()
                AttributeEntry.value = mo.group('attrvalue') or ''
            AttributeList.attrs = {}
            AttributeList.attrs['id'] = Section.gen_id(Title.attributes['title'])
                    AttributeList.attrs[k] = v
        AttributeList.attrs.update(attrs)
            AttributeList.consume(attrs)
        AttributeList.consume(attrs)
                AttributeList.consume(d)
        AttributeList.consume(Title.attributes)
        AttributeList.initialize()
                AttributeList.match = mo
        AttributeList.pattern = document.attributes['attributelist-pattern']
        # attribute list positional attributes.
        AttributeList.subs(attrs)
                        AttributeList.subs(d)
                    AttributeList.translate()
    - Attribute references are substituted in the following order: simple,
    - Attribute references inside 'dictionary' entry values are substituted.
        attributes.
    attributes = {}
    attributes = {}     # Accumulates all the parsed attribute entries.
        attributes are deleted."""
        # attributes list) are merged with the block configuration parameters
    attributes list is named '0'. If keywords are specified string values must
        attributes plus 'd' attributes. Return tuple (stag,etag) containing
                attrlist = {}
                attrlist = mo.group('attrlist')
            attrlist = mo.group('attrlist')
                    attrlist = subs_attrs(attrlist)
                attr = mo.group()
        attr = mo.group('attr')
                attr.name = attr.name[:-1]
            attr.name = re.sub(r'(?u)[^\w\-_]', '', attr.name).lower()
    <attr> Return True if single attrbiute is defined.
                attrs = {}
        attrs = {}
    attrs = {}
    attrs: ''
            attrs[attr] = result
                attrs[attr] = value
            attrs['author'] = author
            attrs['author'] = author.replace('_',' ')
            attrs['authored'] = ''
            attrs['authorinitials'] = initials
                          attrs['doctitle'])
        attrs['doctitle'] = Title.attributes['title']
        attrs = document.attributes
        attrs = document.attributes # Alias for readability.
            attrs['email'] = email
            attrs['firstname'] = firstname
                attrs['firstname'] = s
    attrs: '"hello", planet="earth"'
    attrs: 'hello,world'
                attrs[k] = Lex.subs_1(v[1:-1],SUBS_NORMAL)
                attrs[k] = v
        attrs[k] = v
            attrs['lastname'] = lastname
                attrs['mantitle'] = mantitle;
                attrs['manvolnum'] = mo.group('manvolnum').strip()
            attrs['middlename'] = middlename
        attrs['pageunits'] = config.pageunits
        attrs['pagewidth'] = str(config.pagewidth)
                attrs['revdate'] = attrs['docdate']
                attrs['revdate'] = revdate.strip()
                attrs['revnumber'] = revnumber.strip()
                attrs['revremark'] = revremark
        attrs = self.attributes # Alias for readability.
        attrs = self.mo.groupdict().copy()
    attrs: 'star="sun",planet="earth"'
            attrs['style'] = self.calc_style(self.index)
                    attr.subs = document.attributes.get('attributeentry-subs',
                    attr.subs = mo.group('attrs')
                attr.subs = parse_options(attr.subs, SUBS_OPTIONS,
        attrs.update(AttributeEntry.attributes)
        attrs.update(config.cmd_attrs)
            attrs.update(d)
        attrs.update(d)
                    attrs.update(dictionary)
        attrs.update(dictionary)
            attr.value = attr.value[:-1] + reader.read().strip()
                attr.value = Lex.subs((attr.value,), attr.subs)
                    attr.value = mo.group('value')  # Passthrough.
                attr.value = None
                attr.value = writer.newline.join(attr.value)
        author = attrs.get('author')
            author = author.strip()
            author = mo.groupdict().get('author')
            author = re.sub(r'\s+',' ', author)
            author = '%s %s %s' % (firstname, middlename, lastname)
            # available are in the global asciidoc.conf
        # backend is now known.
    backend = None
    # backend property.
    backend = property(getbackend,setbackend)
            backend = self.attributes.get('backend-alias-' + backend, backend)
            backend = v
        base_ident = char_encode(re.sub(r'(?u)\W+', '_',
        base_ident = idprefix + base_ident
                    (basestring, int, float, long, complex)):
            b.delimiter = r'^(' + Table_OLD.COL_STOP \
            b.dump()
        # be factored to single routine.
        # Before a block is processed it's attributes (from it's
        'before' is the source text before substitution; 'after' text is the
                    before = '\n'.join(before)
        before = s
        # Before we finish replace the table head, foot and body place holders
    be quoted. Examples:
                b.footdata = b.bodydata
                b.footrow = b.bodyrow
                b.headdata = b.bodydata
                b.headrow = b.bodyrow
        blank line. If argument is None nothing is written. self.newline is
                    b.load(k,d)
        """ Block macro translation."""
        block of non-blank lines."""
                blocks.current.translate()
blocks = DelimitedBlocks()  # DelimitedBlock definitions.
        blocks.dump()
        blocks.load(sections)
        blocks.validate()
            # block title.
            BlockTitle.consume(attrs)
        BlockTitle.consume(attrs)
                BlockTitle.consume(d)
            BlockTitle.pattern = pat
                BlockTitle.title = mo.group('title')
            BlockTitle.title = None
        BlockTitle.title = s
    BLOCK_TYPE = DelimitedBlock
    BLOCK_TYPE = List
    BLOCK_TYPE = None   # Block type set in derived classes.
    BLOCK_TYPE = Paragraph
    BLOCK_TYPE = Table
    BLOCK_TYPE = Table_OLD
            body = ()
            body = config.subs_section(section_name,d)
                    body = filter_lines(self.parameters.filter,body,self.attributes)
            body = filter_lines(self.parameters.filter,body,self.attributes)
            body = Lex.set_margin(body) # Move body to left margin.
                body = Lex.subs(body,postsubs)
        body = Lex.subs(body,postsubs)
                body = Lex.subs(body,presubs)
        body = Lex.subs(body,presubs)
        body = reader.read_until(paragraphs.terminators)
                body = reader.read_until(self.delimiter,same_file=True)
        bodyrows = self.parse_rows(bodyrows, self.bodyrow, self.bodydata)
            bodyrows = self.subs_rows(self.rows)
            bodyrows,table = self.split_rows(table)
        bodyrows,table = self.split_rows(table)
        bodyrows = writer.newline.join(bodyrows)
            body = self.sections[section]
        body = [self.text] + list(body)
        bom is optional byte order mark.
                break
                    break
                        break
                                break
                    break;
                        break   # No more parsed or reserved cells.
                break   # Skip cells outside the header width.
                    b = self.BLOCK_TYPE()
        buffer. Note that it's up to the caller to restore the previous
            # BUG: We've already done attribute substitution on the macro which
        # Build and print error description.
            # build an encoded representation
        # Build asciidoc-args attribute.
        # Build colspecs.
        # Build combined tables delimiter patterns and assign defaults.
        Build list of column objects from table 'cols', 'halign' and 'valign'
        # Build outfile name.
        # Build self.columns.
        # But don't do attribute substitution on title -- we've already done it.
            b.validate()
        # (by self.merge_attributes()) resulting in the template substitution
                # Cache compiled delimiter optimization.
        """ Calculate any missing author related attributes."""
        # Calculate column alignment and absolute and percent width values.
            # Calculate column count from number of items in first line.
        # Calculated attribute values.
        # Calculated parameters.
        # Calculate dynamic block parameters.
        # Calculate marked up colwidths from rulerwidths.
        # Calculate separator if it has not been specified.
        # Calculate total ruler width.
        # Calculate width of block margin.
        # Called when callout list is closed.
calloutmap = CalloutMap()   # Coordinates callouts and callout list.
            calloutmap.listclose()
            calloutmap.validate(self.ordinal)
                            # call through.
    can be used in addition to obj['foo'].
            c.colalign = self.ALIGNMENTS[splits[i]]
            c = Column_OLD()
                    c.colwidth = c.colwidth/100 # tablewidth is in percent.
                c.colwidth = c.colwidth * self.tablewidth   # Scale factor.
            c.colwidth = colfraction * config.pagewidth # To page units.
                    # cell.
                    cell = parsed_cells[i]
                    cell = resv
        cells = []
        Cells.
                    cells.append(Cell(data, '1', align_spec, style))
                cells.append(Cell(data, span_spec, align_spec, style))
                cells.pop(0)
                # Change file extension.
        character, the reason we don't is because the escape character itself
                       char_decode(middlename)[:1] + char_decode(lastname)[:1])
                char_decode(title)).strip('_').lower())
        # Check all named sections exist.
        # Check all specialsections section names exist.
        # Check all special words have a corresponding inline macro body.
        # Check all styles for missing templates.
        # Check all tables have valid fill character.
        # Check all text quotes have a corresponding tag.
        check_array_parameter('options')
        check_array_parameter('postsubs')
        check_array_parameter('presubs')
        """Check calculated self.ordinal (1,2,...) against the item number
        # Check configuration for consistency.
            # Check for double-line titles.
                # Check for duplicates.
        # Check for empty rows containing only reserved (spanned) cells.
        # Check for expected pattern match groups.
            # Check for include macro.
        # Check for single-line titles.
            # Check for valid repetition of underline character pairs.
        # Check global table parameters.
            # Check if macro reference is escaped.
    Check if the sequence of attributes is defined in dictionary 'dic'.
        """Check if this block is next in document reader."""
            # Check list has valid type.
        Check Python version and locate the executable and configuration files
        # check routine like the other block checkers?
        # Check special characters are only one character long.
        """Check table definition and set self.check_msg if invalid else set
        # Check table definitions are valid.
        # Check tags and propagate default tags.
        # Check that all list indexes referenced by callouts exist.
        """ Check that all necessary tags are present. """
        # Check that all row spans match.
        """Check the configuration for internal consistancy. Called after all
        # Check the infile exists.
            # Check the parameter is a sequence type.
        # Check we have a default paragraph definition, put it last in list.
        # Check we have a default table definition,
        # Check we have a valid template entry or alternatively that all the
                    ci = 0
            ci = 0  # Column counter 0..colcount
                ci += cell.span
class AbstractBlock:
class AbstractBlocks:
class AttrDict(dict):
class AttributeEntry:
class AttributeList:
class BlockTitle:
class CalloutMap:
class Cell:
class Column:
class Column_OLD:
class Config:
class DelimitedBlock(AbstractBlock):
class DelimitedBlocks(AbstractBlocks):
class Document(object):
class EAsciiDoc(Exception): pass
class FloatingTitle(Title):
class Header:
class InsensitiveDict(dict):
class Lex:
class List(AbstractBlock):
class Lists(AbstractBlocks):
class Macro:
class Macros:
class Message:
class OrderedDict(dict):
class Paragraph(AbstractBlock):
class Paragraphs(AbstractBlocks):
class Plugin:
class Reader1:
class Reader(Reader1):
class Section:
class Table(AbstractBlock):
class Table_OLD(AbstractBlock):
class Tables(AbstractBlocks):
class Tables_OLD(AbstractBlocks):
class Title:
class Trace(object):
    # Class variables
class Writer:
        # Cleanup.
                # Clone self and set as parent (self assumes the role of child).
            cmd = args
                cmd = cmd + ' 2>&1'
            cmd = cmd + (' > %s' % tmp)
    cmd is asciidoc command or asciidoc.py path.
        cmd is the asciidoc command or asciidoc.py path.
                cmd = mo.group('attrlist')
    cmd = mo.group('cmd').strip()
    CMDS = ('install','remove','list','build')
            cmd = v
            codecs.lookup(encoding)
    # Code from:
                col.abswidth = '%.2f' % round(col.abswidth,2)
                col.abswidth = '%d' % round(col.abswidth)
            col.abswidth = self.abswidth * (col.pcwidth/100)
            colcount = len(self.columns)
                    colfraction = width/config.textwidth
                    colfraction = width/totalwidth
                colfraction = width/totalwidth
            col.halign = col.halign or halign or document.attributes.get('halign') or 'left'
                col.pcwidth = float(col.width[:-1])
                col.pcwidth = (float(col.width)/props)*100
            col.pcwidth = int(col.pcwidth)
            cols = []
        cols = []
                cols = 0
                    cols.append(s)
        cols = attrs.get('cols')
                    cols += cell.span
            col = self.columns[i]
            colspec = self.get_tags(col.style).colspec
        COLS_RE1 = r'^((?P<count>\d+)\*)?(?P<align>[<\^>.]{,3})?(?P<width>\d+%?)?(?P<style>[a-z]\w*)?$'
        COLS_RE2 = r'^((?P<count>\d+)\*)?(?P<width>\d+%?)?(?P<align>[<\^>.]{,3})?(?P<style>[a-z]\w*)?$'
                    % cols,self.start)
        cols = str(cols)
                cols = text[0].count(self.parameters.separator) + 1
            #   (ColStop,(ColWidth,FillChar+)?)+, FillChar+, TableWidth?
    COL_STOP = r"(`|'|\.)"  # RE.
                colstyle = cell.style
                colstyle = cell.style or col.style
                            Column(mo.group('width'), mo.group('align'),
column widths."""
            col.valign = col.valign or valign or document.attributes.get('valign') or 'top'
                        col.width = str(int(width))+'%'
                        col.width = str(width)
        # Command-line entries override header derived entries.
        command-line option (in which case it is loaded unconditionally).
        # Command-line options.
            # Command-line overrides header.
                    # comment or an attribute entry.
                            cond = eval(attrlist)
                    cond = False
        conditional exclusion is active (ifdef and ifndef macros)."""
    conditional inclusion system macros. Tabs are expanded and lines are right
      conditional, system.
        conf2 = document.backend + '-' + document.doctype + '.conf'
CONF_DIR = '/etc/asciidoc'
        conf = document.backend + '.conf'
                config.cmd_attrs[k] = v
config = Config()           # Configuration file reader.
            config.dump()
        config.expand_all_templates()
            config.filters.append(v)
                                config.include1[fname] = [
    config.init(cmd)
        config.init(sys.argv[0])
                config.load_backend([indir])
                config.load_file('asciidoc.conf', indir,
                config.load_file('asciidoc.conf', indir)
                    config.load_file(f)
                    config.load_file(f, include=include, exclude=exclude)
            config.load_filters()
                config.load_filters([indir])
            config.load_from_dirs('asciidoc.conf')
        config.load_from_dirs(help_file)
    config.load_from_dirs(help_file)
            config.load_miscellaneous(attrs)
        config.load_miscellaneous(config.cmd_attrs)
                config.load_miscellaneous(config.conf_attrs)
                config.load_sections(section)
                    config.sections[attr.name] = [attr.value]
        config.set_theme_attributes()
    Config.subs_specialwords()."""
            # Configuration file attribute.
# Configuration file processing.
        configuration files have been loaded."""
        # Configuration is fully loaded.
        # Configuration parameter names common to all blocks.
        # Configuration parameters.
        config.validate()
        config.verbose = bool(set(['-v','--verbose']) & set(opt_names))
    confiles = []
            confiles.append(v)
# Constants
                # Consume continued element title and attributes.
            containing the substituted macro body."""
    containing undefined attributes are deleted. If 'lines' is a string then
        'content'."""
        content = Lex.subs(content,subs)
    content line with the end tag. This ensures verbatim elements don't
                contents = []
                contents.append(s)
    continuation character are joined."""
            continuation = False
    continuation = False
            continuation = reader.read_next() == '+'
            continuation = True
            continue
                continue
                        continue
            continue;
    """Convert AsciiDoc document to DocBook document of type doctype
            # Convert escape sequences to their character values.
            # Convert ruler width to output page width.
    """Convert seconds since the Epoch to formatted local date string."""
    """Convert seconds since the Epoch to formatted local time string."""
        # convert to lower case.
                    copy(dst,k,v)
                copy(dst,k,v)
                    copy(dst,k,v) # Derived class specific entries.
Copyright (C) 2002-2010 Stuart Rackham. Free use of this software is granted
        corresponding style parameters; if there are any style parameters
        count = 0
    count = 0
                count += 1
            count += 1
                    count = int(mo.groupdict().get('count') or 1)
        Create plugin Zip file.
    Create Zip file. If src is a directory archive all contained files and
            create_zip(zip_file, plugin_source, skip_hidden=True)
                c.rulerwidth = len(s)+1
                    c.rulerwidth = None
                    c.rulerwidth = prevwidth
                        c.rulerwidth = val
            c = self.columns[i]
        csv=',',
        cursor."""
                cursor = reader.cursor
                    d = {}
                + '([\d\.]*)$'
                d = {}
            d = {}
        d = {}
    d = {}
                d['0'] = chr(0)  # Replace temporarily with unused character.
                    d['0'] = d['target']
                d['alt'] = d['1']
            d[arg.arg] = literal_eval(arg.value)
            d = args[1]
                    data = []
                data = ''
            data = []
        data = ''
                    data.append(char_encode(row[start:end]).strip())
                    data.append(char_encode(row[start:]).strip())
                data = cell.data
            data = [data]
                data = data[:-1]+mo.group() # Reinstate escaped separators.
                        data += dovetail_tags([stag],para.split('\n'),[etag])
            data = filter_lines(self.get_param('filter',colstyle),
            data = Lex.subs(data, postsubs)
            data = Lex.subs(data, presubs)
            data = row.split(separator)
                                data, self.attributes)
            data = [s.strip() for s in data]
        data += text[start:]
            data += text[start:mo.start()]
                    d = AttrDict()
        d = AttributeList.match.groupdict()
                        d['attrlist'] = d['attrlist'].replace('\\]',']')
                d['coid'] = calloutmap.add(listindex)
                d = [d]
                d = data[i]
        d = dict.copy(self)
        d = document.attributes.get('docdir')
                d = d.split('\n')    # So writer.newline is written.
                    'dedication','glossary','bibliography'):
    def add(self,listindex):
        def append_cell(data, span_spec, op, align_spec, style):
def asciidoc(backend, doctype, confiles, infile, outfile, options):
def assign(dst,src):
DEFAULT_BACKEND = 'html'
DEFAULT_DOCTYPE = 'article'
                default = self.blocks[i]
        default = self.tags['default']
                    # Default substitution.
    # Default system macro syntax.
        # Default to English if specified language help files not found.
# Default value for unspecified subs and presubs configuration file entries.
    def build(args):
    def build_colspecs(self):
    def calc_index(index,style):
    def calc_style(index):
    def calloutid(listnumber,calloutindex):
    def calloutids(self,listindex):
    def __call__(self, name, before, after=None):
    def canonical_subs(options):
def char_decode(s):
def char_encode(s):
def char_encoding():
def char_len(s):
        def check_array_parameter(param):
    def check_index(self):
    def check_tags(self):
    def clear(self):
    def clone_reserve(self):
    def closefile(self):
    def close(self):
def column_width(s):
    def consume_attributes_and_comments(self,comments_only=False,noblanks=False):
    def consume(d):
        def _convert(node):
        def copy(obj,k,v):
    def copy(self):
def create_zip(zip_file, src, skip_hidden=False):
def date_str(t):
    def __delattr__(self, key):
    def __delitem__(self, key):
    def deprecated(self, msg, linenos=True):
def die(msg):
    def dosubs(title):
def dovetail(lines1, lines2):
def dovetail_tags(stag,content,etag):
    def dump():
def dump_section(name,dict,f=sys.stdout):
    def dump(self):
    def end_brace(text,start):
    def entries_section(self,section_name):
    def eof(self):
                    # Defer check if template name contains attributes.
                # Defer check if template name contains attributes.
    def error(self, msg, cursor=None, halt=False):
def execute(cmd,opts,args):
    def expand_all_templates(self):
    def expand_templates(self,entries):
    def extract_passthroughs(self,text,prefix=''):
def extract_zip(zip_file, destdir):
    def f(*args,**keywords):
def file_in(fname, directory):
def filter_lines(filter_cmd, lines, attrs={}):
    def find_config_dir(self, *dirnames):
    def findfilter(name,dir,filter):
    def find_in_dirs(self, filename, dirs=None):
    def f(**keywords): return keywords
    def format(self, msg, prefix='', linenos=True, cursor=None, offset=0):
    def gen_id(title):
    def get_args(val):
    def __getattr__(self, key):
    def getbackend(self):
    def get_dir():
    def getdoctype(self):
    def __getitem__(self, key):
    def get_kwargs(val):
    def get_load_dirs(self):
    def getnumber(level):
    def get_param(self,name,params=None):
    def get(self, key, default=None):
    def __getstate__(self):
    def get_style(self,prefix):
    def get_subs(self,params=None):
    def get_tags(self,params):
    def has_key(self, key):
    def has_passthrough(self):
                defined = is_attr_defined(target, document.attributes)
        # defined. Prefix ensures the ID does not clash with existing IDs.
    def initialize():
    def initialize(self):
# definition subs entry.
    def __init__(self):
    def init(self, cmd):
    def __init__(self, data, span_spec=None, align_spec=None, style=None):
    def __init__(self, d=None, **kwargs):
    def __init__(self, width=None, align_spec=None, style=None):
    def install(args):
def is_array(obj):
def is_attr_defined(attrs,dic):
    def is_conf_entry(self,param):
def is_name(s):
    def isnext():
    def isnext(self):
def is_re(s):
def is_safe_file(fname, directory=None):
    def items(self):
def join_lines_OLD(lines):
    def keys(self):
    def list(args):
    def listclose(self):
    def literal_eval(node_or_string):
    def load_backend(self, dirs=None):
    def load_conffiles(include=[], exclude=[]):
    def load(entries):
    def load_file(self, fname, dir=None, include=[], exclude=[]):
    def load_filters(self, dirs=None):
    def load_from_dirs(self, filename, dirs=None, include=[]):
    def load_lang(self):
    def load_miscellaneous(self,d):
    def load_sections(self,sections,attrs=None):
    def load(self,entries):
    def load(self,entry):
    def load(self,name,entries):
    def load(self,sections):
    def load_tags(self,sections):
def localapp():
def lstrip_list(s):
    def match(self,prefix,name,text):
    def merge_attributes(self,attrs,params=[]):
    def next():
    def open(self,fname):
    def open(self,fname,bom=None):
    def parse():
    def parse_align_spec(align_spec):
def parse_attributes(attrs,dict):
    def parse_author(self,s):
    def parse_cols(self, cols, halign, valign):
    def parse_csv(self,rows):
    def parse_csv(self,text):
    def parse_dsv(self,rows):
def parse_entries(entries, dict, unquote=False, unique_values=False,
def parse_entry(entry, dict=None, unquote=False, unique_values=False,
    def parse_fixed(self,rows):
    def parse_header(self,doctype,backend):
    def parse(lines):
def parse_list(s):
def parse_named_attributes(s,attrs):
def parse_options(options,allowed,errmsg):
    def parse_psv_dsv(self,text):
    def parse_replacements(self,sect='replacements'):
    def parse_rows(self, rows, rtag, dtag):
    def parse_rows(self, text):
    def parse_ruler(self,ruler):
    def parse_span_spec(span_spec):
    def parse_specialsections(self):
    def parse_specialwords(self):
    def parse_tags(self):
    def parse_to_list(val):
    def popitem(self):
    def process_author_names(self):
    def read_ahead(self,count=1):
    def read_lines(self,count=1):
    def read_next(self):
    def read(self):
    def read(self, skip=False):
    def read_super(self):
    def read_until(self,terminators,same_file=False):
def re_join(relist):
    def remove(args):
    def __repr__(self):
    def restore_passthroughs(self,text):
        def roman_to_int(roman):
def rstrip_list(s):
def safe():
def safe_filename(fname, parentdir):
    def savetag(level,etag):
    def section2tags(self, section, d={}, skipstart=False, skipend=False):
    def section_name(self,name=None):
    def __setattr__(self, key, value):
    def setbackend(self,backend):
    def setdefault(self, key, default = None):
    def setdefault(self, key, failobj = None):
    def set_deprecated_attribute(self,old,new):
    def setdoctype(self,doctype):
    def set_id():
        def set_if_int_gt_zero(name, d):
    def __setitem__(self, key, item):
    def __setitem__(self, key, value):
    def setlevel(level):
    def set_margin(lines, margin=0):
    def set_replacement(pat, rep, replacements):
    def setsectname():
    def __setstate__(self,value):
    def set_theme_attributes(self):
    def short_name(self):
def show_help(topic, f=None):
    def skip_blank_lines(self):
    def split_rows(self,rows):
    def stderr(self,msg=''):
    def stdout(self,msg):
def strip_list(s):
def strip_quotes(s):
    def style():
    def subs_1(s,options):
    def subs(attrs):
def subs_attrs(lines, dictionary=None):
        def subs_func(mo):
    def subs(lines,options):
    def subs_passthroughs(self, text, passthroughs):
def subs_quotes(text):
    def subs_replacements(self,s,sect='replacements'):
    def subs_row(self, data, dtag):
    def subs_row(self, row, rowtype):
    def subs_rows(self, rows, rowtype='body'):
    def subs_section(self,section,d):
    def subs(self,text):
    def subs(self,text,prefix='',callouts=False):
    def subs_specialchars_reverse(self,s):
    def subs_specialchars(self,s):
def _subs_specialwords(mo):
    def subs_specialwords(self,s):
def subs_tag(tag,dict={}):
def symbolize(s):
def system(name, args, is_macro=False, attrs=None):
    def tag(self, name, d=None):
def time_str(t):
    def translate():
    def translate_body(terminator=Title):
    def translate_entry(self):
    def translate_item(self):
    def translate(self):
    def translate(self,has_header):
    def translate(skipsubs=False):
    def unread(self,cursor):
    def unsafe(self, msg):
    def update_attributes(self,attrs=None):
def update_attrs(attrs,dict):
    def update_parameters(self, src, dst=None, all=False):
        def update_section(section):
    def update(self, dict):
    def update(self, d=None, **kwargs):
def usage(msg=''):
def userdir():
    def validate_attributes(self):
    def validate(self):
    def validate(self,maxlistindex):
    def values(self):
    def verbose(self, msg,linenos=True):
    def warning(self, msg,linenos=True,offset=0):
    def write_line(self, line=None):
    def write(self,*args,**kwargs):
    def write_tag(self,tag,content,subs=None,d=None,**kwargs):
            del attrs['title']
                    del d['attrlist']
                    del dictionary[k]
                del dictionary[k]
                            del dirs[dirs.index(d)]
                del document.attributes[attr.name]
                        del d['subs']
            # Delete groups that didn't participate in match.
    # Delete groups that didn't participate in match.
                # Delete leading backslash.
    # Delete named groups to avoid ambiguity.
        Delete plugin directory.
        # Delete trailing blank lines from sections.
                # Delete undefined macro.
            delimiter = reader.read()   # Discard closing delimiter.
            delimiter = reader.read()   # Discard delimiter line.
        delimiters = []
                delimiters.append(b.delimiter)
            delimiters.append(b.delimiter)
                     delimiter=self.parameters.separator, skipinitialspace=True)
                del replacements[pat]
                    del sections[k][i]
                del sections[s]
                        del sections[section]
                del self.attributes['title']
        del self[key]
                        del self.macros[i]
            del self.next[0]
                del self.quotes[q]  # Undefine quote.
                del self.specialsections[k]
                    del self.specialsections[pat]
                        del self.specialwords[k]
                    del self.tags[k]
                    # DEPRECATED: attributeentry-subs
        # DEPRECATED: date renamed to revdate.
# Deprecated old table classes follow.
        # DEPRECATED: revision renamed to revnumber.
        #DEPRECATED: --unsafe option.
                d = ''  # Fill missing column data with blanks.
        d = get_kwargs(s)
                        d.get('name',''))
    dict: {}
    dict['0'] = attrs
    dict: {'2': 'world', '0': 'hello,world', '1': 'hello'}
        dict.clear(self)
        dict.__delitem__(self, key)
        dict.__init__(self, d)
    dictionary 'dict'. Blank lines are skipped."""
                    dictionary[k] = v
        dictionary of block processing parameters (self.parameters) and tag
    Dictionary ordered by insertion order.
        # dictionary (self.attributes) and the block's processing parameters
        dict[name] = value
    dict: {'planet': 'earth', '0': '"hello",planet="earth"', '1': 'hello'}
    dict: {'planet':'earth', 'star':'sun'}
        dict.setdefault(self, key, failobj)
        dict.__setitem__(self, key, item)
        dict.__setitem__(self, key.lower(), value)
    dict.update(d)
        dict.update(self, d)
        die('--backend, --filter and --theme options are mutually exclusive')
            die('cannot find %s: %s' % (Plugin.type, plugin_dir))
                die('directory not found: %s' % d)
                die('directory not found: %s' % plugins_dir)
            die('failed to create %s directory: %s' % (Plugin.type, str(e)))
            die('failed to create %s: %s' % (zip_file, str(e)))
            die('failed to delete %s: %s' % (Plugin.type, str(e)))
            die('failed to extract %s: %s' % (Plugin.type, str(e)))
            die('file name does not start with legal %s name: %s'
            die('file not found: %s' % zip_file)
            die('illegal --%s command: %s' % (plugin, cmd))
            die('illegal %s name: %s' % (Plugin.type, plugin_name))
            die('invalid number of arguments: --%s build %s'
            die('invalid number of arguments: --%s install %s'
            die('invalid number of arguments: --%s remove %s'
            die('missing --%s command' % plugin)
            die('plugin source not found: %s' % plugin_source)
            die('%s is already installed: %s' % (Plugin.type, plugin_dir))
                die('user directory is not defined')
                die('user home directory is not defined')
                digit = digits[roman[i]]
            digits = {'i':1,'v':5,'x':10}
        # directory.
        directory = '.'
        directory.
        directory = os.getcwd()
        directory = os.path.dirname(document.infile)
                directory = os.path.normpath(os.path.join(destdir, d))
        directory = os.path.realpath(directory)
        'dir'. Return found file path or None if not found."""
            dirs = self.get_load_dirs()
        # Discard title from reader.
        d._keys = self._keys[:]
            d[k] = '%s|%s' % v
            d = kwargs
            d = mo.groupdict()
        # Do attribute substitution last so {brkbar} can be used to escape |.
    DocBook file written to file object dst."""
                doc_conffiles = [
        doc_conffiles = []
            'doctest','filter=','theme='])
    Doctests:
        'doctype' and 'backend' are the doctype and backend option values
        # doctype is now finalized.
    doctype = None
    # doctype property.
    doctype = property(getdoctype,setdoctype)
            doctype = v
        document.attributes and 'd'.  Lines containing undefinded
        document.attributes['asciidoc-args'] = args
                document.attributes[attr.name] = attr.value
        document.attributes[attr] = result
                document.attributes[attr] = value
        document.attributes['backend-'+document.backend] = ''
    document.attributes dictionary and from 'dictionary' ('dictionary'
        document.attributes['doctype-'+document.doctype] = ''
        document.attributes[document.backend+'-'+document.doctype] = ''
                    document.attributes['iconsdir'] = iconsdir
                document.attributes['indir'] = self.indir
        document.attributes['indir'] = self.indir
                document.attributes['infile'] = self.infile
        document.attributes['infile'] = self.infile
                document.attributes[k] = v[:-1]
            document.attributes['listindex'] = str(lists.open[-1].ordinal)
            document.attributes['listindex'] = str(self.ordinal)
                document.attributes['themedir'] = themedir
        document.attributes.update(AttributeEntry.attributes)
                document.consume_attributes_and_comments(noblanks=True)
            document.consume_attributes_and_comments(noblanks=True)
        document.consume_attributes_and_comments(noblanks=True)
        document doctype and backend properties.
document = Document()       # The document being processed.
# Document element classes parse AsciiDoc reader input and write DocBook writer
            document.has_errors = True
        document.has_warnings = True
        # Document header attributes override conf file attributes.
        document.infile = infile
                    % (document.level+1, Title.level))
        document.level = level
            document.load_lang()
        document.outfile = outfile
                document.parse_author(author)
                document.parse_author(s)
        document.process_author_names()
            document.safe = False
            document.safe = True
        document 'trace' attribute (treated as a regexp).
                    document.translate(has_header) # Generate the output.
        document.update_attributes()
        document.update_attributes(attrs) # So they are available immediately.
        # Does not call AbstractBlocks.validate().
            # Don't be fooled by back-to-back delimited blocks, require at
            # Don't dump undefined attributes.
        # Don't load conf files twice (local and application conf files are the
            # Don't override most command-line attributes.
            # Don't process escaped macro references.
                # Don't process include macro once the maximum depth is reached.
            # Do postponed substitutions (backend confs have been loaded).
                            d[option+'-option'] = ''
                    d[option+'-option'] = ''
        d = OrderedDict()
        # Do the work.
    # Double quoted.
                d, outfile = os.path.split(outfile)
            d = Plugin.get_dir()
                        d['presubs'] = d['subs']
                d = re.sub(r'(?m)\n',r' +\n',d)
        # Drop line if it contains  unsubstituted {name} references.
                    # Drop line if the action returns None.
    """Drop non-symbol characters and convert to lowercase."""
                    d = self.tags[name]
        dst defaults to self.parameters.
        dst = dst or self.parameters
            d[str(arg.name)] = literal_eval(arg.expr)
                d[str(i)] = literal_eval(arg)
            d[str(i)] = literal_eval(arg)
                d[str(i)] = literal_eval(arg.id)
        dsv=r':|\n',
                dtag = tags.bodydata
                dtag = tags.footdata
                dtag = tags.headdata
                d['target']= config.subs_specialchars_reverse(d['target'])
            d['title'] = BlockTitle.title
            d['title'] = chr(0)  # Replace with unused character.
            d['title'] = title
        # Dump all macros except the first (built-in system) macro.
        """Dump configuration to stdout."""
    dump_dict = {}
        # Dump only the configuration file and command-line attributes.
        # Dump remaining sections.
        dump_section('attributes',d)
            dump_section('listtags-'+k, v)
        dump_section('quotes',self.quotes)
        dump_section('replacements2',self.replacements2)
        dump_section('replacements',self.replacements)
        dump_section('specialcharacters',self.specialchars)
        dump_section('specialsections',self.specialsections)
        dump_section('specialwords',d)
            dump_section('tabletags-'+k, v)
        dump_section('tags',d)
        dump_section('titles',Title.dump_dict)
        # Dump special sections.
            d.update(AttributeList.attrs)
            d.update(get_args(s))
        d.update(get_args(s))
            d.update(get_kwargs(s))
        d.update(get_kwargs(s))
        d.update(self.cmd_attrs)
        d.update(self.conf_attrs)
                d[v] = '"%s"' % k
                d[v] = '%s "%s"' % (d[v],k)   # Append word list.
east_asian_widths = {'W': 2,   # Wide
        element, else writes argument as single line. If no arguments writes
                elif all or k in self.PARAM_NAMES:
    elif allow_name_only and entry:         # name or name! entry.
    elif AND in attrs:
                elif arg is not None:
        elif AttributeList.isnext():
            elif attr.name in document.attributes:
        elif blocks.isnext():
        elif BlockTitle.isnext() and not tables_OLD.isnext():
            elif cmd.endswith('.rb'):
                elif c == '}': n = n - 1
            elif config.outfilesuffix:
        elif config.pageunits is None:
        elif config.pagewidth is None:
            elif continuation:
    elif directory == '':
elif float(sys.version[:3]) < 2.6:
        elif isinstance(infile, str):
            elif isinstance(next,List):
            elif isinstance(next,Paragraph) and 'listelement' in next.options:
            elif isinstance(node, compiler.ast.List):
            elif isinstance(node, Dict):
            elif isinstance(node, Name):
            elif isinstance(node, Tuple):
            elif isinstance(node, UnarySub):
        elif isinstance(outfile, str):
            elif k == 'bodydata':
            elif k == 'bodyrow':
            elif k == 'colspec':
            elif k == 'delimiter':
            elif k == 'filter':
            elif k == 'footdata':
            elif k == 'footrow':
            elif k == 'format':
            elif k == 'headdata':
            elif k == 'headrow':
                    elif k in params:
            elif k in ('subs','presubs','postsubs'):
            elif k == 'options':
            elif k == 'posattrs':
            elif k == 'separator':
            elif k == 'style':
            elif k == 'tablewidth':
            elif k == 'tags':
            elif k == 'width':
            elif len(body) == 1:
    elif len(lines) == 1:
    elif len(result) == 2:
        elif lists.isnext():
            elif l < level:
            elif l == level:
            elif l > level:
        elif macros.isnext():
    elif n > 1:
                    elif name == 'ifeval':
                elif name == 'ifeval':
                elif name == 'ifndef':
    elif name == 'include':
    elif name == 'include1':
    elif name in ('counter','counter2'):
        elif name in self.parameters:
    elif name in ('set','set2'):
    elif name in ('sys','sys2','sys3'):
    elif name == 'template':
            elif not all_styles_have_template:
                        elif not is_re('^'+v[0]+'$'):
        elif not is_safe_file(args):
                    elif not k in self.attributes:
                elif not self.entries_section(k):
            elif not v in self.sections:
            elif o == 'attributes':
            elif o == 'callouts':
            elif o in ('replacements','replacements2'):
            elif o == 'macros':
            elif op == '+': # Column spanner.
                    elif op in ('@','$'):
                    elif op == '!': s = ''
                    elif op == '?': s = ''
                    elif op == '!': s = rval
                    elif op == '?': s = rval
                    elif op == '#': s = rval
                    elif op == '%': s = rval
                    elif op == '#': s = UNDEFINED   # So the line is dropped.
                    elif op == '%': s = UNDEFINED   # So the line is dropped.
            elif options[0] == 'normal':
            elif options[0] == 'verbatim':
            elif o == 'quotes':
        elif os.path.isdir(src):
            elif o == 'specialwords':
        elif outfile is None:
        elif re.match(r'^[a-z]\.$', index):
        elif re.match(r'^[ivx]+\)$', index):
            elif result is False:
            elif result is not None:
            elif revnumber or revremark:
        elif round(percents) < 100:
            elif rowtype == 'footer':
        elif rowtype == 'footer':
        elif ruler[1:] == self.fillchar*len(ruler[1:]):
        elif safe() and self.name == 'blockdef-backend':
        elif self.backend is None:
        elif self.bodydata is None:
        elif self.bodyrow is None:
        elif self.doctype is None:
            elif self.doctype == 'manpage' and 'name' in config.sections:
        elif self.footdata is None:
        elif self.footrow is None:
        elif self.format == 'csv':
        elif self.format == 'dsv':
        elif self.headdata is None:
        elif self.headrow is None:
            elif self.infile == '<stdin>':
        elif self.parameters.format == 'csv':
            elif self.type == 'labeled':
        elif style == 'loweralpha':
        elif style == 'lowerroman':
            elif style not in self.styles and not isinstance(self,List):
        elif style == 'upperalpha':
        elif style == 'upperroman':
        elif tables.isnext():
        elif tables_OLD.isnext():
        elif 'template' in AttributeList.attrs:
        elif Title.isnext():
            elif v == '':
                                    elif v[1] == '':  # {<name>$<re>::<v2>}
                                else:
                            else:
                        else:
                    else:
                else:
            else:
        else:
    else:
            else:   # Calculate column width from inter-fillchar intervals.
        else:   # Input file is file object from API call.
                                    else:             # {<name>@<re>:<v1>}
                                    else:             # {<name>$<re>:<v1>:<v2>}
        else:   # Output file is file object from API call.
                else: props += int(col.width)
        else: return False
        else: return True
    else: return True
        email = mo.group('email')
    # Empty directory (not to be confused with None) is the current directory.
                    empty = False
            empty = True
    encoding = document.attributes.get('encoding')
        encountered.
                end = end_brace(line,mo.start())
            # End of current file.
# End of deprecated old table classes.
        end of file or line one.  Exits with the reader pointing to the first
                end = start + c.rulerwidth
    endtags = []  # Stack of currently open section (level,endtag) tuples.
        Ensures the 'old' name of an attribute that was renamed to 'new' is
    entries = config.expand_templates(entries)
    ENTRIES_SECTIONS= ('tags','miscellaneous','attributes','specialcharacters',
    entries take precedence). Return a tuple of the substituted lines.  'lines'
        entrytag = subs_tag(self.tag.entry, self.attributes)
            # enveloping quotes and punctuation e.g. a='x', ('x'), 'x', ['x'].
        e = parse_entry(entry)
            e = parse_entry(line)
            e = parse_entry(v, allow_name_only=True)
    'errmsg' is an error message prefix if an illegal option error is thrown."""
            errmsg = 'malformed [titles] underlines entry'
            # Escape = in pattern.
        etag = []
                        etag.append(mo.group('etag'))
                etag.append(s)
                etag = config.section2tags(template,self.attributes,skipstart=True)[1]
        etag = config.section2tags(template, self.attributes,skipstart=True)[1]
            etag = map(lambda x: x.replace(chr(0), title), etag)
                etag = subs_attrs(etag,d)
            etag = subs_attrs(etag, d)
    Evaluate a system attribute ({name:args}) or system block macro
            # Evaluate escape characters.
    Example:
        except:
                except EAsciiDoc,e:
                except Exception:
            except Exception:
        except Exception:
    except Exception:
                        except Exception,e:
        except Exception,e:
    except Exception,e:
    except getopt.GetoptError:
        except IndexError:
        except KeyboardInterrupt:
    except KeyboardInterrupt:
        except KeyError, k: raise AttributeError, k
        except KeyError: return None
        except LookupError,e:
    except: return False
                    except ValueError:
                except ValueError:
            except ValueError:
        # Execute asciidoc.
    Execute asciidoc with command-line options and arguments.
       >>> execute(__file__, opts, [infile])
        # Execute plugin management commands.
            execute(sys.argv[0],opts,args)
        Existing sections are overlaid.
        """Expand any template::[] macros in a list of section entries."""
        # Expand conditional attributes.
            # Expand executable block macros.
        # Expand simple attributes ({name}).
        # Expand system attributes (eval has precedence).
                    'expected level %d, got level %d'
        # EXPERIMENTAL: The number of lines in the table, requested by Benjamin Klum.
                expr = 'chr(ord("%s")+1)' % value
    expression (re1)|(re2)|..."""
        expression.  The string or node provided may only consist of the  
                expr = expr.replace('{\\','{')
                expr = expr.replace('}\\','}')
                expr = mo.group('expr')
                expr = value + '+1'
                ext = ''
                ext = config.outfilesuffix[1:]
                ext = os.path.splitext(self.outfile)[1][1:]
        # Extract miscellaneous configuration section entries from attributes.
        """ Extract the passthrough text and replace with temporary
            extract_zip(zip_file, plugin_dir)
                     'F': 2,   # Full-width (wide)
        failures,tries = doctest.testmod(optionflags=options)
                # Fall back to default style.
            # Fast elimination check.
        fc = re.escape(self.fillchar)
            f = document.backend + '.conf'
        fd,tmp = tempfile.mkstemp()
                        f for f in (f+'.conf', f+'-'+document.backend+'.conf')
                    fh = os.open(outfile, flags)
                    fh = os.open(outfile, flags, perms)
    # file directory).
            filename = 'lang-en.conf'   # Default language file.
            filename = 'lang-' + lang + '.conf'
                                # [filename,linenumber,linetext] lists.
                    filename = os.path.join(root,f)
        # File name related attributes can't be overridden.
    Files and directories names starting with . are skipped
        files += confiles
        files = document.attributes.get('conf-files','')
        files = [f.strip() for f in files.split('|') if f.strip()]
        file unless the filter has been specified with the --filter
        # Fill in missing widths.
        # Fill in unspecified ruler widths.
            # Fill missing column data with blanks.
    --filter and --theme option commands.
# filter and theme plugin commands.
               (filter_cmd, filter_status))
        filter_cmd = '"' + found + '"' + mo.group('tail')
                filter_cmd = 'python ' + filter_cmd
                filter_cmd = 'ruby ' + filter_cmd
    filter_cmd = s.strip()
        # Filter command has no directory path so search filter directories.
        filtername = attrs.get('style')
                filter_opt = len(subdirs) > 1 and subdirs[1] in self.filters
            filtersdir = os.path.join(d,'filters')
    filter_status = p.wait()
                finally:
            finally:
        finally:
    finally:
        Find conf files from dirs list.
        """Find filter file 'fname' with style name 'name' in directory
                    finished = False
                finished = False
        finished = False
            finished = True
        firstname = attrs.get('firstname','')
        firstname = firstname.replace('_',' ')
        firstname,middlename,lastname,author,initials = names
        firstname = mo.group('name1')
        # First search for filter backends.
            # fix have withheld {0} from substitution but this kludge doesn't
            # fix it for other attributes containing unescaped references.
                    flags |= os.O_BINARY
                flags = os.O_CREAT | os.O_WRONLY
    '''Floated titles are translated differently.'''
                    fname = os.path.expandvars(os.path.expanduser(fname))
            fname = os.path.join(dir, fname)
    fname = os.path.normpath(fname)
        fname = os.path.normpath(os.path.join(parentdir,fname))
                    fname = safe_filename(fname, os.path.dirname(self.fname))
            fname = self.cursor[0]
                fname = subs_attrs(mo.group('target'))
        following Python literal structures: strings, numbers, tuples, 
                              'footdata', 'bodydata')
            footrows = self.parse_rows(footrows, self.footrow, self.footdata)
            footrows = self.subs_rows( self.rows[-1:], 'footer')
                footrows,table = self.split_rows(table)
            footrows = writer.newline.join(footrows)
        for a in attrs.split(AND):
        for a in attrs.split(OR):
            for arg in args:
        for arg in args:
    for a,v in src.__dict__.items():
                for b in self.blocks:
        for b in self.blocks:
            for cell in row:
        for cell in row:
                for cell in self.parse_psv_dsv(text[:1]):
        for ch in s:
            for c in self.columns:
        for c in self.columns:
        for c in text:
        for c in text[start:]:
            for coindex in self.comap[listindex]:
            for col in re.split(r'\s*,\s*',cols):
            for col in self.columns:
        for col in self.columns:
            for data in self.subs_row(row,dtag):
                    for d in dirs[:]:
            for d in dirs:
        for d in dirs:
        for d in [os.path.join(d, 'backends', document.backend) for d in dirs]:
        for d in [os.path.join(d, *dirnames) for d in self.get_load_dirs()]:
        for d in [os.path.join(d, Plugin.type+'s') for d in config.get_load_dirs()]:
            for dirpath,dirnames,filenames in os.walk(filtersdir):
        for entry in entries:
    for entry in entries:
        for f in config.filters:
                for f in doc_conffiles:
        for f in doc_conffiles + confiles:
                    for f in filenames:
                for f in files:
            for f in files:
                for f in os.walk(d).next()[1]:
        for f in self.find_in_dirs(filename,dirs):
        for i in range(0,len(splits),2):
                    for i in range(count):
            for i in range(int(cols)):
        for i in range(len(args)):
        for i in range(len(lines)):
            for i in range(len(roman)):
    for i in range(len(s)):
    for i in range(len(s)-1,-1,-1):
            for i in range(len(sections[k])-1,-1,-1):
        for i in range(len(self.blocks)):
        for i in range(len(self.columns)):
                for i in range(span):
        for i in range(Title.linecount):
                for i,m2 in enumerate(self.macros):
                for i,name in enumerate(names):
        for i,v in enumerate(names):
        for i,v in enumerate(posattrs):
        for i,v in enumerate(self.passthroughs):
                        for j in range(1, cell.vspan):
        for key in d.keys():
    for k in config.sections:
                for k in d.keys():
        for k in d.keys():  # Drop any empty positional arguments.
        for k in ('label','text','index'):
        for k in ('sect0','sect1','sect2','sect3','sect4'):
        for k in sections.keys():
        for k in self.sections.keys():
        for k in self.specialchars.keys():
    for k,v in args.items():
        for k,v in attrs.items():
        for k,v in dictionary.items():
            for k,v in dict.items():
        for k,v in dict.items():
    for k,v in dict.items():
            for k,v in d.items():
        for k,v in d.items():
                for k,v in d.items(): s += '%s=%r,' % (k,v)
        for k,v in document.attributes.items():
        for k,v in entries.items():
        for k,v in sections.items():
        for k,v in self.attributes.items():
        for k,v in self.sections.items():
        for k,v in self.specialchars.items():
        for k,v in self.specialsections.items():
                for k,v in self.specialwords.items():
        for k,v in self.specialwords.items():
        for k,v in self.styles.items():
                for k,v in self.styles[style].items():
        for k,v in self.tags.items():
        for k,v in src.items():
            for k,v in Title.attributes.items():
        for k,v in value.items(): self[k]=v
        for level in range(len(Title.underlines)):
            for line in  config.sections[args]:
        for line in entries:
        for line in lines:
    for line in lines:
        for line in self.sections.get('specialwords',()):
                for line in self.sections[k]:
        for l in range(len(Title.section_numbers)):
        for listindex in self.comap.keys():
                for m2 in self.macros:
        for macro in self.specialwords.values():
        format = self.format
        format = self.parameters.format
    FORMATS = ('fixed','csv','dsv')
    FORMATS = ('psv','csv','dsv')
                    format = v
            for m in self.macros:
        for m in self.macros:
        for m in self.macros[1:]:
        for mo in re.finditer(separator,text):
        for name in names:
        for name in params:
        for name in self.ENTRIES_SECTIONS:
                        for n in names:
                    for n in names:
        for o in options:
                        for option in options:
                for option in options:
    for o,v in opts:
                    for para in re.split(r'\n{2,}',text):
        for pat,rep in d.items():
        for pat,rep in getattr(self,sect).items():
            for pat,sect in config.specialsections.items():
        for pat,sectname in d.items():
    for q in keys:
        for q in self.quotes.keys()[:]:
        for reo in [reo1,reo2]:
        for reo in reos:
                for reo in terminators:
        for ri,row in enumerate(self.rows):
            for root, dirs, files in os.walk(srcdir):
            for row in rdr:
        for row in rows:
        for section in sections.keys():
                    for s in arg:
        for s in body:
        for s in lines:
    for s in relist:
        for s in re.split(r'\s*,\s*',options):
        for s in self.CONF_ENTRIES:
            for s in set(sections) & set(exclude):
            for s in set(sections) - set(include):
            for s in underlines:
            for style,d in self.styles.items():
        for tag in ('bodyrow','bodydata','paragraph'): # Mandatory default tags.
        for the given list style."""
        for t in self.tags.values():
        for t in tags:
        for v in d.values():
        for word in self.specialwords.keys():
                for word in words:
        for zi in zipo.infolist():
            f = os.path.join(d,filename)
                f = os.path.splitext(infile)[0]
            found = cmd
                    found = findfilter(filtername, APP_DIR, cmd)
                    found = findfilter(filtername, CONF_DIR, cmd)
            found = findfilter(filtername, d, cmd)
                found = findfilter(filtername, USER_DIR, cmd)
    found = None
            found = reo.findall(s)
    from ast import literal_eval
    from compiler.ast import Const, Dict, Expression, Name, Tuple, UnarySub, Keyword
        f = sys.stdout
            ftr = config.subs_section('footer',{})
            """Function called to perform inline macro substitution.
            """Function called to perform macro substitution.
    f.write('[%s]%s' % (name,writer.newline))
        f.write('%s%s' % (s,writer.newline))
    f.write(writer.newline)
        Generate column related substitution attributes.
        # Generate colwidths and colspecs.
        """Generate colwidths and colspecs. This can only be done after the
                        # Generate ensuing reserved cells spanned vertically by
        # Generate headrows, footrows, bodyrows.
            # Generate ids for sections.
                    # Generate option attributes.
            # Generate option attributes.
        getattr(Plugin,cmd)(args)
        global APP_DIR
        global APP_FILE
# Global configuration files directory (set by Makefile build target).
# Globals
        global USER_DIR
        # Guess whether column widths are specified numerically or not.
                     'H': 1,   # Half-width (narrow)
                          halt=True)
            # Has been set in document header.
        has_header = document.parse_header(doctype,backend)
        has_header = (Title.isnext() and Title.level == 0
        hdr = ''
                hdr = config.subs_section('header',{})
        hdr = hdr + '# Generated by AsciiDoc %s for %s %s.%s' % \
        hdr = hdr + '# %s%s' % (t,writer.newline)
        hdr = hdr + '#' + writer.newline
            'headdata','footdata', 'bodydata','paragraph')
        # Header.
            Header.parse()
                header_span = row_span
        # Headrow, footrow and bodyrow data replaces same named attributes in
                              'headrow','footrow','bodyrow','headdata',
            headrows = bodyrows
        headrows = footrows = []
        headrows = footrows = bodyrows = None
            headrows = self.parse_rows(headrows, self.headrow, self.headdata)
            headrows = self.subs_rows(self.rows[0:1],'header')
            headrows = writer.newline.join(headrows)
HELP_FILE = 'help.conf'     # Default (English) help file.
        help_file = HELP_FILE
        help_file = 'help-' + lang + '.conf'
            'help','no-conf','no-header-footer','out-file=',
    help_option = False
            help_option = True
        # Heuristic to validate that at least one configuration file was loaded.
        home direcory or None if user home not defined.
        horizonatal and vertical alignment names. Unspecified alignments
    http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/107747
        http://en.wikipedia.org/wiki/Byte-order_mark
    # http://mail.python.org/pipermail/python-list/2009-September/1219992.html
            i = 0
        i = 0
                    i += 1
                i += 1
            i += 1
        i = 1
                i += cell.span
            i += cell.span
                iconsdir = os.path.join(themedir, 'icons')
                ident = base_ident
                ident = '%s_%d' % (base_ident, i)
        idprefix = document.attributes.get('idprefix','_')
    ids = []      # List of already used ids.
    i.e. the configuration is in the executable's directory.
            if a0:
            # If a default style is defined make it available in the template.
                if after is None:
        if align_spec:
        If all is True then copy src entries that aren't parameter names.
            if (allowed and s not in allowed) or not is_name(s):
    If allowed=() then all legitimate names are allowed.
            # If all sections are loaded mark this file as loaded.
    If an item is not present None is returned.
        if attr.endswith('!'):
                if AttributeEntry.isnext():
        if AttributeEntry.isnext():
        if AttributeList.attrs:
                if AttributeList.isnext():
            if AttributeList.style() == 'float':
                    if attrlist:
            if 'attrlist' in d:
            if attr.name[-1] == '!':
            if attr.name2 != '':
        if attr.name2 is not None:
                if attr.name in ('attributes','miscellaneous') and attr.name2[-1] == '!':
            if attr.name in config.cmd_attrs \
                if attr.name in config.sections:
        if attrs:
                            if attrs.get(n) is None:
                            if attrs.get(n) is not None:
            if attrs is not None:
        if attrs is not None:
            if attr.value is not None:
        if author:
            if author and 'firstname' not in attrs:
        if author and not (firstname or middlename or lastname):
        if backend:
        if backend is not None:
                if b.bodydata is None: b.bodydata = default.bodydata
                if b.bodyrow is None: b.bodyrow = default.bodyrow
                if b.check_msg:
                if b.colspec is None: b.colspec = default.colspec
            if b.delimiter:
            if before != after and re.match(self.name_re,name):
                if b.fillchar is None: b.fillchar = default.fillchar
                if b.footdata is None: b.footdata = default.footdata
                if b.footrow is None: b.footrow = default.footrow
                if b.format is None: b.format = default.format
                if b.headdata is None: b.headdata = default.headdata
                if b.headrow is None: b.headrow = default.headrow
            if b.isnext():
            if b is not default:
            if blocks.isnext() and 'skip' in blocks.current.options:
        if 'blocktitle' in entries:
        if BlockTitle.title:
                    if b.name == k:
            if b.name == 'paradef-default':
        if bodyrows:
        if bom:
                if b.template is None: b.template = default.template
        # If callouts is True then only callout macros are processed, if False
                if callouts ^ (m.name != 'callout'):
            if cell.reserved:
            if cells[0].data.strip() != '':
                    if cell.vspan > 1:
    if char_encoding():
                if ci <= colcount:
                if ci >= colcount:
                if c is self.columns[-1]:
            if cmd.endswith('.py'):
            if cmd not in Plugin.CMDS:
        if cmd not in Plugin.CMDS:
                if c == '{': n = n + 1
        if cols:
            if colspec:
            if col.width:
                if col.width[-1] == '%': percents += int(col.width[:-1])
        if config.dumping:
            if config.header_footer:
        if config.header_footer:
        if config.load_from_dirs(filename):
            if config.outfilesuffix:
            if config.pageunits in ('cm','mm','in','em'):
        if config.textwidth is None:
            if config.verbose:
        if config.verbose:
        if content:
        if continuation:
    if continuation:
            if continuation: reader.read()  # Discard continuation line.
    if count == 1:
    if count > 1:
                if c.rulerwidth is None:
            if cursor is None:
        if d:
            if data.endswith('\\'):
                if 'data-uri' in document.attributes and os.path.isdir(iconsdir):
                if d['attrlist'] in (None,''):
        if default.format is None: default.subs = 'fixed'
                        if defined: return attrlist
                if 'depth' in attrs:
            if d.get('subslist'):
            if dic.get(a.strip()) is None:
            if dic.get(a.strip()) is not None:
    if dictionary is None:
                if dictionary is not None and action in ('counter','counter2','set','set2'):
    if dict is not None:
        if dir:
    if directory == '':
    if directory is None:
        if dirs is None:
        If dirs not specified try all the well known locations.
        If dirs not specified try all the well known locations.  Suppress
        if d is None:
        if d is None: d = kwargs
        if d is not None:
            if d[k] == '': del d[k]
    if '--doctest' in opt_names:
        if doctype is not None:
        if doctype not in (None,'article','manpage','book'):
        if document.attributes.get('plaintext') is None:
        if document.attributes.get('plaintext') is not None:
            if document.backend == 'docbook' and Title.sectname != 'index':
            if document.backend == 'latex' and 'target' in d and d['target']:
                    if document.consume_attributes_and_comments(noblanks=True):
            if document.doctype == 'book' \
        if document.doctype == 'manpage':
        if document.has_errors:
        if document.infile == '<stdin>':
                        if d.startswith('.'):
                if d['subslist'].startswith(':'):
        if e is None:
        if email:
            if empty:
    if encoding:
        if '-e' not in options:
        if entry and not parse_entry(entry, dict, unquote, unique_values,
            if escape_delimiter:
    if escape_delimiter:
            if etag:
        if etag:
        if etag is None: etag = ''
        if exclude:
            if ext:
        if failures == 0:
        if files:
    if filter_status:
        if firstname:
    if f is None:
if float(sys.version[:3]) < 2.4:
        if float(sys.version[:3]) < MIN_PYTHON_VERSION:
                            if fname not in config.include1:
        if fname == '<stdin>':
        if fname == '<stdout>':
        if footrows:
        if format == 'csv':
        if format == 'psv':
            if found:
        if found:
    if found:
        if halt:
        If halt=False don't exit application, continue in the hope of reporting
        If halt=True raise EAsciiDoc exception.
        if has_header:
        if headrows:
    if help_option:
        if i == 0:
            if i == 1:
        if i == -1:
        if i != -1 and q != '|' and q != '||':
                if i+1 < len(roman) and digits[roman[i+1]] > digit:
            if ident not in Section.ids:
            if i > len(data) - 1:
                    if i >= len(parsed_cells):
        if i >= len(rows):
            if i >= len(self.columns):
            if i > len(self.columns) - 1:
        if include:
        if infile == '-':
            if infile == '<stdin>':
            if infile != '<stdin>':
        if infile != '<stdin>':
        if initials:
            if in_stag:
                    if is_array(after):
                if is_array(arg):
                if is_array(before):
        if isempty:
            if isinstance(arg, ast.Name):
            if isinstance(arg, Keyword):
        if isinstance(e, EAsciiDoc):
            if isinstance(node, Const) and isinstance(node.value,
        if isinstance(node_or_string, basestring):
        if isinstance(node_or_string, Expression):
            if isinstance(obj,dict):
            if isinstance(terminator,DelimitedBlock) and next is Title:
            if isinstance(terminators,basestring):
    if isinstance(text, unicode):
                if isinstance(v,str):
        if is_macro:
    if is_macro:
    If is_macro is True then we are processing a system block macro otherwise
                if is_name(v):
            if i < width: width = i
                    if ''.join(contents):
                if k == 'attrlist':
            if key not in self._keys: self._keys.append(key)
        if key not in self._keys: self._keys.append(key)
            if k == 'fillchar':
            if k == 'format':
            if k in attrs: del attrs[k]
            if k in entries:
                if k in self.sections:
                if k in self.tags:
            if k in Title.dump_dict:
                    if k not in self.TAGS:
                    if k == 'posattrs':
            if k.startswith('+'):
                if k == 'subs': k = 'presubs'
            if k == 'template':
            if l == 0:
    if lang and lang != 'en':
            if lang is None:
        if lang is None:
        if lastname:
        if len(args) == 0:
    if len(args) == 0:
    if len(args) == 0 and len(opts) == 0:
    if len(args) > 1:
        if len(args) == 2:
        if len(args) != 2:
        if len(args) not in (1,2):
            if len(body) == 0:
    if len(config.sections) == 0:
        if len(data) < len(self.columns):
        if len(data) > len(self.columns):
            if len(k) != 1:
        if len(k) != len(k.strip()):
    if len(lines) == 0:
        if len(lines[0]) == 0: return False # Title can't be blank.
        if len(lines) == 0: return False
            if len(lines) < 2: return False
        if len(lists.open):
                if len(names) > 9:
        if len(options) == 1:
    if len(relist) == 0:
    if len(result) == 1:
                if len(s) !=2:
    if len(s) >= 3 and s[0] == '"' and s[-1] == '"':
        if len(self.next) == 0:
        if len(self.next) > 0:
                if len(self.next) > self.READ_BUFFER_MIN:
        if len(self.next) <= self.READ_BUFFER_MIN:
            if len(separator) > 1:
        if len(separator) != 1:
            if len(table) > 0 and re.match(self.underline,table[-1]):
        if len(text) == 0:
            if len(underlines) != len(Title.underlines):
                                    if len(v) == 2:   # {<name>$<re>:<v1>}
                                    if len(v) == 3:   # {<name>@<re>:<v1>:<v2>}
                        if len(v) not in (2,3):
                if Lex.next() is not Title:
            if Lex.next() is not Title:
        if Lex.prev_element and Lex.prev_cursor == reader.cursor:
        if line:
        if line and line[-1] == '\\':
                if line in ('',None):
            if line is None:
                if line is not None:
    if lines and not result:
        if listindex in self.comap:
            if listindex > maxlistindex:
                if localapp():
        if localapp():
                if lval is None:
                    if m2.pattern == m.pattern:
        if 'macros' in options:
            if macros.isnext() and macros.current.name == 'comment':
            if macros.match('+',r'\\eval|\\sys|\\sys2|\\ifdef|\\ifndef|\\endif|\\include|\\include1',result):
                if mantitle is None:
                if mantitle == mantitle.upper():
            if m.has_passthrough() and m.prefix == prefix:
        if middlename:
        if missing:
                if m.name and m.prefix != '+':
            if m.name is None:
                    if m.name == name:
                if mo:
            if mo:
        if mo:
            if mo and not skip:
            if mo.group()[0] == '\\':
    if mo.group()[0] == '\\':
        if mo.group(1):
                    if mo.group('etag'):
        if mo.group('name3'):
                    if mo.group('name') == 'include1':
                    if mo.group('stag'):
    if mo:  # name=value entry.
                if m.prefix == '#':
            if m.prefix == prefix:
                    if m.reo.match(line):
    if msg:
            if m.subslist is not None:
    if n == 0:
            if n == 0: break
        if name:
        if name[-1] == '!':
    If name and allow_name_only=True then value is set to ''.
    If name! and allow_name_only=True then value is set to None.
        if name and name[0] in ('+','#'):
        if name and not is_name(name):
            if name == 'callout':
        if name == 'counter2':
                if name == 'endif':
            if name == 'endif':
                if name == 'ifdef':
            if name == 'image' and '1' in d:
    if name != 'include1':
            if name in d:
    if name in ('eval','eval3'):
                    if name in ('ifdef','ifndef'):
                if name in self.tags:
            if __name__ == '__main__':
        if __name__ == '__main__':
if __name__ == '__main__':
    if name not in ('eval','eval3','sys','sys2','sys3','include','include1','counter','counter2','set','set2','template'):
        if name_re == 'subs':    # Alias for all the inline substitutions.
            if name != 'set2':  # set2 only updates local attributes.
            if name.startswith(prefix):
        if name+suffix in config.sections:
            if name == 'sys2':
    If name= then value is set to ''.
        if 'newline' in d:
        if next and isempty and Title.level > document.level:
                # If next digit is larger this digit is negative.
            if next in lists.open:
                if next is Title:
        if n < len(self.columns) and percents < 100:
                if '__noautoload__' not in filenames or filter_opt:
            if noblanks and not reader.read_next(): return result
        If 'noblanks' is True then consumation halts if a blank line is
                if node.name in _safe_names:
                if not '0' in d:
        if not args in config.sections:
        if not AttributeEntry.pattern:
        if not 'attributelist-pattern' in document.attributes:
                        if not attrlist:
                    if not attrlist:
                if not attrlist or name == 'ifeval':
    if not attrs:
        if not author:
            if not b.fillchar or len(b.fillchar) != 1:
            if not b.footdata:
            if not b.footrow:
            if not b.headdata:
            if not b.headrow:
            if not b.type in Lists.TYPES:
                if not cell.reserved:
        if not cmd:
        if not cols:
                if not col.width:
            if not comments_only:
                        if not config.dumping:
            if not config.find_config_dir('filters', f):
            if not config.load_backend():
            if not config.load_from_dirs('asciidoc.conf',include=['attributes']):
            if not continuation and BlockTitle.title:
            if not d:
        if not 'default' in self.tags:
                        if not defined: return attrlist
        if not document.attributes.get('sectids') is None \
            if not e:
    if not filter_cmd or not filter_cmd.strip():
                    if not fname:
                if not fname:
            if not found:
        if not found:
        if not found use default 'sect<level>' name.
        if not include:
        if not initials:
            if not is_array(self.parameters[param]):
                if not isinstance(Lex.next(),Paragraph):
                if not isinstance(self,List):   # Lists don't have templates.
                if not isinstance(self,List): # Lists don't have templates.
        if not isinstance(terminators,list):
            if not (isinstance(v,str) or isinstance(v,int) or isinstance(v,float) or v is None):
        if not is_name(attr):
        if not is_name(k):
            if not is_name(macro):
            if not is_name(name):
            if not is_name(self.style):
                    if not is_name(style):
            if not is_name(style):
                if not is_name(v):
        if not is_re(e[0]):
            if not is_re(pat):
        if not is_re(pat):
            if not is_re(separator):
                    if not is_re(word):
    if not is_safe_file(fname, parentdir):
    if not lines1 or not lines2:
        if not lines or not options:
        if not listindex in self.comap:
        if not loaded:
            if not macro in self.sections:
                        if not mo:
                if not mo:
            if not mo:
        if not mo:
    if not mo:
                if not mo: break
            if not mo: break
        if not name:
    if not name:
                if not 'name' in d:
        if not name in self.tags:
    if not os.path.dirname(cmd):
        if not os.path.exists(args):
        if not os.path.exists(cmd):
    if not os.path.isabs(fname):
            if not os.path.isdir(d):
                if not os.path.isdir(directory):
        if not os.path.isdir(plugin_dir):
            if not os.path.isdir(plugins_dir):
        if not (os.path.isdir(plugin_source) or os.path.isfile(plugin_source)):
            if not os.path.isdir(USER_DIR):
                    if not os.path.isfile(fname):
        if not os.path.isfile(fname):
            if not os.path.isfile(infile):
        if not os.path.isfile(zip_file):
            if not outfile.endswith('/'):
            if not paragraphs.isnext():
                    if not parse_named_attributes(v,d):
            if not 'passtext' in d:
            if not pat:
                if not pat or not is_re(pat):
            if not pat or not is_re(pat):
            if not plugins_dir:
            if not Reader1.eof(self):
            if not reader.read_next(): break
                if not re.match(r'^\d{1,3}%$',v) or int(v[:-1]) > 100:
            if not re.match(r'^\d+$', k):
            if not re.match(r'\d+',k) and not is_name(k):
            if not re.match(r'^\d+$', value) and len(value) > 1:
                if not re.match(r'^'+fc+r'+$',s):
        if not re.match(r'^\w+$',plugin_name):
                        if not re.match(r'^[^\\\W][-\w]*$',n):
        if not reo:
                    if not re.search(r'{.+}',self.template):
                if not re.search(r'{.+}',t):
            if not re.search(r'(?u)\w',title): return False
            if not result:
        if not result:
                            if not ri+j in reserved:
                if not s:
        if not s:
    if not s:
            if not same_file or fname == self.cursor[0]:
            if not section_name:
                if not sections[k][i]:
            if not self.delimiter_reo:
            if not self.entries_section(k):
        if not self.presubs:
            if not self.set_replacement(pat, rep, getattr(self,sect)):
        if not (self.skip_blank_lines and (not line or not line.strip())):
        if not self.specialchars or not self.tags or not lists:
            if not self.style in self.styles:
                if not self.template in config.sections:
        if not separator:
        if not skipend:
        if not skipped:
        if not skipstart:
        if not skipsubs:
            if not str(i+1) in keywords:
        if not style:
            if not t:
            if not tag:
    if not tag:
        if not tag: continue
                if not tag in self.tags:
                        if not target:
                if not target and name in ('ifdef','ifndef'):
    if not template in config.sections:
            if not t.footdata: t.footdata = t.bodydata
            if not t.footrow: t.footrow = t.bodyrow
            if not t.headdata: t.headdata = t.bodydata
            if not t.headrow: t.headrow = t.bodyrow
        if not title:
            if not 'title' in Title.attributes:
            if not Title.pattern: return False  # Single-line titles only.
        if not Title.subs:
            if not ((ul_len-3 < title_len < ul_len+3)
                    if not v:
            if not v:
                        if not val >= 0:
                        if not val > 0:
                    if not val > 0:
                        if not val >= 1:
        if 'numbered' in document.attributes:
            if o == 'attributes':
            if o == '-b':
            if o == '-c': config.dumping = True
        if o == '--filter':
        if o in ('-a','--attribute'):
        if o in ('-b','--backend'):
        if o in ('-b','--backend','--filter','--theme'):
        if o in ('-c','--dump-conf'):
        if o in ('-d','--doctype'):
        if o in ('-e','--no-conf'):
        if o in ('-f','--conf-file'):
        if o in ('--help','-h'):
        if o in ('-n','--section-numbers'):
        if o in ('-o','--out-file'):
        if o in ('-s','--no-header-footer'):
        if o in ('-v','--verbose'):
                            if op == '@':
            if op == '*':   # Cell multiplier.
                    if op == '=': s = lval
                    if op == '=': s = rval
    if options:
            if options[0] == 'none':
                    if 'options' in d:
            if 'options' in d:
            if ordinal != self.ordinal:
    if OR in attrs:
                    if OR in name:
        if o == '--safe':
            if o == '-s': config.header_footer = False
        if os.path.exists(plugin_dir):
            if os.path.isdir(d):
            if os.path.isdir(plugin_dir):
        if os.path.isfile(cmd):
                        if os.path.isfile(f) ]
                if os.path.isfile(f):
            if os.path.isfile(f):
            if os.path.isfile(result):
        if os.path.isfile(result):
        if os.path.isfile(src):
                if os.path.isfile(tmp):
            if os.path.isfile(tmp):
        if os.path.realpath(fname) in self.loaded:
            if o == 'specialcharacters':
            if os.system(cmd):
        if o == '--theme':
        if o == '--unsafe':
        if outfile == '-':
        if outfile and outfile != '<stdout>' and os.path.isfile(outfile):
        if outfile is None:
        if 'outfilesuffix' in d:
    if output:
            if o == '-v': config.verbose = True
        if o == '--version':
        if 'pageunits' in d:
        if 'pagewidth' in d:
        if params and name in params:
            if passtext is None: passtext = ''
            if pat in replacements:
                if pat in self.specialsections:
                    if pcunits:
            if pcunits:
        if percents > 0 and props > 0:
                if perms == 0:
        if posattrs and posattrs[0] == 'style':
        if prefix is None:
                if ptag:
        if Reader1.eof(self):
        if Reader1.read(self):
        if reader.cursor:
        if reader.eof():
        if reader.eof(): return None
                if reader.read_next():
        if reader.read_next():
                    if re.match(name, mo.group('name')):
            if re.match(name,section_name):
                        if re.match(r'^.+\.conf$',f):
        if re.match(r'^\d+$',cols):
        if re.match(r'^\d+[\.>]$', index):
            if re.match(r'^\d+$', value):
        if re.match(re.escape(topic), k):
            if re.match(r'^'+ self.PREFIX + r'.+$',k):
            if re.match('^'+s+'$',param):
                                if re_mo:
                    if reo.match(s):
            if reo.match(str(v)):
                if reo == reo2:
        if rep is None:
            if 'replacements' in subs:
            if re.search('\x07\\d+\x07', passtext):
            if result:
        if result:
    if result == '~':
    if result and name in ('eval3','sys3'):
            if result is None:
        if result is None:
        if result is None and self.skip:
        if result is not None:
            if result is True:
            if result == len(text)-1 or text[result+1] != '\\':
                if resv:
            if revdate:
            if revnumber:
            if revremark is not None:
            if ri == 0:
        if round(percents) > 100:
            if row == '': continue
            if row_span < header_span:
            if row_span > header_span:
            if rowtype == 'header':
            if rowtype != 'header':
        if rowtype == 'header':
        if ruler[1] != self.fillchar:
                    if s:
                if s == '':
                if s:
            if s:
        if s:
        if s[0] == '#':
            if s[:2] == '\\#':          # Unescape lines starting with '#'.
                    if safe():
    if safe() and name not in ('include','include1'):
        if same_file:
            if s and s[0] == '#':       # Skip comment lines.
            if section and contents:
            if 'sectionbody' in options:
                        if section in sections:
                if section in sections and self.entries_section(section):
        if section in self.sections:
                    if section.startswith('+'):
        if 'sectiontitle' in entries:
        if sectname and sectname != 'float':
            if sectname is None:
            if seed:
        if seed and (not re.match(r'^\d+$', seed) and len(seed) > 1):
        if self.attributes.get(new) is None:
            if self.attributes.get(old) is not None:
            if self.blocks[i].name == 'old_tabledef-default':
            if self.blocks[i].name == 'tabledef-default':
        if self.check_msg:  # Skip if table definition was marked invalid.
        if self.colspec:
            if self.columns[0].rulerwidth is None:
                if self.current_depth >= self.max_depth:
            if self.cursor[2].startswith(UTF8_BOM):
                    if self.depth < 0:
                    if self.depth == self.skipto:
            if self.doctype in ('article','book'):
        if self.doctype == 'manpage':
        if self.doctype == 'manpage' and not has_header:
        if self.filter:
                if self.fname != '<stdin>':
        if self.fname != '<stdout>':
        if self.footdata:
        if self.footrow:
            if self.format == 'fixed':
        if self.format == 'fixed':
        if self.format not in Table.FORMATS:
            if self.has_passthrough():
        if self.has_passthrough():
        if self.headdata:
        if self.headrow:
        if self.index:
            if self.infile and os.path.exists(self.infile):
        if self.infile is not None:
                if self.infile == '<stdin>':
            if self.infile != '<stdin>':
        if self.is_conf_entry('delimiter'):
        if self.is_conf_entry('delimiter') and not self.delimiter:
        if self.is_conf_entry('template') and not 'skip' in self.options:
            if self.isnumeric:
        if self.isnumeric:
        if self.linenos is not False and ((linenos or self.linenos) and reader.cursor):
                if self.load_file(conf,d):
            if self.load_file(conf,d):
            if self.load_file(f, include=include):
            if self.name:
        if self.name_re is not None:
            if self.number_style not in self.NUMBER_STYLES:
        if self.options:
        if self.outfile:
            if self.outfile != '<stdout>':
                if self.parameters.filter:
        if self.parameters.filter:
            if self.parameters.format == 'csv':
        if self.parameters.format in ('psv','dsv'):
            if self.parent:
        if self.posattrs:
            if self.postsubs:
        if self.postsubs:
                    if self.prefix == '':
                    if self.prefix == '#':
                if self.prefix == '#':
            if self.prefix == '':
        if self.prefix == '#':
            if self.prefix == '#' and self.name != 'comment':
        if self.presubs:
        if self.rows:
        if self.rows and 'footer' in self.parameters.options:
        if self.rows and 'header' in self.parameters.options:
        if self.separator:
        if self.short_name() != 'comment':
        if self.short_name() in ('bibliography','glossary','qanda'):
                    if self.skip:
        if self.style:
        if self.styles:
                if self.tablewidth > 1:
                if self.tablewidth is None:
            if self.tablewidth is not None:
                if self.tabsize != 0:
            if self.template:
        if self.template:
        if self.text:
            if self.text: break
        if self.type == 'callout':
            if self.type in ('bulleted','numbered','callout'):
            if self.type in ('numbered','callout'):
        if self.type in ('numbered','callout'):
        if self.type != 'labeled':
                    if sep == OR:
        if s[i]: break
                if s in self.sections:
                if s is None:
            if s is None:
        if s is None:
                if s is not None:
                if skip_hidden:
                    if skip_hidden and f.startswith('.'):
    if skip_hidden is True.
        if 'skip' in options:
            if skipped:
        if skipped:
        if span_spec:
            if srcdir[-1] != os.path.sep:
            if stag:
        if stag:
        if stag is None: stag = ''
            if str(i+1) in self.attributes:
    if string_result:
                if style:
        if style:
        if style == 'arabic':
            if style in self.styles:
            if style != self.number_style:
                    if 'subs' in d:
        if 'subs' in entries:
        if subs is None:
        if subslist is not None:
        if 'subsnormal' in d:
        if 'subsverbatim' in d:
                if sys.platform == 'win32':
    if sys.platform == 'win32':
            if t:
            if table:
        if table:
                if 'tabsize' in attrs:
                if tag[0] == '#':
        if tag[0] == '#':
            if tag not in default:
            if t and not t in config.sections:
                        if target and self.skipname != target:
                if t.bodydata is None: t.bodydata = default.bodydata
                if t.bodyrow is None: t.bodyrow = default.bodyrow
                if t.colspec is None: t.colspec = default.colspec
        if template in config.sections:
        if text:
        if 'text' in attrs: del attrs['text']
            if text[mo.start()] == '\\':
                if t.footdata is None: t.footdata = default.footdata
                if t.footrow is None: t.footrow = default.footrow
                if t.headdata is None: t.headdata = default.headdata
                if t.headrow is None: t.headrow = default.headrow
                # If the cell style is not defined use the column style.
    If the '=' delimiter character is allowed in  the 'name' then
            # If the first column does not start with a fillchar then numeric.
        If the first positional or 'template' attribute is set use it,
        if theme and 'themedir' not in document.attributes:
            if themedir:
        If the parameter is not in params look in self.parameters.
        """If there is a title add it to dictionary 'd' then reset title."""
    if time.daylight and t.tm_isdst == 1:
            if t is not default:
        if title:
        if 'title' in attrs:    # Don't pass the header title.
            if 'title' in self.attributes:
                    if title is not None:
        if Title.level == 0 and document.doctype != 'book':
                if Title.level != 1:
        if Title.level > document.level \
        if Title.level > document.level+1:
            if t not in lists.tags:
            if t not in tables.tags:
        if topic != 'topics':
        if totalwidth <= 0:
                if t.paragraph is None: t.paragraph = default.paragraph
        if 'trace' in kwargs:
        if 'trace' in kwargs and len(args) > 0:
    if type(lines) == str:
            if ul[:2] not in Title.underlines: return False
            if ul_len < 2: return False
            if ul != s[:ul_len]: return False
        if 'underlines' in entries:
        if unique_values:
    If unique_values' is True then dictionary entries with the same value are
    if unquote:
    If 'unquote' is True leading and trailing double-quotes are stripped from
            if USER_DIR:
        if USER_DIR is not None:
                    if v:
            if v:
                    if val > 0:
        if value:
        if value is None:
        if value is not None:
                if v and is_re(v):
                if v and len(v) == 1:
        if v and len(v) != len(v.strip()):
            if v and v[-1] == '@':
            if v in d:
                if v in Table_OLD.FORMATS:
                if v is None:
            if v is None:
        if v is None:
        if v is None: del args[k]
                if v is None: del d[k]
                if v is None: del Title.attributes[k]
            if v is not None:
                    if v == name:
                if v not in self.FORMATS:
                if v not in tables.tags:
                if v == value: del dict[k]
                        if warnings:
                # If we don't substitute attributes line-by-line then a single
            # If we're dealing with a block macro get optional block ID and
        if 'width' in self.attributes:
            if wordlist is None:
                i = i+1
            i = i + 1
            i = i+1
                          'illegal passthrough macro subs option')
                    'illegal [%s] %s: %s' %
                                 'illegal subs in macro entry: %s' % entry)
                            'illegal substitution option')
                'illegal [titles] subs entry')
    import ast
    import compiler
        import csv
        import doctest
    import getopt
import shutil, zipfile
       >>> import StringIO
        import StringIO
import sys, os, re, time, traceback, tempfile, subprocess, codecs, locale, unicodedata, copy
                                include=['attributes','titles','specialchars'])
    include extraneous opening and closing line breaks."""
        # Include files are relative to parent document
        including the next underline (continued lines are joined ) and the
    inclusion."""
        index = index[:-1]
                indir = os.path.dirname(infile)
        infile = args[0]
            infile = os.path.abspath(infile)
            infile = '<stdin>'
       >>> infile = StringIO.StringIO('Hello *{author}*')
        # Initialize default system macro.
        initials = attrs.get('authorinitials')
            initials = (char_decode(firstname)[:1] +
            initials = char_encode(initials).upper()
                    # Inline passthrough syntax.
                            in node.items)
# Input stream Reader and output stream writer classes.
        # input) which are replaced after template attribute substitution.
            # Insert AsciiDoc line break (' +') where row data has newlines
                # Insert line breaks in cell data.
                    in_stag = False
        in_stag = True
        Install plugin Zip file.
        # Internally [miscellaneous] section entries are just attributes.
                    # Internally processed inline macros use UNIX line
        in the document (self.index) and check the number style is the same as
        i = q.find('|')
            i = re.search(r'\S',s).start()
        is a list of Cells.
        is a list of raw data text.
                                  # is corresponding section name.
        i = self.name.rfind('-')
            isempty = False
        isempty = True
                            'is not a valid regular expression: %s' \
                                'is not a valid regular expression: %s' % pat
        itemtag = subs_tag(self.tag.item, self.attributes)
        """Iterates arguments, writes tuple and list arguments one line per
        # it is escaped and should not delimit.
        """It may seem like a good idea to escape special characters with a '\'
    it must be escaped with a backslash and escape_delimiter must be True.
    it's a system attribute.
        # Join lines so quoting can span multiple lines.
    """Join list of regular expressions re1,re2,... to single regular
    Keys are stored in lower case.
    keys = config.quotes.keys()
            key = self._keys[-1]
                keywords[str(i+1)] = args[i]
            k = '"'+k+'"'
                k = k[1:]
        k = k.replace('=',r'\=')    # Escape = in name.
            k = 'sect%s' % level
        k = str(k)
            k,v = e
        labeltag = subs_tag(self.tag.label, self.attributes)
                labelwidth = int(mo.group(1))
    lang = config.cmd_attrs.get('lang')
        lang = self.attributes.get('lang')
        # Last cell follows final separator.
        lastname = attrs.get('lastname','')
            lastname = lastname.replace('_',' ')
            lastname = mo.group('name2')
            lastname = mo.group('name3')
    Leading and trailing white space is striped from 'name' and 'value'.
        # Leading delimiter match object.
            # least one alphanumeric character in title.
            # Length of underline must be within +-3 of title.
    level = 0
    """Lexical analysis routines. Static methods and attributes only."""
                Lex.next().translate()
        Lex.prev_cursor = reader.cursor
        Lex.prev_element = result
    Like a dictionary except key access is case insensitive.
    Like a dictionary except values can be accessed as attributes i.e. obj.foo
        """Like read() but does not advance file pointer."""
        """Like read() but reads lines up to (but not including) the first line
    linecount = None    # Number of lines in title (1 or 2).
                line = line[:mo.start()] + s + line[end:]
                line = line[:mo.start()] + s + line[mo.end():]
            line = line.replace('{\\','{')
            line = line.replace('}\\','}')
        line = line.replace('\\{','{\\')
        line = line.replace('\\}','}\\')
        line of the next element or EOF (leading blank lines are skipped)."""
    """Line oriented AsciiDoc input file reader. Processes include and
            line = reader.read_next()
        line = reader.read_next()
                    lines = []
    lines1 = strip_list(lines1)
    lines2 = strip_list(lines2)
            lines = config.sections[k]
            lines[i] = ' '*margin + lines[i][width:]
        lines = [lines]
        lines = list(lines)
        lines = reader.read_ahead(2)
                lines = reader.read_until(r'^$')
                    lines = [s.rstrip() for s in open(tmp)]
    lines = subs_attrs(config.sections[template],args)
                lines = subs_attrs(para.split('\n'))
                line = subs_attrs(line)
        list."""
        List all plugin directories (global and local).
        list contains a list of cell data elements."""
                listindex =int(d['index'])
    """List of block definitions."""
    """List of delimited blocks."""
        list of lines.
    """List of List objects."""
# List of message strings written to stderr.
        list of output lines."""
    """List of paragraph definitions."""
    """List of tables."""
        lists, dicts, booleans, and None.
        lists.dump()
            # Lists have implicit styles and do their own style checks.
        lists.initialize()
lists = Lists()             # List definitions.
        lists.load(sections)
                                        # lists of section lines.
        lists.open.append(self)
        lists.open.pop()
        lists.validate()
        """Load and validate [titles] section entries dictionary."""
            # Load asciidoc.conf files in two passes: the first for attributes
        # Load backend configuration files.
        """Load block definition from 'sections' dictionary."""
        Load conf file from dirs list.
        load_conffiles()
            load_conffiles(include=['attributes'])
            load_conffiles(include=['attributes','titles','specialchars'])
        # Load conf files specified on the command-line and by the conf-files attribute.
        # Load configuration files from ~/.asciidoc if it exists.
                # Load document specific configuration files.
        loaded = False
                    loaded = True
                loaded = True
            # Load filter .conf files.
        Load filter configuration files from 'filters' directory in dirs list.
            # Load filters and language file.
            # Load from folders in asciidoc executable directory.
            # Load from global configuration directory.
        loading if a file named __noautoload__ is in same directory as the conf
        Load language configuration file.
        Load listtags-* conf file sections to self.tags.
                # Load local conf files (files in the source file directory).
        # Load single-line title patterns.
        Loads sections dictionary. Each dictionary entry contains a
        Loads sections dictionary with sections from file fname.
        Load tabletags-* conf file sections to self.tags.
        Load the backend configuration files from dirs list.
        # Load the selected style attributes.
    # Look for plugin management commands.
            lq = q[:i]      # Left quote.
            lq = rq = q
                                lval = ''
                            lval = ''
                    lval =  attrs.get(name)
                                lval = None
                            lval = None
                macro += '[' + ','.join(m.subslist) + ']'
        macro name 'name'."""
                macros.current.translate()
        macros.dump()
        macros.load(sections.get('macros',()))
macros = Macros()           # Macro definitions.
        macros.passthroughs.append(result)
            macro = '%s=%s%s' % (m.pattern.replace('=',r'\='), m.prefix, m.name)
        macros.validate()
        # Make it easier for regular expressions.
            # manpage title formatted like mantitle(manvolnum).
                # mantitle is lowered only if in ALL CAPS
                    mantitle = mantitle.lower()
                mantitle = mo.group('mantitle').strip()
                mantitle = subs_attrs(mantitle)
"""Mapping of result codes from `unicodedata.east_asian_width()` to character
                # Markup template section attribute.
    match = None
            # means that any escaped attribute references are now unescaped and
                        # Merge entries.
    """Merge the end tag with the first content line and the last
                    # Merge with existing options.
            message.deprecated('old %s list syntax' % self.short_name())
        message.deprecated('old tables syntax')
                message.error("[attributes] missing 'attributeentry-pattern' entry")
            message.error("[attributes] missing 'attributelist-pattern' entry")
                    message.error('block macro cannot occur here: %s' % mo.group(),
                message.error('empty section is not valid')
                            message.error('illegal attribute regexp: %s' % attr)
                            message.error('illegal attribute syntax: %s' % attr)
                message.error('illegal numbered list style: %s' % self.number_style)
                message.error('illegal style name: %s' % style)
                message.error('malformed manpage title')
                    message.error('malformed name section body')
                message.error('malformed presubs attribute: %s' %
            message.error('manpage document title is mandatory',halt=True)
                message.error('missing conf file: %s' % filename, halt=True)
                message.error('name section expected')
                    message.error('name section title must be at level 1')
            message.error('only book doctypes can contain level 0 sections')
                    message.error('section title not allowed in list item',halt=True)
                message.error('section title not permitted in delimited block')
            message.error('%s section cannot contain sub-sections' % prev_sectname)
        message.error('[%s] %s' % (self.name,msg), cursor, halt)
                    message.error('undefined attribute in manpage title')
        message.error('undefined filter attribute in command: %s' % filter_cmd)
    Message functions.
        message.linenos = False         # Disable document line numbers.
        message.linenos = False     # Disable document line numbers.
        message.linenos = None
message = Message()         # Message functions.
messages = message.messages
                message.stderr('-'*60)
            message.stderr('All doctests passed')
        message.stderr('ambiguous help topic: %s' % topic)
        message.stderr('available help topics: %s' % ', '.join(config.sections.keys()))
            message.stderr('FAILED: Missing asciidoc command: %s' % cmd)
            message.stderr('FAILED: Python 2.3 or better required')
            message.stderr('help topic not found: [%s] in %s' % (topic, help_file))
        message.stderr('illegal command options')
                message.stderr(msg)
        message.stderr(msg)
    message.stderr(msg)
                message.stderr(msg+'unexpected error:')
        message.stderr('no help topics found')
            message.stderr('%s%s' % (msg,str(e)))
                message.stderr('%sunexpected error: %s' % (msg,str(e)))
                    message.stdout(os.path.join(d,f))
            message.unsafe('Backend Block')
                        message.unsafe('ifeval invalid')
        message.unsafe('include file: %s' % fname)
            message.unsafe(syntax)
        message.unsafe(syntax)
                    message.verbose('archiving: %s' % arcname)
            message.verbose('archiving: %s' % arcname)
        message.verbose('evaluating: %s' % syntax)
                message.verbose('extracting: %s' % outfile)
    message.verbose('filtering: ' + filter_cmd)
                        message.verbose('ifeval: %s: %r' % (attrlist, cond))
                                message.verbose('include1: ' + fname, linenos=False)
                message.verbose('include: ' + fname, linenos=False)
                        message.verbose('macro redefinition: %s%s' % (m.prefix,m.name))
        message.verbose('reading: '+fname)
            message.verbose('removing: %s' % plugin_dir)
                        message.verbose('skipping: %s' % arcname)
                            message.verbose('skipping: %s' % os.path.join(arcroot, d))
        message.verbose('writing: '+writer.fname,False)
            message.warning('blank block title')
            message.warning('blank section title')
                message.warning('callout refers to non-existent list item '
                    message.warning('colspec dropped: contains undefined attribute')
            message.warning('fewer row data items then table columns')
        message.warning('filter non-zero exit code: %s: returned %d' %
            message.warning('filter not found: %s' % cmd)
                            message.warning('include file not found: %s' % fname)
                message.warning('list item index: expected %s got %s' %
                message.warning('list item style: expected %s got %s' %
                    message.warning('missing configuration section: %s' % attr.name)
                message.warning('missing language conf file: %s' % filename)
                    message.warning('missing macro name group: %s' % mo.re.pattern)
            message.warning('missing macro section: [%s]' % (name+suffix))
                    message.warning('missing section: [%s]' % s)
            message.warning('missing section: [%s]' % section)
                message.warning('missing specialsections section: [%s]' % v)
                message.warning('missing special word macro: [%s]' % macro)
                message.warning('missing style: [%s]: %s' % (self.name,style))
                    message.warning('missing styles templates: [%s]' % self.name)
                        message.warning('missing template section: [%s]'
                    message.warning('missing template section: [%s]' % t)
            message.warning('missing template section: [%s]' % template)
                message.warning('missing theme: %s' % theme, linenos=False)
            message.warning('more row data items than table columns')
        message.warning(msg)
                message.warning('nested inline passthrough')
            message.warning('no callouts refer to list item '+str(listindex))
        message.warning('no output from filter: %s' % filter_cmd)
                message.warning('passthrough macro %s: missing passtext group' %
                    message.warning('[quotes] %s missing tag definition: %s' % (q,tag))
                        message.warning('[%s] contains illegal list tag: %s' %
                        message.warning('[%s] contains illegal table tag: %s' %
                message.warning('section title out of sequence: '
                message.warning('%s: evaluation error: %s' % (syntax, expr))
            message.warning('%s: evaluation error' % syntax)
            message.warning('%s: file does not exist' % syntax)
            message.warning('%s: illegal attribute name' % syntax)
            message.warning('%s: illegal counter seed: %s' % (syntax,seed))
                message.warning('%s: illegal counter value: %s'
            message.warning('skipped %s: undefined attribute in: %s' % (name,args))
            message.warning('skipping %s table: %s' % (self.name,self.check_msg))
                message.warning('%s: non-zero exit status' % syntax)
                    message.warning('[%s] \'%s\' style not in %s' % (
                    message.warning('[%s] table definition: %s' % (b.name,b.check_msg))
            message.warning('[%s] table is empty' % self.name)
            message.warning('%s: template does not exist' % syntax)
                message.warning('table row %d: does not span all columns' % (ri+1))
                message.warning('table row %d: empty spanned row' % (ri+1))
                message.warning('table row %d: exceeds columns span' % (ri+1))
        message.warning('tag \'%s\' dropped: contains undefined attribute' % tag)
                message.warning('[titles] entry has no <title> group')
                    message.warning('to many manpage names')
                    message.warning('unable to delete missing macro: %s' % m.pattern)
    """Methods to process configuration files."""
        middlename = attrs.get('middlename','')
            middlename = middlename.replace('_',' ')
            middlename = mo.group('name2')
            middlename = None
MIN_PYTHON_VERSION = 2.4    # Require this version of Python or better.
        # [miscellaneous] section.
                    ('miscellaneous','subsnormal',d['subsnormal']))
                    ('miscellaneous','subsverbatim',d['subsverbatim']))
        # [miscellanous] entries are dumped as part of the [attributes].
        missing = tags.difference(self.tag.keys())
        # Mix in document attribute list.
            m.load(entry)
            m = Macro()
        m = Macro()
    # Modified to use compiler.ast.List as this module has a List
                # mo.end() not good enough because '{x={y}}' matches '{x={y}'.
                          mo.group(3) and int(mo.group(3)))
            mo = macros.match('+',r'eval|sys|sys2',result)
            mo = macros.match('+',r'ifdef|ifndef|ifeval|endif',result)
        mo = macros.match('+',r'ifdef|ifndef|ifeval|endif',result)
            mo = macros.match('+',r'^include[1]?$',result)
            mo = macros.match('+',r'template',line)
                mo = m.reo.match(text)
        mo = None
            mo = re.match(AttributeEntry.pattern,line)
            mo = re.match(AttributeList.pattern, line)
            mo = re.match(BlockTitle.pattern,line)
                        mo = re.match(Header.RCS_ID_RE,s)
            mo = re.match(Header.RCS_ID_RE,s)
                            mo = re.match(Header.REV_LINE_RE,s)
                mo = re.match(pat,Title.attributes['title'])
            mo = re.match(r'^([<\^>])?(\.([<\^>]))?$', align_spec)
            mo = re.match(r'^(\d{1,2})%?$',v)
            mo = re.match(r'^(\d+)?(\.(\d+))?$', span_spec)
        mo = re.match(r'^(.*'+fc+r'+)([\d\.]+)$',ruler)
            mo = re.match(r'^listtags-(?P<name>\w+)$',section)
                mo = re.match(r'^pass:(?P<attrs>.*)\[(?P<value>.*)\]$', attr.value)
        mo = re.match(r'^(?P<attr>[^:]*?)(:(?P<seed>.*))?$', args)
        mo = re.match(r'^(?P<attr>[^:]*?)(:(?P<value>.*))?$', args)
        mo = re.match(r"^'(?P<cmd>[^']+)'(?P<tail>.*)$", filter_cmd)
    mo = re.match(r'^"(?P<cmd>[^"]+)"(?P<tail>.*)$', filter_cmd)
            mo = re.match(r'^(?P<cmd>\S+)(?P<tail>.*)$', filter_cmd)
                mo = re.match(r'^(?P<manname>.*?)\s+-\s+(?P<manpurpose>.*)$',s)
            mo = re.match(r'^(?P<mantitle>.*)\((?P<manvolnum>.*)\)$',
        mo = re.match(r'^(?P<name1>[^<>\s]+)'
        mo = re.match(r'^(?P<name>[^[]*)(\[(?P<subslist>.*)\])?$', name)
                mo = re.match(r'(?P<stag>.*)\|(?P<etag>.*)',s)
                mo = re.match(r'(?P<stag>.*)\|(?P<etag>.*)',v)
                mo = re.match(r'^(?P<style>.*)-style$',k)
            mo = re.match(r'^tabletags-(?P<name>\w+)$',section)
                mo = re.match(Title.dump_dict[k], lines[0])
            mo = re.match(Title.pattern, title)
                mo = reo1.match(col)
                    mo = reo2.match(col)
                mo = reo.search(line,pos)
            mo = reo.search(line,pos)
            mo = reo.search(text,pos)
        mo = re.search(r'(=)',entry)
        mo = re.search(r'(?:[^\\](=))',entry)
            mo = self.delimiter_reo.match(reader.read_next())
        m.pattern = self.SYS_RE
        m.prefix = '+'
        m.reo = re.compile(m.pattern)
                    m.section_name()
        msg = 'FAILED: '
            msg = 'illegal system attribute name: %s' % name
            msg = 'illegal system macro name: %s' % name
            msg = message.format('', msg)
            msg = message.format(name, 'TRACE: ', self.linenos, offset=self.offset)
                    msg += '\n<<<\n%s\n>>>\n%s\n' % (before,after)
                    msg += '\n%s\n' % before
        msg = self.format(msg, 'DEPRECATED: ', linenos)
            msg = self.format(msg,'ERROR: ',cursor=cursor)
            msg = self.format(msg,linenos=linenos)
        msg = self.format(msg,'WARNING: ',linenos,offset=offset)
        msg = '[%s] malformed entry %%s: %%s' % self.name
        # Multiple names (n1,n2,... or n1+n2+...) -- lower precedence.
        # [<multiplier>*][<align>][<width>][<style>]
        # [<multiplier>*][<width>][<align>][<style>]
                                'must be a single character: %s' % k
        n = 0
    n = 0
        n = 0; percents = 0; props = 0
                n += 1
            n += 1
                     'N': 1,   # Neutral (not East Asian, treated as narrow)
                     'Na': 1,  # Narrow
        name."""
    name2 = None
        # Name and add aguments '1','2'... to keywords.
    'name' and 'value'.
    (name::[args]).
    'name' can contain any printable characters.
        NameChar        ::=     Letter | Digit | '.' | '-' | '_' | ':'
                name = d['name']
        name = entry
            name = entry[:mo.start(1)]
                name =  mo.group('name')
                name = mo.group('name')
            name = mo.group('name')
        name = mo.group('name')
            name = name[:-1]
                name = name.replace(r'\=','=')  # Unescape \= in name.
        name = name.strip()
    name = None
        name_re = document.attributes.get('trace')
            name_re = '|'.join(self.SUBS_NAMES)
NAME_RE = r'(?u)[^\W\d][-\w]*'  # Valid section or attribute name.
                name = self.name
            name = self.name
            name = self.short_name()+' block'
        names = [firstname,middlename,lastname,author,initials]
            names[i] = v
                # Names like name! undefine the attribute.
        names = self.styles.keys()
        names.sort()
                    names = [s.strip() for s in name.split(sep) if s.strip() ]
                names = [s.strip() for s in self.attributes['manname'].split(',')]
            # Names that don't match the formal specification.
        name = strip_quotes(name)
            name,wordlist = e
# Naming convention is an _OLD name suffix.
                               # narrow otherwise, but that doesn't work)
        NCNameChar      ::=     NameChar - ':'
        NCName          ::=     NCNameStartChar NCNameChar*
        NCNameStartChar ::=     Letter | '_'
        # Nested attributes not allowed.
            next = Lex.next()
        next = Lex.next()
        next search for section title in [specialsections],
                    # Next test for backward compatibility.
                next.translate()
            next.translate()
            node_or_string = compiler.parse(node_or_string, mode='eval')
            node_or_string = node_or_string.node
            # No errors.
    non-blank item in 'lines1' with the first non-blank item in 'lines2' into a
    'none','replacements2')
    # Non-template section name regexp's.
            # Non-word (\W) characters are allowed at boundaries to accomodate
            # Normal attribute.
    NOTE: The include1 attribute is used internally by the include1::[] macro
        not safe()
            # ('\n').  This is really only useful when the table format is csv
            n = Title.section_numbers[l]
        number = ''
                number = '%s%d.' % (number, n)
                number = '%s%d.' % (number, n + 1)
    NUMBER_STYLES= ('arabic','loweralpha','upperalpha','lowerroman',
            o = '-a'
                o = '--backend'
        object or list of regular expression objects. If same_file is True then
                obj[k] = v
    only."""
            # Only the macro pattern was specified, mark for deletion.
        # Open input file and parse document header.
                op = mo.groupdict().get('op')
                op = mo.group('op')
        op = None
            op = op or '+'
        # Optimization: Cache answer.
        # Optimization: If we've already checked for an element at this
        Optional params array of additional parameters.
                options = ()
    options = []
            options.append('-c')
            options.append('-e')
            options.append('-s')
            options.append('-v')
                options = config.subsnormal
                options = config.subsverbatim
        options = doctest.NORMALIZE_WHITESPACE + doctest.ELLIPSIS
        options = Lex.canonical_subs(options)
                        options = parse_options(d['options'], (),
                options = parse_options(d['options'], (), 'illegal option name')
        options = self.parameters.options
            options = ('specialcharacters',)
    opt_names = [opt[0] for opt in opts]
       >>> opts = []
    opts and args conform to values returned by getopt.getopt().
       >>> opts.append(('--attribute','author=Joe Bloggs'))
       >>> opts.append(('--backend','html4'))
       >>> opts.append(('--no-header-footer',None))
       >>> opts.append(('--out-file',outfile))
        opts,args = getopt.getopt(sys.argv[1:],
            # or an attribute entry.
OR, AND = ',', '+'              # Attribute list separators.
        order) on sequence of 'lines'."""
            ordinal = int(index)
            ordinal = ord(index) - ord('a') + 1
            ordinal = roman_to_int(index)
            ordinal = self.calc_index(self.index,style)
        or file_in(fname, APP_DIR)
        or file_in(fname, CONF_DIR)
        or file_in(fname, directory)
    or None if illegal entry.
                    or (ul_len-3 < char_len(title) < ul_len+3)):
        os.close(fd)
                    os.close(fh)
                    os.makedirs(directory)
            os.makedirs(plugin_dir)
                        os.path.basename(self.infile))[0]
                            os.path.basename(self.outfile))[0]
                os.remove(tmp)
            os.unlink(outfile)
                    os.write(fh, zipo.read(zi.filename))
        # Other.
    outfile = None
            outfile = os.path.abspath(outfile)
                outfile = os.path.join(directory, outfile)
            outfile = os.path.splitext(infile)[0] + '.' + document.backend
                outfile = os.path.splitext(outfile)[0] + config.outfilesuffix
                outfile = '<stdout>'
            outfile = '<stdout>'
       >>> outfile = StringIO.StringIO()
            outfile = v
            outfile = zi.filename
# output.
        output = p.communicate(os.linesep.join(lines))[0]
    output. There is a single global instance of this class named trace.
        # Override config and style attributes with attribute list attributes.
    pairs. Values must preceed keywords and are named '1','2'... The entire
        paragraphs.dump()
        paragraphs.initialize()
        paragraphs.load(sections)
paragraphs = Paragraphs()   # Paragraph definitions.
        paragraphs.validate()
                para = Lex.subs_1(para,(o,))
            para = macros.extract_passthroughs(para)
            para = macros.restore_passthroughs(para)
        params = list(self.PARAM_NAMES) + params
                para = '\n'.join(lines)
        para = '\n'.join(lines)
                parent = Reader1()
            # Parse and validate passthrough subs.
        Parse AsciiDoc cell alignment specifier and return 2-tuple with
        Parse AsciiDoc cell span specifier and return 2-tuple with horizonatal
                    parse_attributes(d['attrlist'],d)
                parse_attributes(mo.group('attrlist'), attrlist)
                parse_attributes(mo.group('attrlist'),attrs)
                        parse_attributes(v, attrs)
    """Parse comma separated string of Python literals. Return a tuple of of
    """Parse comma separated string of unquoted option names and return as a
            parsed_cells = self.parse_psv_dsv(text)
    parsed values."""
        parse_entries(sections.get('attributes',()), d, unquote=True,
                parse_entries(sections.get(k,()),d)
        parse_entries(sections.get('miscellaneous',()), d, unquote=True,
        parse_entries(sections.get('quotes',()),self.quotes)
                parse_entries(sections.get(section,()),d)
        parse_entries(sections.get('specialcharacters',()),self.specialchars,escape_delimiter=False)
        parse_entries(sections.get('titles',()),d)
        parse_entries(self.sections.get(sect,()), d, unquote=True)
        parse_entries(self.sections.get('specialsections',()),d,unquote=True)
        parse_entries(self.sections.get('tags',()),d)
    # Parse for quoted and unquoted command and command tail.
                # Parse include macro attributes.
        Parse list of PSV or DSV table source text lines and return a list of
            # Parse macro attributes.
    """Parse name=value entries from  from lines of text in 'entries' into
    """Parse name=value entry to dictionary 'dict'. Return tuple (name,value)
        # Parse passthrough subslist.
        Parse processing parameters from src dictionary to dst object.
        """Parse replacements section into self.replacements dictionary."""
        """Parse rows list using the row and data tags. Returns a substituted
        """Parse ruler calculating underline and ruler column widths."""
        Parses header, sets corresponding document attributes and finalizes
        """Parse specialsections section to self.specialsections dictionary."""
        """Parse special words section into self.specialwords dictionary."""
        # Parse table ruler.
        """Parse [tags] section entries into self.tags dictionary."""
        """Parse the list of source table rows. Each row item in the returned
        Parse the table source text and return a list of rows, each row
        Parse the table source text into self.rows (a list of rows, each row
        """Parse the Title.attributes and Title.level from the reader. The
        """Parse title at start of lines tuple."""
        pass
            pass
                pass
        passed on the command-line, None if no command-line option was not
        passed then merge with document attributes and perform attribute
    pass # No compiler
            passtext = d['passtext']
            passtext = Lex.subs_1(passtext,subslist)
                passtext = passtext.replace('\\]',']')
            # Passthrough macros don't have this problem.
            passthroughs.append(passtext)
        passthroughs list."""
            pat = document.attributes.get('attributeentry-pattern')
            pat = entries['blocktitle']
                pat = entries[k]
            pat = entries['sectiontitle']
            pat = strip_quotes(pat)
        pat = strip_quotes(pat)
        pattern, name = e
    pattern = None
        pcunits = percents > 0
        pcwidth = 100.0
                    pcwidth = float(v[:-1])
        percents = 0
            percents += col.pcwidth
                        percents += width
    # Perform attributes substitution on the filter command.
    """Perform attribute substitution and split tag string returning start, end
                # Perform attribute substitution on include macro file name.
        """Perform attribute substitution on 'section' using document
        """Perform inline processing specified by 'options' (in 'options'
        """Perform reverse special character substitution on string 's'."""
        """Perform special character substitution on string 's'."""
        """Perform substitution specified in 'options' (in 'options' order)."""
        # Perform title substitutions.
        Perform title substitutions.
                perms = (zi.external_attr >> 16) & 0777
       <p>Hello <strong>Joe Bloggs</strong></p>
        placeholders."""
        plugin_dir = os.path.join(d, plugin_name)
        plugin_dir = os.path.join(plugins_dir, plugin_name)
        plugin_name = args[0]
        plugin_name = reo.group()
            plugin = o[2:]
            plugins_dir = args[1]
            plugins_dir = Plugin.get_dir()
        plugin_source = args[1]
                    % (Plugin.type, ' '.join(args)))
        Plugin.type = plugin
                    % (Plugin.type, zip_file))
            pos = 0
        pos = 0
        posattrs = self.posattrs
                             'posattrs','style','.*-style','template','filter')
                        posattrs = v
            # Positional attribute style has highest precedence.
        # position return the element.
                pos = mo.end()
                pos = mo.start() + 1
                pos = mo.start() + len(s)
        # Postpone title subs until backend conf files have been loaded.
        postsubs = self.get_param('postsubs',params)
                postsubs = self.parameters.postsubs
        postsubs = self.parameters.postsubs
        pre and post | placeholder tags. 'skipstart' and 'skipend' are
        # Prefill buffer by reading the first line and then pushing it back.
            prefix = ''
    PREFIX = 'blockdef-'
    PREFIX = ''         # Conf file section name prefix set in derived classes.
    PREFIX = 'listdef-'
            prefix, name = name[0], name[1:]
    PREFIX = 'old_tabledef-'
    PREFIX = 'paradef-'
        prefix.  Return None section not found."""
            prefix += '%s: line %d: ' % (os.path.basename(cursor[0]),cursor[1]+offset)
    PREFIX = 'tabledef-'
        # Prefix the ID name with idprefix attribute or underscore if not
            presubs,postsubs = self.get_subs(colstyle)
        presubs = self.get_param('presubs',params)
                presubs = self.parameters.presubs
        presubs = self.parameters.presubs
    prev_cursor = None
    prev_element = None
        prev_sectname = Title.sectname
                prevwidth = 1
                prevwidth = c.rulerwidth
            print('asciidoc %s' % VERSION)
            print >>f, line
    """Print help topic to file object f."""
        print msg
       >>> print outfile.getvalue()
    # Print [topic] section from help file.
        Print trace message if tracing is on and the trace 'name' matches the
        problematic. Use the predefined {amp},{lt},{gt} attributes instead."""
                        # Process AND name expression: n1+n2+...
    # Process command line options.
        # Process document header.
    """Processes Header and Section titles. Static methods and attributes
        # Process explicit and implicit list item continuations.
            # Process first header line after the title that is not a comment
                # Process included file.
                    # process it before continuing with the current parsed
        # Process list till list syntax changes or there is a new title.
                        # Process OR name expression: n1,n2,...
        # Process remaining sections.
                    # Process second header line after the title that is not a
    PROG = os.path.basename(os.path.splitext(__file__)[0])
# Program constants.
        # Propagate defaults to unspecified table parameters.
                        props += width
        p = subprocess.Popen(filter_cmd, shell=True,
        psv=r'((?<!\S)((?P<span>[\d.]+)(?P<op>[*+]))?(?P<align>[<\^>.]{,3})?(?P<style>[a-z])?)?\|'
                ptag = tags.paragraph
        """Push the line (filename,linenumber,linetext) tuple back into the read
        putback = []
                putback.append(self.cursor)
        # Put the {title} back.
    Python Cookbook: Ordered Dictionary, Submitter: David Benjamin.
    """Quoted text is marked up and the resulting text is
        # Quote if necessary.
                + r')+' \
        raise
                raise AssertionError,'illegal [%s] list type' % self.name
        raise AssertionError,'no class instances allowed'
            raise EAsciiDoc, \
                raise EAsciiDoc,'closing [%s] underline expected' % self.name
            raise EAsciiDoc,'closing [%s] underline expected' % self.name
                raise EAsciiDoc,'configuration file asciidoc.conf missing'
            raise EAsciiDoc,'csv parse error: %s' % row
                    raise EAsciiDoc,errmsg
                raise EAsciiDoc,errmsg
                            raise EAsciiDoc,'error evaluating ifeval condition: %s: %s' % (result, str(e))
        raise EAsciiDoc,'filter error: %s: %s' % (filter_cmd, sys.exc_info()[1])
                        raise EAsciiDoc,'ifeval invalid safe document'
            raise EAsciiDoc,'illegal attribute name: %s' % k
            raise EAsciiDoc,'illegal document type'
                        raise EAsciiDoc, 'illegal include macro depth argument'
                        raise EAsciiDoc, 'illegal include macro tabsize argument'
            raise EAsciiDoc,'illegal macro regular expression: %s' % e[0]
                raise EAsciiDoc, 'illegal [miscellaneous] pagewidth entry'
                    raise EAsciiDoc, 'illegal [miscellaneous] %s entry' % name
            raise EAsciiDoc,'illegal section name in macro entry: %s' % entry
                raise EAsciiDoc,'illegal special word name: %s' % macro
                    raise EAsciiDoc, 'illegal [%s] %s: %s' % (self.name,k,v)
                raise EAsciiDoc, 'illegal style name: %s' % self.style
                raise EAsciiDoc,'illegal substitution option: %s' % o
                    raise EAsciiDoc,'illegal table format: %s' % v
            raise EAsciiDoc,'incomplete configuration files'
                raise EAsciiDoc,'input file %s missing' % infile
            raise EAsciiDoc,'malformed dsv separator: %s' % separator
        raise EAsciiDoc,'malformed list: '+s
                        raise EAsciiDoc, 'malformed ruler: bad width'
                    raise EAsciiDoc,'malformed ruler: illegal fillchars'
            raise EAsciiDoc,'malformed section entry: %s' % entry
                    raise EAsciiDoc,'malformed table fillchar: %s' % v
        raise EAsciiDoc,'malformed tag: %s' % tag
                raise EAsciiDoc,'malformed [titles] blocktitle entry'
                raise EAsciiDoc,'malformed [titles] sectiontitle entry'
                    raise EAsciiDoc,'malformed [titles] %s entry' % k
                            raise EAsciiDoc,'mismatched macro: %s' % result
                        raise EAsciiDoc,'mismatched macro: %s' % result
                raise EAsciiDoc,'missing backend conf file: %s' % f
                    raise EAsciiDoc,'missing configuration file: %s' % f
            raise EAsciiDoc,'missing endif::%s[]' % self.skipname
                raise EAsciiDoc,'missing filter: %s' % f
                            raise EAsciiDoc,'missing ifeval condition: %s' % result
                        raise EAsciiDoc,'missing ifeval condition: %s' % result
                            raise EAsciiDoc,'missing macro target: %s' % result
                    raise EAsciiDoc,'missing macro target: %s' % result
            raise EAsciiDoc,'missing section: [OLD_tabledef-default]'
            raise EAsciiDoc,'missing section: [paradef-default]'
            raise EAsciiDoc,'missing section: [tabledef-default]'
            raise EAsciiDoc,'missing section: [tabletags-default]'
        raise EAsciiDoc,'missing special word template [%s]' % template
            raise EAsciiDoc,'missing table rows'
                raise EAsciiDoc,'missing [tabletags-default] entry: %s' % tag
            raise EAsciiDoc, 'missing tag: %s' % name
                        raise EAsciiDoc, msg % (k,v)
                    raise EAsciiDoc, msg % (k,v)
                raise EAsciiDoc, msg % (k,v)
                raise EAsciiDoc,'paragraph expected'
                raise EAsciiDoc,'section title expected'
            raise EAsciiDoc, self.format(msg,linenos=False,cursor=cursor)
                raise EAsciiDoc,'[%s] entry in %s is not a valid' \
                raise EAsciiDoc,'[%s] illegal type' % b.name
            raise EAsciiDoc,'[%s] missing delimiter' % self.name
                raise EAsciiDoc,'[%s] missing or illegal fillchar' % b.name
                raise EAsciiDoc,'[specialcharacters] ' \
                raise EAsciiDoc,'[specialsections] entry ' \
                        raise EAsciiDoc,'[specialwords] entry in %s ' \
                raise EAsciiDoc,'[specialwords] entry in %s is malformed: %s' \
                raise EAsciiDoc,'[specialwords] name in %s is illegal: %s' \
                raise EAsciiDoc,'%s: %s' % (errmsg,s)
                    raise EAsciiDoc,'[%s] %s' % (k,str(e))
                raise EAsciiDoc,'%s: temp file read error' % syntax
            raise EAsciiDoc,str(e)
                    raise EAsciiDoc,'[tag] %s value malformed' % k
            raise EAsciiDoc,'zero width table'
                raise Exception
            raise KeyError('dictionary is empty')
    Raises SystemExit if an error occurs.
            raise ValueError('malformed string')
                            raise ValueError, 'not > 0'
                            raise ValueError, "not >= 0"
                        raise ValueError, "not > 0"
                            raise ValueError, "not >= 1"
            raise ValueError,'src must specify directory or file: %s' % src
    RCS_ID_RE = r'^\$Id: \S+ (?P<revnumber>\S+) (?P<revdate>\S+) \S+ (?P<author>\S+) (\S+ )?\$$'
        rdr.close()
        rdr = csv.reader(StringIO.StringIO('\r\n'.join(rows)),
        rdr = csv.reader(StringIO.StringIO('\r\n'.join(text)),
                + r'(\d*|' + re.escape(b.fillchar) + r'*)' \
        rdr.open(fname)
        rdr = Reader()  # Reader processes system macros.
    READ_BUFFER_MIN = 10        # Read buffer low level.
        Reader1.__init__(self)
                reader.closefile()
        reader is assumed to be at the first line following a previous element,
        reader.open(infile)
            reader.read()
                reader.read()   # Discard (already parsed item first line).
            reader.read()   # Discard (already parsed item first line).
        reader.read()   # Discard (already parsed item first line).
        reader.read()            # Discard attribute entry from reader.
        reader.read()   # Discard attribute list from reader.
        reader.read()   # Discard delimiter.
        reader.read()   # Discard title from reader.
reader = Reader()           # Input stream line reader.
        reader.read_until(r'\s*\S+')
            reader.read_until(self.delimiter,same_file=True)
        reader.skip_blank_lines()
        reader.tabsize = config.tabsize
        """Read next line. Return None if EOF. Expand tabs. Strip trailing
        # Read the entire table.
        real work has already been done by parse()."""
                re.compile(AttributeList.pattern),
                re.compile(blocks.delimiters),
                re.compile(lists.delimiters),
                re.compile(r'^\+$|^$'),
            re.compile(r'(?su)\{(?P<action>eval):(?P<expr>.*?)\}(?!\\)'),
            re.compile(r'(?su)\{(?P<action>[^\\\W][-\w]*?):(?P<expr>.*?)\}(?!\\)'),
                re.compile(tables.delimiters),
                re.compile(tables_OLD.delimiters),
                + re.escape(b.fillchar) + r'+' \
                    ' regular expression: %s' % (sect,self.fname,pat)
        remaining add them to self.attributes (existing attribute list entries
                            re_mo = re.match('^'+v[0]+'$',lval)
            # Remove backslash from escaped entries.
    removed before the parsed entry is added."""
        # Remove numbered document attributes so they don't clash with
        reo1 = re.compile(COLS_RE1)
        reo1 = re.compile(r'(?su)\{(?P<name>[^\\\W][-\w]*?)' \
        reo2 = re.compile(COLS_RE2)
        reo2 = re.compile(r'(?su)\{(?P<name>[^\\\W][-\w'+OR+AND+r']*?)' \
        reo = re.compile(r"^'.*'$")
            reo = re.compile(r'(?msu)(^|.)(\[(?P<attrlist>[^[\]]+?)\])?' \
            reo = re.compile(r'(?msu)(^|[^\w;:}])(\[(?P<attrlist>[^[\]]+?)\])?' \
        reo = re.compile(r'(?:\s|^)(".+?"|[^"\s]+)(?=\s|$)')
        reo = re.compile(r'(?su)\{(?P<name>[^\\\W][-\w]*?)\}(?!\\)')
        reo = re.compile(r'(?u)^\[(?P<section>\+?[^\W\d][\w-]*)\]\s*$')
        reo = re.compile(self.underline)
        reo = re.match(r'^\w+',os.path.split(zip_file)[1])
        reos = [
    # Replace line separators with spaces so line spanning works.
        """ Replace macro attribute lists in text with placeholders.
                  'replacements2')
                  'replacements', 'attributes','macros','callouts',
    'replacements', 'attributes','macros','callouts','normal','verbatim',
            replacements[pat] = strip_quotes(rep)
        # Replace non-alpha numeric characters in title with underscores and
        """ Replace passthough placeholders with the original passthrough
                                            #replace pattern.
                        # Replace section.
                # Replace section.
        # Report empty sections if invalid markup will result.
        Report fatal error.
        reserved = {}  # Reserved cells generated by rowspans.
                                reserved[ri+j] = {}
                            reserved[ri+j][ci] = cell.clone_reserve()
        # Reset instance specific properties.
                # Reset unprocessed section levels.
                result = ''
            result = ''
            result = (
            result = []
        result = ''
        result = []
    result = []
            result = 0
                result = '1'
        result = AbstractBlock.isnext(self)
            result.append(APP_DIR)
            result.append(CONF_DIR)
                result.append('    '+data)
            result.append(data)
            result.append('  '+etag)
            result.append(etag)
                result.append(f)
                    result.append(line)
                result.append(line)
            result.append(line)
    result.append(lines1[-1] + lines2[0])
        result.append(re.sub(r'\?P<\S+?>','',s))
                result.append(row)
            result.append(s)
        result.append(s)
                result.append(self.read())
            result.append(self.read())
            result.append(s+line)
            result.append('  '+stag)
            result.append(stag)
            result.append(USER_DIR)
            result = AttributeEntry
            result = AttributeList
            result = blocks.current
            result = BlockTitle
                result = body[0]
        result = char_encode(result.decode(locale.getdefaultlocale()[1]))
                result = config.subs_replacements(result,o)
                result = config.subs_specialchars(result)
                result = config.subs_specialwords(result)
        result = copy.copy(self)
                    result -= digit
                    result += digit
            result = eval(args)
        result = False
        result = False  # Assume not next.
                result = FloatingTitle
    result = ')|('.join(result)
        result = lines[0]
    result = list(lines1[:-1])
    result += list(lines2[1:])
            result = lists.current
            result = macros.current
                result = macros.subs(result)
                result = macros.subs(result,callouts=True)
                result = (mo.group(1) and int(mo.group(1)),
                    result = m.subs(result)
                    result = '\n'.join(body)
            result = '\n'.join(result)
                result = None
            result = None
        result = None
    result = None
        result = (None, None)
    result = os.path.expanduser('~')
        result = os.path.join(dir,'filters',filter)
            result = os.path.join(dir,'filters',name,filter)
            result = os.path.join(result, '.asciidoc', Plugin.type+'s')
            result = paragraphs.current
                result = Reader1.read(self)
        result = Reader1.read(self,self.skip)
        result.reserved = True
            result = re.sub(pat, rep, result)
            result = re.sub(word, _subs_specialwords, result)
    result = '('+result+')'
                result = result[1:]
            result = result + 1
            result = result + dovetail_tags([stag],data,[etag])
                result = result.expandtabs(reader.tabsize)
                result = result.replace(chr(0), a0)
            result = result.replace(v, k)
            result = result + self.specialchars.get(ch,ch)
            result = result + [stag] + Lex.subs(d,subs) + [etag]
                    result = s
        result = s
                result = seed
                result += ' ' + self.calloutid(self.listnumber,coindex)
            result = self.cursor[2]
                    result += self.expand_templates(self.sections[s])
            result = self.read()
        result = self.read()
            result = self.read_super()
        result = self.read_super()
            result += self.subs_row(row,rowtype)
        result = separator.join(config.include1[args])
            result = separator.join(lines)
                result = separator.join(result)
            result = [s.rstrip() for s in open(args)]
        result = [s.rstrip() for s in output.split(os.linesep)]
    result = s.split('|')
        result = start
        result = s + ' ' + time.tzname[0]
        result = s + ' ' + time.tzname[1]
                result = str(eval(expr))
                result = str(result)
                result = subs_attrs(result)
                result = subs_quotes(result)
                result = (Table.ALIGN.get(mo.group(1)),
            result = tables.current
            result = tables_OLD.current
        result = text
                result = Title
                    result = True
                result = True
        result = tuple(parse_to_list(s))
        result = userdir()
        result.vspan = 1
                    result = writer.newline.join(body)
        result = writer.newline.join(lines)
        result = '\x07' + str(len(macros.passthroughs)-1) + '\x07'
                resv = reserved.get(ri) and reserved[ri].get(ci)
        # Retieve list of callout indexes that refer to listindex.
                                # retrieval by the {include1:} system attribute.
        return
            return
                return
                    return ''
                return ''
            return ''
            return ()
        return []
    return (
        return AbstractBlock.isnext(self)
        """Return a clone of self to reserve vertically spanned cell."""
    """Return a list in which lines terminated with the backslash line
    return a string.
        Return a string of output markup from a list of rows, each row
        return '<AttrDict ' + dict.__repr__(self) + '>'
        return AttributeList.attrs.get('style') or AttributeList.attrs.get('1')
        """Return a two item tuple containing a list of lines up to but not
        return '<Cell: %d.%d %s.%s %s "%s">' % (
        return cells
        return 'CO%d-%d' % (listnumber,calloutindex)
                return -_convert(node.expr)
        return _convert(node_or_string)
        return count != 0
                return d
        return d
        return dic.get(attrs.strip()) is not None
                return dict((_convert(k), _convert(v)) for k, v
        return dict.__getitem__(self, key.lower())
        return dict.get(self, key.lower(), default)
        return dict.has_key(self,key.lower())
        return dict(self)
        return dict.setdefault(self, key.lower(), default)
    return document.safe
    return dovetail(dovetail(stag,content), etag)
    returned."""
        Return empty list if not found in any of the locations.
    return encoding
                return False
            return False
        return False
        Return False if no file was found in any of the locations.
        Return False if no file was sucessfully loaded.
        """ Return False if the author is malformed."""
    Return file name which must reside in the parent file directory.
        # Return first (oldest) buffer entry.
    return fname
        """Return formatted message string."""
        return has_header
                return ident
            return  # If there's a syntax error leave with {0}=attrs.
                            return '{include1:%s}' % fname
        """Return index following end brace that matches brace at start in
    # Return input lines if there's not filter.
    return isinstance(obj,list) or isinstance(obj,tuple)
        return (join_lines_OLD(rows[:i]), rows[i+1:])
        return (key, val)
        return keywords
    return len(char_decode(s))
        return len(text)
            return Lex.prev_element
            return lines
        return lines
        return list(lines1) + list(lines2)
                return list(map(_convert, node.nodes))
        Return list of found file paths.
        Return list of well known paths with conf files.
    Return list with empty items from end of list removed.
    Return list with empty items from start and end of list removed.
    Return list with empty items from start of list removed.
        return [literal_eval(v) for v in values]
        return loaded
                        return m
        """Return macro markup template section name based on macro name and
        return map(self.get, self._keys)
        """Return matching macro if block macro is next on reader."""
                        return mo
                return mo.group()
        return mo.group()[1:]   # Return escaped word.
                return mo.group()[1:]   # Strip leading backslash.
        Return named processing parameter from params dictionary.
            return name+suffix
    return name,value
        """Return next section number at section 'level' formatted like
            return '\n'.join(result)
                 return node.value
                return None
            return None
        return None
        Return None if directory not found.
    Return None if file is not safe.
        Return None if unrecognized style."""
        return [None,None]
           return not safe()
        return number
        return options
        return ordinal
    return os.path.commonprefix((directory, fname)) == directory
    return os.path.isfile(os.path.join(APP_DIR, 'asciidoc.conf'))
            return params[name]
        return para.splitlines()
        Return path of configuration directory.
        Return plugins path (.asciidoc/filters or .asciidoc/themes) in user's
        return prefix + msg
        return (presubs,postsubs)
        Return (presubs,postsubs) tuple.
                return Reader1.eof(self)
                        return Reader1.read(self)   # Return next input line.
                    return Reader1.read(self)   # Return next input line.
        """Return re match object matching 'text' with macro type 'prefix',
    return re.match(r'^'+NAME_RE+r'$',s) is not None
    return re.sub(r'(?u)[^\w\-_]', '', s).lower()
                            return result
                    return result
                return result
            return result
        return result
    return result
        return (result[0] or 1, result[1] or 1)
        return result+[None]
            return result.strip()
        return rows
            return s
        return s
    return s
                    return _safe_names[node.name]
        Returns a list of marked up table cell elements.
        Returns a substituted list of output table data items."""
        """Returns class of next element on the input (None if EOF).  The
            return s.decode(char_encoding())
        return self.attributes.get('backend')
        return self.attributes.get('doctype')
        return self.calloutid(self.listnumber, self.calloutindex)
        return self._keys
            return self.name
            return self.name[i+1:]
            return self.next[0][2]
            return self.parameters[name]
        return self.pattern.find(r'(?P<passtext>') >= 0
        return self.read_next() is None
        return self.reo.sub(subs_func, text)
                return self.styles[name]
        return s.encode(char_encoding())
    Returns False if invalid syntax.
        Returns False if the document does not have a header.
    return s[i:]
    return s[:i+1]
        """Returns (starttag,endtag) tuple named name from configuration file
        return (stag,etag)
        """Returns True if all lines have been read."""
        Returns True if one or more attributes or comments were consumed.
        return style
            return subs_attrs(self.sections[section],d)
        return tables.tags[tags]
        return text
    return text
        """Return the numbered list style ('arabic'...) of the list item index.
        """Return the ordinal number of (1...) of the list item index
        Return the style dictionary whose name starts with 'prefix'.
        """ Return the text following the last dash in the section name."""
    return time.strftime('%Y-%m-%d',t)
        return title
        return Title.isnext() and AttributeList.style() == 'float'
        return Title.parse(lines)
                return True
                return True;
            return True
        return True
        Return True if a backend conf file was found.
        Return True if conf file section contains entries, not a markup
    """Return True if file fname resides inside directory."""
    Return True if object is list or tuple type.
        """Return True if param matches an allowed configuration file entry
    """Return True if s is a valid regular expression else return False."""
    """Return True if s is valid attribute, macro or tag name
    Return True if we are not executing the system wide version
        """Return tuple containing count lines."""
                return tuple(map(_convert, node.nodes))
                        return tuple(result)
        return tuple(result)
    return tuple(result)
    Return user's home directory or None if it is not defined.
        return width
        return writer.newline.join(result)
        return zip(self._keys, self.values())
            revdate = mo.group('revdate')
                # Revert to default value.
                # Revision remarks can continue on following lines.
    REV_LINE_RE = r'^(\D*(?P<revnumber>.*?),)?(?P<revdate>.*?)(:\s*(?P<revremark>.*))?$'
            revnumber = mo.group('revnumber')
                    revremark.append(reader.read())
                revremark = Lex.subs(revremark,['normal'])
            revremark = mo.groupdict().get('revremark')
                revremark = '\n'.join(revremark).strip()
                revremark = [revremark]
            ri = 0  # Current row index 0..
                    ri += 1
            r'old_tabledef-.+')
            roman = roman.lower()
                    row = []
            row = []
                    row.append(cell)
            row = char_decode(row)
            row = literal_eval('"'+row.replace('"','\\"')+'"')
        rows = []
                rows.append([Cell(data) for data in row])
            row_span = 0
                row_span += cell.span
            rows = self.parse_csv(rows)
            rows = self.parse_dsv(rows)
            rows = self.parse_fixed(rows)
            r'paradef-.+',r'listdef-.+',r'blockdef-.+',r'tabledef-.+',
             r'(\[(?P<attrlist>.*?)\])$'
                    + r'(?P<content>.+?)(?:'+re.escape(rq)+r')')
                + r'(?P<content>\S|\S.*?\S)(?:'+re.escape(rq)+r')(?=\W|$)')
                          r'(?P<op>\=|\?|!|#|%|@|\$)' \
                          r'(?P<value>.*?)\}(?!\\)')
            rq = q[i+1:]    # Right quote.
                    + r'(?:' + re.escape(lq) + r')' \
                + r'(?:' + re.escape(lq) + r')' \
            r'tabletags-.+',r'listtags-.+','replacements2',
            rtag = tags.bodyrow
            rtag = tags.footrow
            rtag = tags.headrow
            # Ruler is:
            ruler = mo.group(1)
        ruler = reader.read()
    Run 'lines' through the 'filter_cmd' shell command and return the result.
        # Run module doctests.
                rval = line[mo.start('value'):end-1]
                                        s = ''
                            s = ''
                s = ''
            s = ''
    s = ''
        Safely evaluate an expression node or a string containing a Python
        _safe_names = {'None': None, 'True': True, 'False': False}
        """Same as read_lines() but does not advance the file pointer."""
        # same if the source file is in the application directory).
            s =  attrs.get(mo.group('name'))
        s = attrs.get('revnumber')
            save_cursor = self.cursor
        save_cursor = self.cursor
        """Save section end."""
                "'%s' codec can't decode \"%s\"" % (char_encoding(), s)
        """Search for word patterns from self.specialwords in 's' and
            # Search in the normal locations.
                section = {}
        """Section attribute substitution using attributes from
                    section[attr.name] = [attr.name2]
                   section[attr.name] = ['%s=%s' % (attr.name2,attr.value)]
        section,contents = '',[]
        Section.endtags.append((level,etag))
                # Section entry attribute.
                section = found[0].lower()
                Section.ids.append(ident)
                                (section,k))
    section 'name'."""
            section_name = self.section_name(name)
    section_numbers = [0]*len(underlines)
            'section-numbers','verbose','version','safe','unsafe',
        Section.savetag(Title.level,etag)
        Section.set_id()
        Section.setlevel(0) # Write remaining unwritten section close tags.
        Section.setlevel(Title.level)
        sections = OrderedDict()
                            sections[section] = contents
                            sections[section] += contents
                        sections[section] = contents
                        sections[section] += contents
            Section.translate()
                    Section.translate_body()
                Section.translate_body()
        Section.translate_body()
                Section.translate_body(self)
        sectname = AttributeList.attrs.get('1')
    sectname = None
        seed = mo.group('seed')
    # Select help file.
        self.abswidth = abswidth
        self.abswidth=None      # 1..   (page units).
        self.abswidth = None    # 1..   (page units).
                           self.attributes)
        self.attributes={}
        self.attributes = {}
            self.attributes['asciidoc-confdir'] = APP_DIR
            self.attributes['asciidoc-confdir'] = CONF_DIR
        self.attributes['asciidoc-dir'] = APP_DIR
        self.attributes['asciidoc-file'] = APP_FILE
        self.attributes['asciidoc-version'] = VERSION
        self.attributes['backend'] = backend
            self.attributes['bodyrows'] = '\x07bodyrows\x07'
        self.attributes['bodyrows'] = '\x07bodyrows\x07'
            self.attributes['coids'] = calloutmap.calloutids(self.ordinal)
                self.attributes['colabswidth'] = col.abswidth
            self.attributes['colabswidth'] = col.abswidth
                self.attributes['colalign'] = c.colalign
            self.attributes['colalign'] = c.colalign
        self.attributes['colcount'] = len(self.columns)
            self.attributes['colend'] = str(i+cell.span)
                self.attributes['colnumber'] = str(i)
                self.attributes['colnumber'] = str(i + 1)
            self.attributes['colnumber'] = str(i + 1)
            self.attributes['colnumber'] = str(i+1)
                self.attributes['colpcwidth'] = col.pcwidth
            self.attributes['colpcwidth'] = col.pcwidth
        self.attributes['cols'] = len(self.columns)
            self.attributes['colspan'] = str(cell.span)
            self.attributes['colspecs'] = writer.newline.join(cols)
            self.attributes['colstart'] = self.attributes['colnumber']
                self.attributes['colwidth'] = str(int(c.colwidth))
            self.attributes['colwidth'] = str(int(c.colwidth))
                self.attributes['docdate'] = date_str(t)
                self.attributes['docdir'] = os.path.dirname(self.infile)
                self.attributes['docfile'] = self.infile
                    self.attributes['docname'] = os.path.splitext(
                self.attributes['docname'] = os.path.splitext(
                self.attributes['doctime'] = time_str(t)
            self.attributes['doctitle'] = Title.dosubs(self.attributes['doctitle'])
        self.attributes['doctype'] = doctype
                self.attributes['filetype-'+ext] = ''
                self.attributes['filetype'] = ext
            self.attributes['footrows'] = '\x07footrows\x07'
            self.attributes['halign'] = cell.halign or col.halign
                self.attributes['halign'] = col.halign
            self.attributes['headrows'] = '\x07headrows\x07'
                self.attributes['indir'] = os.path.dirname(self.infile)
                self.attributes['infile'] = self.infile
        self.attributes = InsensitiveDict()
                self.attributes['itemwidth'] = str(100-labelwidth)
                        self.attributes[k] = v
                self.attributes['labelwidth'] = str(labelwidth)
            self.attributes['lang'] = lang  # Reinstate new lang attribute.
        self.attributes['localdate'] = date_str(t)
        self.attributes['localtime'] = time_str(t)
                    self.attributes['manname%d' % (i+1)] = name
                self.attributes['manname'] = mo.group('manname').strip()
                self.attributes['manpurpose'] = mo.group('manpurpose').strip()
            self.attributes['morerows'] = str(cell.vspan-1)
        self.attributes['newline'] = config.newline
                self.attributes[new] = self.attributes[old]
            self.attributes[old] = self.attributes[new]
                self.attributes['outdir'] = os.path.dirname(self.outfile)
                self.attributes['outfile'] = self.outfile
        self.attributes['pageunits'] = config.pageunits
        self.attributes['pagewidth'] = config.pagewidth
        self.attributes['rowcount'] = str(len(self.rows))
            self.attributes['rowspan'] = str(cell.vspan)
        self.attributes['rows'] = str(len(table))
                self.attributes['style'] = self.number_style = self.style
            self.attributes['style'] = self.style
                self.attributes['style'] = style
        self.attributes['tableabswidth'] = int(self.abswidth)
        self.attributes['tablepcwidth'] = int(self.pcwidth)
            self.attributes['tablewidth'] = '100.0'
            self.attributes['tablewidth'] = str(float(self.tablewidth))
            self.attributes.update(attrs)
        self.attributes.update(attrs)
        self.attributes.update(config.cmd_attrs)
        self.attributes['user-dir'] = USER_DIR
            self.attributes['valign'] = cell.valign or  col.valign
                self.attributes['valign'] = col.valign
            self.attributes['verbose'] = ''
                self.attributes[v] = self.attributes[str(i+1)]
            self.backend = backend
            self.backend = DEFAULT_BACKEND
            self.backend = self.backend # Translate alias in header.
                    self.blocks.append(b)
                self.blocks.append(b)
        self.blocks = []        # List of Block objects.
                self.blocks.remove(b)
        self.bodydata=None
                self.bodydata = v
        self.bodyrow=None
                self.bodyrow = v
        self.bom = None         # Byte order mark (BOM).
                self.bom = UTF8_BOM
        self.build_colspecs()
        self.calloutindex = 0
        self.calloutindex = 0   # Current callout index number.
        self.calloutindex += 1
                self.check_index()
            self.check_msg = ''
        self.check_msg=''       # Message set by previous self.validate() call.
            self.check_msg = 'missing bodydata entry'
            self.check_msg = 'missing bodyrow entry'
            self.check_msg = 'missing footdata entry'
            self.check_msg = 'missing footrow entry'
            self.check_msg = 'missing headdata entry'
            self.check_msg = 'missing headrow entry'
            self.check_msg = 'missing [miscellaneous] pageunits entry'
            self.check_msg = 'missing [miscellaneous] pagewidth entry'
            self.check_msg = 'missing [miscellaneous] textwidth entry'
        self.check_msg to blank string."""
        self.check_tags()
                self.closefile()
        self.closefile()
        self.cmd_attrs = {}     # Attributes from command-line -a options.
        self.colalign = None    # 'left','right','center'
        self.colspec=None
                self.colspec = v
        self.columns = []
                        self.columns.append(
            self.columns.append(c)
                self.columns.append(Column())
        self.columns=[]         # List of Columns.
        self.colwidth = None    # Output width in page units.
        self.comap = {}
        self.comap = {}         # key = list index, value = callouts list.
            self.comap[listindex].append(self.calloutindex)
            self.comap[listindex] = [self.calloutindex]
        self.conf_attrs = {}    # Attributes entries from conf files.
        self.CONF_ENTRIES = ('delimiter','options','subs','presubs','postsubs',
        self.CONF_ENTRIES += ('format','tags','separator')
        self.CONF_ENTRIES += ('template','fillchar','format','colspec',
        self.CONF_ENTRIES += ('type','tags')
            self.consume_attributes_and_comments()
        self.consume_attributes_and_comments()
                self.current = b
        self.current_depth = 0  # Current include depth.
                self.current_depth = self.current_depth + 1
                        self.current = m
        self.current=None
        self.current = None     # The last matched block macro.
                self.cursor[2] = self.cursor[2][len(UTF8_BOM):]
                    self.cursor[2] = s  # So we don't re-evaluate.
            self.cursor = None
        self.cursor = None      # Last read() [filename,linenumber,linetext].
                        self.cursor = save_cursor
            self.cursor = save_cursor
            self.cursor = self.next[0]
                self.data)
        self.data = data
                self.default = b
        self.default = None     # Default Block.
        self.delimiter=None # Regular expression matching block delimiter.
        self.delimiter_reo=None # Compiled delimiter.
                self.delimiter_reo = re.compile(self.delimiter)
        self.delimiters = None  # Combined delimiters regular expression.
        self.delimiters = re_join(delimiters)
        self.depth = 0          # if nesting depth.
                            self.depth += 1
                        self.depth += 1
                    self.depth -= 1
                    self.depth = self.depth+1
                self.depth = self.depth-1
            self.doctype = DEFAULT_DOCTYPE
            self.doctype = doctype
        self.dumping = False    # True if asciidoc -c option specified.
            self.error('csv parse error: %s' % row)
                self.error('illegal attribute value: width="%s"' % v)
                    self.error('illegal column spec: %s' % col,self.start)
                self.error('illegal csv separator=%s' % separator)
            self.error('illegal format=%s' % self.format,halt=True)
                self.error('illegal regular expression: separator=%s' %
                    self.error('illegal %s=%s' % (k,v))
                self.error('illegal table cell operator')
            self.error('missing closing delimiter',self.start)
                self.error('missing leading separator: %s' % separator,
            self.error('missing [miscellaneous] entry: pageunits')
            self.error('missing [miscellaneous] entry: pagewidth')
                self.error('missing section: [listtags-%s]' % t,halt=True)
                self.error('missing section: [tabletags-%s]' % t,halt=True)
            self.error('missing style: %s*' % prefix)
            self.error('missing tag(s): %s' % ','.join(missing), halt=True)
            self.error('mixed percent and proportional widths: %s'
            self.error('total width exceeds 100%%: %s' % cols,self.start)
            self.error('total width less than 100%%: %s' % cols,self.start)
        self.error('unsafe: '+msg)
            self.f.close()
        self.f.close()
        self.fillchar=None
                    self.fillchar = v
        self.filter=None    # filter entry.
        self.filters = []       # Filter names specified by --filter option.
        self.fname = fname
                    % (self.fname,line)
        self.fname = ''         # Most recently loaded configuration file name.
                    % (self.fname,name)
        self.fname = None       # Input file name.
        self.fname = None                # Output file name.
                            % (self.fname,word)
        self.f = None           # Input file object.
        self.f = None                    # Output file object.
        self.footdata=None
                self.footdata = v
        self.footrow=None
                self.footrow = v
            self.f = open(fname,'rb')
            self.f = open(fname,'wb+')
        self.format=None    # 'fixed','csv','dsv'
        self.format='psv'
                    self.format = v
                self.format = v
            self.f = sys.stdin
            self.f = sys.stdout
            self.f.write(bom)
            self.f.write((line or '') + self.newline)
                                   self.get_style(mo.group('style')))
                self.halign, self.valign,
        self.halign, self.valign = Table.parse_align_spec(align_spec)
        self.has_errors = False # Set true if processing errors were flagged.
        self.has_warnings = False # Set true if warnings were flagged.
        self.headdata=None
                self.headdata = v
        self.header_footer = True       # -s, --no-header-footer option.
        self.headrow=None
                self.headrow = v
        self.include1 = {}      # Holds include1::[] files for {include1:}.
        self.index=None     # Matched delimiter 'index' group (numbered lists).
            self.index = self.mo.groupdict().get('index')
            self.indir = None
        self.indir = None       # Saved document 'indir' attribute.
            self.indir = os.path.dirname(fname)
            self.infile = fname
            self.infile = None
        self.infile = None      # Saved document 'infile' attribute.
        self.infile = None      # Source file name.
        self.__init__()
            self.isnumeric = False
        self.isnumeric=False    # True if numeric ruler.
            self.isnumeric = True
        self._keys = []
        self._keys.remove(key)
        self[key] = value
            self[k] = v
        self.label=None     # List item label (labeled lists).
            self.label = self.mo.groupdict().get('label')
        self.level = 0          # 0 => front matter. 1,2,3 => sect1,2,3.
        self._lineno = 0            # The last line read from file object f.
        self._lineno = 0        # The last line read from file object f.
                    self._lineno = self._lineno + 1
                self._lineno = self._lineno + 1
        self.linenos = None
        self.linenos = True
        self.lines_out = 0
        self.lines_out = 0               # Number of lines written.
            self.lines_out = self.lines_out + 1
        self.listnumber += 1
        self.listnumber = 1     # Current callout list number.
            self.loaded.append(os.path.realpath(fname))
        self.loaded = []        # Loaded conf files.
                self.load_file(conf2,d)
            self.load_file(conf2,d)
                            self.load_file(f,dirpath)
        self.load_sections(sections,attrs)
        self.load_tags(sections)
                    self.macros.append(m)
        self.macros.append(m)
        self.macros = []        # List of Macros.
        self.max_depth = 5      # Initial maxiumum allowed include depth.
                        self.max_depth = self.current_depth + val
        self.merge_attributes(attrs)
        self.merge_attributes(attrs,['tags'])
        self.messages = []
        self.messages.append(msg)
                self.mo = mo
        self.mo=None
        self.name = ''          # Conf file macro name (None if implicit).
        self.name = name
            self.name = None
        self.name=None      # Configuration file section name.
        self.name_re = name_re
        self.name_re = ''        # Regexp pattern to match trace names.
                        self.name,self.style,self.styles.keys()))
            self.newline = literal_eval('"'+d['newline']+'"')
        self.newline = '\r\n'
        self.newline = '\r\n'            # End of line terminator.
        self.next = []
                self.next.append([self.fname,self._lineno,s])
        self.next.insert(0,cursor)
        self.next = []          # Read ahead buffer containing
        self.number_style=None # Current numbered list style ('arabic'..)
            self.number_style = self.attributes.get('style')
                        (self.number_style,style), offset=1)
        self.offset = 0
        self.open = []  # A stack of the current and parent lists.
                self.open(fname)
        self.options=()     # options entry list.
        self.ordinal = 0
            self.ordinal += 1
        self.ordinal=None   # Current list item ordinal number (1..)
                        (self.ordinal,ordinal), offset=1)
        self.outfile = None     # Output file name.
        self.outfilesuffix = ''
            self.outfilesuffix = d['outfilesuffix']
            self.pageunits = d['pageunits']
        self.pageunits = None
        self.pagewidth = None
                self.pagewidth = val
        # (self.parameters).
        self.parameters are used internally to render the current block.
        self.parameters = AttrDict()
        self.parameters.format = format
                        self.parameters[k] = v
            self.parameters[name] = getattr(self,name)
        self.parameters=None
                        self.parameters[param])
                self.parameters[param] = getattr(self,param)
        self.parameters.separator = separator
        self.parameters.tags = tags
        self.PARAM_NAMES += ('tags',)
        self.PARAM_NAMES=('template','options','presubs','postsubs','filter')
        self.parent = None      # Included reader's parent reader.
                self.parent = parent
            self.parse_author(author)
        self.parse_cols(cols, attrs.get('halign'), attrs.get('valign'))
        self.parse_replacements()
        self.parse_replacements('replacements2')
        self.parse_rows(text)
        self.parse_ruler(ruler)
        self.parse_specialsections()
        self.parse_specialwords()
        self.parse_tags()
        self.passthroughs = []
            self.pattern = entry
        self.pattern = None     # Matching regular expression.
        self.pattern = pattern
        self.pcwidth = None     # 1..99 (percentage).
        self.pcwidth = pcwidth
        self.posattrs=()    # posattrs entry list.
        self.postsubs=()    # postsubs entry list.
        self.prefix = ''        # '' if inline, '+' if system, '#' if block.
        self.prefix = prefix
            self.presubs = config.subsnormal
        self.presubs=None   # presubs/subs entry list.
                             self.presubs, self.attributes,trace='list term')
            self.process_author_names()
        self.quotes = OrderedDict()    # Values contain corresponding tag name.
        self.reo = None         # Compiled pattern re object.
        self.reo = re.compile(pattern)
        self.replacements2 = OrderedDict()
        self.replacements = OrderedDict()   # Key is find pattern, value is
        self.reserved = False
        self.rows = []
                    self.rows.append(row)
        self.rows=[]            # Parsed rows, each row is a list of Cells.
            self.rows = self.parse_csv(text)
            self.rows = self.rows[:-1]
            self.rows = self.rows[1:]
        self.rulerwidth = None
        self.safe = False       # Default safe mode.
            self.sections[k] = self.expand_templates(v)
                    self.sections[k] = v
                    self.sections[k] += v
                self.sections[k] = v
        self.sections = OrderedDict()   # Keyed by section name containing
            self.separator = literal_eval('"'+self.separator+'"')
        self.separator=None
        self.set_deprecated_attribute('date','revdate')
        self.set_deprecated_attribute('revision','revnumber')
        self.skip_blank_lines = False    # If True don't output blank lines.
                        self.skip = defined
                        self.skip = False
        self.skip = False       # true if we're skipping ifdef...endif.
        self.skipname = ''      # Name of current endif macro target.
                        self.skipname = target
                    self.skip = not cond
                        self.skip = not defined
        self.skipto = -1        # The depth at which skipping is reenabled.
                        self.skipto = self.depth
                self.span, self.vspan,
        self.span, self.vspan = Table.parse_span_spec(span_spec)
        self.specialchars = {}  # Values of special character substitutions.
        self.specialsections = {} # Name is special section name pattern, value
                self.specialsections[pat] = sectname
        self.specialwords = {}  # Name is special word pattern, value is macro.
                    self.specialwords[word] = name
                        self.start)
        self.start = None   # File reader cursor at start delimiter.
            self.start = reader.cursor[:]
            self.stderr(msg)
        self.stderr(msg)
        self.style=None     # Default style.
                self.style or '',
        self.styles=OrderedDict() # Each entry is a styles dictionary.
                    self.styles[style] = d
        self.style = style
        self.style = style      # Style name or None.
        self.subslist = []      # Default subs for macros passtext group.
        self.subslist = subslist or []
            self.subsnormal = parse_options(d['subsnormal'],SUBS_OPTIONS,
        self.subsnormal = SUBS_NORMAL
            self.subsverbatim = parse_options(d['subsverbatim'],SUBS_OPTIONS,
        self.subsverbatim = SUBS_VERBATIM
                    self.tablewidth = float(attrs['tablewidth'])
            self.tablewidth = float(mo.group(2))
            self.tablewidth = None
        self.tablewidth=None    # Optional table width scale factor.
        self.tabsize = 8
        self.tabsize = 8        # Tab expansion number of spaces.
                    self.tabsize = config.tabsize
                        self.tabsize = val
        self.tag = lists.tags[self.parameters.tags]
        self.tag=None       # Current tags AttrDict.
        self.tags={}
                    self.tags[k] = (mo.group('stag'), mo.group('etag'))
                self.tags[k] = (None,None)
        self.tags={}    # List tags dictionary. Each entry is a tags AttrDict.
                self.tags[name] = d
        self.tags=None      # Name of listtags-<tags> conf section.
        self.tags=None          # Name of tabletags-<tags> conf section.
        self.tags = self.tags or 'default'
        self.tags = {}          # Values contain (stag,etag) tuples.
                                        % self.template)
        self.template=None  # template section entry.
        self.terminators = [
        self.terminators=None    # List of compiled re's.
        self.text=None      # Text in first line of list item.
        self.text=None          # Text in first line of paragraph.
            self.text = self.mo.groupdict().get('text')
        self.textwidth = 70             # DEPRECATED: Old tables only.
                self.translate_entry()
                self.translate_item()
        self.translate_item()
        self.type=None
        self.type=None      # List type ('numbered','bulleted','labeled').
        self.underline = None
        self.underline=None     # RE matching current table underline.
        self.underline = r'^' + fc + r'{3,}$'
                self.unread(putback.pop())
                        self.unread(self.cursor)
            self.unread(self.cursor)
        self.update_parameters(attrs)
        self.update_parameters(entries, self, all=True)
        self.validate_attributes()
        self.verbose = False
        self.width = width or '1'
            self.write(content)
            self.write(etag)
            self.write_line()
                    self.write_line(arg)
                        self.write_line(s)
            self.write(stag)
                        sep = AND
                        separator)
                    # separator.
                separator = ','
        separator = literal_eval('"'+separator+'"')
        separator = '(?msu)'+self.parameters.separator
        separator = '\n'
    SEPARATORS = dict(
        separator = self.attributes.get('separator',':')
        separator = self.separator
            separator = Table.SEPARATORS[format]
                separator = v
        separator = writer.newline
                        sep = OR
        setattr(dst,a,v)
                # Set attributes in child.
                setattr(obj,k,v)
                        setattr(self, name, val)
        # Set calculated attributes.
        # Set column (and indirectly cell) default alignments.
        # Set defaults.
        # Set default table defaults.
        """Set document level and write open section close tags up to level."""
            # Set horizontal list 'labelwidth' and 'itemwidth' attributes.
        set_if_int_gt_zero('tabsize', d)
        set_if_int_gt_zero('textwidth', d) # DEPRECATED: Old tables only.
        Set implicit attributes and attributes in 'attrs'.
        """Set miscellaneous configuration entries from dictionary 'd'."""
        # Set named positional attributes.
        # Set processing options.
                # Set revision date to ensure valid DocBook revision.
            # Set the numbering style from first list item.
        Set Title section name:
        set to None.
        # Set to True or False to globally override line numbers method
            show_help(args[-1])
            show_help('default')
    show_help('default', sys.stderr)
                shutil.rmtree(plugin_dir)
            shutil.rmtree(plugin_dir)
                                '%s: illegal option name' % name)
        # single-line title pattern -- can this be done here or do we need
        # Single name -- higher precedence.
        # Single quoted.
    single string.
                    # Size proportional to page width.
                    # Size proportional to ruler width.
                s = ' '.join(lines)
        s = ','.join(s)
            # Skip blank lines
            # Skip braces that are followed by a backslash.
        # Skip comments and attribute entries that preceed the header.
            skipinitialspace=True)
                # Skip past start of match.
        skipped = False
        skipped = re.search(r'(?su)\{[^\\\W][-\w]*?\}(?!\\)', line)
                    skipped = True
                # Skip vertically spanned placeholders.
            s = k+'='+v
        s = Lex.subs((BlockTitle.title,), Title.subs)
        # Sliently skip missing configuration file.
    s = lstrip_list(s)
            s = macros.extract_passthroughs(s,'#')
                s = macros.restore_passthroughs(s)
        s = map(lambda x: '"' + x.strip() + '"', s)
                s = mo.group(1) + stag + mo.group('content') + etag
                s = mo.group('attrlist')
                # Some sections can have name! syntax.
        # Source rows are parsed as single block, rather than line by line, to
        source text after substitutuion.
                span = mo.groupdict().get('span')
        span = None
                span = Table.parse_span_spec(span_spec)[0]
                                'specialcharacters,attributes')
            'specialwords','macros','replacements','quotes','titles',
    'specialwords','replacements','macros','replacements2')
    """Special word substitution function called by
        specified.
        specified in attrs.
        # specify interpreter.
                '(\s+<(?P<email>\S+)>)?$',s)
        # Split macro body into start and end tag lists.
        splits = re.split(self.COL_STOP,ruler)[1:]
                '(\s+(?P<name2>[^<>\s]+))?'
                '(\s+(?P<name3>[^<>\s]+))?'
            srcdir = os.path.abspath(src)
                srcdir += os.path.sep
            s = rdr.read()
                    s = reader.read()
            s = reader.read()
        s = reader.read()
        s = reader.read_next()
                s = re.sub(fc+r'+$','',s)
    s = re.sub(r'\s', ' ', attrs)
                                    s.rstrip() for s in open(fname)]
    s = rstrip_list(s)
                s = s[1:]
        s = s[1:-1]
                s = self.f.readline()
            s = self.f.readline()
            s = self.read()
            s = self.subs(s)
            s = '\\' + s    # Escape so not treated as comment lines.
                    s = s.expandtabs(self.tabsize)
            s = s + line[:-1]
            s = splits[i+1]
        s = s.replace('"','\\"')
                s = s.rstrip()
            s = s.rstrip()
        s = s.split(',')
        s = s.strip()
    s = s.strip()
                s = str(s)
        s = subs_attrs(args)
                s = subs_attrs(colspec, self.attributes)
    s = subs_attrs(filter_cmd, attrs)
                    s = subs_attrs(s)
        s = subs_attrs(s)
                s = subs_attrs(self.colspec,self.attributes)
    s = subs_attrs(tag,dict)
                s = system(action, cmd, is_macro=True)
                s = system(action, expr, attrs=dictionary)
        stag = []
                        stag.append(mo.group('stag'))
                    stag.append(s)
                stag = config.section2tags(template,self.attributes,skipend=True)[0]
        stag = config.section2tags(template, self.attributes,skipend=True)[0]
                    stag,etag = config.section2tags('preamble')
                stag,etag = config.section2tags(template,self.attributes)
            stag,etag = config.section2tags(template,Title.attributes)
        stag,etag = config.section2tags(Title.sectname,Title.attributes)
                stag,etag = config.tag(tag, attrlist)
        stag,etag = self.tags[name]
            stag,etag = subs_tag(dtag,self.attributes)
                    stag,etag = subs_tag(ptag,self.attributes)
        stag,etag = subs_tag(rtag,self.attributes)
        stag,etag = subs_tag(self.tag.list, self.attributes)
        stag,etag = subs_tag(tag,d)
            stag = map(lambda x: x.replace(chr(0), title), stag)
                stag = subs_attrs(stag,d)
            stag = subs_attrs(stag, d)
            start = 0
        start = 0
                start = end
            start = mo.end()
    (starts with alpha containing alphanumeric and dashes only)."""
        # Start with configuration file defaults.
    @staticmethod
    """Static methods and attributes only."""
    stdin,stdout = sys.stdin,sys.stdout
                stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        still honored.
    s = time.strftime('%H:%M:%S',t)
                                # Store the include file in memory for later
        string_result = False
        string_result = True
        # Strip and save optional tablewidth from end of ruler.
        # Strip margin width from all lines.
    # Strip quotation mark characters from quoted strings.
                # Strip trailing fillchars.
            # Strip white space and illegal name chars.
                        + str(listindex))
            style = 'arabic'
                        # Style attributes don't take precedence over explicit.
            style = 'loweralpha'
            style = 'lowerroman'
                style = mo.groupdict().get('style')
                    style = mo.group('style')
            style = None
        style = None
            style = self.attributes.get('1')
            style = self.attributes.get('style',self.style)
            style = self.calc_style(self.index)
                    style = self.get_style(style)
                style = self.style
        # styles have templates.
            style = 'upperalpha'
            style = 'upperroman'
    subdirectories, if src is a file archive the src file.
                subdirs = dirpath[len(filtersdir):].split(os.path.sep)
    subs = ()
            subs = config.subsnormal
            # Sub-sections of multi-part book level zero Preface and Appendices
                        # Subs is an alias for presubs.
                # Subs is an alias for presubs.
        subslist = mo.group('subslist')
                subslist = parse_options(d['subslist'], SUBS_OPTIONS,
            subslist = parse_options(subslist, SUBS_OPTIONS,
                subslist = self.subslist
    SUBS_NAMES = ('specialcharacters','quotes','specialwords',
    subs = None
SUBS_NORMAL = ('specialcharacters','quotes','attributes',
SUBS_OPTIONS = ('specialcharacters','quotes','specialwords',
            subs = self.get_subs()[0]
    # Substitute all attributes in all lines.
        Substitute and append the passthrough attribute lists to the
        # Substitute and indent all data in all rows.
        # Substitute attribute references inside dictionary values.
        # Substitute document parameters and write document footer.
    """Substitute 'lines' of text with attributes from the global
        """Substitute patterns from self.replacements in 's'."""
                    # Substitute single quoted attribute values in block macros.
        '''Substitute single quoted attribute values normally.'''
        Substitute the list of Cells using the data tag.
        """Substitute the list of source row data elements using the data tag.
        substitute using corresponding macro."""
        substitution attributes (self.attributes).
        substitution on tags."""
        Substitutions specified in the 'subs' list are perform on the
SUBS_VERBATIM = ('specialcharacters','callouts')
            suffix = '-blockmacro'
            suffix = '-inlinemacro'
            s = ul[:2]*((ul_len+1)/2)
                                        s = UNDEFINED # So the line is dropped.
                        s = UNDEFINED               # So the line is dropped.
                                        s = v[1]
                                    s = v[1]         # {<name>@<re>:<v1>[:<v2>]}
                                        s = v[2]
        s = writer.newline.join(s)
        syntax = '{%s:%s}' % (name,args)
        syntax = '%s::[%s]' % (name,args)
                                % (syntax,value))
            sys.exit(0)
        sys.exit(0)
                sys.exit(1)
            sys.exit(1)
        sys.exit(1)
    sys.exit(1)
    SYS_RE = r'(?u)^(?P<name>[\\]?\w(\w|-)*?)::(?P<target>\S*?)' + \
            sys.stderr.write('%s: %s%s' % (self.PROG, msg, os.linesep))
            sys.stdin = infile
        sys.stdin,sys.stdout = stdin,stdout
            sys.stdout = outfile
        sys.stdout.write(hdr)
                sys.stdout.write('[%s]%s' % (k,writer.newline))
                    sys.stdout.write('%s%s' % (line,writer.newline))
                sys.stdout.write(writer.newline)
        table = []
            table.append(reader.read())
        table arguments have been parsed since we use the table format."""
    """Table column."""
        # tabledef conf file parameters.
        tables.dump()
        tables.load(sections)
        tables_OLD.dump()
        tables_OLD.load(sections)
tables_OLD = Tables_OLD()   # Table_OLD definitions.
        tables_OLD.validate()
tables = Tables()           # Table definitions.
        table = subs_attrs(config.sections[self.parameters.template],
        table = subs_attrs(config.sections[self.template],self.attributes)
        tables.validate()
            table = table.replace('\x07bodyrows\x07', bodyrows, 1)
        table = table.replace('\x07bodyrows\x07', bodyrows, 1)
            table = table.replace('\x07footrows\x07', footrows, 1)
            table = table.replace('\x07headrows\x07', headrows, 1)
        # Table tags dictionary. Each entry is a tags dictionary.
            # Table terminated by underline followed by a blank line or EOF.
                          Table.VALIGN.get(mo.group(3)))
        table = writer.newline.join(table)
            # Tabs guarantee the placeholders are unambiguous.
        tag = config.quotes[q]
    TAGS = ('colspec', 'headrow','footrow','bodyrow',
            tag = self.quotes[q]
    TAGS = ('list', 'entry','item','text', 'label','term')
        [tags] section. Raise error if not found. If a dictionary 'd' is
        tags = self.get_param('tags',params)
            tags = self.get_tags(colstyle)
        tags = [self.tags]
        tags = self.tags
        tags = set(Lists.TAGS)
        tags += [s['tags'] for s in self.styles.values() if 'tags' in s]
        tags = tables.tags[self.parameters.tags]
            tags = tags.difference(['entry','label','term'])
                    tags = v
                    tag = tag[1:]
            tag = tag[1:]
    tag tuple (c.f. Config.tag())."""
        take precedence).
                target = mo.group('target')
            target = mo.group('target')
        template.
    template = config.specialwords[word]    # The corresponding markup template.
        template = 'floatingtitle'
            template = self.parameters.template
        template = self.parameters.template
            template = subs_attrs(template,attrs)
        template = subs_attrs(template,attrs)
                terminators = [re.compile(terminators)]
                terminators = [terminators]
        text."""
    text = char_decode(s)
                    # Text in last column can continue forever.
                text[mo.end('passtext'):mo.end()]
                text[mo.start():mo.start('passtext')] +
                text = m.subs_passthroughs(text, self.passthroughs)
                    text = '\n'.join(data).strip()
        text = '\n'.join(text)
        text = reader.read_until(lists.terminators)
        text = reader.read_until(self.delimiter)
            text = [self.text] + list(text)
                text = text[:mo.start()] + s + text[mo.end():]
                text = text[:mo.start()] + text[mo.start()+1:]
            text = text.replace('\x07'+str(i)+'\x07', self.passthroughs[i])
        that matches the terminator regular expression, regular expression
            # The alt attribute is the first image macro positional attribute.
    The AsciiDoc document is read from file object src the translated
    The 'attrs' dictionary contains additional filter attributes.
    The attrs dictionary is updated by the counter and set system attributes.
    The attrs string is a comma separated list of values and keyword name=value
        The 'before' and 'after' messages are only printed if they differ.
                # The body is treated like a section body.
            # The case of one column followed by fillchars is numeric.
        # The count and align group matches are not exact.
                        # the current cell.
                # The default language file must exist.
        The 'exclude' list contains section names not to be loaded.
        the first item (self.number_style)."""
        The 'include' list contains the section names to be loaded.
            themedir = config.find_config_dir('themes', theme)
        theme = document.attributes.get('theme')
        # then all non-callout macros are processed.
        # The names of block parameters.
        the 'Namespaces in XML' Recommendation:
        then has to be escaped and this makes including code listings
        The normalized value of the id attribute is an NCName according to
        the routine was called."""
        # The 'rowcount' attribute is used by the experimental LaTeX backend.
                    # These actions create and update attributes.
            # the second for everything. This is so that locally set attributes
        # The section is not empty if contains a subsection.
# These will be removed from future versions of AsciiDoc
        # (the tab character does not appear elsewhere since it is expanded on
        # the table markup template. In order to ensure this data does not get
        the terminating pattern must occur in the file the was being read when
            # The text within constrained quotes must be bounded by white space.
    # This class is not used directly, use Reader class instead.
                            # This is a configuration dump, just pass the macro
                # This is where continued elements are processed.
    Throws exception if error occurs.
        Title.attributes['level'] = str(Title.level)
                    Title.attributes = mo.groupdict()
                Title.attributes = mo.groupdict()
            Title.attributes['sectnum'] = ''
            Title.attributes['sectnum'] = Title.getnumber(document.level)
                Title.attributes['title'] = lines[0]
                        Title.attributes['title'] = mo.group().strip()
            Title.attributes['title'] = Title.dosubs(Title.attributes['title'])
                        Title.attributes['title'] = title.strip()
                # Titled elements terminate the list.
        title = d.get('title')
        Title.dump()
            Title.dump_dict['blocktitle'] = pat
                Title.dump_dict[k] = pat
            Title.dump_dict['sectiontitle'] = pat
            Title.dump_dict['subs'] = entries['subs']
            Title.dump_dict['underlines'] = entries['underlines']
            title_len = column_width(title)
            Title.level += int(document.attributes.get('leveloffset','0'))
                    Title.level = level
                Title.level = list(Title.underlines).index(ul[:2])
                (Title.level, Title.attributes['title']))
        title = Lex.subs((title,), Title.subs)
                    Title.linecount = 1
                Title.linecount = 2
        Title.load(d)
                    title = mo.groupdict().get('title')
    title = None
            Title.pattern = pat
                Title.section_numbers[l] = 0
                Title.section_numbers[l] = n + 1
            Title.sectname = AttributeList.attrs['template']
                    Title.sectname = sect
                Title.sectname = 'sect%d' % Title.level
            Title.sectname = sectname
        Title.setsectname()
            Title.subs = config.subsnormal
            Title.subs = parse_options(entries['subs'], SUBS_OPTIONS,
                Title.translate()
        Title.translate()
        Title.translate(skipsubs=True)
            title,ul = lines[:2]
            Title.underlines = tuple(underlines)
        title = writer.newline.join(title)
                t = None
        # TODO: Check we have either a Title.pattern or at least one
        # TODO If separator is preceeded by an odd number of backslashes then
        #TODO: Move to class Tables
            # TODO: Should we warn if substitution drops a tag?
        # TODO: This is virtually the same as parse_replacements() and should
                    # to plain string before further processing
        # Top up buffer.
                t = os.path.getmtime(self.infile)
        totalwidth = 0
            totalwidth = totalwidth + c.rulerwidth
                traceback.print_exc(file=sys.stderr)
            trace('dropped line', line)
            trace(kwargs['trace'],args[0])
            trace(kwargs['trace'],[stag]+content+[etag])
                trace('macro block',before,s)
            trace(o, s, result)
            trace(self.short_name()+' block close',etag)
trace = Trace()             # Implements trace attribute processing.
        """Translate block from document reader."""
        """Translate composite subs values."""
            # Translate mandatory NAME section.
                # Translate 'preamble' (untitled elements between header
    trimmed."""
    """Trim white space and, if necessary, quote characters from s."""
                # True if processing a filter specified by a --filter option.
                        try:
                    try:
                try:
            try:
        try:
    try:
        Try all the well known locations.
        try: del self[key]
    try: re.compile(s)
        try: return self[key]
        t = time.asctime(time.localtime(time.time()))
    t = time.localtime(t)
                t = time.time()
        t = time.time()
        tuple of all lines after the underline."""
    tuple of valid options. 'allowed' is a list of allowed option values.
            t = v.get('template')
    type = None     # 'backend', 'filter' or 'theme'.
    TYPES = ('bulleted','numbered','labeled','callout')
            ul_len = char_len(ul)
            # Unconstrained quotes can appear anywhere.
        # Unconstrained quotes prefix the tag name with a hash.
                # Undefine all words associated with 'name'.
                # undefined attribute will drop the entire paragraph.
                UNDEFINED = '{zzzzz}'
    underlines = ('==','--','~~','^^','++') # Levels 0,1,2,3,4.
        # Underlines must be 3 or more fillchars.
                underlines = parse_list(entries['underlines'])
under the terms of the GNU General Public License (GPL).
                        # Unescape ] characters in inline macros.
                # Unescape ] characters in inline macros.
            # Unescape escaped characters.
            # Unescape escaped system macros.
            # Unescape special characters in LaTeX target file names.
            # Unquoted catch all.
    Unzip Zip file to destination directory.
    """Update a attrs dictionary with name="value" attributes from the s string.
    """Update a dictionary with name/value attributes from the attrs string.
    """Update 'attrs' dictionary with parsed attributes in dictionary 'dict'."""
        update_attrs(self.conf_attrs,d)
        """Update block definition from section 'entries' dictionary."""
        """Update blocks defined in 'sections' dictionary."""
            # Update document attributes with attribute value.
        # Update new sections.
        Updates 'attrs' with parsed [attributes] section entries.
            """ Update section in sections with contents. """
        update_section(section)         # Store last section.
                update_section(section) # Store previous section.
        """Update table definition from section entries in 'entries'."""
        # Update with command-line attributes.
        # Update with configuration file attributes.
                    'upperroman')
        usage()
                usage('Illegal -a option: %s' % v)
        usage('No source file specified')
        usage('To many arguments')
        # Use body tags if header and footer tags are not specified.
### Used by asciidocapi.py ###
        """Used by class methods to close nested include files."""
    Used in conjunction with the 'trace' attribute to generate diagnostic
        used to suppress substitution."""
            # Use explicit style attribute, fall back to default style.
                USER_DIR = None
USER_DIR = None             # ~/.asciidoc
            USER_DIR = os.path.join(USER_DIR,'.asciidoc')
        USER_DIR = userdir()
            Uses matched macro regular expression object and returns string
                # Use table style unless overriden by cell style.
        Use the current blocks attribute list (attrs dictionary) to build a
                    # Use the encoded string to slice, but convert back
#!/usr/bin/env python
UTF8_BOM = '\xef\xbb\xbf'
# Utility functions and classes.
        """Utility routine that sets the left margin to 'margin' space in a
                val = float(d['pagewidth'])
        """Validate and parse table attributes."""
        """Validate block after the complete configuration has been loaded."""
        # Validate delimiters and build combined lists delimiter pattern.
        # Validate overridable attributes.
        """Validate the block definitions."""
        # Validate widths and calculate missing widths.
    Valid 'attrs' sequence syntax:
    VALIGN = {'<':'top', '>':'bottom', '^':'middle'}
                        val = int(attrs['depth'])
                        val = int(attrs['tabsize'])
                    val = int(d[name])
                        val = int(s)
        val = self[key]
            value = ''
        value = document.attributes.get(attr)
            value = entry[mo.end(1):]
        value = mo.group('value')
            value = None
    value = None
        values = ast.parse("[" + val + "]", mode='eval').body.elts
        values = compiler.parse("[" + val + "]", mode='eval').node.asList()
            value = strip_quotes(value)
            value = value.strip()
            v = config.subs_specialchars(v)
VERSION = '8.6.6'           # See CHANGLOG file for version history.
            (VERSION,document.backend,document.doctype,writer.newline)
            v = 'numbered'
                    v = parse_options(v, (), msg % (k,v))
                v = parse_options(v, (), msg % (k,v))
                    v = parse_options(v, SUBS_OPTIONS, msg % (k,v))
                        v = re.split(r'(?<!\\):',rval)
                            v = [s.replace('\\:',':') for s in v]
            v = str(self.attributes['width'])
                v = subs_attrs(str(v))
                    v = subs_attrs(v)
            v = subs_attrs(v)
            v = 'theme='+v
                    v = tuple(set(dst.options).union(set(v)))
            v = '"'+v+'"'
                warnings = attrs.get('warnings', True)
            # Was not set on command-line or in document header.
        was specified.
        # We expect a dummy blank item preceeding first PSV cell.
                    # We have a cell generated by a previous row span so
        while attr.value.endswith(' +'):
            while i < count and not self.eof():
        while i < count and not self.eof():
            while Lex.next() in (BlockTitle,AttributeList):
        while Lex.next() is self:
        while Lex.next() is self and not BlockTitle.title:
        while next and next is not terminator:
        while not finished:
        while not rdr.eof():
        while not reader.eof():
        while not reo.match(rows[i]):
        while not self.eof():
            while putback:
                while reader.read_next():
            while s:
        while Section.endtags and Section.endtags[-1][0] >= level:
        while self.skip:
            while True:
        while True:
        white space. Maintain self.next read ahead buffer. If skip=True then
        width = 0
                width = 1
            width += east_asian_widths[unicodedata.east_asian_width(c)]
                width = float(100 - percents)/float(len(self.columns) - n)
            width = float(c.rulerwidth)
        width = len(lines[0])
            # will be substituted by config.subs_section() below. As a partial
        # Windows doesn't like running scripts directly so explicitly
        # with the real data.
    word = mo.re.pattern                    # The special word.
                words = reo.findall(wordlist)
                    word = strip_quotes(word)
    """ Wraps (well, sought of) Reader1 class and implements conditional text
        write('')
        """Write block definition to stdout."""
        write('bodydata='+self.bodydata)
        write('bodyrow='+self.bodyrow)
            write('colspec='+self.colspec)
        """Write content enveloped by tag.
            write('delimiter='+self.delimiter)
        write('fillchar='+self.fillchar)
            write('filter='+self.filter)
            write('footdata='+self.footdata)
            write('footrow='+self.footrow)
        write('format='+self.format)
            write('headdata='+self.headdata)
            write('headrow='+self.headrow)
        # Write item text.
        # Write ItemText.
        # Write labels.
        write = lambda s: sys.stdout.write('%s%s' % (s,writer.newline))
            write(macro)
        write('[macros]')
            write('options='+','.join(self.options))
    """Write parameters in 'dict' as in configuration file section format with
            write('posattrs='+','.join(self.posattrs))
            write('postsubs='+','.join(self.postsubs))
                write('presubs='+','.join(self.presubs))
                    writer.close()
            writer.newline = config.newline
                writer.open(outfile, reader.bom)
                writer.write(config.subs_section('name',{}), trace='name')
                writer.write(dovetail_tags(stag,body,etag),trace=name)
        writer.write(dovetail_tags(stag,body,etag),trace='paragraph')
        writer.write(entrytag[0],trace='list entry open')
        writer.write(entrytag[1],trace='list entry close')
            writer.write(etag,trace='list close')
                writer.write(etag,trace=name+' close')
                    writer.write(etag,trace='preamble close')
            writer.write(ftr,trace='footer')
                writer.write(hdr,trace='header')
        writer.write(itemtag[0],trace='list item open')
        writer.write(itemtag[1],trace='list item close')
        writer.write(labeltag[0],trace='list label open')
        writer.write(labeltag[1],trace='list label close')
writer = Writer()           # Output stream line writer.
                writer.write(s)
            writer.write(Section.endtags.pop()[1],trace='section close')
            writer.write(stag,trace='floating title')
            writer.write(stag,trace='list open')
                writer.write(stag,trace=name+' open')
                    writer.write(stag,trace='preamble open')
        writer.write(stag,trace='section open: level %d: %s' %
        writer.write(table,trace='table')
            writer.write_tag(self.tag.term, [self.label],
            writer.write_tag(self.tag.text, text, self.presubs, self.attributes,trace='list text')
        write('['+self.name+']')
    """Writes lines to output file."""
                write('%s-style=%s' % (style,s[:-1]))
                # Write start tag, content, end tag.
        # Write start tag, content, end tag.
            write('style='+self.style)
                write('subs='+','.join(self.presubs))
        write('tags='+self.tags)
            write('template='+self.template)
        write('type='+self.type)
                '\x07' + str(len(passthroughs)-1) + '\x07' +
        zip_file = args[0]
                    # Zip files created under Windows do not include permissions.
        zipo.close()
                    zipo.write(filename, arcname, zipfile.ZIP_DEFLATED)
            zipo.write(src, arcname, zipfile.ZIP_DEFLATED)
    zipo = zipfile.ZipFile(zip_file, 'r')
    zipo = zipfile.ZipFile(zip_file, 'w')
