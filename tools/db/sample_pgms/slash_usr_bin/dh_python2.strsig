################################################################
 2010-2011 Piotr O
# all copies or substantial portions of the Software.
             'and add them to ${python:Depends}. '
        # and it should remain there even if __init__.py was the only .py file
                                          'and shipped in python%s\'s dist-'
    # arch=False->arch:all only, arch=True->arch:any only, None->all of them
            args = pdir
                    args += " -V %s" % vrange_str(options.vrange)
                    args += " -V %s" % vrepr(shebangs[0])
                args += " -V %s" % vrepr(ver)
                args += " -V %s" % vrepr(version)
                args += " -X '%s'" % pattern.replace("'", r"'\''")
arowski <piotr@debian.org>
                # at least one extension's version not detected
                # at least one file that is not an extension
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        bin_dir = private_dir = None
                    bin_dir = root
                    break
                              'Build extensions for all supported Python '
                    # cannot share it, pyshared contains another copy
        # check files
                            clean_egg_name, \
                clean_name = clean_egg_name(fn)
                clean_name = clean_egg_name(name)
# -*- coding: UTF-8 -*- vim: et ts=4 sw=4
        common_dirs = []
                common_dirs.append([i, None])
        common_dirs = dc.subdirs.iteritems()
        common_files = []
                common_files.append(i)
        common_files = cmpfiles(dir1, dir2, common_files, shallow=False)[0]
        common_files = dc.common_files
         'compile': False,
                    ['compile'] = True
            continue
                continue
                    continue
# copies of the Software, and to permit persons to whom the Software is
# Copyright 
                # could be removed while handling .so symlinks
    """Create extension symlinks in /usr/lib/pyshared/pythonX.Y.
            create_ext_links(fpath1)
        create_ext_links(sitedir(version, package))
            create_public_links(fpath1, vrange, join(root, fn))
                create_public_links(pyshared_dir, options.vrange)
    """Create public module symlinks for given directory."""
    dbg_package = package.endswith('-dbg')
        dbg_to_check.append("usr/lib/debug/usr/lib/pyshared/python%s" % ver)
        dbg_to_check = ['usr/lib/debug/%s' % i for i in to_check]
                dc = dircmp(dir1, dir2)
    debian, package, path = dir1.split('/', 2)
    debian, package, path = dir2.split('/', 2)
    debsorted, getver, vrepr, parse_pycentral_vrange, \
def create_ext_links(dir1):
def create_public_links(dir1, vrange, root=''):
def fix_locations(package):
def main():
def move_to_pyshared(dir1):
def scan(package, dname=None, clean_dbg_pkg=True):
def share_2x(dir1, dir2, dc=None):
def share(package, stats, options):
             'dependencies and add them to ${python:Recommends}')
             'dependencies and add them to ${python:Suggests}')
        dependencies = Dependencies(package)
                dependencies.depend("python%d.%d" % version)
                dependencies.depend("python%s" % ver)
        dependencies.export_to(dh)
        dependencies.parse(stats, options)
        dest='arch', default=None,
        dest='arch', help='act on architecture dependent packages')
            dest='clean_dbg_pkg', default=True,
        dest='guess_deps', default=True, help='disable guessing dependencies')
        dest='guess_versions', default=True,
                dh.addsubstvar(package, 'python:Provides', \
            dh.addsubstvar(package, 'python:Versions', \
            dh.autoscript(package, 'postinst', 'postinst-pycompile', '')
            dh.autoscript(package, 'postinst', 'postinst-pycompile', args)
                dh.autoscript(package, 'preinst',
                dh.autoscript(package, 'prerm', 'prerm-pyclean', '')
            dh.autoscript(package, 'prerm', 'prerm-pyclean', '')
    dh = DebHelper(options)
    dh.save()
                         'Did you forget "--install-layout=deb"?',
            dir1 = sitedir(version1, package)
    # dir1 starts with debian/packagename/usr/lib/pythonX.Y/*-packages/
                dir2 = sitedir(version2, package)
        # dircmp returns common names only, lets check files more carefully...
                # directories with .so files will be blocked earlier
                    dirs[dirs.index(name)] = clean_name
                    dirs.remove(name)
    # disable PyDist if dh_pydeb is used
        # do not touch symlinks created by previous loop or other tools
        # do the same with debug locations
        # (dpkg has problems with symlinks anyway)
    dstdir = join(debian, package, 'usr/lib/pyshared/', python, module_subpath)
    dstdir = join(debian, package, 'usr/share/pyshared/', \
                dstdir = join('debian', package, 'usr/share/python/dist/')
            dstdir = join('debian', package, 'usr/share/python/ns/')
                dstdir = join(sitedir(version, package), root)
        dstdir = sitedir(version, package)
        dstdir = sitedir(version, package, gdb=True)
                    dstfpath = fpath
                        dstfpath = join(root, os.readlink(dstfpath))
            # .egg-info files
EGGnPTH_RE = re.compile(r'(.*?)(-py\d\.\d+)?(.*?)(\.egg-info|\.pth)$')
        elif exists(fpath2) and exists(fpath3) and \
            elif False in ext_for:
            elif fcmp(fpath3, fpath1, shallow=False):
                elif fext == 'py':
        elif i.rsplit('.', 1)[-1] == 'so':
    elif islink(dir1):
    elif len(pubvers) == 1:
                        elif not version:
                elif options.vrange and options.vrange != (None, None):
            elif private_dir:
                    else:
                else:
            else:
        else:
    else:
            else:  # i.e. not public_dir and not private_dir
                else:  # try shebang or default Python version
                except Exception:
        except Exception:
        except IOError:
            except (IOError, OSError), e:
            exit(1)
                    exit(2)
                    exit(3)
                exit(4)
                exit(5)
                exit(6)
                                exit(7)
            # extension was build for
            ext_for = details.get('ext')
         'ext': set()}
        # fail now rather than at runtime
             fcmp(fpath2, fpath3, shallow=False):
                    fcopy(fpath1, fpath2)
                fcopy(pydist_file, join(dstdir, package))
            fext = fn.rsplit('.', 1)[-1]
    fext = lambda fname: fname.rsplit('.', 1)[-1]
### FILES ######################################################
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            fix_locations(package)
# * fn - file name (without path)
    for dn, dc in common_dirs:
    for fn in common_files:
    for fn in os.listdir(dir1):
        for fn in sorted(file_names):
        for i in os.listdir(dir1):
    for i in os.listdir(dir1):
            for i in private_to_check:
                           for i in sorted(vrepr(stats['public_vers']))))
            for line in fp:
        for location in dbg_to_check:
        for location in to_check:
                        for lpath in links:
        for name in dirs:
    for package, pdetails in dh.packages.iteritems():
            for pattern in options.regexpr or []:
    for pattern in options.regexpr or []:
        for pdir, details in stats['private_dirs'].iteritems():
        for pos, version1 in enumerate(pubvers):
    for root, dirs, file_names in os.walk(proot):
        for root, dirs, file_names in os.walk(proot, topdown=False):
            for version2 in pubvers[pos + 1:]:
        for version in get_requested_versions(options.vrange):
    for version in stats['ext']:
    for version in SUPPORTED:
            for version in versions:
                              'found in two locations:\n %s\n %s',
    found_versions = {}
                found_versions[ver] = location
        fpath1 = join(dir1, fn)
        fpath1 = join(dir1, i)
                        fpath1_target = normpath(join(dir1, fpath1_target))
                    fpath1_target = os.readlink(fpath1)
        fpath2 = join(dir2, fn)
            fpath2 = join(dstdir, i)
        fpath3 = join(dstdir, fn)
# * fpath - file path
            fpath = join(root, fn)
                fp.writelines("%s\n" % i for i in nsp)
from debpython.debhelper import DebHelper
from debpython.depends import Dependencies
from debpython.option import Option
from debpython.pydist import validate as validate_pydist, \
from debpython.tools import sitedir, relative_symlink, \
from debpython.version import SUPPORTED, DEFAULT, \
from filecmp import dircmp, cmpfiles, cmp as fcmp
from __future__ import with_statement
from optparse import OptionParser, SUPPRESS_HELP
from os.path import isabs, isdir, islink, exists, join, normpath, realpath,\
from shutil import rmtree, copy as fcopy
from stat import ST_MODE, S_IXUSR, S_IXGRP, S_IXOTH
# furnished to do so, subject to the following conditions:
    """Gather statistics about Python files in given package."""
    get_requested_versions, parse_vrange, vrange_str
        # handle some EGG related data (.egg-info dirs)
            # handle usr/share/foo dirs (without leading slash)
        help='act on architecture independent packages')
        help='act on the package named PACKAGE')
        help='be quiet')
        help='compile all files from given private directory in postinst, '
        help='disable guessing other supported Python versions')
        help='do not act on the specified package')
        help='do not remove files from debug packages')
        help='do not translate shebangs into Debian dependencies')
        help='don\'t check private directories')
        help='exclude items that match given REGEXPR. You may use this option '
        help='generate maintainer script that will remove pycentral files')
        help="ignore Egg's namespace_packages.txt file and --namespace option")
        help='recreate __init__.py files for given namespaces at install time')
        help='specify list of supported Python versions. ' +\
        help='translate given requirements into Debian '
        help='translate given requirements into Debian dependencies '
        help='turn verbose mode on')
            if any(fn for fn in os.listdir(fpath1) if fext(fn) != 'so'):
            if bin_dir:
                if clean_name != fn:
                if clean_name != name:
                if dbg_package and clean_dbg_pkg:
    if dbg_package and clean_dbg_pkg:
                if dbg_package and clean_dbg_pkg and fext not in ('so', 'h'):
        if dc and not islink(fpath1):
        if dc is None:  # guess/copy mode
    if dc is None:  # guess/copy mode
        if dname is False:
                    if exists(dstfpath) and '.so.' in split(dstfpath)[-1]:
            if exists(fpath2):
                if exists(fpath3):
                if exists(join(root, fn)):
        if exists(pydist_file):
            if ext_for is None:  # no extension
            if fext in ('pyc', 'pyo'):
            if fext(i) == 'so':
                if fext == 'so':
                if fext == 'so' and islink(fpath):
            if fn.endswith('.egg-info'):
                    if isabs(fpath1_target):
        if isdir(fpath1):
        if isdir(fpath1) and not islink(fpath1):
        if isdir(pyshared) and not os.listdir(pyshared):
            if isdir(srcdir):
            if isdir(subdir1) and not islink(subdir1):
                if islink(fpath1):
            if islink(fpath1):
            if len(ps) > 1 and ps[0] == 'python':
    if len(pubvers) > 1:
                if len(root.split('/', 6)) < 6 and (\
                if line and not line.startswith('#'):
                    if mode & S_IXUSR or mode & S_IXGRP or mode & S_IXOTH:
            if name.endswith('.egg-info'):
if __name__ == '__main__':
            if 'namespace_packages.txt' in file_names:
    if not args:
            if not details.get('compile'):
    if not dname:
        if not exists(dir2):
                if not exists(dstdir):
            if not exists(dstdir):
    if not exists(dstdir) and not islink(dir1):
            if not exists(fpath):
            if not exists(fpath2):
            if not exists(fpath3):
                if not isdir(dstdir):
                if not options.ignore_shebangs and len(shebangs) == 1:
    if not options.vrange and dh.python_version:
    if not options.vrange and exists('debian/pyversions'):
        if not private_dir:
        if not private_dir.startswith('/'):
            if not pyclean_added:
            if not pyinstall(package, options.vrange):
            if not pyremove(package, options.vrange):
            if not stats['public_vers'] and exists(pyshared_dir):
            if not validate_pydist(pydist_file):
                if not versions_without_ext:
        if nsp:
        if options.arch is False and pdetails['arch'] != 'all' or \
            if options.clean_pycentral:
    if options.guess_deps:
    if options.guess_versions and pubvers:
        if options.ignore_namespace:
    if options.skip_private:
    if options.verbose or os.environ.get('DH_VERBOSE') == '1':
                if options.vrange and '-' not in vrange_str(options.vrange):
    if package.endswith('-dbg'):
            if '-packages/' in root and not file_names:
                        if public_dir:
            if public_dir:
        if public_dir:
            if public_dir or private_dir:
            if 'requires.txt' in file_names:
                        if res:
                if res:
            if re.search('\n\s*dh_pydeb', rules) or \
        if root.endswith('.egg-info'):
            if root.endswith('-packages'):
            if root[root.find('/lib/python'):].count('/') == 2:
                if root.startswith(join('debian', package, i)):
        if 'so' in fn.split('.'):  # foo.so, bar.so.0.1.2, etc.
                    if so_version:
                if srcver in stats['public_vers']:
        if stats['compile']:
        if stats['public_vers']:
        if '/usr/lib/python3' in root or\
                if ver in found_versions:
        if version >= (2, 6):
            if version not in pubvers:
                            if version != so_version:
                           if v) or [None])[0] or DEFAULT
        # ignore Python 3.X locations
    # ignore some debhelper options:
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
import debpython.namespace as ns
import logging
import os
import re
import sys
# initialize script
# in the Software without restriction, including without limitation the rights
            # in unlikely case where extensions are exactly the same
                  '/'.join(dir1.split('/')[6:]))
                           ', '.join("python%s-%s" % (i, ps[1])\
                           ', '.join(sorted(vrepr(stats['public_vers']))))
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                                     'libpython%s: %s', vrepr(so_version), fn)
                line = line.strip()
                        links.add(dstfpath)
                    links = set()
    locations."""
        log.debug('args: %s', args)
        log.debug('argv: %s', sys.argv)
                log.debug('guessing files for Python %s', vrepr(version))
                log.debug('moving files from %s to %s', srcdir, dstdir)
        log.debug('options: %s', options)
    log.debug("package %s details = %s", package, r)
        log.debug('parsing version range from debian/pyversions')
        log.debug('processing package %s...', package)
                log.error('cannot remove __init__.py from package: %s', e)
                    log.error('extension for python%s is missing. '
                                log.error('extension linked to libpython%s '
                    log.error('files for version %s '
            log.error('regular expression is not valid: %s', pattern)
logging.basicConfig(format='%(levelname).1s: %(module)s:%(lineno)d: '
                            log.info('removing symlink: %s', lpath)
                        log.info('renaming %s to %s', dstfpath, fn)
                    log.info('renaming %s to %s', fn, clean_name)
                    log.info('renaming %s to %s', name, clean_name)
log = logging.getLogger(__name__)
        log.setLevel(logging.DEBUG)
            log.warning('cannot open debian/rules file')
                log.warning('dh_pydeb detected, PyDist feature disabled')
                log.warning('Python 3.x location detected, '
                log.warning("%s.pydist file is invalid", package)
                            log.warn('public extension linked with '
                log.warn('Python %s should install files in %s. '
    main()
                           '%(message)s')
                    mode = os.stat(join(root, fn))[ST_MODE]
    """Move common files to pyshared and create symlinks in original
    """Move files to the right location."""
    """Move files to /usr/share/pyshared/ if possible."""
                move_to_pyshared(join(dir1, i))
        move_to_pyshared(sitedir(pubvers[0], package))
             'multiple times to build up a list of things to exclude.')
        # namespace feature - recreate __init__.py files at install time
# naming conventions used in the file:
                              '--no-guessing-versions to dh_python2',
        # note that pycompile/pyclean is already added to maintainer scripts
        # nothing to share in debug packages
             'not just the ones provided by the package')
            nsp = None
            nsp = ns.parse(stats['nsp.txt'], options.namespaces)
                nsp = ns.remove_from_package(package, nsp,
         'nsp.txt': set(),
# of this software and associated documentation files (the "Software"), to deal
                    # only one version from shebang
                                   option_class=Option)
           options.arch is True and pdetails['arch'] == 'all':
    options, args = parser.parse_args(sys.argv[1:] + \
                options.guess_deps = False
        options.vrange = parse_pycentral_vrange(dh.python_version)
                    options.vrange = parse_vrange(line)
                    os.environ.get('DH_OPTIONS', '').split())
            os.makedirs(dir2)
                    os.makedirs(dstdir)
                os.makedirs(dstdir)
        os.makedirs(dstdir)
                os.remove(fpath)
                    os.remove(fpath1)
                os.remove(fpath1)
            os.remove(fpath2)
                    os.remove(join(root, fn))
                            os.remove(lpath)
                        os.rename(dstfpath, fpath)
                    os.rename(fpath1, fpath2)
                    os.rename(fpath1, fpath3)
                os.rename(fpath1, fpath3)
                    os.rename(join(root, fn), join(root, clean_name))
                    os.rename(join(root, name), join(root, clean_name))
                os.renames(srcdir, dstdir)
            os.rmdir(pyshared)
                    os.rmdir(root)
                        os.symlink(fpath1_target, fpath2)
                os.symlink(os.readlink(fpath1), fpath2)
os.umask(022)
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
### PACKAGE DETAILS ############################################
                                          'packages: %s', vrepr(so_version),
    parser.add_option('-a', '-s', '--arch', action='store_true',
    parser.add_option('--clean-pycentral', action='store_true', default=False,
    parser.add_option('--compile-all', action='store_true', default=False,
    parser.add_option('--depends', action='append',
    parser.add_option('--ignore-namespace', action='store_true', default=False,
    parser.add_option('--ignore-shebangs', action='store_true', default=False,
    parser.add_option('-i', '--indep', action='store_false',
    parser.add_option('--namespace', action='append', dest='namespaces',
    parser.add_option('-N', '--no-package', action='append',
    parser.add_option('--no-dbg-cleaning', action='store_false',
    parser.add_option('--no-guessing-deps', action='store_false',
    parser.add_option('--no-guessing-versions', action='store_false',
    parser.add_option('-O', help=SUPPRESS_HELP)
    parser.add_option('-p', '--package', action='append',
    parser.add_option('-q', '--quiet', action='store_false', dest='verbose',
    parser.add_option('--recommends', action='append',
    parser.add_option('--skip-private', action='store_true', default=False,
    parser.add_option('--suggests', action='append',
    parser.add_option('-V', type='version_range', dest='vrange',
    parser.add_option('-v', '--verbose', action='store_true', default=False,
    parser.add_option('-X', '--exclude', action='append', dest='regexpr',
    parser = OptionParser(usage, version='%prog 2.0~beta1',
                    pass
            pattern = re.compile(pattern)
# Permission is hereby granted, free of charge, to any person obtaining a copy
                            'please use dh_python3: %s', root)
                              'preinst-pycentral-clean', '')
        private_dir = args[0]
        private_dir = False
                    private_dir = '/' + i
        private_dir = None
            private_dir = '/' + private_dir
         'private_dirs': {},
            private_to_check = []
        private_to_check = [dname[1:]]
            private_to_check = [i % package for i in
        proot = "debian/%s" % package
        proot = join('debian', package, dname.strip('/'))
        proot = proot + '/usr/lib'
            ps = package.split('-', 1)
        public_dir = PUBLIC_DIR_RE.match(root)
                             PUBLIC_DIR_RE
         'public_vers': set(),
    pubvers = debsorted(i for i in stats['public_vers'] if i[0] == 2)
        pyclean_added = False  # invoke pyclean only once in maintainer script
                pyclean_added = True
            pyclean_added = True
        pydist_file = join('debian', "%s.pydist" % package)
                            pyinstall, pyremove
            pyshared_dir = "debian/%s/usr/share/pyshared/" % package
        pyshared = join('debian', package, 'usr/share/pyshared/')
    python, _, module_subpath = path[8:].split('/', 2)
    python-support and python-central packages.
                # ralative links will work as well, it's always the same level
    # regexpr option type is not used so lets check patterns here
                relative_symlink(fpath1, join(dstdir, fn))
            relative_symlink(fpath1, join(dstdir, i))
                        relative_symlink(fpath1_target, fpath2)
                relative_symlink(fpath2, fpath1)
                    relative_symlink(fpath3, fpath1)
                relative_symlink(fpath3, fpath1)
                    relative_symlink(fpath3, fpath2)
            relative_symlink(fpath3, fpath2)
    # remove duplicates
        # remove empty directories in -dbg packages
            # remove empty pyshared directory
                        # rename .so.$FOO symlinks, remove other ones
                    # replace with a link to pyshared
            # replace with a link to pyshared
               re.search('\n\s*dh\s+[^#]*--with[^#]+pydeb', rules):
                res = shebang2pyver(fpath)
                        res = shebang2pyver(join(root, fn))
        return
    return r
                    (r if public_dir else
                    rmtree(join(root, name))
                r['nsp.txt'].add(join(root, 'namespace_packages.txt'))
                   root.endswith('/sbin') or root.endswith('/bin') or\
                   root.endswith('/usr/games')):
                            r['private_dirs'].setdefault(private_dir, {})\
                     r['private_dirs'].setdefault(private_dir, {}))\
                r['public_vers'].add(version)
                r['requires.txt'].add(join(root, 'requires.txt'))
    r = {'requires.txt': set(),
                    r['shebangs'].add(res)
            rules = open('debian/rules', 'r').read()
                   # /(s)bin or /usr/(s)bin or /usr/games
        # scan private directory *only*
            # search for scripts in bin dirs
             'See pycompile(1) for examples')
                    .setdefault('ext', set()).add(version)
                                .setdefault('shebangs', set()).add(res)
                share_2x(dir1, dir2, dc)
        share_2x(join(dir1, dn), join(dir2, dn), dc)
                share_2x(sitedir(srcver, package), sitedir(version, package))
            share(package, stats, options)
### SHARING FILES ##############################################
                            shebang2pyver, so2pyver, \
                shebangs = list(v for i, v in details.get('shebangs', []) if v)
         'shebangs': set(),
        # skip this symlink in pyshared
            # sorted() to make sure .so files are handled before .so.foo
                    so_version = so2pyver(join(root, fn))
            srcdir = "debian/%s/%s" % (package, location)
                srcver = versions_without_ext[0]
                stats['compile'] = True
                                                 stats['ext'])
    stats['nsp.txt'] = set(realpath(i) for i in stats['nsp.txt'])
                                             stats['public_vers'])
                    stats['public_vers'].add(version)
                stats['public_vers'] = get_requested_versions(options.vrange)
    stats['requires.txt'] = set(realpath(i) for i in stats['requires.txt'])
        stats = scan(package, private_dir, options.clean_dbg_pkg)
            subdir1 = join(dir1, i)
sys.path.insert(1, '/usr/share/python/')
# The above copyright notice and this permission notice shall be included in
    These symlinks are used to let dpkg detect file conflicts with
# THE SOFTWARE.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
            to_check.append("usr/lib/python%s/site-packages" % ver)
        to_check = [i % ver for i in (\
            # TODO: find a way to specify Python version private
        # TODO: remove this once file conflicts will not be needed anymore
    # TODO: support more than one private dir at the same time (see :meth:scan)
                # TODO: what about relative symlinks?
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                try:
            try:
        try:
    usage = '%prog -p PACKAGE [-V [X.Y][-][A.B]] DIR [-X REGEXPR]\n'
             'Use it for missing items in requires.txt.')
#! /usr/bin/python
                    'usr/lib/pymodules/python%s')]
                                ('usr/lib/%s', 'usr/lib/games/%s',
           '/usr/local/lib/python3' in root:
                    'usr/local/lib/python%s/dist-packages',
                    'usr/local/lib/python%s/site-packages',
                                'usr/share/%s', 'usr/share/games/%s')]
                    'var/lib/python-support/python%s',
                    ver = (list(v for i, v in details.get('shebangs', [])
                              ver, location, found_versions[ver])
                version = ext_for.pop()
            version = False
            version = getver(public_dir.group(1))
    versions = get_requested_versions(vrange)
                            version = so_version
                              'versions (`pyversions -vr`) or adjust '
                versions_without_ext = debsorted(set(pubvers) -\
# * version - tuple of integers
                         ver, sitedir(version))
# * ver - string representation of version
                    ver = vrange_str(options.vrange)
                    ver = vrepr(ver)
        ver = vrepr(version)
# * vrange - version range, pair of max and min versions
                              vrepr(version))
                                          vrepr(version), fn)
            # warn only once
                    while islink(dstfpath):
        with open('debian/pyversions') as fp:
            with open(join(dstdir, package), 'a') as fp:
                              'X-Python-Version field or pass '
