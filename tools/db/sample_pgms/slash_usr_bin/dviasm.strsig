  ##########################################################
############################################################
                    action="append", type="string", dest="subfont",
                    action="store_true", dest="ptex", default=False,
                    action="store", type="int", dest="tabsize",
                    action="store", type="string", dest="encoding",
                    action="store", type="string", dest="output",
                    action="store", type="string", dest="unit",
  aDVI = DVI(unit=options.unit)
    aDVI.Load(args[0])
    aDVI.Parse(args[0], encoding=options.encoding)
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
(at your option) any later version."""
# (at your option) any later version.
binary format. It is fully documented at
BOP = 139; EOP = 140;
        break
            break
# but WITHOUT ANY WARRANTY; without even the implied warranty of
class DVI(object):
      cnt = [SignedQuad(fp) for i in xrange(10)]
# -*- coding: utf_8 -*-
        continue
          continue
# Copyright (C) 2007-2008 by Jin-Hwan Cho <chofchof@ktug.or.kr>
Copyright (C) 2007-2008 by Jin-Hwan Cho <chofchof@ktug.or.kr>
          count = [GetInt(c) for c in v[1:]]
    c = SignedQuad(fp) # font_check_sum
cur_dsize = 0
    cur_font = f; cur_ssize = z
          cur_font = n; cur_dsize = d; cur_ssize = q
        cur_font = n; cur_ssize = z
cur_font = None
cur_ssize = 0
  def AppendFNT1(self):
def BadDVI(msg):
  def by_bp_conv(self, a):
  def by_cm_conv(self, a):
  def by_in_conv(self, a):
  def by_mm_conv(self, a):
  def by_pt_conv(self, a):
  def by_sp_conv(self, a):
  def CmdPair(self, cmd):
  def ComputeConversionFactors(self):
  def ConvLen(self, s):
  def DefineFont(self, e, fp):
  def Dump(self, fn, tabsize=2, encoding=''):
  def DumpToFile(self, fp, tabsize=2, encoding=''):
  def Get1Arg(self, o, fp):
def Get2Bytes(fp): # { returns the next two bytes, unsigned }
def Get3Bytes(fp): # { returns the next three bytes, unsigned }
def GetByte(fp): # { returns the next byte, unsigned }
  def GetFntDef(self, s):
def GetInt(s):
def GetStrASCII(s): # used in Parse()
def GetStrUTF8(s): # used in Parse()
  def Initialize(self):
  def __init__(self, unit='pt'):
def IsDVI(fname):
def IsFontChanged(f, z):
  def LoadFromFile(self, fp):
  def Load(self, fn):
  def ParseFromString(self, s, encoding=''):
  def Parse(self, fn, encoding=''):
def ProcessOptions():
  def ProcessPage(self, fp):
  def ProcessPostamble(self, fp):
  def ProcessPreamble(self, fp):
def Put2Bytes(q):
def Put3Bytes(q):
def PutByte(q):
def PutSigned(q):
def PutSignedQuad(q):
def PutStrASCII(t): # unsed in Dump()
def PutStrLatin1(t): # unsed in Dump()
def PutStrSJIS(t): # unsed in Dump()
def PutStrUTF8(t): # unsed in Dump()
def PutUnsigned(q):
  def Save(self, fn):
  def SaveToFile(self, fp):
def SignedByte(fp): # { returns the next byte, signed }
def SignedPair(fp): # {returns the next two bytes, signed }
def SignedQuad(fp): # { returns the next four bytes, signed }
def SignedTrio(fp): # { returns the next three bytes, signed }
def UCS2toJIS(c):
def Warning(msg):
  def WriteFontDefinitions(self, fp):
    denominator = SignedQuad(fp)
        d = GetInt(val)
DIR = 255;
DOWN1 = 157; DOWN2 = 158; DOWN3 = 159; DOWN4 = 160;
      d, q = size.split(')', 1)
    d = SignedQuad(fp) # font_design_size
    # DumpFontDefinitions
  # Dump: Internal Format -> Text
    # DumpPages
    # DumpPostamble
    # DumpPreamble
DVIasm is a Python script to support changing or creating DVI files
# DVI class
DVI_ID = 2; DVIV_ID = 3; XDVI_ID = 5;
# DVI identifications
# DVI opcodes
# DVIV opcodes
    elif 32 <= o < 127 or 161 <= o < 256: s += chr(o)
      elif 32 <= o < 127: s += chr(o)
    elif 32 <= o < 127: s += chr(o)
        elif cmd[0] == DIR:
        elif cmd[0] == DOWN1:
        elif cmd[0] == FNT1:
        elif cmd[0] in (RIGHT1, DOWN1):
        elif cmd[0] in (SET_RULE, PUT_RULE):
        elif cmd[0] in (W0, X0, Y0, Z0):
        elif cmd[0] == POP:
        elif cmd[0] == PUSH:
        elif cmd[0] == PUT1:
        elif cmd[0] == PUT_RULE:
        elif cmd[0] == RIGHT1:
        elif cmd[0] == SET1:
        elif cmd[0] == SET_RULE:
        elif cmd[0] == W0:
        elif cmd[0] == W1:
        elif cmd[0] == X0:
        elif cmd[0] == X1:
        elif cmd[0] == XXX1:
        elif cmd[0] == Y0:
        elif cmd[0] == Y1:
        elif cmd[0] == Z0:
        elif cmd[0] == Z1:
      elif d <= 0 or d >= 01000000000:
    elif encoding == 'latin1': PutStr = PutStrLatin1
    elif encoding == 'sjis':   PutStr = PutStrSJIS
      elif is_ptex:
      elif k != 223: break
      elif key == "comment":
      elif key == "denominator":
      elif key == 'dir':
      elif key == 'down':
      elif key == 'fnt':
      elif key == "fntdef":
      elif key == "magnification":
      elif key == "maxh":
      elif key == "maxs":
      elif key == "maxv":
      elif key == "numerator":
      elif key == "pages":
      elif key == 'pop':
      elif key == 'push':
      elif key == 'put':
      elif key == 'putrule':
      elif key == 'right':
      elif key == 'set':
      elif key == 'setrule':
      elif key == 'w':
      elif key == 'w0':
      elif key == 'x':
      elif key == 'x0':
      elif key == 'xxx':
      elif key == 'y':
      elif key == 'y0':
      elif key == 'z':
      elif key == 'z0':
      elif k == FNT_DEF2: p = Get2Bytes(fp)
      elif k == FNT_DEF3: p = Get3Bytes(fp)
      elif k == FNT_DEF4: p = SignedQuad(fp)
      elif k != NOP: break
    elif m == "bp": return int(round(f / self.bp_conv))
    elif m == "cm": return int(round(f / self.cm_conv))
    elif m == "in": return int(round(f / self.in_conv))
    elif m == "mm": return int(round(f / self.mm_conv))
    elif m == "sp": return int(round(f / self.sp_conv))
      elif o < 128:       s += ('\\x%02x' % o)
    elif o < 128:       s += ('\\x%02x' % o)
    elif o < 256:                         s += ('\\x%02x' % o)
    elif o < 256:       s += ('\\x%02x' % o)
    elif o < 65536:                       s += ('\\u%04x' % o)
    elif o < 65536:     s += ('\\u%04x' % o)
      elif o == BOP:
      elif o == DIR:
      elif o == EOP:
      elif o < FNT_NUM_0 + 64 or o in (FNT1, FNT2, FNT3, FNT4):
      elif o in (DOWN1, DOWN2, DOWN3, DOWN4):
      elif o in (FNT_DEF1, FNT_DEF2, FNT_DEF3, FNT_DEF4):
      elif o in (POST, POST_POST):
      elif o in (PUT1, PUT2, PUT3, PUT4):
      elif o in (RIGHT1, RIGHT2, RIGHT3, RIGHT4):
      elif o in (W1, W2, W3, W4):
      elif o in (X1, X2, X3, X4):
      elif o in (XXX1, XXX2, XXX3, XXX4):
      elif o in (Y1, Y2, Y3, Y4):
      elif o in (Z1, Z2, Z3, Z4):
      elif o == NOP:
      elif o == POP:
      elif o == PRE:
      elif o == PUSH:
      elif o == PUT_RULE:
      elif o == W0:
      elif o == X0:
      elif o == Y0:
      elif o == Z0:
    elif unit == 'bp': self.byconv = self.by_bp_conv
    elif unit == 'cm': self.byconv = self.by_cm_conv
    elif unit == 'in': self.byconv = self.by_in_conv
    elif unit == 'mm': self.byconv = self.by_mm_conv
            else:
          else:
        else:
      else:
    else:
    else:              aDVI.DumpToFile(sys.stdout, tabsize=options.tabsize, encoding=options.encoding)
    else:              aDVI.SaveToFile(sys.stdout)
  else: # dump -> dvi
    else:                   GetStr = GetStrUTF8
  else: # not the case of subfont
    else:                      PutStr = PutStrUTF8
  else:         return ''
  else: return ''
  else: return ((a - 256) << 8) + b
  else: return ((((a - 256) << 8) + b) << 8) + c
  else: return ((((((a - 256) << 8) + b) << 8) + c) << 8) + d
  else: return b - 256
    else:           return "%fbp" % v
    else:           return "%fcm" % v
    else:           return "%fin" % v
    else:           return "%fmm" % v
    else:           return "%fpt" % v
    else:       return [ord(c)       for c in t]
  else:           return (ord(s[3]) << 8) + ord(s[4])
          else:       s.append(chr(XXX4) + PutSignedQuad(l) + cmd[1])
          else:           s.append(self.CmdPair(cmd))
            else:       s.append(self.CmdPair([SET1, o]))
    else:              self.byconv = self.by_pt_conv
      else:               s += unichr(o).encode('utf8')
        else: v = l.split(' ')
            e = self.fnt_num
      e = self.fnt_num
            e = self.font_def.keys()[self.font_def.values().index(f)]
      e = self.font_def.keys()[self.font_def.values().index(f)]
          except:
      except:
    except:
  except:
  except: BadDVI('Failed to Get2Bytes()')
  except: BadDVI('Failed to Get3Bytes()')
  except: BadDVI('Failed to get SignedQuad()')
  except: BadDVI('Failed to SignedPair()')
  except: BadDVI('Failed to SignedTrio()')
    except: d = q
    except KeyError:
    except: pass
      except: return 0
    except: return 0
  except: return -1
    f = {'name':cur_font+"%02x"%subfont_idx, 'design_size':cur_dsize, 'scaled_size':cur_ssize, 'checksum':0}
          f = {'name':n, 'design_size':d, 'scaled_size':q, 'checksum':0}
FNT1 = 235; FNT2 = 236; FNT3 = 237; FNT4 = 238;
FNT_DEF1 = 243; FNT_DEF2 = 244; FNT_DEF3 = 245; FNT_DEF4 = 246;
FNT_NUM_0 = 171; FNT_NUM_63 = 234;
      for cmd in page['content']:
    for e in sorted(self.font_def.keys()):
    for l in options.subfont:
    for l in s.split('\n'):
  for n in subfont_list:
          for o in cmd[1]:
          for o in ol[1:]:
    for o in t:
  for o in t:
    for page in self.pages:
    fp.close()
    fp = file(fname, 'rb')
    fp = file(fn, 'r')
    fp = file(fn, 'rb')
    fp = file(fn, 'w')
    fp = file(fn, 'wb')
    fp.seek(0)
    fp.seek(0, 2)
      fp.seek(-2, 1)
    fp.seek(-4, 2)
    fp.seek(-5, 1)
    fp.seek(-5, 2) # at least four 223's
      fp.seek(loc)
    fp.seek(q) # move to post
            fp.write("at %s\n" % self.by_pt_conv(cur_ssize))
      fp.write("at %s\n" % self.by_pt_conv(self.font_def[e]['scaled_size']))
    fp.write("comment: %s\n" % repr(self.comment))
    fp.write("denominator: %d\n" % self.denominator)
          fp.write("dir: %d\n" % cmd[1])
          fp.write("down: %s\n" % self.byconv(cmd[1]))
      fp.write("fntdef: %s " % self.font_def[e]['name'])
            fp.write("fnt: %s " % cur_font)
    fp.write("id: %d\n" % self.id)
    fp.write(''.join([chr(POST_POST), PutSignedQuad(post_loc), PutByte(self.id), '\xdf\xdf\xdf\xdf']))
    fp.write(''.join([chr(POST), PutSignedQuad(loc), PutSignedQuad(self.numerator), PutSignedQuad(self.denominator), PutSignedQuad(self.mag), PutSignedQuad(self.max_v), PutSignedQuad(self.max_h), Put2Bytes(stackdepth+1), Put2Bytes(len(self.pages))]))
    fp.write(''.join([chr(PRE), PutByte(self.id), PutSignedQuad(self.numerator), PutSignedQuad(self.denominator), PutSignedQuad(self.mag), PutByte(len(self.comment)), self.comment]))
      fp.write(''.join(s))
    fp.write(''.join(s))
    fp.write("magnification: %d\n" % self.mag)
    fp.write("maxh: %s\n" % self.byconv(self.max_h))
    fp.write("maxs: %d\n" % self.max_s)
    fp.write("maxv: %s\n" % self.byconv(self.max_v))
    fp.write("\n[font definitions]\n")
      fp.write("\n[page" + (" %d"*10 % tuple(page['count'])) + "]\n")
    fp.write("\n[postamble]\n")
    fp.write("numerator: %d\n" % self.numerator)
    fp.write("pages: %d\n" % self.total_pages)
    fp.write("[preamble]\n")
          fp.write("push:\n")
          fp.write("putrule: %s %s\n" % (self.byconv(cmd[1][0]), self.byconv(cmd[1][1])))
          fp.write("put: %s\n" % PutStr(cmd[1]))
          fp.write("right: %s\n" % self.byconv(cmd[1]))
          fp.write("setrule: %s %s\n" % (self.byconv(cmd[1][0]), self.byconv(cmd[1][1])))
          fp.write("set: %s\n" % PutStr(cmd[1]))
        fp.write("%s" % (' ' * indent))
          fp.write("%spop:\n" % (' ' * indent))
              fp.write("(%s) " % self.by_pt_conv(self.font_def[cmd[1]]['design_size']))
        fp.write("(%s) " % self.by_pt_conv(self.font_def[e]['design_size']))
          fp.write("w0:\n")
          fp.write("w: %s\n" % self.byconv(cmd[1]))
          fp.write("x0:\n")
      fp.write('\xdf'); loc += 1
          fp.write("x: %s\n" % self.byconv(cmd[1]))
          fp.write("xxx: %s\n" % repr(cmd[1]))
          fp.write("y0:\n")
          fp.write("y: %s\n" % self.byconv(cmd[1]))
          fp.write("z0:\n")
          fp.write("z: %s\n" % self.byconv(cmd[1]))
from optparse import OptionParser
  from os.path import splitext
          f = self.font_def[cmd[1]]['name']
      f = self.font_def[e]
  global cur_font, cur_ssize, subfont_idx, is_subfont
    global GetStr, cur_font, cur_dsize, cur_ssize, subfont_idx
    global is_ptex
    global PutStr
    global subfont_list
# Global variables
GLYPH_ARRAY = 253; GLYPH_STRING = 254;
# GNU General Public License for more details.
                    help="encoding for input/output [default=%default]")
                    help="extended DVI for Japanese pTeX")
                    help="filename for output instead of stdout")
                    help="tab size for push/pop [default=%default]")
                    help="the list of fonts with UCS2 subfont scheme (comma separated); disable internal subfont list if STR is empty")
                    help="unit (sp, pt, bp, mm, cm, in) [default=%default]")
http://ajt.ktug.kr/assets/2008/5/1/0201cho.pdf"""
http://tug.org/TUGboat/Articles/tb28-2/tb89cho.pdf 
    id = GetByte(fp)
            idx = (o >> 8)
  if 0 <= q < 0x800000:               return PutUnsigned(q)
  if a < 128: return (a << 8) + b
  if a < 128: return (((a << 8) + b) << 8) + c
  if a < 128: return (((((a << 8) + b) << 8) + c) << 8) + d
  if b < 128: return b
        if cmd[0] == POP:
        if cmd[0] == PUSH:
        if cmd[0] == SET1:
          if cmd[1] < 64: s.append(chr(FNT_NUM_0 + cmd[1]))
      if cur_font == n and cur_ssize == z:
        if d <= 0:
    if denominator <= 0:
    if encoding == 'ascii': GetStr = GetStrASCII
    if   encoding == 'ascii':  PutStr = PutStrASCII
      if f['checksum'] != c:
      if f['design_size'] != d:
      if f['name'] != n:
    if fp.tell() < 53: BadDVI('less than 53 bytes long')
      if f['scaled_size'] != q:
    if GetByte(fp) != 223: return False
      if GetByte(fp) != BOP: BadDVI('byte %d is not bop' % fp.tell())
    if GetByte(fp) != PRE: BadDVI("First byte isn't start of preamble")
    if GetByte(fp) != PRE: return False
    if id != DVI_ID and id != DVIV_ID and id != XDVI_ID:
            if idx != subfont_idx:
  if IsDVI(args[0]): # dvi -> dump
          if IsFontChanged(f, z):
    if is_ptex: return [UCS2toJIS(c) for c in t]
        if is_subfont:
  if is_subfont:
      if   k < 0:    BadDVI('all 223s; is it a DVI file?') # found EOF
    if k != DVI_ID and k != DVIV_ID and k != XDVI_ID:
      if key == "id":
      if   k == FNT_DEF1: p = GetByte(fp)
    if k != POST: BadDVI('byte %d is not post' % k)
    if k != POST_POST:
        if l[-1] == ']': v = l[:-1].split(' ')
          if l < 256: s.append(chr(XXX1) + chr(l) + cmd[1])
  if len(args) != 1:
          if len(count) < 10: count += ([0] * (10-len(count)))
  if len(s) > 1 and ((s[0] == "'" and s[-1] == "'") or (s[0] == '"' and s[-1] == '"')):
  if len(s) > 1 and ((s[0] == "'" and s[-1] == "'") or (s[0] == '"' and s[-1] == '"')): return [ord(c) for c in s[1:-1].decode('unicode_escape')]
  if len(s) == 1: return ord(s)
          if len(stack) > stackdepth: stackdepth = len(stack)
        if len(v) != 2:
    if mag <= 0:
    if m != DVI_ID and m != DVIV_ID and m != XDVI_ID:
    if   m == "pt": return int(round(f / self.pt_conv))
if __name__ == '__main__':
    if n == f[:-2]:
        if n in subfont_list:
      if not l or l[0] == '%': continue
  if not options.encoding in ['ascii', 'latin1', 'utf8', 'sjis']:
    if not options.encoding in ['utf8', 'sjis']:
    if not options.subfont[0]: # disable subfont
  if not options.unit in ['sp', 'pt', 'bp', 'mm', 'cm', 'in']:
    if numerator <= 0:
            if o < 128: s.append(chr(SET_CHAR_0 + o))
      if o == 92:         s += '\\\\'
    if o == 92:                           s += '\\\\'
    if o == 92:         s += '\\\\'
    if o < FNT_NUM_0 + 64:
    if o in (NOP, BOP, EOP, PUSH, POP, PRE, POST, POST_POST) or o > POST_POST:
    if o in (RIGHT1, W1, X1, DOWN1, Y1, Z1):
    if o in (RIGHT2, W2, X2, DOWN2, Y2, Z2):
    if o in (RIGHT3, W3, X3, DOWN3, Y3, Z3):
    if o in (SET1, PUT1, FNT1, XXX1, FNT_DEF1, DIR):
    if o in (SET2, PUT2, FNT2, XXX2, FNT_DEF2):
    if o in (SET3, PUT3, FNT3, XXX3, FNT_DEF3):
    if o in (SET4, SET_RULE, PUT4, PUT_RULE, RIGHT4, W4, X4, DOWN4, Y4, Z4, FNT4, XXX4, FNT_DEF4):
    if o in (W0, X0, Y0, Z0):
    if options.output: aDVI.Dump(options.output, tabsize=options.tabsize, encoding=options.encoding)
    if options.output: aDVI.Save(options.output)
  if options.ptex:
  if options.subfont:
  if options.tabsize < 0: 
    if o < SET_CHAR_0 + 128:
          if o < SET_CHAR_0 + 128 or o in (SET1, SET2, SET3, SET4):
      if o < SET_CHAR_0 + 128 or o in (SET1, SET2, SET3, SET4):
      if o == SET_RULE:
      if q <= 0 or q >= 01000000000:
    if q < 0 or q > m - 33: BadDVI('post pointer %d at byte %d' % (q, m - 4))
  if q < 0: q += 0x100000000
  if q >= 0x1000000: return (3, PutSignedQuad(q))
  if q >= 0x10000:   return (2, Put3Bytes(q))
  if q >= 0x100:     return (1, Put2Bytes(q))
  if q < -0x800000 or q >= 0x800000:  return (3, PutSignedQuad(q))
  if q < -0x8000:     q += 0x1000000; return (2, Put3Bytes(q))
  if q < -0x80:       q += 0x10000;   return (1, Put2Bytes(q))
    if q[:2] == "at": q = q[2:]
            if self.font_def[cmd[1]]['design_size'] != self.font_def[cmd[1]]['scaled_size']:
      if self.font_def[e]['design_size'] != self.font_def[e]['scaled_size']:
        if self.id != DVI_ID and self.id != DVIV_ID and self.id != XDVI_ID:
    if SignedQuad(fp) != self.denominator:
    if SignedQuad(fp) != self.mag:
    if SignedQuad(fp) != self.numerator:
    if SignedQuad(fp) != self.post_loc:
  if splitext(fname)[1] != '.dvi': return False
    if   unit == 'sp': self.byconv = self.by_sp_conv
        if v[0] == "[page":
    if v == int(v): return "%dbp" % int(v)
    if v == int(v): return "%dcm" % int(v)
    if v == int(v): return "%din" % int(v)
    if v == int(v): return "%dmm" % int(v)
    if v == int(v): return "%dpt" % int(v)
import sys, os.path
      indent = 0
          indent -= tabsize
          indent += tabsize
  # Initialize: Required by __init__(), Load(), and Parse()
is_ptex = False
    is_ptex = True
          is_subfont = False
    is_subfont = False
is_subfont = False
          is_subfont = True
      is_subfont = True
# it under the terms of the GNU General Public License as published by
it under the terms of the GNU General Public License as published by
        key = key.strip(); val = val.strip()
        key, val = l.split(':', 1)
      k = GetByte(fp)
    k = GetByte(fp)
          l = len(cmd[1])
      l = l.strip()
  # Load: DVI -> Internal Format
      loc = fp.tell()
    loc = fp.tell()
    loc = self.first_backpointer
      loc = SignedQuad(fp)
    l, q = PutSigned(cmd[1])
      l, q = PutUnsigned(e)
    mag = SignedQuad(fp)
# Main Routine
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                    metavar="FILE",
                    metavar="INT",
                    metavar="STR",
    m = fp.tell() # id_byte
    m = GetByte(fp)
  # Misc Functions
# Misc Functions for Main Routine
    m = s[-2:]
        msssage("%s---not loaded, bad design size (%d)!" % (n, d))
NATIVE_FONT_DEF = 250;
    n = fp.read(GetByte(fp) + GetByte(fp))
              nl.append(o & 0xff)
              nl = [o & 0xff]
          nl = [ol[0] & 0xff]
    n = n.strip(); q = q.strip()
NOP = 138;
        n, q, d = self.GetFntDef(val)
      n, q = s.split(' ', 1)
      n, size = s.split('(', 1)
    numerator = SignedQuad(fp)
          o = GetByte(fp)
      o = GetByte(fp)
        ol = GetStr(val)
  (options, args) = parser.parse_args()
  (options, args) = ProcessOptions()
      page = self.ProcessPage(fp)
      # Parse Font Definitions
      # Parse Pages
      # Parse Postamble
      # ParsePreamble
  parser.add_option("-e", "--encoding",
  parser.add_option("-o", "--output",
  parser.add_option("-p", "--ptex",
  parser.add_option("-s", "--subfont",
  parser.add_option("-t", "--tabsize",
  parser.add_option("-u", "--unit",
      parser.error("invalid encoding '%s' for Japanese pTeX!" % options.encoding)
    parser.error("invalid encoding '%s'!" % options.encoding)
    parser.error("invalid unit name '%s'!" % options.unit)
    parser.error("negative tabsize!")
    parser.error("try with the option --help!")
  parser = OptionParser(usage=usage, version=version)
  parser.set_defaults(unit='pt', encoding='utf8', tabsize=2)
  # Parse: Text -> Internal Format
PDF_FILE = 251; PIC_FILE = 252;
    post_loc = fp.tell()
PRE = 247; POST = 248; POST_POST = 249;
          p = self.Get1Arg(o, fp)
      p = self.Get1Arg(o, fp)
PUSH = 141; POP = 142;
PUT1 = 133; PUT2 = 134; PUT3 = 135; PUT4 = 136;
PUT_RULE = 137;
            q.append(p)
        q = fp.read(p)
        q = [p]
    q = self.ConvLen(q.strip())
    q = SignedQuad(fp)
    q = SignedQuad(fp) # font_scaled_size
  raise AttributeError, 'Bad DVI file: %s!' % msg
      return 0
  return (0, PutByte(q))
  return (a << 8) + b
  return (((a << 8) + b) << 8) + c
    return chr(cmd[0] + l) + q
  return chr(q & 0xff)
    return "%dsp" % int(v)
        return False
    return False
      return Get2Bytes(fp)
      return Get3Bytes(fp)
      return GetByte(fp)
    return n, q, d
      return o - FNT_NUM_0
  return (options, args)
      return o - SET_CHAR_0
  return PutByte(q>>16) + PutByte(q>>8) + PutByte(q)
  return PutByte(q>>24) + PutByte(q>>16) + PutByte(q>>8) + PutByte(q)
  return PutByte(q>>8) + PutByte(q)
    return s
      return SignedByte(fp)
      return SignedPair(fp)
      return SignedQuad(fp)
      return SignedTrio(fp)
  return "'%s'" % s
        return True
    return True
  return True
RIGHT1 = 143; RIGHT2 = 144; RIGHT3 = 145; RIGHT4 = 146;
    s = []
  s = ''
          s.append(chr(cmd[0]))
          s.append(chr(cmd[0]) + PutSignedQuad(cmd[1][0]) + PutSignedQuad(cmd[1][1]))
          s.append(chr(DIR) + chr(cmd[1]))
      s.append(chr(EOP))
          s.append(chr(POP))
          s.append(chr(PUSH))
        s.append([DIR, p])
        s.append([DOWN1, p])
        s.append([FNT1, p])
        s.append([POP])
        s.append([PUSH])
        s.append([PUT1, p])
      s.append(PutByte(FNT_DEF1 + l))
      s.append(PutByte(len(self.font_def[e]['name'])))
        s.append([PUT_RULE, [p, SignedQuad(fp)]])
      s.append(PutSignedQuad(loc))
      s.append(PutSignedQuad(self.font_def[e]['checksum']))
      s.append(PutSignedQuad(self.font_def[e]['design_size']))
      s.append(PutSignedQuad(self.font_def[e]['scaled_size']))
      s.append(q)
        s.append([RIGHT1, p])
          s.append(self.CmdPair(cmd))
          s.append(self.CmdPair([PUT1, cmd[1][0]]))
      s.append(self.font_def[e]['name'])
        s.append([SET1, q])
        s.append([SET_RULE, [p, SignedQuad(fp)]])
        s.append([W0])
        s.append([W1, p])
        s.append([X0])
      s.append('\x00')
        s.append([X1, p])
        s.append([XXX1, q])
        s.append([Y0])
        s.append([Y1, p])
        s.append([Z0])
        s.append([Z1, p])
  # Save: Internal Format -> DVI
  s = c.encode('iso2022-jp')
      s = [chr(BOP)]
              self.AppendFNT1()
          self.AppendFNT1()
    self.bp_conv = (self.numerator / 254000.) * (72. / self.denominator)
    self.cm_conv = (self.numerator / 100000.) / self.denominator
    self.comment = ''
    self.comment = fp.read(GetByte(fp))
        self.comment = val[1:-1]
          self.ComputeConversionFactors()
    self.ComputeConversionFactors()
          self.cur_page = []
        self.cur_page.append([DIR, GetInt(val)])
        self.cur_page.append([DOWN1, self.ConvLen(val)])
          self.cur_page.append([FNT1, e])
    self.cur_page.append([FNT1, e])
        self.cur_page.append([POP])
        self.cur_page.append([PUSH])
        self.cur_page.append([PUT1, GetStr(val)])
        self.cur_page.append([PUT_RULE, [self.ConvLen(c) for c in v]])
        self.cur_page.append([RIGHT1, self.ConvLen(val)])
              self.cur_page.append([SET1, nl])
          self.cur_page.append([SET1, nl])
          self.cur_page.append([SET1, ol])
        self.cur_page.append([SET_RULE, [self.ConvLen(c) for c in v]])
        self.cur_page.append([W0])
        self.cur_page.append([W1, self.ConvLen(val)])
        self.cur_page.append([X0])
        self.cur_page.append([X1, self.ConvLen(val)])
        self.cur_page.append([XXX1, eval(val)])
        self.cur_page.append([Y0])
        self.cur_page.append([Y1, self.ConvLen(val)])
        self.cur_page.append([Z0])
        self.cur_page.append([Z1, self.ConvLen(val)])
        self.DefineFont(p, fp)
      self.DefineFont(p, fp)
    self.denominator = 473628672
          self.denominator = d
      self.denominator = denominator
    self.DumpToFile(fp, tabsize=tabsize, encoding=encoding)
    self.first_backpointer = SignedQuad(fp)
    self.fnt_num = 0
            self.fnt_num += 1
        self.fnt_num += 1
      self.fnt_num += 1
    self.font_def = {}
      self.font_def[e] = f
      self.font_def[e] = {'name':n, 'checksum':c, 'scaled_size':q, 'design_size':d}
            self.font_def[self.fnt_num] = f
        self.font_def[self.fnt_num] = {'name':n, 'design_size':d, 'scaled_size':q, 'checksum':0}
    self.id = DVI_ID
        self.id = GetInt(val)
      self.id = id
    self.in_conv = (self.numerator / 254000.) * (1. / self.denominator)
    self.Initialize()
    self.LoadFromFile(fp)
    self.mag = 1000
          self.mag = d
      self.mag = mag
        self.max_h = self.ConvLen(val)
    self.max_h = SignedQuad(fp)
    self.max_s = Get2Bytes(fp)
        self.max_s = GetInt(val)
        self.max_v = self.ConvLen(val)
    self.max_v = self.max_h = self.max_s = self.total_pages = 0
    self.max_v = SignedQuad(fp)
    self.mm_conv = (self.numerator / 10000.) / self.denominator
    self.numerator   = 25400000
          self.numerator = d
      self.numerator = numerator
    self.pages = []
          self.pages.append({'count':count, 'content':self.cur_page})
      self.pages.insert(0, {'count':cnt, 'content':page})
    self.ParseFromString(s, encoding=encoding)
    self.post_loc = q
    self.ProcessPostamble(fp)
    self.ProcessPreamble(fp)
    self.pt_conv = (self.numerator / 25400000.) * (7227. / self.denominator)
    self.SaveToFile(fp)
    self.sp_conv = (self.numerator / 25400000.) * (473628672. / self.denominator)
    self.total_pages = Get2Bytes(fp)
        self.total_pages = GetInt(val)
    self.WriteFontDefinitions(fp)
SET1 = 128; SET2 = 129; SET3 = 130; SET4 = 131;
SET_CHAR_0 = 0; SET_CHAR_127 = 127;
SET_RULE = 132;
      s.extend([PutSignedQuad(c) for c in page['count']])
    s = fp.read()
      s += ''.join(['\x1b$B', chr(o/256), chr(o%256)]).decode('iso2022-jp').encode('sjis')
        s += ''.join(['\x1b$B', chr(o/256), chr(o%256)]).decode('iso2022-jp').encode('utf8')
          stack.append((w, x, y, z))
    stackdepth = 0; loc = -1
subfont_idx = 0
              subfont_idx = idx
      subfont_idx = int(f[-2:], 16)
          subfont_idx = (ol[0] >> 8)
      subfont_list = []
subfont_list = ['cyberb', 'outbtm', 'outbtb', 'outgtm', 'outgtb']
      subfont_list.extend([f.strip() for f in l.split(',')])
      s += unichr((subfont_idx << 8) + o).encode('utf8')
    sys.stderr.write('Failed to read %s\n' % fname)
  sys.stderr.write('%s\n' % msg)
the Free Software Foundation; either version 2 of the License, or
# the Free Software Foundation, either version 3 of the License, or
# This is DVIasm, a DVI utility for editing DVI files directly.
This is free software; you can redistribute it and/or modify
# This program is distributed in the hope that it will be useful,
# This program is free software: you can redistribute it and/or modify
          try:
      try:
    try:
  try: a, b, c, d = map(ord, fp.read(4))
  try: a, b, c = map(ord, fp.read(3))
  try: a, b = map(ord, fp.read(2))
  try: b = ord(fp.read(1))
    try:    d = self.ConvLen(d.strip())
    try:    f = float(s[:-2])
      try:    return int(round(f / self.pt_conv))
    try:    return int(s)
  try: return int(s)
  try: return ord(fp.read(1))
    t = s[1:-1].decode('string_escape').decode('utf8')
  usage = """%prog [options] dvi_file|dvi_dump_file
#! /usr/bin/env python
  version = """This is %prog-20080520 by Jin-Hwan Cho (Korean TeX Society)
via disassembling into text, editing, and then reassembling into
    v = self.bp_conv * a
    v = self.cm_conv * a
    v = self.in_conv * a
    v = self.mm_conv * a
    v = self.pt_conv * a
    v = self.sp_conv * a
        v = val.split(' ')
W0 = 147; W1 = 148; W2 = 149; W3 = 150; W4 = 151;
      Warning('bad postamble pointer in byte %d!' % (fp.tell() - 4))
        Warning('bop occurred before eop!')
      Warning('byte %d is not postpost!' % (fp.tell() - 1))
      Warning("denominator doesn't match the preamble!")
      Warning('denominator is %d; use the default 473628672!' % denominator)
      Warning('ID byte is %d' % k)
      Warning("ID byte is %d; use the default %d!" % (id, DVI_ID))
          Warning("identification byte should be %d, %d, or %d!" % (DVI_ID, DVIV_ID, XDVI_ID))
      Warning('identification in byte %d should be %d, %d, or %d!' % (fp.tell() - 1, DVI_ID, DVIV_ID, XDVI_ID))
          Warning('invalid command %s!' % cmd[0])
        Warning('invalid command %s!' % key)
      Warning("magnification doesn't match the preamble!")
      Warning('magnification is %d; use the default 1000!' % mag)
          Warning('non-positive denominator %d!' % d)
          Warning('non-positive magnification %d!' % d)
          Warning('non-positive numerator %d!' % d)
      Warning('Not support characters > 65535; may skip %d.\n' % o)
      Warning("numerator doesn't match the preamble!")
      Warning('numerator is %d; use the default 25400000!' % numerator)
        Warning('postamble command %d!' % o)
        Warning('preamble command within a page!')
        Warning("%s---not loaded, bad scale (%d)!" % (n, q))
        Warning("\t---check sum doesn't match previous definition!")
        Warning("\t---design size doesn't match previous definition!")
        Warning("\t---font name doesn't match previous definition!")
        Warning("\t---scaled size doesn't match previous definition!")
          Warning('two values are required for putrule!')
          Warning('two values are required for setrule!')
        Warning('undefined command %d!' % o)
          w = cmd[1]; s.append(self.CmdPair(cmd))
    while loc >= 0:
    while (loc % 4) != 0:
        while True:
    while True:
    # WriteFontDefinitions
    # WritePages
    # WritePostamble
    # WritePostPostamble
    # WritePreamble
      w = x = y = z = 0; stack = []
          w, x, y, z = stack.pop()
X0 = 152; X1 = 153; X2 = 154; X3 = 155; X4 = 156;
          x = cmd[1]; s.append(self.CmdPair(cmd))
# XDVI opcodes (not supported yet!)
XXX1 = 239; XXX2 = 240; XXX3 = 241; XXX4 = 242;
Y0 = 161; Y1 = 162; Y2 = 163; Y3 = 164; Y4 = 165;
          y = cmd[1]; s.append(self.CmdPair(cmd))
# You should have received a copy of the GNU General Public License
Z0 = 166; Z1 = 167; Z2 = 168; Z3 = 169; Z4 = 170;
          z = cmd[1]; s.append(self.CmdPair(cmd))
          z = self.font_def[cmd[1]]['scaled_size']
