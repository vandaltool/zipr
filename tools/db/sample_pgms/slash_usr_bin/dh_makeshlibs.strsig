ABI without updating the upstream version number), so that if the
		addsubstvar($package, "misc:Pre-Depends", "multiarch-support");
	"add-udeb=s" => \$dh{SHLIBS_UDEB},
a Pre-Dependency on multiarch-support is set in ${misc:Pre-Depends} ;
				# as a side effect.
Assuming the current version of the package is 1.1-3, generates a shlibs
Assuming this is a package named F<libfoobar1>, generates a shlibs file that
		autoscript($package,"postinst","postinst-makeshlibs");
		autoscript($package,"postrm","postrm-makeshlibs");
B<dh_makeshlibs> is a debhelper program that automatically scans for shared
B<dh_makeshlibs> [S<I<debhelper options>>] [B<-m>I<major>] [B<-V>I<[dependencies]>] [B<-n>] [B<-X>I<item>] [S<B<--> I<params>>]
	# because only if we can get a library name and a major number from
be processed and installed. Use the I<arch> specific names if you need
(be sure to include the package name).
be upgraded.
Beware of using B<-V> without any parameters; this is a conservative setting
By default, the shlibs file generated by this program does not make packages
				# Call isnative becuase it sets $dh{VERSION}
	close FIND;
				complex_doit("echo '$line' >>$tmp/DEBIAN/shlibs");
		complex_doit("echo '$_' >>$tmp/DEBIAN/shlibs");
Create an additional line for udebs in the shlibs file and use I<udeb> as the
debhelper compatibility levels before v4, the Debian part of the package
debian/control file for packages supporting multiarch.
				# debian revision, while new do not.
dependency that looks like "I<packagename> B<(E<gt>>= I<packageversion>B<)>". Note that in
depend on any particular version of the package containing the shared
				$deps=$dh{V_FLAG};
				$deps="$package (>= $version)";
dh_makeshlibs - automatically create shlibs file and call dpkg-gensymbols
			@{$dh{U_PARAMS}});
		doit("chmod",644,"$tmp/DEBIAN/shlibs");
		doit("chown","0:0","$tmp/DEBIAN/shlibs");
		doit("dpkg-gensymbols", "-p$package", "-I$symbols",
			doit("install","-d","$tmp/DEBIAN");
	doit("rm", "-f", "$tmp/DEBIAN/shlibs");
			doit("rm", "-f", "$tmp/DEBIAN/symbols");
Do not modify F<postinst>/F<postrm> scripts.
	# dpkg-gensymbols files
			else {
		elsif ($ret=~m/\s+SONAME\s+(.+)-(.+)\.so/) {
		$exclude="! \\( $dh{EXCLUDE_FIND} \\) ";
Exclude files that contain I<item> anywhere in their filename or directory 
file that looks something like:
foreach my $package (@{$dh{DOPACKAGES}}) {
	foreach (@udeb_lines) {
from being treated as shared libraries.
Generates a shlibs file that looks something like:
=head1 AUTHOR
=head1 DESCRIPTION
=head1 EXAMPLES
=head1 FILES
=head1 NAME
=head1 OPTIONS
=head1 SEE ALSO
=head1 SYNOPSIS
			# idiotic crap soname format
	if (! compat(2) && ! $dh{NOSCRIPTS} && $need_ldconfig) {
				if (! compat(3)) {
		if (! compat(7)) {
	if (defined($dh{EXCLUDE_FIND}) && $dh{EXCLUDE_FIND} ne '') {
		if (defined($dh{M_PARAMS}) && $dh{M_PARAMS} ne '') {
				if (defined($dh{SHLIBS_UDEB}) && $dh{SHLIBS_UDEB} ne '') {
		if (defined($library) && defined($major) && defined($deps) &&
		if (defined $multiarch && $multiarch ne '' && m,/$multiarch/,) {
			if ($dh{V_FLAG} ne '') {
		if ($dh{V_FLAG_SET}) {
		if (! -d "$tmp/DEBIAN") {
	if (-e $symbols) {
	if (-e "$tmp/DEBIAN/shlibs") {
	if ($is_multiarch) {
		if ($ret=~m/\s+SONAME\s+(.+)\.so\.(.+)/) {
			if (! $seen{$line}) {
		if (-s "$tmp/DEBIAN/symbols" == 0) {
		# -I is used rather than using dpkg-gensymbols
information, the current upstream version of the package is plugged into a
information to the shlibs file. If B<-V> is specified with no dependency
init(options => {
Instead of trying to guess the major number of the library with objdump,
			$is_multiarch=1;
				isnative($package);
		# is not 100% compatible with debhelper. (For example,
It also adds a call to ldconfig in the F<postinst> and F<postrm> scripts (in
=item B<--add-udeb=>I<udeb>
=item B<dh_makeshlibs>
=item B<dh_makeshlibs -V>
=item B<dh_makeshlibs -V 'libfoobar1 (E<gt>= 1.0)'>
=item B<--> I<params>
=item B<-m>I<major>, B<--major=>I<major>
=item B<-n>, B<--noscripts>
=item B<-V>, B<-V>I<dependencies>
=item B<--version-info>, B<--version-info=>I<dependencies>
=item B<-X>I<item>, B<--exclude=>I<item>
=item debian/I<package>.symbols
=item debian/I<package>.symbols.I<arch>
Joey Hess <joeyh@debian.org>
L<debhelper(7)>
least as tight as they need to be (unless your library is prone to changing
 libfoobar 1 libfoobar1
  libfoobar 1 libfoobar1 (>= 1.0)
 libfoobar 1 libfoobar1 (>= 1.1)
			@liblist,
			@liblist=map { "-e$_" } @lib_files;
libraries, and generates a shlibs file for the libraries it finds.
			$library=$1;
library. It may be necessary for you to add some version dependency
		    $library ne '' && $major ne '' && $deps ne '') {
			    		$line="udeb: "."$library $major $udeb_deps";
looked at library filenames rather than using objdump.
looks something like:
maintainer screws up then they won't break. The flip side is that packages
			$major=$2;
			$major=$dh{M_PARAMS};
	"major=s" => \$dh{M_PARAMS},
	# match "*.so.*". And we only look at real files not
might end up with dependencies that are too tight and so find it harder to
	"m=s", => \$dh{M_PARAMS},
		my $deps=$package;
	my $exclude='';
	my $is_multiarch = 0;
		my @liblist;
		my ($library, $major);
		    	my $line="$library $major $deps";
my $multiarch=dpkg_architecture_value("DEB_HOST_MULTIARCH");
	my $need_ldconfig = 0;
my $objdump=cross_command("objdump");
		my $ret=`$objdump -p $_`;
	my %seen;
	my $symbols=pkgfile($package, "symbols");
	my $tmp=tmpdir($package);
					my $udeb_deps = $deps;
	my (@udeb_lines, @lib_files);
				my $version = $dh{VERSION};
		    	$need_ldconfig=1;
	# New as of dh_v3.
	next if is_udeb($package);
	# objdump is anything actually added.
				# Old compatibility levels include the
	open (FIND, "find $tmp -type f \\( -name '*.so' -or -name '*.so.*' \\) $exclude |");
		# own search for symbols files, since that search
package name for udebs to depend on instead of the regular library package.
Packages that support multiarch are detected, and
	# packages. This may have a few false positives, which is ok,
parameters can be used to specify the exact dependency information needed
Pass I<params> to L<dpkg-gensymbols(1)>.
		    	# Prevent duplicate lines from entering the file.
			# proper soname format
			"-P$tmp",
		push @lib_files, $_;
					push @udeb_lines, $line;
					# Remove debian version, if any.
				$seen{$line}=1;
	# So, we look for files or links to existing files with names that
	# symlinks, so we don't accidentually add shlibs data to -dev
that always ensures that other packages' shared library dependencies are at
These symbols files, if present, are passed to L<dpkg-gensymbols(1)> to
This program is a part of debhelper.
		# this supports --ignore being used.)
to provide different symbols files for different architectures.
					$udeb_deps =~ s/\Q$package\E/$dh{SHLIBS_UDEB}/e;
use Debian::Debhelper::Dh_Lib;
useful than it used to be, back in the bad old days when this program
use strict;
use the major number specified after the -m parameter. This is much less
#!/usr/bin/perl -w
v3 mode and above only) to any packages in which it finds shared libraries.
	"version-info:s" => \$dh{V_FLAG},
version number is also included. If B<-V> is specified with parameters, the
					$version =~ s/-[^-]+$//;
	while (<FIND>) {
	# Write udeb: lines last.
you should make sure to put that token into an appropriate place in your
