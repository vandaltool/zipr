# ######## #
# ########## #
# ########### #
# ############# #
## Actually use our module ##
Alignment is not available when using this,
a little more compatible, see L</--file-compat>.
	# --all
	'all'		=> ['a'],
All other files are compiled from these source files. To re-compile them
Also the default becomes to print descriptions instead of mimetypes.
Also the wording of the descriptions will differ.
are ignored.
	: $args{brief}
			$args{database}
		$args{describe} ? desc($_[1]) : $_[1] ) };
$args{describe}++ if $args{'file-compat'} && !$args{mimetype};
$args{'file-compat'}++ if $0 =~ m#(^|/)file$#;
				$args{$key} .= ( $args{$key} ? ' ' : '' ).$arg; # join with whitespace
	: $args{noalign}
				$args{$opt} .= ( $args{$opt} ? ' ' : '' ) . $arg;
$args{separator} = ':' unless defined $args{separator};
		$args{stdin}++ if $args{'file-compat'} && $opt eq '-';
arguments failed, a module it depends on wasn't found or the shared
A single '-' won't be considered a separator
because it only uses magic typing. This will happen also if the STDIN filehandle
because it seems to me that this can only be done by un-compressing the file,
between options and filenames anymore, but becomes identical to L</--stdin>.
B<mimetype> doesn't provide a switch for looking inside compressed files
	$bn =~ s|^(.*/)*||;
	'brief'		=> ['b'],
but uses mimetypes instead of descriptions.
but WITHOUT ANY WARRANTY; without even the implied warranty of
called 'file'.
	close IN;
	$code =~ s/(?<!\\)%d/'.desc(\$_[1]).'/g;
	$code =~ s/(?<!\\)%f/'.\$_[0].'/g;
	$code =~ s/(?<!\\)%m/'.\$_[1].'/g;
	# code will get @_ = qw/file type/
Commandline options to specify alternative magic files are not
Compiled information about globs.
Compiled information about magic numbers.
				complain('-'.$o, 2) unless defined $arg;
				complain('--'.$opt, 2) unless defined $arg;
			complain($o) unless $key;
complain(undef, 4) unless scalar(@ARGV) || $args{stdin} || $args{namefile};
containing the following escapes:
Copyright (c) 2003,2008 Jaap G Karssenberg. All rights reserved.
Copyright (c) 2003 Jaap G Karssenberg. All rights reserved.
# --database
	'database'	=> ['', 1],
database. The directories specified by the basedir specification
	%d description
# --debug
	'debug'		=> ['D'],
*default = \&File::MimeInfo::default;
default when using L</--file-compat>.
# --dereference
	# --dereference
	'dereference'	=> ['L'],
	$desc{$mt} ||= describe($mt) || describe($mt, ''); # second form overrules the language settings to default
	'describe'	=> ['d'],
descriptions being outputted in the specified language.
Descriptions of a mimetype in multiple languages, used for the
Determine type of content from STDIN, less powerful then normal file checking
	die "Could not find perl module File::Spec\n" if $@;
	die "Could not find perl module IO::Scalar\n" if $@;
	die "Could not find perl module Pod::Usage\n" if $@;
		|| die "Couldn't open file: $args{namefile}\n";
die $@ if $@;
directories. If these are not set, there will be searched for the 
doesn't match any globs. An empty description can also mean that
Do not align output fields.
Do not check for extensions, globs or inode type, only look at the content
Do not prepend filenames to output lines (brief mode).
# do stuff #
			else { $args{$key}++; }
			else { $args{$opt}++ }
		else { complain('--'.$opt) }
	else { complain($opt) }
	else { print $format->($file, mimetype($f)), "\n" }
	elsif ($args{all}) {
	elsif ($m == 2) { print STDERR "$bn: option '$opt' requires an argument" }
	elsif ($m == 3) { print STDERR "$bn: $opt: No such file or directory\n" }
	elsif ($m == 4) { print STDERR "usage: $bn [options] files" }
	elsif ($opt =~ s/^-(?!-)//) {
	elsif ($opt =~ s/^--([\w-]+)(?:=(.*))?/$1/) {
eval 'exec /usr/bin/perl  -S $0 ${1+"$@"}'
eval 'use File::MimeInfo::Magic qw/mimetype globs inodetype magic describe/;';
	eval 'use File::Spec';
	eval 'use IO::Scalar';
	eval 'use Pod::Usage';
exist for strict compatibility with file(1). Possibly a subclass should be
	exit 0;
	exit $m;
		-exitval => 0,
	%f for the filename
					File::BaseDir::xdg_data_dirs()
					File::BaseDir::xdg_data_home(),
# --file-compat
	'file-compat'	=> [''],
	$File::MimeInfo::DEBUG++;
@File::MimeInfo::DIRS = split /:/, $args{database} if $args{database};
$File::MimeInfo::LANG = $args{language} if $args{language};
	$File::MimeInfo::Magic::DEBUG++;
following directories:
Follow symbolic links.
	for (@ARGV) { $l = length($_) if $l < length($_) }
Force the program to look in these directories for the shared mime-info
foreach my $file (@ARGV) {
		foreach my $o (split //, $opt) {
# Formatting stuff
For naming switches I followed the manpage of file(1) version 4.02
		for (qw#inodetype globs magic default#) {
=head1 AUTHOR
=head1 BUGS
=head1 COPYRIGHT
=head1 DESCRIPTION
=head1 DIAGNOSTICS
=head1 ENVIRONMENT
=head1 FILES
=head1 NAME
=head1 OPTIONS
=head1 SEE ALSO
=head1 SYNOPSIS
=head1 TODO
	'help'		=> ['h'],
	$HOME/.local/share/mime
    if 0; # not running under some shell
If a file has an empty mimetype or an empty description,
if ($args{debug}) {
if ($args{dereference}) {
if ($args{help} || $args{usage}) {
	if ($args{'magic-only'}) { 
if ($args{namefile}) {
if ($args{stdin}) {
if ($args{version}) {
		if (exists $opts{$opt}) {
	if ($m == 1) { print STDERR "$bn: unrecognized option '$opt'" }
If one symlinks the I<file> command to I<mimetype> it will behave
	if ($opt =~ /^--?$/) {
			if ($opts{$key}[1]) { 
			if ($opts{$opt}[1]) { 
If you want an alternative output format, you can specify a format string
implemented the same because of the conflicting data formats.
is a pipe.
is turned on automatically when you call mimetype by a link
=item B<-a>, B<--all>
=item B<-b>, B<--brief>
=item B<--database>=I<mimedir>:I<mimedir>:...
=item B<-D>, B<--debug>
=item B<-d>, B<--describe>
=item B<--file-compat>
=item B<-f> I<namefile>, B<--namefile>=I<namefile>
=item B<-F> I<string>, B<--separator>=I<string>
=item B<-h>, B<--help>
=item B<-i>, B<--mimetype>
=item B<-L>, B<--dereference>
=item B<-l> I<code>, B<--language>=I<code>
=item B<-M>, B<--magic-only>
=item B<-N>, B<--noalign>
=item B<--output-format>
=item B<--stdin>
=item B<-u>, B<--usage>
=item B<-v>, B<--version>
=item F<BASE/mime/globs>
=item F<BASE/mime/magic>
=item F<BASE/mime/MEDIA/SUBTYPE.xml>
=item F<BASE/mime/packages/SOURCE.xml>
=item XDG_DATA_DIRS
=item XDG_DATA_HOME
Jaap Karrssenberg E<lt>pardus@cpan.orgE<gt>
# --language
	'language'	=> ['l', 1],
L</--describe> switch.
L<file(1)>,
L<File::MimeInfo(3)>,
L<http://freedesktop.org/Software/shared-mime-info>
L<http://freedesktop.org/Standards/basedir-spec>
	$link = File::Spec->rel2abs($link, $dir);
	$link = resolvelink($link) if -l $link; # recurs
L<update-mime-database(1)>,
made for this one day.
	# --magic-only
	'magic-only'	=> ['M'],
Make mimetype behave a little more L<file(1)> compatible. This
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
method (globs, magic, etc.).
mime-info database wasn't accesable. See L<File::MimeInfo> for more details.
mime-info will be expected in the "mime" sub directory of one of these
mimetype - Determine file type
	'mimetype'	=> ['i'],
mimetype [options] [-] files
mime-typing method. This needs to be implemnted in the modules first.
	%m mime type
modify it under the same terms as Perl.
most probably the file doesn't exist and the given name 
				my $arg = $2 || shift @ARGV;
my %args = ();
				my $arg = shift @ARGV;
	my $bn = $0;
	my $code = "sub { '$form' }";
	my $data;
	my $f = ($args{dereference} && -l $file) ? resolvelink($file) : $file;
	my $file = shift;
my $format = $args{'output-format'}
	my $form = shift;
			my ($key) = grep { $opts{$_}[0] eq $o } keys %opts;
my $l = 5; # "STDIN"
	my $link = readlink($file) || return $file;
			my $m = eval "$_(\$f)";
	my $m = shift || 1;
	my $mt = shift;
my %opts = (
	my $opt = shift;
	my $opt = shift @ARGV;
	my $scalar = new IO::Scalar \$data;
	my (undef, $dir, undef) = File::Spec->splitpath($file);
		), "\n";
	# name	=> [char, expect_arg_bit ]
# --namefile
	'namefile'	=> ['f', 1],
	'noalign'	=> ['N'],
No known bugs, please mail the author if you find one.
of the file. This is particularly useful if for some reason you don't trust
(one per line) before the argument list.
	open IN, $args{namefile} 
or description, defaults to ':' .
our %desc; # desc caching hash
our $VERSION = '0.15';
	'output-format'	=> ['', 1],
# Parse ARGV #
	? parse_format($args{'output-format'})
	pod2usage( {
# prepare stuff #
Print a help message and exits.
	print	'> Data dirs are: ', join( ', ', 
Print debug information about how the mimetype was determined.
Print file descriptions instead of mime types, this is the
		print $format->($file, magic($f) || default($f)), "\n";
			print $format->($file, $m), "\n" if $m;
	print $format->('STDIN', mimetype($scalar)), "\n";
	print "mimetype $VERSION\n\n", << 'EOV';
	print "\nTry '$bn --help' for more information.\n" unless $m == 3;
Print the version of the program and exit.
	read(STDIN, $data, $File::MimeInfo::Magic::max_buffer);
Read the names of the files to be examined from the file 'namefile' 
	return eval $code;
	return $link;
	return undef unless $mt;
See also the "XDG Base Directory Specification" 
see L</ENVIRONMENT>.
	'separator'	=> ['F',1],
Shared MIME-info database. It is intended as a kind of I<file(1)> work-alike, 
Show output of all rules that match the file.
something that defeats the purpose. On the other hand the option should 
				? ( split /:/, $args{database} )
# --stdin
	'stdin'		=> [''],
	? sub { ( $_[0], $args{separator}, ' ', $args{describe} ? desc($_[1]) : $_[1] ) }
	: sub { ( $_[0], $args{separator}, ' 'x($l + 1 - length($_[0])),
	? sub { $args{describe} ? desc($_[1]) : $_[1] }
sub complain { # Error messages
sub desc { # Cache desciption
sub parse_format { # Advanced formatting
sub resolvelink { # --dereference
# Subroutines #
that is not backward compatible with the original file command. )
The '--all' switch doesn't really show all matches, but only one per
The base dir for all data files is determined by two environment variables,
The language attribute specifies a two letter language code, this makes
the name or the extension a file has.
The program exits with a non-zero exit value if either the commandline
there is no description available in the language you specified.
These variables can list base directories to search for data files. The shared 
this is the default when _not_ using L</--file-compat>.
This program is distributed in the hope that it will be useful,
This program is free software; you can redistribute it and/or
This script tries to determine the mime type of a file using the
TODO: this method now just returns one match for each
To use this option L<IO::Scalar> needs to be installed.
unless ($args{brief} || $args{noalign}) {
	unshift @ARGV, map {chomp; $_} (<IN>);
	'usage'		=> ['u'],
use B<update-mime-database(1)>.
Use mime types, opposite to L</--describe>,
use strict;
Use string as custom separator between the file name and its mimetype
#!/usr/bin/perl 
	/usr/local/share/mime
	/usr/share/mime
'utilities' chapter of IEEE Std 1003.1-2001 (POSIX).
		-verbose => 1,
	'version'	=> ['v'],
when possible. They seem to differ completely from the spec in the 
while ((@ARGV) && ($ARGV[0] =~ /^-/)) {
( You can still use '--' as separator, but
you need to post-process the output to do that.
