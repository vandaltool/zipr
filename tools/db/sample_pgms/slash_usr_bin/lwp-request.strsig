        }
    'a', # content i/o in text(ascii) mode
%allowed_methods = (
        $allowed_methods{$method} = "";
        $allowed_methods{$method} = "C";  # force content
              "application/x-www-form-urlencoded"
# a superset for all methods supported for every scheme that may be
    -a            Use text mode for content I/O
Authentication.  If the document is protected and you did not specify
		    $base = $options{'b'} if $options{'b'};
    -b <base>     Use the specified URL as base
            [B<-C> I<credentials>] [B<-p> I<proxy-url>] [B<-o> I<format>] I<url>...
Because this program is implemented using the LWP library, it will
before it fails.  The default unit for the timeout value is seconds.
be installed for I<-o text> or I<-o ps> to work.
            [B<-i> I<if-modified-since>] [B<-c> I<content-type>]
    binmode STDIN unless -t or $options{'a'};
	    binmode STDOUT unless $options{'a'};
B<lwp-request> [B<-afPuUsSedvhx>] [B<-m> I<method>] [B<-b> I<base URL>] [B<-t> I<timeout>]
    'b=s', # base url
C<application/x-www-form-urlencoded>.  The default Content-type for
    -c <conttype> use this content-type for POST, PUT, CHECKIN
C<-c>.  The default Content-Type for POST is
	    chomp($password);
	    chomp($user);
    $content = join("", <STDIN>);
content type of the response is not HTML, then this option has no
$content = undef;
Copyright 1995-1999 Gisle Aas.
Copyright 1995-1999, Gisle Aas.
C<-P> option.
    # Create the URL object, but protect us against bad URLs
# Create the user agent object
    'c=s', # content type for POST
    'C=s', # credentials for basic authorization
    -C <username>:<password>
    -d            Do not display content
    'd', # don't display content
    DELETE     => "",
		    die $@;
    die <<"EOT";
		die "Illegal -o option value ($options{'o'})\n";
    die "$progname: Can't set Content-type for $method requests\n"
        die "$progname: Illegal Content-type format\n"
    die "$progname: Illegal timeout value!\n" unless defined $1;
        die "$progname: Illegal time syntax for -i option\n"
    die "$progname: $method is not an allowed method\n";
		    die "The HTML-Tree distribution need to be installed for the -o option to be used.\n";
Do B<not> print the content of the response.
Don't load proxy settings from environment.
    'e', # display response headers (default for HEAD)
    -e            Display response headers (implies -s)
    'E', # display whole chain of headers
    -E            Display whole chain of headers (implies -S and -U)
effect.  The legal format values are; I<text>, I<ps>, I<links>,
    else {
		else {
elsif (!defined $allowed_methods{$method}) {
	elsif (-t) {
	$errors++;
$errors = 0;
    $errors++ unless $response->is_success;
    eval {
	    eval {
eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
exit $errors;
    'f', # make request even if method is not in %allowed_methods
    -f            make request even if $progname believes method is illegal
force methods to take content by using the C<-f> option together with
Force request through, even if the program believes that the method is
		    for ( @{ $html->extract_links } ) {
formatted as Postscript.
        for my $r ($response->redirects) {
for my $user_header (@{ $options{'H'} || [] }) {
    GET        => "",
Getopt::Long::config("noignorecase", "bundling");
Gisle Aas <gisle@aas.no>
given as argument.
    HEAD       => "",
=head1 AUTHOR
=head1 COPYRIGHT
=head1 DESCRIPTION
=head1 NAME
=head1 SEE ALSO
=head1 SYNOPSIS
    $header_name =~ s/^\s+//;
	$header_value .= $ua->agent if $header_value =~ /\s\z/;
    -H <header>   send this HTTP header (you can specify several)
	-H 'Host: somehost' \
hours, respectively.  The default timeout is '3m', i.e. 3 minutes.
    -h            Print this message
    'h', # print usage
	-H 'Referer: http://other.url/' \
    'H=s@', # extra headers, form "Header: value string"
		    $html->dump;
	http://this.url/
    if ($@) {
	    if ($@) {
    if 0; # not running under some shell
if ($allowed_methods{$method} eq "C") {
    if (defined $2) {
        if defined $options{'c'};
if (defined $options{'i'}) {
if (defined $options{'t'}) {
    if (-e $options{'i'}) {
    if (lc($header_name) eq "user-agent") {
	if ($main::options{'C'}) {
		if ($@ =~ m,^Can't locate HTML/Parse.pm in \@INC,) {
if ($method eq "HEAD") {
    if ($options{'c'}) {
if ($options{'c'}) { # will always be set for request that wants content
if ($options{'f'}) {
	if ($options{'o'} &&
    if ($options{'S'}) {
if ($options{'S'} || $options{'E'}) {
if ($options{'v'}) {
        if -t;
	if ($url =~ /^\w+:/ || $options{'b'}) {  # is there any scheme specification
If you specify the I<text> format then the HTML will be formatted as
I<html> and I<dump>.
illegal.  The server might reject the request eventually.
    @ISA = qw(LWP::UserAgent);
    'i=s', # if-modified-since
=item -a
=item -b <uri>
=item -c <content-type>
=item -C <username>:<password>
=item -d
=item -e
=item -f
=item -h
=item -H <header>
=item -i <time>
=item -m <method>
=item -o <format>
=item -P
=item -p <proxy-url>
=item -s
=item -t <timeout>
=item -u
=item -v
I<time> is not a file, it is parsed as a literal date. Take a look at
    -i <time>     Set the If-Modified-Since header on the request
		# It is bad to not notice this before now :-(
		    last;
L<HTTP::Date> for recognized formats.
			$link = URI->new($link)->abs($base)->as_string;
L<lwp-mirror>, L<LWP>
# Load proxy settings from *_proxy environment variables.
local file system. The request content for POST and PUT
    lwp-request \
lwp-request, GET, POST, HEAD - Simple command line user agent
methods is read from stdin.  The content of the response is printed on
$method = uc(lc($progname) eq "lwp-request" ? "GET" : $progname);
$method = uc($options{'m'}) if defined $options{'m'};
    -m <method>   use method for the request (default is '$method')
modify it under the same terms as Perl itself.
    'm=s', # set method
		    my $base = $response->base;
    my $DISTNAME = 'libwww-perl-' . LWP::Version();
		    my $f = HTML::FormatPS->new;
		    my $f = HTML::FormatText->new;
my @getopt_args = (
    my ($header_name, $header_value) = split /\s*:\s*/, $user_header, 2;
    my $header = ($user_ct ? 'header' : 'init_header');
	    my $html = HTML::Parse::parse_html($response->content);
    my $last = shift;
			my($link, $elem) = @$_;
	    my $netloc = $uri->host_port;
	    my $password = <STDIN>;
    my $r = shift;
	my $self = LWP::UserAgent::new(@_);
	my($self, $realm, $uri) = @_;
			my $tag = uc $elem->tag;
	    my $user = <STDIN>;
name of a file, use the modification timestamp for this file. If
# "" = No content in request, "C" = Needs content in request
Note that the C<HTML-Tree> distribution needs to be installed for this
    -o <format>   Process HTML content in various ways
# Ok, now we perform the requests, one URL at a time
only support the protocols that LWP supports.
    OPTIONS    => "",
        $options{'c'} = ($method eq "POST") ?
    $options{'d'} = 1;
    $options{'E'} = 1 if $options{'e'};
    $options{'e'} = 1 unless $options{'d'};
    $options{'i'} = time2str($time);
		$options{'o'} eq 'dump' && do {
		$options{'o'} eq 'html' && do {
		$options{'o'} eq 'links' && do {
		$options{'o'} eq 'ps' && do {
		$options{'o'} eq 'text' && do {
    $options{'s'} = 1;
$options{'s'} = 1 if $options{'e'};
    $options{'t'} =~ /^(\d+)([smh])?/;
    $options{'u'} = 1;
    $options{'U'} = 1 if $options{'E'};
$options{'u'} = 1 if $options{'U'};
option to work.  In addition the C<HTML-Format> distribution needs to
    'o=s', # output format
    package RequestAgent;
# Parse command line
    'P', # don't load proxy setting from environment
    -P            don't load proxy settings from environment
plain latin1 text.  If you specify the I<ps> format then it will be
    POST       => "C",
    -p <proxyurl> use this as a proxy
		    print $f->format($html);
		    print $html->as_HTML;
    print $method, " ", $r->request->uri->as_string, "\n" if $options{'u'};
Print request headers in addition to request method and absolute URL.
Print request method and absolute URL as requests are made.
	    print $response->content;
Print response headers.  This option is always on for HEAD requests.
Print response status chain. This shows redirect and authorization
Print response status chain with full response headers.
Print response status code.  This option is always on for HEAD requests.
    print $r->headers_as_string, "\n" if $options{'E'} or $last;
    print $r->request->headers_as_string, "\n" if $options{'U'};
    print $r->status_line, "\n" if $options{'s'};
	print STDERR $@;
	    print STDERR "Enter username for $realm at $netloc: ";
	    print STDERR "\n";  # because we disabled echo
	    print STDERR "Password: ";
    print STDERR "Please enter content ($options{'c'}) to be ${method}ed:\n"
			print "$tag\t$link\n";
Print the version number of the program and quit.
Print usage message and quit.
Process HTML content in various ways before printing it.  If the
$progname = $0;
$progname =~ s,.*[\\/],,;  # use basename only
$progname =~ s/\.\w*$//;   # strip extension, if any
                  provide credentials for basic authentication
Provide credentials for documents that are protected by Basic
proxy settings from the environment.  You can disable this with the
    'p=s', # proxy URL
    PUT        => "C",
Relative links will be expanded to absolute ones.
    $request->content($content);
#$request->header('Accept', '*/*');
    $request->header('Content-Length', length $content);  # Not really needed
    $request->$header('Content-Type', $options{'c'});
$request->header('If-Modified-Since', $options{'i'}) if defined $options{'i'};
$request = HTTP::Request->new($method);
	$request->push_header($header_name, $header_value);
requests that are handled by the library.
requests that take a content, i.e. POST and PUT.  You can
    $request->uri($url);
		    require HTML::FormatPS;
		    require HTML::FormatText;
		require HTML::Parse;
    require LWP;
require LWP;
	    $response->content_type eq 'text/html') {
    $response = $ua->request($request);
	    return split(':', $main::options{'C'}, 2);
	    return (undef, undef)
	    return (undef, undef) unless length $user;
	    return ($user, $password);
	$@ =~ s/ at .* line \d+.*//;
    -S            Display response status chain (implies -u)
    -s            Display response status code
    's', # display status code
    'S', # display whole chain of status codes
	$self->agent("lwp-request/$main::VERSION ");
    # Send the request and get a response back from the server
Send this HTTP header with each request. You can specify several, e.g.:
        # set default content type
Set text(ascii) mode for content input and output.  If this option is not
Set the Content-Type for the request.  This option is only allowed for
Set the If-Modified-Since header in the request. If I<time> is the
Set the proxy to be used for the requests.  The program also loads
Set the timeout value for the requests.  The timeout is the amount of
# Set up a request.  We will use the same request object for all URLs.
Set which method to use for the request.  If this option is not used,
	    show($r);
    show($response, $options{'e'});
# Simple user agent using LWP library.
# specific.  You might use the -f option to force a method through.
status value indicating the number of URLs that failed.
stdout.  Error messages are printed on stderr.  The program returns a
    sub get_basic_credentials
    sub new
sub show {
sub usage
# supported by the library.  Currently it might be a bit too HTTP
	    system("stty -echo");
	    system("stty echo");
            : "text/plain";
The following options controls what is displayed by the program:
The I<html> format will reformat the HTML code and the I<dump> format
The I<links> format will output all links found in the HTML document.
then the method is derived from the name of the program.
The options are:
the others is C<text/plain>.
the username and password with this option, then you will be prompted
This is lwp-request version $VERSION ($DISTNAME)
This library is free software; you can redistribute it and/or
This program can be used to send requests to WWW servers and your
This program is free software; you can redistribute it and/or
    # This request needs some content
# This table lists the methods that are allowed.  It should really be
This URI will be used as the base URI for resolving all relative URIs
    $timeout = $1;
        $timeout *= 3600 if $2 eq "h";
        $timeout *= 60   if $2 eq "m";
        $time = (stat _)[9];
        $time = str2time($options{'i'});
time that the program will wait for a response from the remote server
to provide these values.
    TRACE      => "",
    't=s', # timeout
    -t <timeout>  Set timeout value
	$ua->agent($header_value);
$ua->env_proxy unless $options{'P'};
    $ua->proxy($url->scheme, decode(locale => $options{'p'})) if $options{'p'};
$ua = RequestAgent->new;
    $ua->timeout($timeout);
    -u            Display method and URL before any response
    'u', # display method and URL of request
    'U', # display request headers also
    -U            Display request headers (implies -u)
    unless (defined $options{'c'}) {
            unless defined $time;
unless (GetOptions(\%options, @getopt_args)) {
            unless $options{'c'} =~ m,^[\w\-]+/[\w\-.+]+(?:\s*;.*)?$,;
    unless ($options{'d'}) {
	    $url = uf_uri($url);
	    $url = URI->new(decode(locale => $url), decode(locale => $options{'b'}));
	    $url = $url->abs(decode(locale => $options{'b'})) if $options{'b'};
    usage();
usage() if $options{'h'} || !@ARGV;
Usage: $progname [-options] <url>...
used, content input and output is done in binary mode.
use Encode;
use Encode::Locale;
use Getopt::Long;
use HTTP::Date qw(time2str str2time);
use HTTP::Status qw(status_message);
	$user_ct++;
$user_ct = undef;
# user/password if document is protected.
use URI;
use URI::Heuristic qw(uf_uri);
#!/usr/bin/perl -w
$VERSION = "6.03";
    'v', # print version
    -v            Show program version
# We make our own specialization of LWP::UserAgent that asks for
while ($url = shift) {
will just dump the HTML syntax tree.
You might append "m" or "h" to the timeout value to make it minutes or
