                        }
                    }
                (([^*]|\*(?!/))*)
                }
             (([^*]|\*(?!/))*)
            }
           (?:/\*<
       ([^*]+|\*(?!/))*
	    ([^*]+|\*(?!/))*
                   (?:[^,/]|/(?!\*))*       # anything but a comma or comment
                        # approximation to C constant folding
	# Autogenerate a prefix
	    # canonicalize user defined prefixes
            chomp ($prod);
    chomp ($prod);
	        chomp ($prod);
		chomp ($tmp_prod);
	close (ARGV);		# reset line numbering
  close (FILE);
	      'comment', $comment_tmpl);
    $comment =~ s/\@comment\@/Generated data (by glib-mkenums)/;
    $comment =~ s/\@comment\@/Generated data ends here/;
  $comment_tmpl = "/* \@comment\@ */" if $comment_tmpl eq "";
  $comment_tmpl = $tmpl{'comment'};
  # default to C-style comments
	defined ($new = <>) || die "Unmatched comment in $ARGV";
	    defined ($new = <$file>) || die "Unmatched comment in $ARGV";
	defined $val or $val = 1;
	# Didn't have trailing '{' look on next lines
		    die "Hit end of file while parsing enum in $ARGV";
      die "Malformed template file $file\n";
	  die "Malformed template file $file\n";
                            die "Unable to parse enum value '$num'";
                    } else {
      } else {
	    } else {
	} else {
		    } else {
    else { usage; }
    elsif (/^--comments$/)                   { $comment_tmpl = shift }
    elsif (/^--eprod$/)                      { $eprod = $eprod . shift }
    elsif (/^--fhead$/)                      { $fhead = $fhead . shift }
    elsif (/^--fprod$/)                      { $fprod = $fprod . shift }
    elsif (/^--ftail$/)                      { $ftail = $ftail . shift }
    elsif (/^--help$/ || /^-h$/ || /^-\?$/)  { usage; }
    elsif (/^--identifier-prefix$/)          { $idprefix = shift }
      elsif (($in eq $2) && ($1 eq 'END') && (exists($tmpl{$2}))) {
	} elsif (m@^\s*\#@) {
    elsif (/^--symbol-prefix$/)              { $symprefix = shift }
	} elsif (!$symprefix && !$idprefix) {
    elsif (/^--version$/ || /^-v$/)          { version; }
    elsif (/^--vhead$/)                      { $vhead = $vhead . shift }
    elsif (/^--vprod$/)                      { $vprod = $vprod . shift }
    elsif (/^--vtail$/)                      { $vtail = $vtail . shift }
	    $enspace = $enumname;
	    $enspace =~ s/^([A-Z][a-z]*).*$/$1/;
	@entries = ();
	        @{$entry} = ($name, $num, $nick);
	      'enumeration-production', $eprod,
	    $enumindex++;
	    $enumlong = $enumname_prefix . "_" . $enumshort;
	    $enumlong = uc($enspace) . "_" . $enumshort;
	    $enumlong = uc $option_underscore_name;
	    $enumname = $1;
		$enumname = $1;
	    # enumname is e.g. GMatchType
	    $enumname_prefix = $enumlong;
	    $enumname_prefix = $enumname;
	    $enumname_prefix =~ s/^([A-Z][a-z]*).*$/$1/;
	    $enumname_prefix =~ s/_$enumshort$//;
	    $enumname_prefix = $symprefix && uc($symprefix) || uc($idprefix);
	    $enumname_prefix = uc($enumname_prefix);
		$enum_prefix = "";
			$enum_prefix = $enum_prefix & $tmp;
			$enum_prefix = $name;
	    $enum_prefix = $options{prefix};
		$enum_prefix =~ s/_[^_]*$/_/;
	    $enum_prefix =~ s/(.*)([^_])$/$1$2_/;
	    $enum_prefix =~ s/-/_/g;
	    $enum_prefix = uc($enum_prefix);
	    $enum_prefix = undef;
	    $enumshort = $enumlong;
	    $enumshort = $enumname;
	    $enumshort =~ s/^[A-Z][a-z]*//;
		$enumshort =~ s/^[A-Z][a-z]*//;
	    $enumshort =~ s/^[A-Z][A-Z0-9]*_//;
	    $enumshort =~ s/([^A-Z])([A-Z])/$1_$2/g;
	    $enumshort =~ s/([A-Z][A-Z])([A-Z][0-9a-z])/$1_$2/g;
		$enumshort =~ s/^${idprefix}//;
	    $enumshort = uc($enumshort);
	    $enumsym = lc($enspace) . "_" . lc($enumshort);
	    $enumsym = lc($enumlong);
	    $enumsym = lc $option_underscore_name;
		$enumsym = $option_lowercase_name;
  $eprod = $tmpl{'enumeration-production'};
    exit 0;
  $fhead = $tmpl{'file-header'};
	# figure out if this was a flags or enums enumeration
	      'file-production', $fprod, 
	      'file-tail', $ftail, 
	    $firstenum = 0;
	$firstenum = 1;		# Flag to print filename at next enum
	    $flags = $options{flags};
	    $flags = $seenbitshift;
	    $flags = undef;
	    for (@entries) {
	for $entry (@entries) {
				# for example to fix the cases we don't get the
    for $opt (split /\s*,\s*/, $opts) {
  $fprod = $tmpl{'file-production'};
  $ftail = $tmpl{'file-tail'};
# glib-mkenums.pl 
				# guess where to put the underscores.
       \*/@@gx;
	   \*/@@gx;
	# Handle include files
	if (!defined $1 && !defined $4) {
	if (defined $2) {
if (!defined $ARGV[0]) {
	    if (!defined $enum_prefix) {
		    if (defined $enum_prefix) {
	if (!defined $enum_prefix) {
	if (!defined $flags) {
	    if (!defined $flags && defined $value && $value =~ /<</) {
            if (!defined $nick) {
		if (!defined $nick) {
                    if (defined $num) {
                        if (!defined $num or $num !~ /^-?\d+$/) {
	    if (defined($option_lowercase_name)) {
	if (defined $option_lowercase_name) {
	    if (defined $options) {
		if (!defined $options{skip}) {
	    if (defined $option_underscore_name) {
	if (defined $option_underscore_name) {
    if (eof) {
		if (eof) {
	if ($firstenum) {
	    if ($flags) { $prod =~ s/\@type\@/flags/g; } else { $prod =~ s/\@type\@/enum/g; }
		if ($flags) { $tmp_prod =~ s/\@type\@/flags/g; } else { $tmp_prod =~ s/\@type\@/enum/g; }
	    if ($idprefix) {
	if (/^\#include\s*<([^>]*)>/ ) {
    if (!($in eq 'junk')) {
  if (!($in eq 'junk')) {
      if (($in eq 'junk') && ($1 eq 'BEGIN') && (exists($tmpl{$2}))) {
	if (length($eprod)) {
if (length($fhead)) {
	    if (length($fprod)) {
if (length($ftail)) {
	if (length($vhead)) {
	if (length($vprod)) {
	if (length($vtail)) {
	if ($looking_for_name) {
        if (m@^\s*
    if (m@^\s*typedef\s+enum\s*
	    if (parse_entries (\*NEWFILE, $NEWFILE)) {
                if ($prod =~ /\@valuenum\@/) {
	if (/^\s*\}/) {
    if (/^\/\*\*\*\s+(BEGIN|END)\s+([\w-]+)\s+\*\*\*\//) {
		if (s/^\s*\{//) {
	if (/^\s*\}\s*(\w+)/) {
	    if (/^\s*(\w+)/) {
    if (/^--template$/)                      { read_template_file (shift); }
    # ignore forward declarations
	    # ignore preprocessor directives
	$in = $2;
# Information about the current enumeration
	$in = 'junk';
		    last;
    last if /^--$/;
    last if not defined($ARGV[0]);
	    $looking_for_name = 1;
                        # make sure it parsed to an integer
				# mixed-case -> underscorized transform right.
    my $base = basename ($ARGV);
		my $base = basename ($ARGV);
    my $base = basename ($ARGV[0]);
    my $comment = $comment_tmpl;
my $comment_tmpl = "";   # comment template
my @entries;			# [ $name, $val ] for each entry
my $enumindex = 0;		# Global enum counter
my $enumname;			# Name for this enumeration
my $enumname_prefix;		# prefix of $enumname
my $enum_prefix;		# Prefix for this enumeration
my $enumshort;			# $enumname without prefix
my $eprod = "";   # per enum text (produced prior to value itarations)
my $fhead = "";   # output file header
  my ($file) = @_;
            my $file= "../$1";
    my $file_name = shift;
    my $file = shift;
my $firstenum = 1;		# Is this the first enumeration per file?
my $flags;			# Is enumeration a bitmask?
my $fprod = "";   # per input file production
my $ftail = "";   # output file trailer
my $idprefix = "";    # "G", "Gtk", etc
  my $in = 'junk';
        my ($key,$val) = $opt =~ /(\w+)(?:=(.+))?/;
    my $looking_for_name = 0;
		    my $name = $_->[0];
		my ($name,$num,$nick) = @{$_};
	    my ($name,$num,$nick) = @{$entry};
            my ($name, $value, $options) = ($1,$2,$3);
	    my $new;
	my $new;
            my $next_num = 0;
		my $nick = $_->[2];
my $option_lowercase_name;	# DEPRECATED.  A lower case name to use as part
	    my %options = parse_trigraph ($2);
		my %options = parse_trigraph($options);
my $option_underscore_name;	# Overriden underscore variant of the enum name
    my @opts;
    my $opts = shift;
	    my $prod = $eprod;
    my $prod = $fhead;
		my $prod = $fprod;
    my $prod = $ftail;
	    my $prod = $vhead;
	    my $prod = $vprod;
	    my $prod = $vtail;
my $sandbox = Safe->new;        # sandbox for safe evaluation of expressions
my $seenbitshift;		# Have we seen bitshift operators?
my $symprefix = "";   # "g", "gtk", etc, if not just lc($idprefix)
  my %tmpl = ('file-header', $fhead, 
			my $tmp = ~ ($name ^ $enum_prefix);
		my $tmp_prod = $prod;
my $vhead = "";   # value header, produced before iterating over enum values
my $vprod = "";   # value text, produced for each enum value
my $vtail = "";   # value tail, produced after iterating over enum values
	    $_ .= $new;
	$_ .= $new;
	    next;
	    next if defined $options{skip};
	next if m@^\s*$@;
    next if /^\s*typedef\s+enum.*;/;
                    $next_num = $num + 1;
	        $nick = lc($nick);
 	        ($nick = $name) =~ s/^$enum_prefix//;
	        $nick =~ tr/_/-/;
	# Now parse the entries
                        $num = $next_num;
                        $num = $sandbox->reval ($num);
				# of the *_get_type() function, instead of the
				# one that we guess. For instance, when an enum
                    # only attempt to eval the value if it is requested
  open (FILE, $file) || die "Can't open $file: $!\n";
	    open NEWFILE, $file or die "Cannot open include file $file: $!\n";
	    $option_lowercase_name = $options{lowercase_name};
	    $option_lowercase_name = undef;
		$option_lowercase_name = undef;
              (?:/\*<                    # options
	    $option_underscore_name = $options{underscore_name};
	    $option_underscore_name = undef;
    @opts;
	$opt =~ s/^\s*//;
	$opt =~ s/\s*$//;
		   |                        # OR
	parse_entries (\*ARGV, $ARGV);
    print "  \@basename\@            base name of the current input file (Since: 2.22)\n";
    print "  --comments <text>            Comment structure\n";
    print "  \@enum_name\@           prefix_the_xenum\n";
    print "  \@EnumName\@            PrefixTheXEnum\n";
    print "  \@ENUMNAME\@            PREFIX_THE_XENUM\n";
    print "  \@ENUMPREFIX\@          PREFIX\n";
    print "  \@ENUMSHORT\@           THE_XENUM\n";
    print "  --eprod <text>               Per enum text (produced prior to value itarations)\n";
    print "  --fhead <text>               Output file header\n";
    print "  \@filename\@            name of current input file\n";
    print "  --fprod <text>               Per input file production\n";
    print "  --ftail <text>               Output file trailer\n";
    print "glib-mkenums comes with ABSOLUTELY NO WARRANTY.\n";
    print "  glib-mkenums [OPTION...] [FILES...]\n\n";
    print "glib-mkenums version glib-2.32.3\n";
    print "GLib source package. Sources, examples and contact\n";
    print "Help Options:\n";
    print "  -h, --help            Show this help message\n\n";
    print "  --identifier-prefix <text>   Identifier prefix\n";
    print "information are available at http://www.gtk.org\n";
    print "\n" . $comment . "\n\n";
            print "$prod\n";
    print "$prod\n";
	    print "$prod\n";
		print "$prod\n";
    print "Production text substitutions:\n";
		print STDERR "$0: $ARGV:$.: lowercase_name is deprecated, use underscore_name\n";
		print STDERR "$0: $ARGV:$.: lowercase_name overriden with underscore_name\n";
	    print STDERR "$0: $file_name:$.: Failed to parse `$_'\n";
    print "  --symbol-prefix <text>       Symbol prefix\n";
    print "  --template file              Template file\n";
    print "the GNU General Public License which can be found in the\n";
		print "$tmp_prod\n";
    print "  \@type\@                either enum or flags\n";
    print "Usage:\n";
    print "Utility Options:\n";
    print "  \@VALUENAME\@           PREFIX_THE_XVALUE\n";
    print "  \@valuenick\@           the-xvalue\n";
    print "  \@valuenum\@            the integer value (limited support, Since: 2.26)\n";
    print "  --vhead <text>               Value header, produced before iterating over enum values\n";
    print "  --vprod <text>               Value text, produced for each enum value\n";
    print "  --vtail <text>               Value tail, produced after iterating over enum values\n";
    print "  -v, --version                Print version informations\n\n";
    print "You may redistribute copies of glib-mkenums under the terms of\n";
            $prod =~ s/\\a/\a/g; $prod =~ s/\\b/\b/g; $prod =~ s/\\t/\t/g; $prod =~ s/\\n/\n/g;
    $prod =~ s/\\a/\a/g; $prod =~ s/\\b/\b/g; $prod =~ s/\\t/\t/g; $prod =~ s/\\n/\n/g;
	    $prod =~ s/\\a/\a/g; $prod =~ s/\\b/\b/g; $prod =~ s/\\t/\t/g; $prod =~ s/\\n/\n/g;
		$prod =~ s/\\a/\a/g; $prod =~ s/\\b/\b/g; $prod =~ s/\\t/\t/g; $prod =~ s/\\n/\n/g;
    $prod =~ s/\@basename\@/$base/g;
		$prod =~ s/\@basename\@/$base/g;
            $prod =~ s/\@ENUMNAME\@/$enumlong/g;
	    $prod =~ s/\@ENUMNAME\@/$enumlong/g;
            $prod =~ s/\@EnumName\@/$enumname/g;
	    $prod =~ s/\@EnumName\@/$enumname/g;
	    $prod =~ s/\@enum_name\@/$enumsym/g;
	    $prod =~ s/\@ENUMPREFIX\@/$enumname_prefix/g;
            $prod =~ s/\@ENUMSHORT\@/$enumshort/g;
	    $prod =~ s/\@ENUMSHORT\@/$enumshort/g;
            $prod =~ s/\\f/\f/g; $prod =~ s/\\r/\r/g;
    $prod =~ s/\\f/\f/g; $prod =~ s/\\r/\r/g;
	    $prod =~ s/\\f/\f/g; $prod =~ s/\\r/\r/g;
		$prod =~ s/\\f/\f/g; $prod =~ s/\\r/\r/g;
    $prod =~ s/\@filename\@/$ARGV[0]/g;
    $prod =~ s/\@filename\@/$ARGV/g;
		$prod =~ s/\@filename\@/$ARGV/g;
# production variables:
		push @entries, [ $name, $value ];
		    push @entries, [ $name, $value, $options{nick} ];
	push @opts, $key, $val;
# put auto-generation comment
    # read lines until we have no open comments
	# read lines until we have no open comments
    return 0;
	    return 1;
		return 1;
            >\s*\*/)?
               >\s*\*/)?,?
                  ))?,?\s*
              \s*$
           ({)?\s*
           \s*({)?
    s@/\*(?!<)
	s@/\*(?!<)
	$seenbitshift = 0;
		$seenbitshift = 1;
    shift;
	# skip empty lines
	s@\n@ @;
	# Spit out the output
    # strip comments w/o options
	# strip comments w/o options
	# strip newlines
sub parse_entries {
sub parse_trigraph {
sub read_template_file {
sub usage {
sub version {
		   \s*\w+\s*\(.*\)\s*       # macro with multiple args
                    # this prevents us from throwing errors otherwise
	$tmpl{$in} .= $_;
		$tmp_prod =~ s/\@VALUENAME\@/$name/g;
		$tmp_prod =~ s/\@valuenick\@/$nick/g;
                    $tmp_prod =~ s/\@valuenum\@/$num/g;
			($tmp) = $tmp =~ /(^\xff*)/;
		# Trim so that it ends in an underscore
    usage;
use File::Basename;
				# uses abnormal capitalization and we can not
use Safe;
                        # use sandboxed perl evaluation as a reasonable
use warnings;
#! /usr/bin/perl
              (?:=(                      # value
	      'value-header', $vhead,
	      'value-production', $vprod,
	      'value-tail', $vtail,
  $vhead = $tmpl{'value-header'};
  $vprod = $tmpl{'value-production'};
  $vtail = $tmpl{'value-tail'};
	    while (<>) {
while (<>) {
while ($_=$ARGV[0],/^-/) {
    while (<$file>) {
  while (<FILE>) {
    while (m@/\*([^*]|\*(?!/))*$@) {
	while (m@/\*([^*]|\*(?!/))*$@) {
              (\w+)\s*                   # name
             @x) {
         @x) {
