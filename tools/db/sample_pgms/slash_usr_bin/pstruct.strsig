        }
    $_ = '';
######################################################################
########################################################################################
			      ];
	    $_[0] = "A$ncount ";
	    $_[0] = $template x $ncount;
	    $_[1] = '';
	$| = 1;
$| = 1 if $debug;
    1 while s/(\w) \1/$1$1/g;
Actually, this was generated by a particular set of options.  You can control
	@a = @DB'args;
	    $_ = &adecl($_);
	$_ = &adecl($_,1);
    &adjust_start_addrs;
    -a	dump information on intrinsics also
-a	dump information on intrinsics also
	$a = $h ? '(' . join(', ', @a) . ')' : '';
All you need to be able to use this is a C compiler than generates
    and the resulting *.s groped for stab information.  If no files are
Anyway, here it is.  Should run on perl v4 or greater.  Maybe less.
	$ARGV[0] =~ s/\.c$/.s/;
	@ARGV = ($TMP);
	$arraytype = &typeno($arraytype);
	($arraytype, $unknown) = ($2, $3);
    ($arraytype, $unknown, $lower, $upper) = ();
#   As c2ph, do this PLUS generate perl code for getting at the structures.
a shame.
#   As pstruct, dump C structures as generated from 'cc -g -S' stabs.
As you see, the name of the package is the name of the structure.  Regular
    a temporary *.c file and sent through:
		a thing to dump out your u structure for you.
	($basename = $_) =~ s/\.[^.]+$//;
		    ($base+$offset)/8,
been less cavalier in how the parts of the program communicated with each
binary dumps or poking around the kernel.
    'bit',			$bitorder,
	     	Bitfields are not quite yet supported however.
$bitorder = 'b';  # ascending; set to B for descending bit fields
		    ($bits = ($base+$offset)%8) ? ".$bits" : "  ",
		    ($bits = $length % 8) ? ".$bits": ""
BSD/GCC-style stabs.  The B<-g> option on native BSD compilers and GCC
    --$build_recursed;
    $build_recursed++;
	    $build_recursed = 0;
&buildscrunchlist;
	    &build_template($mytype) unless $mytype eq $name;
	    &build_template($name) unless defined $template{&psou($name)} ||
But if you're a perl programmer, then for you I have something much more
#   c2ph (aka pstruct)
    c2ph [-dpnP] [var=val] [files ...]
c2ph, pstruct - Dump C structures as generated from C<cc -g -S> stabs
	% c2ph  some_include_file.h  >> /usr/lib/perl/tmp.ph
$CC = 'cc';
	    $CC $CFLAGS $DEFINES
$CFLAGS = '-gstabs -S';
    'char', 			'1',
    'char', 			'c',
    char *mask = "%d %s\n";
	$chdir = "cd $dir && " if $dir;
      chop;
	    chop $@;
    close PIPE;
    close(PIPE) || die "couldn't read intrinsics!";
    close TMP;
compiler and gcc.
    &compute_intrinsics if $perl && !$opt_i;
    contains stab information.  All other lines will be ignored.  At
      $continued = $_;
    $continued = '';
    $_ = $continued . $_ if length($continued);
	$count .= $1;
	$count .= $2;
    $countof{$what} = $struct_count unless defined $countof{$whati};
cpp symbols, not real C, which was also very much needed.  What I offer
C than I could ever hope to be.
Date: 25 Jul 91 08:10:21 GMT
declarations at least, but that's quite a bit.
    defined \$${mname}index
    defined \$${mname}'index
$DEFINES = '';
    &defvar('CC', 'which_compiler to call');
    &defvar('CFLAGS', 'how to generate *.s files with stabs');
    &defvar('DEFINES','any extra cflags or cpp defines, like -I, -D, -U');
    &defvar('indent', 'how far to indent each nesting level');
    &defvar('member_width', 'width of member field (column 2)');
    &defvar('offset_fmt', 'sprintf format type for offset');
    &defvar('offset_width', 'width of offset field (column 3)');
    &defvar('size_fmt', 'sprintf format type for size');
    &defvar('size_width', 'width of size field   (column 4)');
    &defvar('type_width', 'width of type field   (column 1)');
delete $intrinsics{'bit'};
delete $intrinsics{'neganull'};
delete $intrinsics{'null'};
    'double',			'8',
    'double',			'd',
    -d	spew reams of debugging output
-d	spew reams of debugging output
easier to parse.  It's still not a pretty program, but at least it's more
	&edecl;
		elements in the structure.  You would use this for indexing
    } else {
    #} else {
    else {
	    } else {
	    else {
	} else  {
	} else {
		} else {
    #else { $tname = "$tname*"; }
    elsif (/^=ar/) {
    elsif (@ARGV == 1 && $ARGV[0] =~ /\.c$/) {
    } elsif (/^\d+$/) {
    elsif (defined $struct{$mytype}) {
    elsif (defined $template{$mytype}) {
    elsif (grep(/\.s$/,@ARGV)) {
        } elsif ($inseq) {
    } elsif ($isastruct{$what})  {
    } elsif (!$oops) {
	elsif (s/^(\d+|\(\d+,\d+\))?,(\d+),(\d+);//) {
	elsif (s/^((\d+|\(\d+,\d+\))(=[*f](\d+|\(\d+,\d+\)))+),(\d+),(\d+);//) {
    } elsif (s/^(\d+)(=[*suf]\d*)//) {
	} elsif (s/(\d+)=([us])(\d+|\(\d+,\d+\))//) { #
	elsif (s/(\d+)=([us])(\d+|\(\d+,\d+\))//) { # the dratted anon struct
        elsif (s/^(\d+)=xs\w+:,(\d+),(\d+);//) {
    elsif (s/^=e//) { # blessed be thy compiler; mine won't do this
    elsif (s/((\w+):t(\d+|\(\d+,\d+\)))?=r?(;\d+;\d+;)?//) {  # the ?'s are for gcc
	elsif ($template{&psou($mytype)} !~ /\$$/) {
    elsif (/^[\$\w]+:/) {
	} elsif ($whatis =~ /[su]/) {  #
	$entry = '';
		    $entry,
	    $entry =~ s/(\*+)( )/$2$1/;
	    $entry = sprintf($pmask1,
    $enum{$name} = $_;
    $_ = eval;
eval '$'.$1.'$2;' while $ARGV[0] =~ /^([A-Za-z_]+=)(.*)/ && shift;
    eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
    eval $scrunch_code;
	eval '$sizeof{$name} = length(pack($fmt, ()))';
    exit;
    exit(0);
    exit 1;
    exit 1 if $] <= 4.003;  # caller broken
    exit unless $isatty;
	    $fieldname = $1;
	    #$fieldname = &gensym;
	($fieldname, $typeno, $count, $offset, $length) = split(/,/, $field);
fields are just their own names.  Plus the following accessor functions are
	$fieldtype = &psou($mytype);
    $finished_template{$sname}++;
    'float',			'4',
    'float',			'f',
	$fmt = '?';
	$fmt = $template{$mytype};
	$fmt = $template{'pointer'};
	$fmt = $template{&psou($mytype)} || '?';
    $fmt x $count . ' ';
	$fname = &psou($name);
	for (@a) {
    foreach $name (sort bysizevalue keys %intrinsics) {
    foreach $name (sort keys %intrinsics) {
    foreach $name (sort keys %struct) {
    for $field (split(/;/, $struct{$what})) {
    for ($i=0; $i <= $#sub; $i++) {
    for ($i = 0; ($p,$f,$l,$s,$h,$w) = caller($i); $i++) {
    for $i (0 .. $#type) {
	for $i (reverse 0..$#type) {
    for (reverse @pdecls) {
    for (sort keys %start) {
    for (split(/[\s,]+/, $opt_s)) {
    for $type (@intrinsics) {
    for (values %intrinsics) {
generator that translates C code into perl code!  Well, structure and union
getopts('aixdpvtnws:') || &usage(0);
    # global $typeno, @type
	     	guarantee that a union is unpacked into all its aliases.
	% h2ph <some_include_file.h  >  /usr/lib/perl/tmp.ph
=head1 DESCRIPTION
=head1 NAME
=head1 SYNOPSIS
=head2 OPTIONS
    '$iam';
	$iam = ($isastruct{$name} && 's') || ($isaunion{$name} && 'u');
I can't know this for your system, but it's not usually too terribly difficult.
    -i	do NOT recompute sizes for intrinsic datatypes
-i	do NOT recompute sizes for intrinsic datatypes
	if ($@) {
	if ($_[0] =~ /^\s*c\s*$/i) {
    if ( $_[1] ) {
    If any *.[ch] files are given, these will be catted together into
if (@ARGV) {
	if (@ARGV > 1) {
	if ($build_templates) {
    if ($build_templates && !defined $sizeof{$name}) {
	if (/^(\d+|\(\d+,\d+\))=ar/) {
		if $debug;
		if defined $lastoffset;
	if (!defined $template{&psou($mytype)}) {
	    if (defined($type[$typeno])) {
	if ($extra =~ /\*/ && defined $type[$struct]) {
    if ($extra =~ /[us*]/) {
	    if (! $finished_template{$sname}) {
    if (grep(!/\.[csh]$/,@ARGV)) {
    if ($isaunion{$what})  {
		if ($isaunion{$what}) {
      # if last 2 chars of string are '\\' then stab is continued
    if ($mytype =~ /\*/) {
    if ($mytype =~ s/(\[\d+\])+$//) {
    if (($name, $pdecl) = /^([\$ \w]+):[tT]((\d+)(=[rufs*](\d+))+)$/) {
    if (($name, $typeordef, $typeno, $extra, $struct, $_)
	    if ($nesting==1 && !$build_templates) {
        if ($num == ($last + 1)) {
if ($opt_s) {
if ($opt_w) {
if ($opt_x) {
    if ($perl) {
	    if ($perl) {
	if ($perl) {
	    if ($perl && $nesting == 1) {
				if $perl && $verbose;
			if !$perl || $verbose;
		if $recurse && defined $struct{$type};
	if $running_under_some_shell;
    if (s/\\\\$//) {
	if ($saveline) {
	if (s/\\\\"[d,]+$//) {
	if (s/^(\d+);(\d+);//) {
    if (s/;\d*,(\d+),(\d+);//) {
    if (s/^([(,)\d*f=]*),(\d+),(\d+);//) {
	    if (/^StB\000/ && length($_) == length($_main{'_main'})) {
	if (s/^([\$\w]+)://) {
	if (-t && !@ARGV) {
    if ($tname =~ s/^f//) { $tname = "$tname&"; }
    if ($trace) {
	if ($trace && !($. % 10)) {
    #if ($typedef) {
	if ($whatis =~ /^(\d+|\(\d+,\d+\))=/) {
	if ($whatis =~ /[f*]/) {
    if (/(([ \w]+):t(\d+|\(\d+,\d+\)))=r?(\d+|\(\d+,\d+\))(;\d+;\d+;)?/) {
If you're only a C programmer, than this is the end of the message for you.
	    ($iname = $name) =~ s/\..*//;
	($iname = $name) =~ s/\..*//;
$indent = 2;
      # in next stab entry
        $inseq = 0;
	% install
    'int',			'4',
	$interested{$_}++;
    'int',			'i',
		into arrays of structures, perhaps like this
		into the packed structure with vec() if you're too lazy
%intrinsics =
	$intrinsics{$_[1]} = $template{$_[0]};
     int                        tty.t_canq.c_cc                      02c      4
     int                        tty.t_canq.c_cfx                     034      4
     int                        tty.t_canq.c_clx                     038      4
     int                        tty.t_canq.c_cmax                    030      4
   int                          tty.t_locker                         000      4
   int                          tty.t_mutex_index                    004      4
   (*int)()                     tty.t_oproc_cpu                      06c      4
   (*int)()                     tty.t_oproc_iop                      070      4
     int                        tty.t_outq.c_cc                      04c      4
     int                        tty.t_outq.c_cfx                     054      4
     int                        tty.t_outq.c_clx                     058      4
     int                        tty.t_outq.c_cmax                    050      4
     int                        tty.t_rawq.c_cc                      00c      4
     int                        tty.t_rawq.c_cfx                     014      4
     int                        tty.t_rawq.c_clx                     018      4
     int                        tty.t_rawq.c_cmax                    010      4
   (*int)()                     tty.t_stopproc_cpu                   074      4
   (*int)()                     tty.t_stopproc_iop                   078      4
    $isatty++;
	$isatty++;
				+ &itimerval'it_value
				+ (&ITIMER_VIRTUAL * &itimerval'struct)
It's a little tricker with c2ph because you have to get the includes right.
    # i wanna say this, but perl resists my efforts:
			join("\n\t", '', @fieldnames), "\n    );\n\n";
			join("\n\t", '', @offsetof), "\n    );\n\n";
			join("\n\t", '', @sizeof), "\n    );\n\n";
			join("\n\t", '', @typedef), "\n    );\n\n";
			join("\n\t", '', @typeof), "\n    );\n\n";
	last if $signal;
            $last = $num;
        $last = $num;
	    ($lastoffset, $lastlength) = ($offset, $length);
leading zeroes or whatever.
		    $length/8,
	    $length = $offset;
	    $length = $sizeof{$name};
    $line = $_;
	$line = $_;
	    $lineno = $..'';
line program when I started, or I might not have begun. :-)  But I would have
	    $line = $saveline;
listings like this:
    local($_) = @_;
	local($_) = @_;
    local($amstruct) = $struct{$me} ?  'struct ' : '';
    local($bits,$bytes);
    local($build_templates) = 1;
    local($count) = 1;
	local($dir, $file) = $ARGV[0] =~ m#(.*/)?(.*)$#;
    local($field, $fieldname, $typeno, $count, $offset, $entry);
    local($fieldname, $scripts, $type, $arraytype, $unknown,
    local($fieldtype);
    local($fmt);
	local($fmt) = &scrunch($template{$sname});
	local($fname) = &psou($name);
    local($i,$_);
    local($iam);
	local($ident) = $2;
    local($last) = -1e8;
		local($little) = &scrunch($template);
    local($lparen) = '(' x $build_recursed;
    local($me) = @_;
    local(\$${mname}'index) = shift;
    local($mname) = &munge($name);
	    local($mycount) = defined $struct{$mytype} ? $countof{$mytype} : 1;
    local($mytype) = @_;
    local($mytype, $mycount, $entry2);
    local($name) = @_;
	    local($name) = "$prefix.$fieldname";
	    local($name) = $type[$typeno];
	local($ncount) = &scripts2count($_[1]);
    local($num);
    local($oops) = @_;
    local($pad, $revpad, $length, $prepad, $lastoffset, $lastlength, $fmt);
    local($pdecl) = @_;
    local(@pdecls);
    local($p,$f,$l,$s,$h,$a,@a,@sub);
    local($prefix) = '';
    local($prefix, $_, $offset) = @_;
    local($rparen) = ')' x $build_recursed;
    local($seq) = '..';
    local($sname) = &psou($what);
    local($sou);
	local($start, $size) = ($1, $2);
    local($string);
    local($struct_count) = 0;
    local($template);
    #  local($template, $scripts) = @_;  have to change caller's values
    local($TMP) = "$SAFEDIR/c2ph-i.$$.c";
    local($tname);
    local($_, $typedef) = @_;
    #local($typeno);
    local($typeno,$sou);
    local($type, $tname);
    local($var, $msg) = @_;
    #local($wasdef) = defined($type[$typeno]) && $debug;
    local($what, $_) = @_;
    local($what) = @_;
	local($whatis) = $2;
    local($what,$prefix,$base) = @_;
    'long',			'4',
    'long int',			'4',
    'long int',			'l',
    'long',			'l',
    'long long',		'8',
    'long long int',		'8',
    'long long int',		'q',
    'long long',		'q',
    'long unsigned int',	'4',
    'long unsigned int',	'L',
	    ($lower, $upper) = ($1, $2);
main() {
		member.  You may wish to use this for indexing directly
    \@${mname}'fieldnames;
			"${mname}'${fieldname}", $struct_count);
	$mname = &munge($name);
	? \$${mname}'offsetof[\$${mname}'index]
	: \$${mname}'sizeof;
	? \$${mname}'sizeof[\$${mname}'index]
	: \$${mname}'typedef;
	? \$${mname}'typedef[\$${mname}'index]
	? \$${mname}'typeof[\$${mname}'index]
    most one *.s file should be supplied.
	    $mycount *= &scripts2count($count) if $count;
	$mytype = $1;
		. "';\n";
	: '$name';
    -n	do not generate perl code  (default when invoked as pstruct)
-n  	do not generate perl code  (default when invoked as pstruct)
    'neganull',			'X',
    --$nesting;
    $nesting++;
            next;
      next;
	    next;
	next if $opt_s && !$interested{$iname};
    next if /^\s*$/;
	next if $size_printed{$name};
	next if !$type || $type eq 'void' || $type =~ /complex/; # sun stuff
	    #next SFIELD;
	    next STAB;
	next STAB;
    next unless $continued || /:[\$\w]+(\(\d+,\d+\))?=[\*\$\w]+/;  # (\d+,\d+) is for sun
	    next unless defined($name = $type[$i]);
	    next unless defined $struct{$name};
	next unless defined $type[$i];
    #next unless $extra =~ /[su*]/;
	next unless /^\s*\.stabs\s+/;
	next; # variable
		No args to this one is a noop.  Someday I'll post such
    'null',			'x',
    ($offset_fmt, $offset_width, $size_fmt, $size_width) = ( 'x', '08', 'x', 04 );
($offset_fmt, $size_fmt) = ('d', 'd');
    offsetof	This function is the byte offset into the array of that
offsets for you.  This was especially useful for people looking at
	    $offset = $sizeof{$name};
	    $offset += $sizeof{$name};
of the stabs on the fly, and then account for micro differences between my
Once upon a time, I wrote a program called pstruct.  It was a perl
		one returns the C type of that field.  This would allow
    open(PIPE, "cd $SAFEDIR && $CC $TMP && $SAFEDIR/a.out|");
	open (PIPE, "|". ($ENV{PAGER} || 'more'));
    open (TMP, ">$TMP") || die "can't open $TMP: $!";
$opt_d && $debug++;
    Options:
Options:
$opt_n && ($perl = 0);
$opt_p && $perl++;
					$opt_s && !$interested{$iname};
$opt_t && $trace++;
$opt_v && $verbose++;
other, etc.  It might also have helped if I didn't have to divine the makeup
	    $pad = ($offset - ($lastoffset + $lastlength))/8
	$pad = $prepad = 0;
    &panic("already got a template for $name") if defined $template{$name};
    &panic("can't eval scrunch_code $@ \nscrunch_code") if $@;
    &panic("$_: $@") if $@;
	&panic("no length for $prefix.$fieldname") unless $length;
          &panic("no length?") unless $length;
	    &panic("no length?") unless $length;
	&panic("type 0??") unless $typeno;
    &panic("why do you care?") unless $perl;
	$pcode = '';
		$pcode .= sprintf("sub %-32s { %4d; }\n",
	    &pdecl($pdecl);
	&pdecl($pdecl);
    $pdecl =~ s/\(\d+,(\d+)\)/$1/g;
    $pdecl =~ s/\*//g;
    @pdecls = split(/=/, $pdecl);
	    ($pdecl, $start, $length) =  ($1,$5,$6);
	    &pdecl($whatis);
$perl++ if $0 =~ m#/?c2ph$#;
    -p	generate perl code         (default when invoked as c2ph)
-p  	generate perl code         (default when invoked as c2ph)
    $pmask1 = "%-${type_width}s %-${member_width}s";
    $pmask2 = "%-${sum}s %${offset_width}${offset_fmt}%s %${size_width}${size_fmt}%s";
    'pointer',			'4',
    'pointer',			'p',
			"$prefix.$fieldname" . $count);
	$prefix = 'struct ';
	$prefix = 'union ';
    $prefix . $what;
	    print "anon ".($isastruct{$name}) ? "struct":"union"." for $prefix.$fieldname\n" if $debug;
		print "anon type $typeno is $prefix.$fieldname\n" if $debug;
	    print ", a typedef for a pointer to " , $type[$struct] if $debug;
	print ", a typedef for " , $type[$typeno] if $debug;
	    #print "done with anon, start is $start, offset is $offset\n";
    print <<'EOF';
    print <<EOF;
   print <<'EOF';
	    print <<EOF;
	print <<"EOF";
    printf "%-16s%-15s  %s\n", $var, eval "\$$var", $msg;
    printf "%d;\n", $sizeof{$me};
    printf(mask,sizeof(char *), "pointer");
    printf(mask,sizeof($type), "$type");
	print "$fname {\n" if !$perl || $verbose;
	    ##printf "new type $typeno is $name" if $debug;
	printf "new type $typeno is $name" if $debug;
	    printf("\nsub %-32s { %4d; }\n\n", "${mname}'struct", $countof{$name});
	    printf $pmask2,
	printf "%s is type %d", $name, $typeno if $debug;
    printf "you have used %8.3fs+%8.3fu seconds.\n", $utime, $stime;
	print "hit <RETURN> for further explanation: ";
	    print '# ' if $perl && $verbose;
	print "# " if $perl && $verbose;
	print "intrinsic $_[1] is size $_[0]\n" if $debug;
	print "it's a bare array typedef -- that's pretty sick\n" if $debug;
	    print "\@${mname}'fieldnames[\@${mname}'indices] = (",
	    print "\@${mname}'indices = (", &squishseq(@indices), ");\n";
	    print "\@${mname}'offsetof[\@${mname}'indices] = (",
	    print "\@${mname}'sizeof[\@${mname}'indices] = (",
	    print "\$${mname}'sizeof = $sizeof{$name};\n\n";
	    print "\@${mname}'typedef[\@${mname}'indices] = (",
	    print "\$${mname}'typedef = '" . &scrunch($template{$fname})
	    print "\@${mname}'typeof[\@${mname}'indices] = (",
	print '$',&munge($name),"'sizeof = ", $sizeof{$name}, ";\n";
	print '$',&munge($name),"'typedef = '", $template{$name}, "';\n";
    print "\n";
	    print "\n";
	print "\n";
    print "\n1;\n" if $perl;
	print "\n1;\n" if $perl;
	print "$name is a typedef for some funky pointers: $pdecl\n" if $debug;
    print "\n" if $debug;
	print "$_\n" if $debug;
	    print "\n" if !$perl || $verbose;
	print "}\n" if !$perl || $verbose;
	print "\n" if $perl && $verbose;
    print "\npanic: @_\n";
    print "oops, apparent pager foulup\n";
	    print "$pcode";
    print "$prefix.$fieldname is an array of $type[$arraytype]\n" if $debug;
	    print "$prefix.$fieldname is an array$scripts anon structs; disgusting\n"
	#print "redefining $type[$typeno] to " if $wasdef;
    print "$scrunch_code" if $debug;
    print '$sizeof{\'', $amstruct, $me, '\'} = ';
	print "start of $prefix is $start, size of $sizeof{$prefix}\n" if $debug;
	print "start: $_ @ $start{$_}\n" if $debug;
    print STDERR "computing intrinsic sizes: " if $trace;
    print STDERR "done\n" if $trace;
    print STDERR "dumping structs: " if $trace;
	print STDERR "intrinsic $2 in new type $typeno\n" if $debug;
	print STDERR "intrinsic $ident in new type $typeno\n" if $debug;
	    print STDERR $lineno, "\b" x length($lineno);
    print STDERR "$lparen$name$rparen " if $trace;
	print STDERR "$name " if $trace;
	print STDERR "\nbuilding type templates: " if $trace;
    print STDERR "@_\n" if $trace;
    print STDERR "$.\n" if $trace;
    print STDERR "\n" if $trace;
	print STDERR "\n\n" if $trace;
	print STDERR "no size for $name, punting with $fmt..." if $debug;
	    print STDERR "reading from " . (@ARGV ? "@ARGV" : "<STDIN>").": ";
	    print STDERR "reading from your keyboard: ";
    print STDERR "resolving types\n" if $trace;
	    print STDERR $sizeof{$name}, "\n" if $debUg;
    print STDERR "TEMPLATE for $name is ", $template{&psou($name)}, "\n" if $debug;
	print $sub[$i];
    print "type[$arraytype] is $type[$arraytype]\n" if $debug;
	print "type[$i] $_ ==> " if $debug;
	print "type[$_] is $tname\n" if $debug;
	    print "type[$i] $type[$i]\n" if $debug;
	#print "$type[$typeno]\n" if $wasdef;
    print "usage: $0 [-dpnP] [var=val] [files ...]\n";
	    print '  ', ' ' x $indent x $nesting, $template
Prior to this point, anyone programming in perl who wanted to interact
program that tried to parse out C structures and display their member
provided for your convenience:
    &pstruct($name,$name,0);
	&pstruct($name,$name,0);
Pstruct takes any .c or .h files, or preferably .s ones, since that's
	&pstruct($type, "$prefix.$fieldname", $base+$offset)
Pstruct was not a pretty program.  Neither was it particularly robust.
		push(@fieldnames, "'$fieldname',");
		push(@indices, $struct_count);
	push(@intrinsics, $2);
	push(@intrinsics, $ident);
		push(@offsetof, int($offset/8) .",\t# $fieldname");
		push(@sizeof, int($length/8) .",\t# $fieldname");
	push(@sub, "$w&$s$a from file $f line $l\n");
		push(@typedef, "'$little', \t# $fieldname");
		push(@typeof, "'$mytype" . ($count ? $count : '') .
    &quick_scrunch;
$RCSID = '$Id: c2ph,v 1.7 95/10/28 10:41:47 tchrist Exp Locker: tchrist $';
$recurse = 1;
	    &repeat_template($template,$count);
		&repeat_template($template,$count);
    require 'syscall.ph';
    require 'sys/resource.ph';
    require 'sys/time.ph';
	# resolve template -- should be in stab define order, but even this isn't enough.
    &resolve_types;
    return '' if $_ eq '';
	    $revpad = $length/8 if $isaunion{$what};
    $ru = "\0" x &rusage'sizeof();
	   + ($ru[ &rusage'ru_stime + &timeval'tv_usec ]) / 1e6;
	   + ($ru[ &rusage'ru_utime + &timeval'tv_usec ]) / 1e6;
			&rusage'sizeof(&rusage'ru_utime)
    @ru = unpack($t = &rusage'typedef(), $ru);
    s/^\[//;
    s/ $//;
    s/;$//;
    s/\]$//;
	    s/^"//;
		s/([^\0]*)/'$1'/ unless /^-?[\d.]+$/;
		s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
	s/(\*+)([^*]+)(\*+)/$1$3$2/;
		s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
    &safedir;
	&safedir;
    $SAFEDIR = File::Temp::tempdir("c2ph.XXXXXX", TMPDIR => 1, CLEANUP => 1)
	    $_ = $savebar . $_;
	    $savebar  = $_;
	$savebar = $saveline = undef;
	    $saveline .= $line;
	$scripts = '';
	    $scripts .= '[' .  ($upper+1) . ']';
    $scrunch_code .= "}\n";
    $scrunch_code = "sub quick_scrunch {\n";
        $scrunch_code .= "\ts/(${_}{2,})/'$_' . length(\$1)/ge;\n";
	s/^(\d+)(\**)\&\*(\**)/"$2($3".&type($1) . ')()'/e;
    s/\(\d+,(\d+)\)/$1/;
	#s/(\d+)(\*|(\[[\[\]\d\*]+]\])+)/&type($1).$2/ge;
    s/;[-\d]*;[-\d]*;$//;  # we don't care about ranges
	$_ = &sdecl($name, $_, 0);
	    $_ = &sdecl($name, $_, $start+$offset);
	    $_ = &sdecl("$prefix.$fieldname", $_, $start+$offset);
	    #$_ = &sdecl("$prefix.$fieldname", $_, $start+$offset);
	s/^(\d+)([\*\[].*)/&type($1).$2/e;
	s/^(\d+)/&type($1)/e;
	s/^(\d+)\&/&type($1)/e;
#   See the usage message for more.  If this isn't enough, read the code.
	select(PIPE);
    select(STDERR);
	select(STDERR);
    select(STDOUT);
    select(TMP);
    s/  / /g;
    s/\]\[/*/g;
    s/\$//g;
		s/'/\\'/g;
sgtty structure was laid out differently, your program broke.  Which is
    'short',			'2',
    'short int',		'2',
    'short int',		's',
    'short',			's',
    'short unsigned int',	'2',
    'short unsigned int',	'S',
should get this for you.
	$SIG{PIPE} = PLUMBER;
    /s/ && $isastruct{$what}++;
    $size = $3 if $3;
%sizeof = (
	$sizeof{$_[1]} = $_[0];
    $sizeof{$name} = $size if $size;
	$sizeof{$prefix} = $size;
    sizeof   	Returns the bytes in the structure, or the member if
	    $size_printed{$fname}++;
    -slist  give comma-separated list a structures to dump
-slist  give comma-separated list a structures to dump
    s/"// 						|| next;
So I got smart:  I decided to be lazy and let the C compiler parse the C,
# some handy data definitions.   many of these can be reset later.
	    &sou($name,$2);
	&sou($name, $extra);
	    &sou($name,$sou);
	    &sou($name, $whatis);
	split(' ',$_,2);;
		$_ = sprintf("%s",$_);
	s/[\s\$\.]/_/g;
	s/^\s*\.stabs\s+//;
STAB: while (<>) {
          ($start, $length) =  ($2, $3);
	    ($start, $length) =  ($2, $3);
	($start, $length) = ($2, $3);
	$start{$prefix} = $start;
	$start{$_} += $start{$basename};
	    $start = $start{$name};
	<STDIN>;
    $stime =  $ru[ &rusage'ru_stime + &timeval'tv_sec  ]
    $string;
        $string .= ',' if defined $string;
    $string .= $last if $inseq && $last != -e18;
            $string .= $last unless $last == -1e8;
        $string .= $num;
            $string .= $seq unless $inseq++;
   struct clist                 tty.t_canq                           02c     20
   struct clist                 tty.t_outq                           04c     20
   struct clist                 tty.t_rawq                           00c     20
	    $struct_count += $mycount;
	$struct{$name} .= join(',', $fieldname, $typeno, $scripts, $start, $length) . ';';
    struct	This takes no arguments, and is merely the number of first-level
   struct thread *              tty.t_rsel                           07c      4
 struct tty {
     struct tty *               tty.t_canq.c_tp_cpu                  03c      4
     struct tty *               tty.t_canq.c_tp_iop                  040      4
     struct tty *               tty.t_outq.c_tp_cpu                  05c      4
     struct tty *               tty.t_outq.c_tp_iop                  060      4
     struct tty *               tty.t_rawq.c_tp_cpu                  01c      4
     struct tty *               tty.t_rawq.c_tp_iop                  020      4
   struct tty *                 tty.t_tp_virt                        008      4
		structure without knoning anything about it beforehand.
    study;
sub adecl {
sub adjust_start_addrs {
sub buildscrunchlist {
sub build_template {
    sub bysizevalue { $sizeof{$a} <=> $sizeof{$b}; }
sub compute_intrinsics {
sub defvar {
sub edecl {
sub fetch_template {
sub ${mname}'fieldnames {
sub ${mname}'isastruct {
sub ${mname}'offsetof {
sub ${mname}'sizeof {
sub ${mname}'typedef {
sub ${mname}'typeof {
    sub munge {
sub panic {
sub pdecl {
sub PLUMBER {
sub psize {
sub psou {
sub pstruct {
sub repeat_template {
sub resolve_types {
sub safedir {
sub scripts2count {
sub scrunch {
sub sdecl {
sub sou {
sub squishseq {
sub stab {
sub system {
sub typeno {  # sun thinks types are (0,27) instead of just 27
sub type { &psou($type[$_[0]] || "<UNDEFINED>"); }
sub usage {
    $sum = 2 + $type_width + $member_width;
    supplied, then stdin is read directly with the assumption that it
    #	   s/(\w)(\1+)/$2 . length($1)/ge;
	s/\((\*+)(\w+)(\*+)\)/$3($1$2)/;
    s/",([x\d]+),([x\d]+),([x\d]+),.*// 		|| next;
    syscall(&SYS_getrusage, &RUSAGE_SELF, $ru)      && die "getrusage: $!";
    system @_;
	&system("cat @ARGV > $TMP") && exit 1;
	&system("cd $SAFEDIR && $CC $CFLAGS $DEFINES $TMP") && exit 1;
	&system("$chdir$CC $CFLAGS $DEFINES $file") && exit 1;
<tchrist@perl.com>
%template = (
	    $template = &fetch_template($type);
		$template = &fetch_template($type);
	$template{$fname} = &scrunch($template{$fname}) if $perl;
	    $template_printed{$fname}++;
    $template{$sname} .= '$' if $build_templates;
		$template{$sname} .= $template;
		    $template{$sname} .= 'x' x $pad    . ' '    if $pad;
		    $template{$sname} .= 'X' x $revpad . ' '    if $revpad;
		    "',\t# $fieldname");
The code isn't pretty as I mentioned  -- I never thought it would be a 1000-
the C structures, and then hardwire these into his program.  Of course,
The following is the old c2ph.doc documentation by Tom Christiansen
the format it is going to massage them into anyway, and spits out
the formatting of each column, whether you prefer wide or fat, hex or decimal,
them in terms of packages and functions.  Consider the following program:
The problem, you see, was that the C compiler was much better at parsing
The way I see this being used is like basically this:
	     	the whole structure, otherwise you get that of the member
				+ &timeval'tv_usec
	$TMP = "$SAFEDIR/c2ph.$$.c";
	$TMP =~ s/\.c$/.s/;
    $tname = pop @pdecls;
	$tname  .= s/^f// ? "&" : "*";
	#$tname =~ s/^f(.*)/$1&/;
To learn more, just type a bogus option, like B<-\?>, and a long usage message
#   Tom Christiansen, <tchrist@convex.com>
		to unpack it.
    -t	trace execution
-t 	trace execution
	$type =~ /([^[]*)(\[.*\])?/;
    $type[$arraytype] = "$type[$typeno]$scripts" if defined $type[$typeno];
	#$type[$arraytype] = $type[$typeno] unless defined $type[$arraytype];
    typedef  	This is the perl format definition for passing to pack and
	$_ = $type[$i];
	$type[$i] = $_;
	$_ = "$typeno$_";
	$typeno = $_;
	    $typeno = $1;
    $typeno = $pdecls[0];
    $typenos{$name} = $typeno;
	    ($typeno, $sou) = ($1, $2);
	    $typeno = &typeno($1);
          $typeno = &typeno($1) if $1;
	    $typeno = &typeno($1) if $1;
	$typeno = &typeno($3);
	    $typeno = &typeno($typeno);
	$typeno = &typeno($typeno);  # sun foolery
	    $typeno = &typeno($whatis);
    typeof	Not to be confused with the typedef accessor function, this
		$type =~ s/(struct|union) //;
    #$type[$struct] = $name;
	$type[$_] = $tname unless defined $type[$_];
	$type[$typeno] = $2;
	$type[$typeno] = $ident;
	    #$type[$typeno] = $name unless defined $type[$typeno];
	$type[$typeno] = $name unless defined $type[$typeno];
	    $type[$typeno] = "$prefix.$fieldname";
		$type[$typeno] = "$prefix.$fieldname" unless defined $type[$typeno];
	#$type[$typeno] = "$whatis$scripts"; # unless defined $type[$typeno];
	$type = $type[$typeno];
    ($type_width, $member_width, $offset_width) = (45, 35, 8);
($type_width, $member_width, $offset_width, $size_width) = (20, 20, 6, 5);
    /u/ && $isaunion{$what}++;
	undef @fieldnames;
	undef @indices;
    undef %intrinsics;
	undef @offsetof;
undef $SAFEDIR;
	undef @sizeof;
	undef @typedef;
	undef @typeof;
	$unknown = &typeno($unknown);
	unless (/\d/) {
      unless (defined($SAFEDIR));
    unless (defined $type[$typeno]) {
    unless ($perl && $opt_a) {
    unless (-t STDOUT) {
	unlink $TMP;
    unlink $TMP if $TMP;
    unlink($TMP, "$SAFEDIR/a.out");
	     	unpack.  If you ask for the typedef of a nothing, you get
    'unsigned char', 		'1',
    'unsigned char', 		'C',
     unsigned char *            tty.t_canq.c_buf_cpu                 044      4
     unsigned char *            tty.t_canq.c_buf_iop                 048      4
     unsigned char *            tty.t_outq.c_buf_cpu                 064      4
     unsigned char *            tty.t_outq.c_buf_iop                 068      4
     unsigned char *            tty.t_rawq.c_buf_cpu                 024      4
     unsigned char *            tty.t_rawq.c_buf_iop                 028      4
    'unsigned int',		'4',
    'unsigned int',		'I',
    'unsigned long',		'4',
    'unsigned long int',	'4',
    'unsigned long int',	'L',
    'unsigned long',		'L',
    'unsigned long long',	'8',
    'unsigned long long int',	'8',
    'unsigned long long int',	'Q',
    'unsigned long long',	'Q',
    'unsigned short',		'2',
    'unsigned short int',	'2',
    'unsigned short int',	'S',
    'unsigned short',		'S',
	    &usage;
	&usage;
    &usage(1);
		    $usec = $u[ &user'u_utimer
use File::Temp;
use File::Temp 'tempdir';
use Getopt::Std qw(getopts);
# use -s to recompute sizes
#!/usr/bin/perl
    #!/usr/local/bin/perl
    $utime =  $ru[ &rusage'ru_utime + &timeval'tv_sec  ]
Var Name        Default Value    Meaning
    -v	generate perl code, with C decls as comments
-v	generate perl code, with C decls as comments
	warn "bad array stab: $_ in $line ";
	    warn "can't find array bounds: $_";
	    warn "can't grok stab for $name ($_) in line $line ";
	warn "can't grok stab: <$_> in: $line " if $_;
	    warn "couldn't get size for \$name: $@";
	warn "Funny remainder for $name on line $_ left in $line " if $_;
    #warn "got size $size for $name\n";
	    #warn "incomplete template for $mytype\n";
		warn "now how did we get type $1 in $fieldname of $line?";
	warn "Only *.[csh] files expected!\n";
	    warn "Only one *.s file allowed!\n";
    warn "pdecl: $pdecl\n" if $debug;
	warn "sdecl $_\n" if $debug;
	warn "unknown fmt for $mytype\n";
	    warn "weird field $_ of $line" if $debug;
	    warn "what's this? $whatis in $line ";
We've had Larry's h2ph translator, which helped, but that only works on
	$whatis = $1;
    $whatis, $pdecl, $upper,$lower, $start,$length) = ();
when you feel like it.  Or not.
when you took your wonderfully crafted program to a system where the
which would spit out debugger stabs for me to read.  These were much
    while (/^([^;]+);/) {
    while (defined($num = shift)) {
    while (<PIPE>) {
    while (s/^((\d+|\(\d+,\d+\))=)?ar(\d+|\(\d+,\d+\));//) {
will be provided.  There are a fair number of possibilities.
with C programs, like the kernel, was forced to guess the layouts of
wondrous than just a structure offset printer.
	= /^([\$ \w]+):([ustT])(\d+|\(\d+,\d+\))(=[rufs*](\d+))?(.*)$/)
	$w = $w ? '@ = ' : '$ = ';
    -w	wide; short for: type_width=45 member_width=35 offset_width=8
-w	wide; short for: type_width=45 member_width=35 offset_width=8
    -x	hex; short for:  offset_fmt=x offset_width=08 size_fmt=x size_width=04
-x	hex; short for:  offset_fmt=x offset_width=08 size_fmt=x size_width=04
			' ' x ($nesting * $indent) . $fieldtype,
	     	you ask for.  Padding is taken care of, as is the magic to
You can quit right now, and if you care to, save off the source and run it
you is a symbolic way of getting at all the C structures.  I've couched
	     	you pass it an argument, such as
You see, if you call pstruct by its other incybernation, c2ph, you have a code
		you to print out a nice structured pretty print of some
