                }
            }
            };
            # "@ *"
        }
#                                           #
#############################################
###########################################################################
% ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ~~
0 0 moveto
    0 -24 rmoveto
0 -$init_yinc rmoveto
    $| = 1;
                        [10, 1.1],
                        [10, 1.2],
    ==> 10 converted fonts.
                        [12, 1.0],
                        [12, 14.40/12],
                        [12, 17.28/12],
                        [12, 20.74/12],
                        [12, 24.88/12]) {
1.3c or later is part of all distributions of LaTeX version 2006/05/20
                        [17, 1.0],
    ==> 1 merged font.
            "1|no-repeats" => \$single_font_use) || pod2usage(2);
28> and ending with a matching C<%EndDVIPSBitmapFont> is known to
      36 0 rmoveto
                        [ 5, 1.0],
                        [ 6, 1.0],
                        [ 7, 1.0],
                        [ 8, 1.0],
                        [ 9, 1.0],
                            || $a cmp $b} keys %name2chars;
actually used in a document are particularly problematic for
Add I<fontspec> to the list of font specifications against which
additionally displays information about individual font comparisons.
    \afterassignment\puthelper
After running the preceding commands, F<oldfonts.ps> shows samples of
(Alternatively B<pkfix> may issue an error message such as C<!!!
Although B<pkfix-helper> tries to automate as much as possible the
a mismatch value greater than or equal S<to 1.0>.  (The mismatch value
and appear crisp at any size or scale.
an odd size for a font.  Then again, many documents I<do> use
                    # ASCII character number
A second B<--verbose> additionally displays details about some of the
attempts to determine the association between each document-font name
[B<--cache>=I<filename>]
B<dvips> and utilizing at least one bitmapped font.  It's always worth
B<dvips>-produced PostScript files with the corresponding vector
B<dvips> surrounds bitmapped-font definitions.  For example, a font
  \begingroup
\%\%BeginProcSet: $progname.pro
            $bestmatch;
            $bestmatch  = $match;
            @besttfms   = ($tfminfo);
# better).  The third, optional, argument is a scale factor for the
[B<--exclude>=I<regexp>]
B<--force> designates a font specification to use only for a
[B<--force>=I<name>=I<fontspec>]
B<--force> option to designate an alternative replacement font or
[B<--help>]
[B<--include>=I<fontspec>]
} bind def
    binmode INFILE;
binmode $psfile;
    binmode SAMPLE_PS;
/bitmap-font-transform [$dvips_xscale 0.0 0.0 $dvips_yscale 0 0] def
    Bitmapped fonts are typeset at 600 DPI.
[B<--no-repeats>]
B<pkfix-helper> accepts on the command line the filename of a
B<pkfix-helper> allows C<*> to be used as a scaling factor to tell the
B<pkfix-helper> because many fonts may be near-enough matches to fool
B<pkfix-helper> compares I<every> document font.  (In contrast,
B<pkfix-helper> honors the following environment variables:
B<pkfix-helper> is designed so that a user can guide the
B<pkfix-helper> works by comparing character widths, not the actual
B<pkfix-helper> works by comparing every document font against every
B<pkfix-helper> works only with PostScript files produced by B<dvips>,
[B<--ps>=I<filename.ps>]
[B<--quiet>]
[B<--spp>=I<number>]
[B<--tex>=I<filename.tex>]
[B<--verbose>]
# By Scott Pakin <scott+pkfh@pakin.org>     #
can be specified repeatedly on the command line.
    \catcode`\\=0\relax
    \catcode`\{=1\relax
    \catcode`\}=2\relax
            "C|cache=s"    => \$tfm_cache_file,
C<cmss10>)> and fonts size (e.g., S<C<11> points>).  It then
% char0 char1 PRINT-WIDTH -
characters actually used by the document are defined.  B<pkfix> then
# characters in that font.
# characters utilized) to every TFM file (in increasing order of
character widths (at least for those characters used by a given
            $charnum++;
            $charnum = $chardef[$#chardef-1];
                    $charnum = oct $2;
                    $charnum = ord $2;
    (   CHAR: ) print 8 string cvs print
        chomp $oneline;
    close CACHEFILE;
close GSCMD || die "${progname}: failed to run $GS ($!)\n";
    close INFILE;
close OUTFILE;
    close $plfile;
        close PLFILE;
close $psfile;
    close SAMPLE_PS;
    close SAMPLE_TEX;
                              cmcsc cmex cmitt cmmi cmmib cmsl cmsltt
    <cmmi10.pfb><cmtt10.pfb><cmr8.pfb><cmti10.pfb><cmr10.pfb>[1]
                              cmss cmssbx cmssi cmsy cmti lasy lasyb
command line further increase the program's verbosity.  By default,
$commented_ps =~ s|(\%\%Creator: dvips\S*) \S+|$1 5.62|;  # pkfix rejects dvips <= 5.58
$commented_ps =~ s|^\%(End)?DVIPSBitmapFont.*$||gm;    # Remove existing comments (if any)
        $commented_ps =~ s|\n|\n$dvips_params\n|;
$commented_ps =~ s|/(\S+)\s+\d+\s+\d+\s+df.*?>[^<]*?[DI]\s+E|write_comments($1, $&)|gse;
    $commented_ps =~ s|/\@start\s*\{|$& pop |;
    $commented_ps =~ s|TeXDict begin\s+\d+\s+\d+\s+bop|\%\%EndProlog\n$&|s;
        # Comments must have been stripped.
# Compare every document font (ordered by decreasing number of
compare them carefully for incorrect fonts and sizes.
# Compare two character maps and return their mismatch (smaller is
comparison is imperfect and B<pkfix-helper> may attribute an incorrect
    # Complete the TeX file.
# Construct a list of (possibly nonexistent) TFM files to try.  These
# Construct a mapping from each document font name to a list of valid
        # Convert absolute to relative sizes.
# Convert any user-specified TFMs to the appropriate internal format.
Copyright (C) 2009, Scott Pakin
correct font.  Suggestions for fixing these bugs are welcome.
        # corresponding character to @charlist.
corresponding F<.pfb> vector version) and selecting the best matching
Create a Plain TeX file called I<filename.tex> that shows the B<dvips>
Create a PostScript file called I<filename.ps> that shows the B<dvips>
create (with the default being the standard output device).  The
      currentfont bitmap-font-transform makefont setfont
(CURRENTMATRIX: ) print
data the metrics for each character.  The first time B<--cache> is
(default: F<tftopl>)
    \def\do##1{\catcode`##1=12}%
\% Define a transformation matrix for dvips bitmapped fonts.  We _could_
define font C<Fi> as C<cmss10> (Computer Modern Sans Serif at a design
# Define some code to display the width of every valid character in
# Define some global variables.
# Define the global variables that the user can modify from the command line.
definition beginning with the comment C<%DVIPSBitmapFont: Fi cmss10 11
\def\makeprintable{%
\def\put(#1,#2)#{%
\def\puthelper{%
                $designsize = $1 + 0.0;
    # Determine the list of eligible fonts to compare against.
# Determine the number of dots per inch used to generate the bitmaps.
            die $parse_error;
    die $parse_error;
        die "${progname}: Internal error" if $#fields == -1;
die "${progname}: No character-width information was found\n" if !%fontwidth;
    die "${progname}: No fonts are eligible to match $fontname\n" if !@eligible_tfms;
die "${progname}: No TFM files were processed successfully\n" if !$numtfms;
die "${progname}: No Type 3 fonts were encountered in the input file\n" if $#sortedfontnames==-1;
die "${progname}: Samples per page must be at least 1 ($samples_per_page was specified)\n" if $samples_per_page < 1;
    die "${progname}: Unable to inject display code\n" if $output_width_ps !~ s/TeXDict begin\s+\d+\s+\d+\s+bop.*eop\s+end/\n$displaycode\n/s;
        die "${progname}: Unable to inject display code\n" if $sample_ps !~ s/TeXDict begin\s+\d+\s+\d+\s+bop.*eop\s+end/\n$displaycode\n/s;
    die "${progname}: Unable to inject prologue code\n" if $output_width_ps !~ s/TeXDict begin\s+\d+\s+\d+\s+bop/\n$showfontnamecode\n$&/s;
        die "${progname}: Unable to inject prologue code\n" if $sample_ps !~ s/TeXDict begin\s+\d+\s+\d+\s+bop/\n$showfontnamecode\n$&/s;
        die "${progname}: Unable to process user-specified TFM file \"$tfm\"\n";
                    die "${progname}: Unknown TFM character type \"$1\"\n";
                                      DIR => File::Spec->tmpdir(),
\% Display a page title.
$displaycode .= <<'ENDDISPLAYCODE';
    $displaycode .= "eop\nend\n";
    $displaycode .= "/$fontname ($samplestring) print-char-widths\n";
        $displaycode .= "/$fontname ($samplestring) print-font-sample\n";
            $displaycode .= <<"PAGETRANSITION";
    $displaycode .= sprintf "0 0 moveto\n";
\% Display samples of each document font in decreasing order of the number
displays as it runs.  Additional instances of B<--verbose> on the
Display usage information and exit.  The B<--verbose> and B<--quiet>
        $doc_dot_tfm += $docwidth * $tfmwidth;
document).  As an extreme example, all Computer Modern Teletype fonts
doing so means choosing a highly nonstandard font size:
% Don't add extra space to paragraphs.
    \dospecials
# Do the same for all user-specified font mappings.
\% do this dynamically but there seems to be a bug in GhostView (v3.6.1)
    $dpi = $1 + 0;
    # Duplicate the last character of the sample string so kshow can
# dvips look newer.
    $ dvips newfonts.dvi -o newfonts.ps
# Dvips scales the page.  Determine the scaling it uses.
        $dvips_xscale = $1 * 1.0;
        $dvips_yscale = $2 * -1.0;
                else {
            else {
        else {
    else {
                elsif ($1 eq "C") {
        elsif ($bestmatch == $match) {
        elsif ($charnum >= 32 && $charnum <= 126) {
    elsif ($oneline =~ /CURRENTMATRIX: \[\s*([-\d.]+)\s+[-\d.]+\s+[-\d.]+\s+([-\d.]+)\s+[-\d.]+\s+[-\d.]+\s*\]/o) {
        elsif ($scale_info =~ /^\s*\@\s*([\d.]+)\s*(pt|bp)\s*$/io) {
        elsif ($scale_info =~ /^\s*\@\s*([\d.]+)\s*X\s*$/io) {
        elsif ($scale_info =~ /^\s*\@\s*\*\s*$/o) {
    elsif ($verbose == 1) {
embedded graphics.
            # Empty
encountered.
ENDDISPLAYCODE
  \endgroup
    \endmakeprintable
\%\%EndProcSet
    $entirefile = <INFILE>;
    || $entirefile =~ /Resolution (\d+)dpi/i) {
Error: Parse error (@start parameters)!>.)  Only when B<pkfix> can't
# Escape an array of characters for PostScript's benefit.
# Escape an array of characters for TeX's benefit.
Even when B<pkfix-helper> finds a perfect match S<(i.e., the> correct
# every bitmapped font.  Fonts are displayed in decreasing order of
@exclude_res = ('^\s*$') if $#exclude_res == -1;
    exit 0;
               -exitval => "NOEXIT");
extracted character metrics to I<filename>.  On subsequent runs in
fabricates the PostScript comments that B<pkfix> expects to see so
\% factor.
            "f|force=s"    => \@forced_fonts,
file but serve as suitable input for B<pkfix>:
# file produced by an ancient dvips         #
# file, return the optimal scale factor for the TFM file to best match
Files produced using the B<--tex> option are Plain TeX files and
file.  The F<.dvi> file and document source may have been lost; or,
    Finding character widths ... done.
            $firstfontnum = $fontnum;
    # First see if the information is already cached.
F<newfonts.ps>.  This is where the trial-and-error stage begins.
(F<oldfile.ps> in this example) and the name of an output file
    *** Font conversion: `cmbx10' -> `CMBX10'.
    *** Font conversion: `cmbx12' -> `CMBX12'.
    *** Font conversion: `cmmi10' -> `CMMI10'.
    *** Font conversion: `cmr10' -> `CMR10'.
    *** Font conversion: `cmr6' -> `CMR6'.
    *** Font conversion: `cmr8' -> `CMR8'.
    *** Font conversion: `cmsy10' -> `CMSY10'.
    *** Font conversion: `cmti10' -> `CMTI10'.
    *** Font conversion: `cmtt10' -> `CMTT10'.
font-detection process, some fonts will invariably be incorrectly
font in the correct size) the mismatch value is still typically
  FONTLOOP:
    $fontmatch{$1} = parse_font_spec $2;
    $fontmatch{$fontname} = $besttfms[0];
    font-name 8 string cvs /font-name-string exch def
% font-name and, for each character of test-string, call print-width
            $fontname, $besttfm, $bestscale,
            $fontname, $besttfm, $bestscale, $bestmatch;
      font-name cvx exec
    font-name cvx exec {print-width} sample-string kshow
    /font-name exch def
% font-name sample-string PRINT-CHAR-WIDTHS -
% font-name sample-string PRINT-FONT-SAMPLE -
      font-name-string show (:) show
    $fontname, $tfm, $origsize*$scale, 1+$#{$name2chars{$fontname}};
            && $fontnum != $#sortedfontnames) {
    (FONT: ) print font-name-string print
fonts and help the program provide proper input to B<pkfix>.
                # Fonts are incomparable.
# font's design size and a mapping from character number to character
font-selection process by manually designating matching fonts.  With a
fonts, it is not always possible to rerun B<dvips> on an old F<.dvi>
fonts.  It works by parsing the PostScript comments with which
fonts look grainy when zoomed in on screen.  The solution is to use
\font\somefont=phvr at 18bp
  (Fonts used by $infilename_ps) show
\font\timesbXII=ptmb at 12bp
font to a given name.  Fonts comprising only one or two characters
        $fontwidth{$fontname}->{$charnum} = $width * 72.27 / $dpi;
Force B<pkfix-helper> to associate a specific font with a given font
    foreach my $basefont (qw (cmr cmb cmtt cmbsy cmbx cmbxsl cmbxti
        foreach my $fontname (@sortedfontnames) {
foreach my $fontname (@sortedfontnames) {
    foreach my $fontnum (0 .. $#sortedfontnames) {
foreach my $fontnum (0 .. $#sortedfontnames) {
    foreach my $item (@_) {
foreach my $mapstr (@forced_fonts) {
    foreach my $onechar (@_) {
        foreach my $regexp (@exclude_res) {
foreach my $size_scale ([10, 1.0],
foreach my $tfm (@extra_tfms) {
    foreach my $tfminfo (@eligible_tfms) {
    foreach my $tfminfo ($fontmatch{$fontname} || @tfmlist) {
foreach my $tfminfo (@tfmlist) {
    foreach my $tfm (keys %tfmmissing) {
foreach my $tfm (sort {$a cmp $b}
for fatal error messages.
    format SAMPLE_TEX =
For the purpose of the following examples, assume that F<oldfile.ps>
F<pdftex>, F<pdfetex>, etc.), I<not> with F<latex>.
F<pkfix-oldfile.ps>.  Print F<oldfonts.ps> and F<newfonts.ps> and
(F<pkfix-oldfile.ps>), which will have the same contents as the input
from B<pkfix-helper>'s list of known fonts.  The B<--exclude> option
F<.tfm> file for every document font.  B<pkfix-helper> has access only
F<.tfm> font file it knows about (assuming that each such font has a
F<tftopl>-based process only for TFM files that were not previously
generally needed to guide B<pkfix-helper>'s font-matching procedures.
    # Generate code to output a sample of each font in turn.
GetOptions ("h|help"       => \$wanthelp,
Getopt::Long::Configure ("bundling");
# Ghostscript on the temporary file, and process Ghostscript's output.
# Given a Type 3 font definition, surround it with DVIPSBitmapFont comments.
# Given the base name of a .tfm file, process the file and return the
# Given two character maps, one for a document font and one for a TFM
glyphs.  Consequently, it is misled by sets of fonts with similar
grestore
    grestore
    gsave
=head1 AUTHOR
=head1 BUGS
=head1 COPYRIGHT AND LICENSE
=head1 DESCRIPTION
=head1 DIAGNOSTICS
=head1 ENVIRONMENT
=head1 EXAMPLES
=head1 NAME
=head1 NOTES
=head1 OPTIONS
=head1 RESTRICTIONS
=head1 SEE ALSO
=head1 SYNOPSIS
=head2 Frequently Used Options
=head2 Infrequently Used Options
=head2 Motivation
=head2 Overview
Heiko Oberdiek's B<pkfix> script replaces bitmapped fonts in
# Help pkfix decipher fonts in a PostScript #
# Help pkfix handle ancient versions of dvips by artificially making
  /Helvetica 18 selectfont
identified.  The program outputs a warning message if it I<knows> a
                if ($1 eq "O") {
        if ($bestmatch > $match) {
        if ($#besttfms == 0) {
        if ($chardef[$#chardef] eq "I") {
if ($commented_ps !~ /^%DVIPSParameters:.*dpi=([\dx]+)/) {
if ($commented_ps !~ /\%\%EndProlog/) {
if ($commented_ps =~ s|(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+\@start|$1 $2 $3 $4 $5 ($infilename_ps) \@start|gx) {
    if ($commented_ps !~ s|^\%\%EndComments.*$|$&\n$dvips_params|m) {
            if (defined $newscale) {
if (defined $sample_file_ps) {
if (defined $sample_file_tex) {
    if (defined $tfm2size{$tfmname}) {
    if (!defined ($tfmfontwidth{$tfm})) {
    if (defined $tfmmissing{$tfmname}) {
if ($entirefile =~ /dpi=(\d+)/i
        if ($#fields == -1) {
        if ($fontnum % $samples_per_page == $samples_per_page-1
        if ($fontnum % $samples_per_page == $samples_per_page-1) {
I<filename>.  On some systems it takes a long time to read a TFM file,
    if (%num2widths) {
        if ($onechar =~ /[\\()]/) {
        if ($onechar =~ m|[\000-\037\\{}\177-\377]|) {
    if ($oneline =~ /FONT: (\S+)\s*CHAR: (\d+)\s*XPOS: (\S+)/o) {
if ($output_width_ps !~ s/\%\%EndProcSet/$&\n$showfontnamecode/s) {
if ($output_width_ps !~ s/\%\%Page:.*(\%\%Trailer)/$displaycode$1/s) {
    if ($sample_ps !~ s/\%\%EndProcSet/$&\n$showfontnamecode/) {
    if ($sample_ps !~ s/\%\%Page:.*(\%\%Trailer)/$displaycode$1/s) {
        if ($scale_info =~ /^\s*$/o) {
    if ($single_font_use) {
    if ($spec =~ /^\s*([-\w]+)(.*)$/o) {
    if (!system "$TFTOPL $tfmname $plname $discard_output") {
        if ($tfminfo->{"scale"} eq "*") {
    if ($tfminfo->{"scale_type"} eq "@") {
# If the user requested a PostScript font sample, produce that.
# If the user requested a TeX font sample, produce that.
if ($verbose) {
    if ($verbose >= 2) {
if ($wanthelp) {
if ($wantversion) {
            "i|include=s"  => \@extra_tfms,
[I<input.ps> [I<output.ps>]]
Increase the amount of status information that B<pkfix-helper>
indicated using the B<--ps> and B<--tex> options.  The default
indicate that B<pkfix-helper> did a good job.  It is therefore
$infilename_ps =~ s/[()\\]/\\$1/g;
initmatrix
In its simplest form, B<pkfix-helper> takes the name of an input file
input device) and the filename of a modified PostScript document to
            # Insert a page break after every $samples_per_page font samples.
# Insert %DVIPSBitmapFont comments around every Type 3 font definition.
# Insert some helper code after the first ProcSet.
    # Insert some helper code at an appropriate place in the file.
instance of B<--force> for each font you want to alter.
Instruct B<pkfix-helper> to produce no output during its run except
in the document.  Also, the program recognizes only a limited set of
invariably utilize bitmapped (PostScript S<Type 3>) fonts.  The
# is of the form {full name, scale factor}.
I<specific> document font.)  The B<--include> option can be specified
is the name of a PostScript file produced by an old version of
is the sum of the squares of the difference between the character
=item B<-1>, B<--no-repeats>
=item B<-C> I<filename>, B<--cache>=I<filename>
=item B<-f> I<name>=I<fontspec>, B<--force>=I<name>=I<fontspec>
=item B<-h>, B<--help>
=item B<-i> I<fontspec>, B<--include>=I<fontspec>
=item B<-p> I<filename.ps>, B<--ps>=I<filename.ps>
=item B<-q>, B<--quiet>
=item B<-s>, B<--spp>
=item B<-t> I<filename.tex>, B<--tex>=I<filename.tex>
=item B<-v>, B<--verbose>
=item B<-x> I<regexp>, B<--exclude>=I<regexp>
=item C<Best match for I<name> is rather poor>
=item GS
        $item_hash{$item} = 1;
=item TFTOPL
            join("/", map {sprintf "%s\@%.5gX", $_->{"tfm"}, $_->{"scale"}} @besttfms),
  \leavevmode
\let\endmakeprintable=\endgroup
Let's hypothesize that C<cmb12> is a better match than C<cmbx12> but
Let's try scaling up F<cmb10.tfm> instead:
L<http://www.adobe.com/products/postscript/pdfs/PLRM.pdf>.
license is in L<http://www.latex-project.org/lppl.txt> and version
loaded by B<dvips> can be analyzed, not bitmapped fonts loaded by
    local $/ = undef;
look grainy on a S<600 DPI> printer.  Even worse, I<all> bitmapped
    \lower\yofs
    \makeprintable
% Make printable all special characters between
% \makeprintable...\endmakeprintable except for "\", "{", and "}".
    $mapstr =~ /^(\w+)\s*=\s*(.*)$/ || die "${progname}: Unable to parse font specification \"$mapstr\"\n";
    Matching fonts:
match is bad but the lack of a warning message does not necessarily
matrix currentmatrix ==
    *** Merging font `CMBX12' (2).
modicum of diligence and patience a user can correct any mismatched
more than one B<dvips> font name.
                              msam msbm cmssdc cmtcsc)) {
    my $begincomment = sprintf '%%DVIPSBitmapFont: %s %s %.5g %d',
    my $bestmatch = 10**9;    # Best matching value
    my $bestscale = $besttfminfo->{"scale"};
    my $besttfm = $besttfminfo->{"tfm"};
    my $besttfminfo = $fontmatch{$fontname};
    my @besttfms;             # Best matching TFM file(s), sizes, and scales
        my @chardef = split " ", $1;
    my @charlist = ();   # List of valid characters in PostScript-friendly format
    my @charlist = psify @{$name2chars{$fontname}};
    my $charnum = 0;     # Current character number
        my $charnum;      # Current character number
        my $charnum = ord $onechar;
my $commented_ps = $entirefile;
    my $designsize;        # Design size of the font
    my ($designsize, %num2widths) = @{tfm2widths $tfm};
my $discard_output = $^O eq "MSWin32" ? "> NUL:" : "> /dev/null 2>&1";  # Command suffix to discard all output
my $displaycode = "\%\%Page: 1 1\nTeXDict begin\n1 0 bop\n";
    my $displaycode = <<"PAGEHEADER";
    my $doc_dot_tfm = 0.0;    # Sum of $docmap{$c}*$tfmmap{$c} for all $c
    my %docmap = %{$_[0]};    # Map for a document font
my $dpi = 300;                     # Number of dots per inch used to generate bitmapped characters
    my $dvips_params = "\%DVIPSParameters: dpi=$dpi";
my ($dvips_xscale, $dvips_yscale); # Scaling factors from Dvips's PostScript CTM
    my @eligible_tfms;
    my $endcomment = '%EndDVIPSBitmapFont';
my $entirefile;
my @exclude_res;                   # Regexps for fonts to exclude
my @extra_tfms;                    # Extra TFM files to use
        my @fields = split " ", $oneline;
    my $firstfontnum = 0;
    my $fontbody = $2;   # List of character definitions as hexadecimal strings
my %fontmatch;                     # Map from a font name to its best match
    my $fontname = $1;   # Name of current font (e.g., "Fa")
        my ($fontname, $charnum, $xpos) = ($1, $2, $3);
    my ($fontname, $fontdef) = @_;
        my $fontname = $sortedfontnames[$fontnum];
    my $fontname = $sortedfontnames[$fontnum];
    my $font_spec = parse_font_spec $tfm;
my %fontwidth;     # Map from font name to character number to character width
my @forced_fonts;                  # Font mappings the user asserts are correct
        my $friendly_name = sprintf "%s%d \@ %.5gX", $basefont, $pointsize, $scale;
my @goodtfmlist;
my $gscmd = "$GS -q -dNOPAUSE -dBATCH -dNODISPLAY $psfilename";
my $GS = $ENV{"GS"} || "gs";       # Name of the Ghostscript interpreter
my $infilename = $#ARGV>=0 ? $ARGV[0] : "-";
my $infilename_ps = $infilename;   # PostScript version of $infilename
    my $infilename_tex = texify split "", $infilename;
my $init_yinc = 36;                # Space after title
    my %item_hash;
        my $match = compare_maps $fontwidth{$fontname}, $tfmfontwidth{$tfm}, $scale;
my %name2chars;        # Map from a font name to a character list
            my $newscale = optimal_scale $fontwidth{$fontname}, $tfmfontwidth{$tfminfo->{"tfm"}};
                my %newtfminfo = %$tfminfo;
    my %num2width;         # Resultant mapping
my $numfonts = 1 + $#tfmlist;
    my $numlines = 0;
my $numtfms = keys %tfm2size;
    my $oneline;     # One line to write to the TeX file.
    my $origsize = $tfm2size{$tfm};
my $outfilename = $#ARGV>=1 ? $ARGV[1] : "-";
my $output_width_ps = $entirefile;    # PostScript code to output character widths
    my $pageno = 1;
    my $parse_error = "${progname}: Unable to parse font specification \"$spec\"\n";
    my $plfile;       # Filehandle corresponding to $plname
    my $plname;       # Name of PL file; some tftopl programs can't write to stdout.
    my ($pointsize, $scale) = @$size_scale;
my @previnfo = ("", 0.0);   # Previous font name and final character position
my $progname = basename $0;        # Name of this program
    my @ps_chars;
my ($psfile, $psfilename) = tempfile ("pkfix-helper-XXXXXX",
my $sample_file_ps;                # Name of a PostScript file of font samples to write
my $sample_file_tex;               # Name of a TeX file of font samples to write
    my $sample_ps = $entirefile;
my $samples_per_page = 25;         # Number of font samples to print per page
    my $samplestring = join("", @charlist) . $charlist[$#charlist];
        my $samplestring = join("", psify @{$name2chars{$fontname}});
        my $samplestring = texify @{$name2chars{$fontname}};
    my $scale = $_[2] || 1.0; # Scale for each TFM width
        my $scale_amount;       # How much to scale the TFM file, "*"=automatic
        my $scale = $fontmatch{$fontname}->{"scale"};
    my $scale = $fontmatch{$fontname}->{"scale"};
        my $scale_info = $2;    # Concatenation of scale type and scale factor
        my $scale = $tfminfo->{"scale"};
        my $scale_type;         # "X"=multiply, "@"=assign
    my $showfontnamecode = <<"SHOWFONTNAME";
my $showfontnamecode = <<"SHOWFONTNAME";
my $single_font_use = 0;           # 1=one use per font; 0=allow repetitions
        my $size = $tfm2size{$tfm};
my @sortedfontnames = sort {$#{$name2chars{$b}} <=> $#{$name2chars{$a}}
    my $spec = $_[0];
    my $sqdiff = 0;           # Sum of squares of differences
    my @texchars;
        my $tfm = $1;           # Name of tfm file (e.g., "cmr10")
my %tfm2size;                      # Map from font name to design size
my $tfm_cache_file;                # Name of a file in which to cache font metrics
    my $tfm_dot_tfm = 0.0;    # Sum of $tfmmap{$c}**2 for all $c
        my $tfm = $fontmatch{$fontname}->{"tfm"};
    my $tfm = $fontmatch{$fontname}->{"tfm"};
my %tfmfontwidth;                  # Map from font name to character number to character width
my @tfmlist;                       # List of TFM files to use
    my %tfmmap = %{$_[1]};    # Map for a TFM font
my %tfmmissing;                    # Set of TFM files we looked for but didn't find
    my $tfmname = $_[0];   # Name of the TFM file
        my $tfm = shift @fields;
                my $tfm = $tfminfo->{"tfm"};
        my $tfm = $tfminfo->{"tfm"};
    my $tfm = $tfminfo->{"tfm"};
        my $tfmwidth = $tfmmap{$char};
my $TFTOPL = $ENV{"TFTOPL"} || "tftopl";    # Name of the TFM to PL converter
my $verbose = 1;                   # 0=quiet; 1=verbose output; 2=more verbose output
my $wanthelp = 0;                  # 1=user wants to see the program's documentation
my $wantversion = 0;               # 1=user wants to see the program's version number
            my %widths = @fields;
        my @widths = %{$tfmfontwidth{$tfm}};
        my $width = $xpos + 0.0;
my $xinc = 36;                     # Width of font name in PostScript points
my $yinc = 24;                     # Height of font in PostScript points
        my $yoffset = ($fontnum-$firstfontnum)*$yinc + $init_yinc;
    $name2chars{$fontname} = \@charlist;
name and a font sample of every font that B<pkfix-helper> used in the
name and a font sample of every font used by the input document.
name appearing the document.  I<name> is a two-character B<dvips> font
name such as C<Fa>.  I<fontspec> is a font specification such as
\newdimen\xofs
\newdimen\yofs
    (./newfonts.tex [1] )
                $newtfminfo{"scale"} = $newscale;
                next;
            next FONTLOOP if $friendly_name =~ $regexp;
    next if !defined ($tfmfontwidth{$tfm});
    ==> no fonts converted
no longer be available.
            # No metrics -- TFM file must not have been found.
nonstandard sizes so this may in fact be correct.  The best way to
nonzero.  The same error is probably what causes B<pkfix-helper>
Note that this is a Plain TeX document.  Compile it with tex, *not*
not with arbitrary PostScript files.  The program has not been tested
    (\\n) print
(\n) print
                $num2width{$charnum} = $1 * $designsize;
% number (char0), and the character's width in PostScript points.
    Number of Type 3 fonts encountered: 10
            # "@ <number> pt" or "@ <number> bp"
            # "@ <number> X"
	$numlines++;
# obscurity).
                    # Octal character number
of a given design size (e.g., C<cmtt10>, C<cmsltt10>, and C<cmitt10>)
\% of characters utilized from the font.
Older versions of B<dvips> lack C<%DVIPSBitmapFont> comments and
$oneline
            $oneline =~ /\(CHARACTER (\S) (\S+)/ && do {
            $oneline =~ /\(CHARWD R (\S+)\)/ && do {
            $oneline =~ /\(DESIGNSIZE R (\S+)\)/ && do {
    $oneline = <<"TEX_HEADER";
only major operations are displayed.  A single B<--verbose>
Oops, it looks like we don't have a F<cmb12.tfm> file on our system.
    open(CACHEFILE, ">", $tfm_cache_file) || die "${progname}: Failed to create $tfm_cache_file ($!)\n";
    open(CACHEFILE, "<", $tfm_cache_file) || do {
open (GSCMD, "$gscmd|") || die "${progname}: failed to fork ($!)\n";
    open (INFILE, "<$infilename") || die "open(\"$infilename\"): $!\n";
open (OUTFILE, ">$outfilename") || die "${progname}: Unable to open $outfilename ($!)\n";
        open (PLFILE, "<$plname") || die "${progname}: Unable to open $tfmname ($!)\n";
    open (SAMPLE_PS, ">$sample_file_ps") || die "${progname}: Unable to open $sample_file_ps ($!)\n";
    open (SAMPLE_TEX, ">$sample_file_tex") || die "${progname}: Unable to open $sample_file_tex ($!)\n";
    # Optionally remove the font from @goodtfmlist.
options can be used to increase and decrease the amount of information
or (at your option) any later version.  The latest version of this
\% or GhostScript (ESP v7.07.1) that causes the page layout to change
or later.
our $VERSION = "1.2";              # Version number of this program
        # Output a single font sample.
output document.
% output font-name-string in Times Bold in case the user wants to view
output from older versions may or may not work.  Only bitmapped fonts
    # Output samples of each font in turn.
    # Output the document's title.
% Output the document's title.
# Output the modified PostScript code to a temporary file, run
% Output the name of the current font (font-name-string), its character
    Output written on newfonts.dvi (1 page, 1292 bytes).
\%\%Page: 1 1
PAGEHEADER
            $pageno++;
$pageno @{[$pageno-1]} bop
\%\%Page: $pageno $pageno
PAGETRANSITION
\parindent=0pt
# Parse a font specification into a hash of information.
            # Parse and store the TFM data.
# Parse the command line.
# Parse the list of forced font mappings.
\parskip=0pt
    PKFIX 1.3, 2005/02/25 - Copyright (c) 2001, 2005 by Heiko Oberdiek.
pkfix(1), dvips(1), tex(1), gs(1)
    # pkfix expects *six* arguments to @start, not five as in old
    # pkfix fails silently if it doesn't see an %%EndProlog.
pkfix-helper
    $ pkfix-helper oldfile.ps pkfix-oldfile.ps
    $ pkfix-helper oldfile.ps pkfix-oldfile.ps --force="Ff=cmb10 @ *"
    $ pkfix-helper oldfile.ps pkfix-oldfile.ps --force="Ff=cmb12 @ *"
pkfix-helper - preprocess dvips-produced PostScript documents before passing them to pkfix
    $ pkfix-helper -q oldfile.ps pkfix-oldfile.ps \
    pkfix-helper: Unable to process user-specified TFM file "cmb12"
    $ pkfix oldfile.ps newfile.ps
    $ pkfix pkfix-oldfile.ps newfile.ps
    ($plfile, $plname) = tempfile (DIR => File::Spec->tmpdir(), SUFFIX => ".pl");
    pod2usage (-verbose => $verbose,
PostScript comments to guide it, B<pkfix> is unable to determine which
PostScript documents created with old versions of B<dvips> almost
PostScript document to process (with the default being the standard
PostScript Language Reference, Third Edition.
            "p|ps=s"       => \$sample_file_ps,
presented.
Prevent B<pkfix-helper> from associating the same I<fontspec> with
        @previnfo = ($fontname, $xpos);
previously extracted metrics from I<filename>, going through the
        print CACHEFILE "$tfm\n";
        print CACHEFILE "$tfm $size @widths\n";
/print-char-widths {
/print-font-sample {
        printf SAMPLE_TEX "\\font\\somefont=%s%s\\somefont\n",
        printf SAMPLE_TEX "\\put(0, %d){\\timesbXII %s:}%%\n", $yoffset, $fontname;
        printf SAMPLE_TEX "\\put(%d, %d){%s}%%\n", $xinc, $yoffset, $samplestring;
            printf STDERR "    Best match for %s is %s \@ %.5gX (tied among %s) with mismatch=%.5f.\n\n",
            printf STDERR "    Best match for %s is %s \@ %.5gX with mismatch=%.5f.\n\n",
    printf STDERR "Bitmapped fonts are typeset at $dpi DPI.\n" if $verbose;
        printf STDERR "    Comparing %s and %s \@ %.5gX ... ", $fontname, $tfm, $scale if $verbose >= 2;
        printf STDERR "done (mismatch=%.5f).\n", $match if $verbose >= 2;
        printf STDERR "done (%s \@ %.5gX, mismatch=%.5f).\n", $besttfm, $bestscale, $bestmatch;
    printf STDERR "Number of Type 3 fonts encountered: %d\n", 1+$#sortedfontnames;
    printf STDERR "Reading %s ... ", $infilename eq "-" ? "standard input" : $infilename;
            printf STDERR "    %s -- %3d character(s)\n", $fontname, 1+$#{$name2chars{$fontname}};
print OUTFILE $commented_ps;
    print "pkfix-helper $VERSION\n";
print $psfile $output_width_ps;
    print "Report bugs to scott+pkfh\@pakin.org.\n" if $verbose == 1;
    print SAMPLE_PS $sample_ps;
    print SAMPLE_TEX "\n\\bye\n";
    print SAMPLE_TEX "\n\% Output font samples.\n";
    print SAMPLE_TEX '\put(0, 0){\somefont New fonts to use for ', "$infilename_tex}\n";
    print SAMPLE_TEX <<'TEX_BOILERPLATE';
            print SAMPLE_TEX "\\vskip 0pt plus 1fill\\eject\n";
        print STDERR "    Discarding $tfmname (not found).\n" if $verbose >= 3;
    print STDERR "done.\n" if $verbose;
print STDERR "done.\n" if $verbose;
print STDERR "done.\n" if $verbose >= 1;
        print STDERR "done.\n" if $verbose >= 2;
    print STDERR "done ($numlines entries).\n" if $verbose;
print STDERR "done ($numtfms TFMs in $numfonts scaling variations).\n" if $verbose;
        print STDERR "failed.\n" if $verbose;
print STDERR "Finding character widths ... " if $verbose >= 1;
        print STDERR "Ignoring TFM cache file $tfm_cache_file ($!).\n" if $verbose;
print STDERR "Matching fonts:\n" if $verbose;
print STDERR "\n" if $verbose >= 2;
print STDERR "\n    Invoking: $gscmd\n" if $verbose >= 2;
        print STDERR 'No %%EndProcSet comment was found.  We have to guess where to inject PostScript code.', "\n" if $verbose >= 3;
    print STDERR 'No %%EndProcSet comment was found.  We have to guess where to inject PostScript code.', "\n" if $verbose >= 3;
    print STDERR "No %%EndProlog comment was found.  Adding one.\n" if $verbose >= 3;
        print STDERR 'No %%Page and/or %%Trailer comments were found.  We have to guess where to inject PostScript code.', "\n" if $verbose >= 3;
    print STDERR 'No %%Page and/or %%Trailer comments were found.  We have to guess where to inject PostScript code.', "\n" if $verbose >= 3;
                print STDERR "    Not scaling $tfm; ${fontname}'s character set is not a subset of ${tfm}'s.\n" if $verbose >= 2;
    print STDERR "    Processing $fontname ... " if $verbose == 1;
        print STDERR "    Processing $tfmname ... cached as not found.\n" if $verbose >= 2;
        print STDERR "    Processing $tfmname ... cached.\n" if $verbose >= 2;
        print STDERR "    Processing $tfmname ... " if $verbose >= 2;
    print STDERR "Reading TFM data from $tfm_cache_file ... " if $verbose;
print STDERR "Reading TFM files ... " if $verbose;
    print STDERR "Writing TFM data to $tfm_cache_file ... " if $verbose;
/print-width {
problem with bitmapped fonts is that they target a specific device
        Processing Fa ... done (cmti10 @ 1X, mismatch=0.08892).
        Processing Fb ... done (cmr8 @ 1X, mismatch=0.07133).
        Processing Fc ... done (cmr6 @ 1X, mismatch=0.00284).
        Processing Fd ... done (cmmi10 @ 1X, mismatch=0.03966).
        Processing Fe ... done (cmbx10 @ 1X, mismatch=0.00762).
        Processing Ff ... done (cmb10 @ 1.5708X, mismatch=0.00035).
        Processing Ff ... done (cmbx12 @ 1.2X, mismatch=0.02948).
        Processing Fg ... done (cmsy10 @ 1X, mismatch=0.00875).
        Processing Fh ... done (cmtt10 @ 1X, mismatch=0.06895).
        Processing Fi ... done (cmr10 @ 1X, mismatch=0.11683).
        Processing Fj ... done (cmbx12 @ 1X, mismatch=0.03972).
    # process the final character delta.
program also accepts the following command-line options:
program's internal operations.
program to automatically detect an optimal scaling factor, even if
      --ps=oldfonts.ps --tex=newfonts.tex
Published by Addison-Wesley, ISBN 0-201-37922-8,
            push @besttfms, $tfminfo;
        push @charlist, chr $charnum;
                push @eligible_tfms, \%newtfminfo;
            push @eligible_tfms, $tfminfo;
    push @goodtfmlist, $tfminfo;
            push @ps_chars, "\\" . $onechar;
            push @ps_chars, $onechar;
            push @ps_chars, sprintf "\\%03o", $charnum;
            push @texchars, $onechar;
            push @texchars, sprintf '\char"%02X{}', ord $onechar;
    push @tfmlist, $font_spec;
        push @tfmlist, {"tfm"        => $basefont . $pointsize,
% Put a piece of text at specific PostScript coordinates.
        # Put the current character number in $charnum then append the
            "q|quiet"      => sub {$verbose=0},
# Read each TFM file and store its design size and character widths.
    Reading netpipe.ps ... done.
    Reading TFM files ... done (103 TFMs in 193 scaling variations).
    Reading TFM files ... failed.
# Read %tfm2size, %tfmfontwidth, and %tfmmissing from a file named by
read_tfm_cache_file() if defined $tfm_cache_file;
# Read TFM font metrics from a cache file if specified.
# Read the entire input file.
Remove all font specifications matching regular expression I<regexp>
# Remove nonexistent fonts from @tfmlist and replace all absolute
repeatedly on the command line.
replace bitmapped fonts with vector fonts is B<pkfix-helper> needed.
replacement fonts that B<pkfix-helper> used to produce
replaces the font definition with one that defines C<Fi> using the
# Replace the bulk of the PostScript file with the display code.
                # Replace the "*" with the optimal multiplier.
            # Replace "*" with the best scaling factor we can find.
# Report the number of fonts in our repertoire.
resolution; a PostScript file produced using S<300 DPI> fonts will
        return;
        return 10**9 if !defined $tfmwidth;      # Match is impossible.
# Return all of the unique items in a given list.
        return [$designsize, %num2width];
    return [$designsize, %num2width];
    return $doc_dot_tfm / $tfm_dot_tfm;
    return join "", @texchars;
    return keys %item_hash;
    return "\n" . $begincomment . "\n" . $fontdef . "\n" . $endcomment . "\n";
    return @ps_chars;
    return $sqdiff;
        return [$tfm2size{$tfmname}, %{$tfmfontwidth{$tfmname}}];
        return {"tfm"        => $tfm,
        return undef if !defined $tfmwidth;      # Match is impossible.
    \rlap{\hskip\xofs\the\toks0}%
same set of characters but taken from the F<cmss10.pfb> vector font
samples and iterate until all of the fonts look correct.  Use one
    /sample-string exch def
      sample-string show
            $scale_amount = "*"
            $scale_amount = $1;
            $scale_amount = 1.0;
            $scale_amount = $1 + 0.0;
            $scale_amount *= 72.0/72.27 if $2 eq "bp";  # Convert to TeX points
                             || $_->{"scale"} != $bestscale} @tfmlist;
                        "scale"      => $scale};
                "scale"      => $scale_amount};
            $scale_type = '@';
                "scale_type" => $scale_type,
                        "scale_type" => "X",
            $scale_type = 'X';
scaling amount.
# ("@") scaling with relative ("X") scaling.
S<C<cmsy10 @ 1.1X>>.  The B<--force> option can be specified
Scott Pakin, I<scott+pkfh@pakin.org>
S<(e.g., C<Fi>)> in a PostScript file and the original font S<(e.g.,
    select (SAMPLE_TEX);
    select (STDOUT);
    # Select the first of the best matches.
# should be in order of decreasing likelihood.  Each entry in the list
SHOWFONTNAME
            # Single winner
size of S<10 points>) scaled to S<C<11> points>.  Only the C<28>
sometimes to consider the wrong font as being a better match than the
spawn F<tftopl> to convert it to PL format, and extract from the PL
specified, B<pkfix-helper> proceeds as normal then writes all of the
Specify the number of font samples per page to print to the files
Speed up TFM file processing by caching character metrics into file
        $sqdiff += ($docwidth - $tfmwidth*$scale) ** 2;
            "s|spp=i"      => \$samples_per_page,
            # Store the current character number.
            # Store the current character width.
            # Store the font design size.
% Store the name of font-name in the string font-name-string.  Then,
% Store the name of font-name in the string font-name-string.  Then, select
% string.  Finally, move the cursor to the next line in preparation for
strongly recommended that the user produce "before" and "after" font
sub compare_maps ($$;$)
sub optimal_scale ($$)
sub parse_font_spec ($)
sub psify (@)
sub read_tfm_cache_file
sub texify (@)
sub tfm2widths ($)
sub unique_items (@)
sub write_comments ($$)
sub write_tfm_cache_file
                                      SUFFIX => ".ps");
Suppose that the choice of C<cmbx12 @ 1.2X> for font C<Ff> looks
S<value, 25,> should work well in most circumstances.
    # Tell pkfix what resolution to use.
TEX_BOILERPLATE
    <texc.pro><8r.enc><texps.pro>. <cmr6.pfb><cmsy10.pfb><cmbx10.pfb><cmbx12.pfb>
TeXDict begin
TEX_HEADER
    $ tex newfonts.tex
    ' TeX output 2006.06.11:1636' -> newfonts.ps
        $tfm2size{$tfm} = $designsize * 1.0;
            $tfm2size{$tfm} = shift @fields;
# $tfm_cache_file.
        $tfm_dot_tfm += $tfmwidth**2;
# TFM file.
        $tfmfontwidth{$tfm} = \%num2widths;
            $tfmfontwidth{$tfm} = \%widths;
    $tfminfo->{"designsize"} = $tfm2size{$tfm};
        $tfminfo->{"scale"} /= $tfminfo->{"designsize"};
        $tfminfo->{"scale_type"} = "X";
@tfmlist = @goodtfmlist;
        @tfmlist = grep {$_->{"tfm"} ne $besttfm
            $tfmmissing{$tfm} = 1;
        $tfmmissing{$tfm} = 1;
        $tfm, $scale==1.0 ? "" : sprintf(" at %.5gbp", $scale*$size);
than v5.58 S<(ca. 1996)>.  Naturally, the older a PostScript document,
that B<pkfix> can do its job.
The best font B<pkfix-helper> found for B<dvips> font name I<name> has
The B<pkfix-helper> script is a preprocessor for B<pkfix> that
            # The desired scaling factor is specified explicitly.
# the document font.
                        # The following are common cmbx12 section headings.
% the font samples.  Next, select font-name and output the sample
the fonts in F<oldfile.ps> and F<newfonts.ps> shows samples of the
    # The information is not cached -- read it from a file.
the LaTeX Project Public License, either version 1.3c of this license
the less likely its sources still exist and can still be recompiled.
The match has definitely improved, although S<15.708 pt.> is certainly
the most popular F<.tfm> files and scaling factors.  Consequently, the
The name of a utility for converting F<.tfm> files to F<.pl> files
The name of the Ghostscript interpreter (default: F<gs>)
% the next invocation of print-font-sample.
# the number of characters used.
the problem.
therefore must be compiled with F<tex> (or a variation such F<etex>,
the source may no longer compile because packages it depends upon may
This file may be distributed and/or modified under the conditions of
This file was generated by $0.  DO NOT EDIT.  Edit $progname instead.
    This is dvips(k) 5.92b Copyright 2002 Radical Eye Software (www.radicaleye.com)
    This is TeX, Version 3.14159 (Web2C 7.4.5)
            # Tie for first place
      /Times-Bold 12 selectfont
    \toks0=%
% to output its width.
to the widths of characters and only to those characters actually used
    Transcript written on newfonts.log.
    # Try each TFM file in increasing order of obscurity.
            "t|tex=s"      => \$sample_file_tex,
    # Typeset the string starting at horizontal offset 0.
undef $commented_ps;
undef @goodtfmlist;
undef $output_width_ps;
    undef $sample_ps;
Unfortunately, B<pkfix> works only with versions of B<dvips> newer
                 unique_items map {$_->{"tfm"}} (@tfmlist, values %fontmatch)) {
    unlink $plname;
unlink $psfilename;
use exactly the same widths for all characters.  Human assistance is
use File::Basename;
use File::Spec;
use File::Temp qw (tempfile);
use Getopt::Long;
use Pod::Usage;
use strict;
use warnings;
#! /usr/bin/env perl
various other PostScript comments on which B<pkfix> relies.  Without
vector fonts correspond with which bitmapped fonts.
vector (PostScript S<Type 1>) fonts, which are resolution-independent
verifying that B<pkfix> can't convert the file on its own:
verify is once again to produce, print, and compare a pair of font
    # versions of dvips.
            "v|verbose+"   => \$verbose,
            "V|version"    => \$wantversion,
    warn "${progname}: Best match for $fontname is rather poor\n" if $bestmatch>=1.0;
    warn "${progname}: Could not determine the target printer resolution; assuming $dpi DPI\n";
we don't know how much to scale the font.  Fortunately,
            # We found a closer match than what we had before.
            # We found an equal match to what we had before.
% We use Times Bold at 12 point for font names.
which B<--cache>=I<filename> is specified, B<pkfix-helper> reads the
while ($entirefile =~ m|/(\S+)\s+\d+\s+\d+\s+df(.*?>[^<>]*?[DI])\s+E|gs) {
    while ($fontbody =~ /<[0-9A-F\s]+>(.*?[DI])/gs) {
While it is no longer difficult to configure B<dvips> to use vector
    while (my ($char, $docwidth) = each %docmap) {
while (my ($fontname, $tfminfo) = each %fontmatch) {
    while (my $oneline = <CACHEFILE>) {
while (my $oneline = <GSCMD>) {
        while (my $oneline = <PLFILE>) {
    while (my ($tfm, $size) = each %tfm2size) {
# width.
        $width -= $previnfo[1] if $fontname eq $previnfo[0];
widths of a document font and a potential replacement font.)  Use the
with output from versions of B<dvips> older than v5.490 S<(ca. 1992)>;
\% with rescaling.  To avoid problems we simply hardwire the scaling
    write SAMPLE_TEX;
# Write %tfm2size, %tfmfontwidth, and %tfmmissing to a file named by
write_tfm_cache_file() if defined $tfm_cache_file;
# Write the modified PostScript code to the specified file.
    # Write the PostScript file.
# Write the TFM font metrics to a a cache file if specified.
wrong; say the characters look taller in F<oldfonts.ps> than in
            "x|exclude=s"  => \@exclude_res,
    \xofs=#1bp
    (   XPOS: ) print currentpoint pop 80 string cvs print
    \yofs=#2bp
