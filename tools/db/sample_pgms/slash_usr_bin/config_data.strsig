	       );
   $0 --module Foo::Bar --config magic_number
   $0 --module Foo::Bar --feature bazzable
   $0 --module Foo::Bar --set_config magic_number=42
   $0 --module Foo::Bar --set_feature bazzable=1
0) value.
akin to "user preferences" or "local settings".  This is a
and C<feature> values.  A C<config> value may be any perl scalar,
as either 1 or 0.
    @auto{$cf->auto_feature_names} = () if $cf->can("auto_feature_names");
be 1 if the feature is enabled, 0 if the feature is not enabled, or
C<Foo::ConfigData>) (I would have called it C<Foo::Config>, but that
    $cf->set_config($k, $v);
    $cf->set_feature($k, 0+$v); # Cast to a number, not a string
  $cf->write;
C<Module::Build>.  Under this system, configuration information for a
complicated data structures to be stored.  For really complicated
  config_data --help
  config_data --module Foo::Bar --config magic_number
  config_data --module Foo::Bar --feature bazzable
  config_data --module Foo::Bar --set_config magic_number=42
  config_data --module Foo::Bar --set_feature bazzable=1
config_data - Query or change configuration of Perl modules
config entries will be shown.
		config      => {type => ':s',
configuration data, as well as publically accessible methods for
configuration of a single module.  On the command line, specify which
configuration of Perl modules.  By "configuration", we mean something
Copyright (c) 1999, Ken Williams.  All rights reserved.
data.  The C<config_data> script (whose docs you are currently
				desc => 'eval() config values before setting'},
				desc => 'Print a help message and exit'},
				desc => 'Print the value of a config option'},
				desc => 'Print the value of a feature or all features'},
				desc => 'Set a config option to the given value'},
				desc => "Set a feature to 'true' or 'false'"},
				desc => 'The name of the module to configure (required)'},
die "Exactly one of the options '" . join("', '", @exclusive) . "' must be specified\n" . usage(%opt_defs)
    die "Feature value must be 0 or 1\n" unless $v =~ /^[01]$/;
      die $@ if $@;
  die $@ if $@;
die "Option --module is required\n" . usage(%opt_defs)
  } else {
} elsif (exists $opts{config}) {
} elsif (exists $opts{set_config}) {
} elsif (exists $opts{set_feature}) {
empty if the feature is unknown.  When no feature name is supplied,
    eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
  eval "require $cf";
		eval        => {type => '',
evaluated as perl code before being stored.  This allows moderately
  Examples:
		feature     => {type => ':s',
    for ($defs{$name}{type}) {
    foreach my $name (sort $cf->config_names) {
    foreach my $name (sort $cf->feature_names) {
  foreach my $name (sort keys %defs) {
formalization and abstraction of the systems that people like Andreas
  # Get config/feature values
GetOptions( \%opts, map "$_$opt_defs{$_}{type}", keys %opt_defs ) or die usage(%opt_defs);
have developed independently.
=head1 AUTHOR
=head1 COPYRIGHT
=head1 DESCRIPTION
=head1 NAME
=head1 SEE ALSO
=head1 SYNOPSIS
=head1 USAGE
		help        => {type => '',
if (exists $opts{feature}) {
  if (length $opts{config}) {
  if (length $opts{feature}) {
    if ($opts{eval}) {
  if $opts{help};
	if $running_under_some_shell;
If the C<--eval> option is used, the values in C<set_config> will be
including references to complex data structures.  It must, however, be
=item config
=item eval
=item feature
=item help
=item module
=item set_config
=item set_feature
it under the same terms as Perl itself.
just use the Perl API instead.
Ken Williams, kwilliams@cpan.org
Koenig (C<CPAN::Config>), Jon Swartz (C<HTML::Mason::Config>), Andy
  local $Data::Dumper::Terse = 1;
may create alternate front-ends.
Module::Build(3), perl(1).
module C<Foo>, for example, is stored in a module called
module's configuration you're interested in, and pass options to get
		module      => {type => '=s',
  $mod =~ /^([\w:]+)$/
    my %auto;
my $cf = load_config($opts{module});
  my $cf = $mod . "::ConfigData";
  my %defs = @_;
my @exclusive = qw(feature config set_feature set_config);
  my $mod = shift;
my %opt_defs = (
my %opts;
  my $out = "\nUsage: $0 [options]\n\n  Options include:\n";
  my %to_set = %{$opts{set_config}};
  my %to_set = %{$opts{set_feature}};
    # note: need to support older ConfigData.pm's
    or die "Invalid module name '$mod'";
or set C<config> or C<feature> values.  The following options are
    $out .= "$defs{$name}{desc}\n";
  $out .= <<EOF;
    $out .= "  --$name";
    pad_line($out, 35);
paragraph...).  These C<...::ConfigData> modules contain the
  # Print a usage message
    print $cf->feature($opts{feature});
    print " Configuration defined in $cf:\n";
  print "Config value" . 's'x(keys(%to_set)>1) . " saved\n";
    print Data::Dumper::Dumper($cf->config($opts{config})), "\n";
    print " Features defined in $cf:\n";
  print "Feature" . 's'x(keys(%to_set)>1) . " saved\n";
      print "  $name => ", $cf->feature($name), (exists $auto{$name} ? " (dynamic)" : ""), "\n";
      print "  $name => ", Data::Dumper::Dumper($cf->config($name)), "\n";
Prints a help message, including a few examples, and exits.
print usage(%opt_defs) and exit(0)
querying and setting (yes, actually re-writing) the configuration
reading) is merely a front-end for those methods.  If you wish, you
  require Data::Dumper;
  return $cf;
  return $out;
      /^=s$/  and      $out .= " <string>";
      /^=s%$/ and      $out .= " <string>=<value>";
serializable using C<Data::Dumper>.  A C<feature> is a boolean (1 or
  # Set config/feature values
		set_config  => {type => '=s%',
		set_feature => {type => '=s%',
Sets the given C<config> entry to the given value.
Sets the given C<feature> to the given boolean value.  Specify the value
Specifies the name of the module to configure (required).
structures, you probably shouldn't use this command-line interface,
sub load_config {
sub pad_line {  $_[0] .= ' ' x ($_[1] - length($_[0]) + rindex($_[0], "\n")) }
sub usage {
supported:
The C<config_data> tool provides a command-line interface to the
The configuration system emplyed here was developed in the context of
the names and values of all known features will be shown.
The two types of data that may be stored are called C<config> values
This library is free software; you can redistribute it and/or modify
This script functions as a basic getter/setter wrapper around the
  unless grep(exists $opts{$_}, @exclusive) == 1;
  unless $opts{module};
use Getopt::Long;
use Module::Build 0.25;
use strict;
#!/usr/bin/perl
      $v = eval($v);
Wardley (C<Template::Config>), and Larry Wall (perl's own Config.pm)
was taken by all those other systems mentioned in the previous
When no config name is supplied, the names and values of all known
When passed the name of a C<config> entry, shows its value.  The value
When passed the name of a C<feature>, shows its value.  The value will
  while (my ($k, $v) = each %to_set) {
will be displayed using C<Data::Dumper> (or similar) as perl code.
