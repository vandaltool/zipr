        }
        	    }
        	}
##############################################################################
    001.001 001.002 001.003 Black
$0 =~ s!.*/!!;
		    	    16 + $Class1RecordSize * $l, 
		    		2 + $r * $PairValueRecordSize, 
    aacute acircumflex adieresis agrave
    Aacutesmall Acircumflexsmall Atildesmall Adieresissmall
    Acircumflex Adieresis Agrave Aring
    ae dotlessi lslash oslash
A few updates to the documentation
and language (defaulting to `latn' and `DFLT') and print only the kerning
and language. Maybe it would be better to let the user choose a script
and prints it (in F<afm> format) to C<stdout>.
    aring atilde ccedilla eacute
    Aringsmall AEsmall Ccedillasmall Egravesmall
    Atilde Ccedilla Eacute Ecircumflex
at specific font sizes or device resolutions'>. Since there is no way to
binmode FONT;
    Bold Book Light Medium
B<ot2kpx> prints data from all features named `kern', regardless of script
B<ot2kpx> uses only the XAdvance data associated with the first glyph in any
    braceleft bar braceright asciitilde
    bracketleft backslash bracketright asciicircum
    brokenbar degree thorn threequarters
    bullet quotesinglbase quotedblbase quotedblright
    caron emdash AE ordfeminine
    c d e f
    ($CFF, @Strings) = getidx $CFF;
    ($CFF, @TopDict) = getidx $CFF;
    ($CFF, undef) = getidx substr($Table{CFF}, $HdrSize);
Changed warning that's given when the font contains no GPOS table, to an
	$Charset = substr $Table{CFF}, $TopDict{15};
    (chop($fn = `findtexmf $ARGV[0] 2>&1`) and -e $fn)) 
	    $c[$i + $StartGlyph] = getu(substr $_[0], 6 + 2 * $i, 2);
        	$c[$j] = $Class;
		$Class1Count = getu(substr $SubTable, 12, 2);
		@Class1 = getclass(substr $SubTable, $ClassDef1);
		    	    $Class1RecordSize;
        	    $Class1RecordSize = $Class2Count * $Class2RecordSize;
        	    $Class1Record = substr $SubTable, 
		$Class2Count = getu(substr $SubTable, 14, 2);
		@Class2 = getclass(substr $SubTable, $ClassDef2);
        	$Class2RecordSize = 2;
	    	    $Class2RecordSize += 2;
		    		$Class2RecordSize * $m, $Class2RecordSize;
		$ClassDef1 = getu(substr $SubTable, 8, 2);
		$ClassDef2 = getu(substr $SubTable, 10, 2);
    colonmonetary onefitted rupiah Tildesmall
		@Coverage = getcov($Coverage);
	$coverage = getu(substr $Table{kern}, $startSubTable + 4, 2);
		$Coverage = substr $SubTable, getu(substr $SubTable, 2, 2);
    Csmall Dsmall Esmall Fsmall
    dagger daggerdbl periodcentered paragraph
data from features associated with these values.
	    die "Error: can't open `$ARGV[0]' - $!\n";
    	die "Error: NumGlyphs in `maxp' different from `CFF'\n";
die "Usage: $0 fontfile\n" if @ARGV != 1;
        $d[$i] = substr $_[0], 2 + ($n + 1) * $sz + $off[$i], 
    dollarinferior periodinferior commainferior Agravesmall
    dollarsuperior ampersandsmall Acutesmall parenleftsuperior
    Dotaccentsmall Macronsmall figuredash hypheninferior
    dsuperior esuperior isuperior lsuperior
    Eacutesmall Ecircumflexsmall Edieresissmall Igravesmall
    ecircumflex edieresis egrave iacute
    Edieresis Egrave Iacute Icircumflex
    else {
	    else {
	else {die "Error: unknown CharsetFormat `$Format'\n"}
    elsif (${$_[0]}[0] >= 247) {
    elsif (${$_[0]}[0] >= 251) {
    elsif (${$_[0]}[0] == 29) {
    elsif (${$_[0]}[0] == 30) {
    elsif ($ClassFormat == 2) {
    elsif ($CoverageFormat == 2) {
	elsif ($Format == 1) {
	elsif ($Format == 2) {
	    elsif ($PosFormat == 2) {
	elsif ($TopDict[0] == 12) {
    elsif ($TopDict{15} == 1) {
    elsif ($TopDict{15} == 2) {
EndKernData
    exclamdown cent sterling fraction
    exclamdownsmall centoldstyle Lslashsmall Scaronsmall
express such adjustments in F<afm> format, ignoring them seems to be the
F<afm2afm>, F<autoinst>, F<cmap2enc>, F<font2afm>, F<pfm2kpx>.
    $FeatureCount = getu(substr $FeatureList, 0, 2);
	$Feature = getu(substr $FeatureList, 6 + 6 * $i, 2);
    $FeatureList = substr $Table{GPOS}, getu(substr $Table{GPOS}, 6, 2);
	$FeatureTag = substr $FeatureList, 2 + 6 * $i, 4;
    ffl parenleftinferior parenrightinferior Circumflexsmall
        	$first = getu(substr $Charset, 1 + 3 * $j, 2);
        	$first = getu(substr $Charset, 1 + 4 * $j, 2);
First version
    fiveoldstyle sixoldstyle sevenoldstyle eightoldstyle
    fivesuperior sixsuperior sevensuperior eightsuperior
    $FONT = <FONT>;
font I know of that does contain data other than XAdvance is Linotype
    for $i (0 .. 0xFF) {
        for $i (0, 1) {
	for $i (0 .. 228) {$glyphName[$i] = $Strings[$i]}
        for $i (0 .. 3) {
	for $i (0 .. $ClassRangeCount - 1) {
    for $i (0 .. $FeatureCount - 1) {
	for $i (0 .. $GlyphCount - 1) {
for ($i = 0; $i < $NumTables; $i++) {
    for $i (0 .. $LookupCount - 1) {
    for $i (0 .. $n) {
    for $i (0 .. $n - 1) {
    for $i (0 .. $nTables - 1) {
for $i (0 .. $NumGlyphs - 1) {
    for $i (0x100 .. $NumGlyphs - 1) {
	    for ($j = 0; $i < $NumGlyphs; $j++) {
	for $j (0 .. $LookupCount - 1) {
	for $j (0 .. $nPairs - 1) {
    for $j (0 .. $NumGlyphs - 1) {
	    for $j (1 .. $NumGlyphs - 1) {
    for $j (@{$LookupListIndex{kern}}) {
	    for $j ($Start .. $End) {
        	for $k (0 .. $nLeft) {
	for $k (0 .. $SubTableCount - 1) {
		for $l (0 .. $Class1Count - 1) {
		for $l (0 .. $#Coverage) {
    	    	    for $m (0 .. $Class2Count - 1) {
	$Format  = getu(substr $Charset, 0, 1);
    		for $m (@Coverage) {
	for my $i (0 .. $GlyphCount - 1) {
    for my $i (0 .. $n - 1) {
	for my $i (0 .. $RangeCount - 1) {
	    for my $j ($Start .. $End) {
		    for $n (0 .. $NumGlyphs - 1) {
		    for $r (0 .. $PairValueCount - 1) {
				gets16(substr $ValueRecord, $ValueOffset, 2);
	    	    getu(substr $FeatureList, $Feature + 4 + 2 * $j, 2);
	    	getu(substr $LookupList, 2 + 2 * $i, 2);
	    	    getu(substr $LookupTable, 6 + 2 * $k, 2);
		    	    getu(substr $SubTable, 10 + 2 * $l, 2);
    g h i j
		$GlyphCount = @Coverage;
	    $glyphName[0] = $Strings[0];
	    	    $glyphName[$i], $glyphName[$j], 
	$glyphName[$i] = sprintf "index0x%02X", $i;
	$glyphName[$i] = sprintf "index0x%04X", $i;
	    $glyphName[$i++] = $Strings[0];
        	    $glyphName[$i++] = $Strings[$first + $k];
        	$glyphName[$j] = $Strings[getu(substr $Charset, 1 + 2 * $j,2)];
    grave acute circumflex tilde
    Gsmall Hsmall Ismall Jsmall
    guillemotright ellipsis perthousand questiondown
    guilsinglright fi fl endash
    $HdrSize = getu(substr $Table{CFF}, 2, 1);
=head1 AUTHOR
=head1 DESCRIPTION
=head1 HISTORY
=head1 NAME
=head1 RESTRICTIONS
=head1 SEE ALSO
=head1 SYNOPSIS
    hyphensuperior Gravesmall Asmall Bsmall
	    $i = 0;
    Iacutesmall Icircumflexsmall Idieresissmall Ethsmall
    icircumflex idieresis igrave ntilde
    Idieresis Igrave Ntilde Oacute
    if (${$_[0]}[0] == 28) {
if ((chop($fn = `kpsewhich $ARGV[0] 2>&1`) and -e $fn) or
    if ($ClassFormat == 1) {
	if ($coverage != 0x01) {
    if ($CoverageFormat == 1) {
if (exists $Table{CFF}) {
if (exists $Table{GPOS}) {
if (exists $Table{kern}) {
	if ($Format == 0) {
		if ($GlyphCount != $PairSetCount) {
	if ($LookupType != 2) {
    if ($NumGlyphs != getu(substr $Table{CFF}, $TopDict{17}, 2)) {
	    if ($PosFormat == 1) {
	if ($TopDict[0] > 21) {
    if ($TopDict{15} == 0) {
    if ($v > 0x7FFF) {
		if ($ValueFormat1 & 0x01) {
		if ($ValueFormat1 & 0x02) {
        	if (!($ValueFormat1 & 0x04) || $ValueFormat2 != 0) {
		if ($ValueFormat1 & 0x08) {$Class2RecordSize += 2}
		if ($ValueFormat1 & 0x08) {$PairValueRecordSize += 2}
		if ($ValueFormat1 & 0x10) {$Class2RecordSize += 2}
		if ($ValueFormat1 & 0x10) {$PairValueRecordSize += 2}
		if ($ValueFormat1 & 0x20) {$Class2RecordSize += 2}
		if ($ValueFormat1 & 0x20) {$PairValueRecordSize += 2}
		if ($ValueFormat1 & 0x40) {$Class2RecordSize += 2}
		if ($ValueFormat1 & 0x40) {$PairValueRecordSize += 2}
		if ($ValueFormat1 & 0x80) {$Class2RecordSize += 2}
		if ($ValueFormat1 & 0x80) {$PairValueRecordSize += 2}
	if ($Value = $KPX{$i}{$j}) {
			if ($Value = $Value[$Class1[$m]][$Class2[$n]]) {
Improved the documentation
informational message.
In many OpenType fonts, most kerning data is stored in the `GPOS' table rather
Input files searched using B<kpsewhich> or B<findtexmf>
Input files searched via B<kpsewhich> (where available)
=item B<->
=item I<2005-01-10>
=item I<2005-02-18>
=item I<2005-03-08>
=item I<2005-03-15>
=item I<2005-03-21>
=item I<2005-04-29>
=item I<2005-05-25>
=item I<2005-07-29>
kerning pair; all other data in the ValueRecords is ignored. I'm not sure 
	    $kernRecord = substr $Table{kern}, $startSubTable + 14 + 6 * $j, 6;
    k l m n
 @{KPX}EndKernPairs
$KPX = @KPX;
	    $KPX{$left}{$right} ||= $value * 1000 / $UnitsPerEM;
			$KPX{$left}{$right} ||= $Value * 1000 / $UnitsPerEM;
                            $KPX{$m}{$n} ||= $Value * 1000 / $UnitsPerEM;
    Ksmall Lsmall Msmall Nsmall
	    	    $left = $Coverage[$l];
	    $left = getu(substr $kernRecord, 0, 2);
    $Length = getu(substr $Record, 12, 4);
    	$length = getu(substr $Table{kern}, $startSubTable + 2, 2);
    local $/;
	$LookupCount = getu(substr $FeatureList, $Feature + 2, 2);
    $LookupCount = getu(substr $LookupList, 0, 2);
	$Lookup[$i] = substr $LookupList, 
    $LookupList = substr $Table{GPOS}, getu(substr $Table{GPOS}, 8, 2);
	$LookupTable = $Lookup[$j];
	$LookupType = getu(substr $LookupTable, 0, 2);
    Lslash Oslash OE ordmasculine
    macron breve dotaccent dieresis
Marc Penninga <marc@penninga.info>
    msuperior nsuperior osuperior rsuperior
    multiply threesuperior copyright Aacute
    mu trademark Eth onehalf
    my $arg = shift;
    my @c = (0) * $NumGlyphs;
    my $ClassFormat = getu(substr $_[0], 0, 2);
	    my $Class = getu(substr $ClassRangeRecord, 4, 2);
	my $ClassRangeCount = getu(substr $_[0], 2, 2);
	    my $ClassRangeRecord = substr $_[0], 4 + 6 * $i, 6;
    my $CoverageFormat = getu(substr $Coverage, 0, 2);
    my $Coverage = shift;
	    my $End   = getu(substr $ClassRangeRecord, 2, 2);
	    my $End = getu(substr $RangeRecord, 2, 2);
	my $GlyphCount = getu(substr $_[0], 4, 2);
    	my $GlyphCount = getu(substr $Coverage, 2, 2);
    my $i;
    my($i, $j);
    my $n  = getu(substr $_[0], 0, 2);
    my $n = length $arg;
    my @r = ();
    my $r = 0;
    	my $RangeCount = getu(substr $Coverage, 2, 2);
	    my $RangeRecord = substr $Coverage, 4 + 6 * $i, 6;
    my(@r, @off, @d, $i);
	    my $Start = getu(substr $ClassRangeRecord, 0, 2);
	    my $Start = getu(substr $RangeRecord, 0, 2);
	my $StartGlyph = getu(substr $_[0], 2, 2);
    my $sz = getu(substr $_[0], 2, 1);
    my $v = getu $_[0];
    ($Name = substr $Record, 0, 4) =~ s/\s//g;
        	    next;
        	next;
	    next;
		    next;
    	$nibbles = "";
	$nibbles =~ s/c/E-/g;
	$nibbles .= sprintf("%02x", shift @{$_[0]}) until $nibbles =~ /f/;
	$nibbles =~ tr/abef/.E-/d;
    nineoldstyle commasuperior threequartersemdash periodsuperior
    ninesuperior zeroinferior oneinferior twoinferior
        	$nLeft = getu(substr $Charset, 3 + 3 * $j, 1);
        	$nLeft = getu(substr $Charset, 3 + 4 * $j, 2);
no other data, so this approach gives correct results (in fact, the only
    .notdef space exclam quotedbl
	$nPairs = getu(substr $Table{kern}, $startSubTable + 6, 2);
    $nTables = getu(substr $Table{kern}, 2, 2);
    Ntildesmall Ogravesmall Oacutesmall Ocircumflexsmall
    numbersign dollar percent ampersand
$NumGlyphs = getu(substr $Table{maxp}, 4, 2);
$NumTables = getu(substr $FONT, 4, 2);
    oacute ocircumflex odieresis ograve
    Ocircumflex Odieresis Ograve Otilde
    oe germandbls onesuperior logicalnot
	    	$off[$i + 1] - $off[$i];
        $off[$i] = getu(substr $_[0], 3 + $i * $sz, $sz);
    $Offset = getu(substr $Record, 8, 4);
    Ogoneksmall Ringsmall Cedillasmall questiondownsmall
    oneeighth threeeighths fiveeighths seveneighths
    oneoldstyle twooldstyle threeoldstyle fouroldstyle
    onethird twothirds zerosuperior foursuperior
only option.)
    open FONT, "<$ARGV[0]" or 
    open FONT, "<$fn" or die "Error: can't open `$fn' - $!\n";
	    @Operands = undef;
	    $Operator = shift(@TopDict);
	    $Operator = shift(@TopDict) . " " . shift(@TopDict);
    o p q r
    Osmall Psmall Qsmall Rsmall
ot2kpx - extract kerning information from an OpenType font
ot2kpx I<font>
    otilde scaron uacute ucircumflex
    Otildesmall Odieresissmall OEsmall Oslashsmall
=over 12
		$PairSetCount = getu(substr $SubTable, 8, 2);
	    	    $PairSet = substr $SubTable, 
		    $PairValueCount = getu(substr $PairSet, 0, 2);
				$PairValueRecordSize;
	    	    $PairValueRecordSize += 2;
        	$PairValueRecordSize = 4;
			$PairValueRecord = substr $PairSet, 
Palatino; this also contains XAdvDevice data, which is used (according to 
    parenrightsuperior twodotenleader onedotenleader zerooldstyle
    plus comma hyphen period
    plusminus Thorn onequarter divide
	    $PosFormat = getu(substr $SubTable, 0, 2);
print <<EOF;
	    push @KPX, sprintf("KPX %s %s %d\n", 
	    push @{$LookupListIndex{$FeatureTag}}, 
	    push @Operands, getnum(\@TopDict);
	    push @r, getu(substr $Coverage, 4 + 2 * $i, 2);
	    	push @r, $j;
    question at A B
    questionsmall asuperior bsuperior centsuperior
    quoteright parenleft parenright asterisk
    quotesingle quotedblleft guillemotleft guilsinglleft
        $r =  256 * (shift(@{$_[0]}) - 247) + shift(@{$_[0]}) + 108;
        $r = -256 * (shift(@{$_[0]}) - 251) - shift(@{$_[0]}) - 108;
$Record = substr $FONT, 12 + 16 * $i, 16;
    Regular Roman Semibold
    return @c;
    return @r;
    return $r;
    return substr($_[0], 2 + ($n + 1) * $sz + $off[$n]), @d;
    return $v;
    	$r = eval $nibbles;
Rewrote some of the code
	    $right = getu(substr $kernRecord, 2, 2);
			$right = getu(substr $PairValueRecord, 0, 2);
    ring cedilla hungarumlaut ogonek
            $r = ($r << 8) | shift(@{$_[0]});
        $r = ($r << 8) + unpack("C", substr($arg, $i, 1));
        $r = shift(@{$_[0]}) - 139;
    Scaron Uacute Ucircumflex Udieresis
    semicolon less equal greater
    seven eight nine colon
    seveninferior eightinferior nineinferior centinferior
        shift(@{$_[0]});
	shift @{$_[0]};
    slash zero one two
    Ssmall Tsmall Usmall Vsmall
    ssuperior tsuperior ff ffi
@StandardStrings = qw(
StartKernData
StartKernPairs $KPX
    $startSubTable = 4;
	    $startSubTable += $length;
	$startSubTable += $length;
    s t u v
sub getclass($) {
sub getcov($) {
sub getidx($) {
sub getnum($) {
sub gets16($) {
sub getu($) {
	$SubTableCount = getu(substr $LookupTable, 4, 2);
    	    $SubTable = substr $LookupTable, 
    $Table{$Name} = substr $FONT, $Offset, $Length;
Test if GPOS table is present before trying to read it
than in the `kern' table. B<ot2kpx> extracts the kerning data from both tables
the OpenType specification) to I<`define subtle, device-dependent adjustments
    three four five six
    threeinferior fourinferior fiveinferior sixinferior
    @TopDict = map ord, split(//, $TopDict[0]);
	    ($TopDict{$Operator} = join " ", @Operands) =~ s/^\s*//;
    twosuperior registered minus eth
    udieresis ugrave yacute ydieresis
    Ugravesmall Uacutesmall Ucircumflexsmall Udieresissmall
    Ugrave Yacute Ydieresis Zcaron
    underscore quoteleft a b
$UnitsPerEM = getu(substr $Table{head}, 18, 2);
    unshift @Strings, @StandardStrings;
use integer;
use warnings; no warnings qw(uninitialized);
#!/usr/bin/perl
        $v -= 0x10000;
	    	    $Value > 0x7FFF ? $Value - 0x10000 : $Value);
        	$ValueFormat1 = getu(substr $SubTable, 4, 2);
		$ValueFormat1 = getu(substr $SubTable, 4, 2);
        	$ValueFormat2 = getu(substr $SubTable, 6, 2);
		$ValueFormat2 = getu(substr $SubTable, 6, 2);
		    	 "$ValueFormat2)' not implemented\n";
	    $value = gets16(substr $kernRecord, 4, 2);
			$Value = getu(substr $PairValueRecord, $ValueOffset, 2);
                	$Value[$l][$m] = 
        	$ValueOffset = 0;
        	$ValueOffset = 2;
		    $ValueOffset += 2;
                	$ValueRecord = substr $Class1Record, 
	    	    warn "ERROR: GlyphCount not equal to PairSetCount\n";
	    warn "Warning: format of `kern' table not supported\n";
	warn "Warning: predefined CharSet `Expert' not implemented\n";
	warn "Warning: predefined CharSet `ExpertSubset' not implemented\n";
	warn "Warning: unknown ClassFormat `$ClassFormat'\n";
    	warn "Warning: unknown CoverageFormat `$CoverageFormat'\n";
        	warn "Warning: unknown PosFormat `$PosFormat'\n";
        	    warn "Warning: ValueFormat `($ValueFormat1, " . 
	    warn "Warning: wrong LookupType `$LookupType', table skipped\n";
whether this is The Right Thing to Do; however, almost always there is
    while (@TopDict) {
    Wsmall Xsmall Ysmall Zsmall
    w x y z
    Yacutesmall Thornsmall Ydieresissmall 001.000
    yen florin section currency
    zcaron exclamsmall Hungarumlautsmall dollaroldstyle
    Zcaronsmall Dieresissmall Brevesmall Caronsmall
