################################################################
 2010-2011 Piotr O
 2010 Canonical Ltd
# all copies or substantial portions of the Software.
arowski <piotr@debian.org>
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                break
    # byte compile files
        cfn = fn + 'c' if (__debug__ or not optimize) else 'o'
        child_output, child_unused = process.communicate()
    cmd = "/usr/bin/python%s%s -m py_compile -" \
# -*- coding: utf-8 -*-
### COMPILE ####################################################
                compile(files, compile_versions, options.force,
            compile(files, versions,
        compile(files, versions,
                                              compile_versions)
        compile_versions = debsorted(versions)[:1]
            continue
                continue
                    continue
# copies of the Software, and to permit persons to whom the Software is
# Copyright 
            coroutine.next()
            coroutine = py_compile(version, optimize, WORKERS)
                ctime = 0
                ctime = os.stat(cfn).st_mtime
        default=False, help='be quiet')
        default=False, help="byte-compile to .pyo files")
        default=False, help='force rebuild even if timestamps are up-to-date')
def compile(files, versions, force, optimize, e_patterns=None):
def filter_files(files, e_patterns, compile_versions):
def get_exclude_patterns(directory='/', patterns=None, versions=None):
def get_exclude_patterns_from_dir(name='/usr/share/python/bcep/'):
def main():
def py_compile(version, optimize, workers):
        dest='regexpr', type='regexpr',
    elif args:  # other directories/files
    elif options.package:  # package's public modules
            elif type_ == 're' and pattern.match(fn):
            else:
    else:
        e_patterns = get_exclude_patterns()
            e_patterns = get_exclude_patterns(item, options.regexpr, \
            e_patterns = get_exclude_patterns(item, options.regexpr, versions)
Examples:
            except KeyError:
            except os.error:
### EXCLUDES ###################################################
       exists("/usr/bin/python%d.%d" % options.vrange[0]):
        exit(1)
        exit(3)
    exit(rv)
        filename = (yield)
            files = add_namespace_files(files, action=True)
        files = add_namespace_files(files, options.package, action=True)
                files = dpf.filter_directory(pkg_files, item)
            files = dpf.filter_out_ext(files, ('.so',))
        files = dpf.filter_out_ext(files, ('.so',))
        files = dpf.filter_public(files, versions)
            files = dpf.from_directory(item, extensions=('.py', '.so'))
        files = dpf.from_package(options.package, extensions=('.py', '.so'))
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            # FIXME: find out the package the file belongs to
    for fn in files:
    for fn in listdir(name):
    for fn, versions_to_compile in filter_files(files, e_patterns, versions):
        for item in args:
            for line in lines:
    for process in WORKERS.itervalues():
        for type_, vers, dname, pattern in e_patterns:
    for type_, vers, dname, pattern in get_exclude_patterns_from_dir():
    for version in versions:
        for version in versions_to_compile:
from debpython import files as dpf
from debpython.namespace import add_namespace_files
from debpython.option import Option, compile_regexpr
from debpython.pydist import PUBLIC_DIR_RE
from debpython.tools import memoize
from debpython.version import SUPPORTED, debsorted, vrepr, \
from __future__ import with_statement
from given range, regardless of the default Python version in the system.
from os import environ, listdir
from os.path import exists, isdir, islink, join
from subprocess import PIPE, STDOUT, Popen
            ftime = os.stat(fn).st_mtime
# furnished to do so, subject to the following conditions:
    """Generate (file, versions_to_compile) pairs."""
        # get requested Python version
        get_requested_versions, parse_vrange, getver
    global STDINS, WORKERS
        help='exclude items that match given REGEXPR. You may use this option \
        help="""force private modules to be bytecompiled with Python version
        help='specify Debian package name whose files should be bytecompiled')
        help='turn verbose mode on')
            if ctime > ftime:
        if exists(cfn) and not force:
            if islink(fn):
if __name__ == '__main__':
        if not dname.startswith(directory[:len(dname)]):
        if not exists(fn):
            if not exists(item):
    if not isdir(name):
    if not isinstance(version, basestring):
            if not valid_versions:
                if not versions:
    if not versions:
    if options.package and args:  # package's private directories
    if options.regexpr and not args:
    if options.verbose or environ.get('PYCOMPILE_DEBUG') == '1':
    if options.vrange and options.vrange[0] == options.vrange[1] and\
    if patterns:
        if process.returncode not in (None, 0):
            if public_dir:
    if rv != 0:
If there are no other options, bytecompile all public modules for installed
            if type_ == 'dir' and fn.startswith(dname):
                if type_ == 're':
        if valid_versions:
        if version not in STDINS:
        if versions and not versions & vers:
        if versions is None:
    if versions is not None:
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
import logging
import optparse
import os
import sys
# initialize script
# in the Software without restriction, including without limitation the rights
                          item, compile_versions)
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        log.debug('args: %s', args)
        log.debug('argv: %s', sys.argv)
                log.debug('byte compiling %s using Python %s',
        log.debug('compile versions: %s', versions)
        log.debug('options: %s', options)
        log.error('Requested versions are not installed')
logging.basicConfig(format='%(levelname).1s: %(module)s:%(lineno)d: '
log = logging.getLogger(__name__)
        log.setLevel(logging.DEBUG)
        log.setLevel(logging.WARN)
                log.warn('dangling symlink skipped: %s (%s)', fn,
                log.warn('No such file or directory: %s', item)
    main()
        # make sure it's a set (debsorted returns a list)
@memoize
                           '%(message)s')
            # move to the next file if all versions were removed
multiple times to build up a list of things to exclude.')
newer), '2.5-2.7' (version 2.5 or 2.6), '-3.0' (all supported 2.X versions)""")
        # no need to limit versions here, version is hardcoded in path or
# of this software and associated documentation files (the "Software"), to deal
            'only, please use /usr/share/python/bcep to specify '
                                   option_class=Option)
    (options, args) = parser.parse_args()
                    options.force, options.optimize, e_patterns)
                options.force, options.optimize, e_patterns)
                        options.optimize, e_patterns)
       options.vrange != (None, None) and\
                          os.readlink(fn))
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    parser.add_option('-f', '--force', action='store_true', dest='force',
    parser.add_option('-O', action='store_true', dest='optimize',
    parser.add_option('-p', '--package',
    parser.add_option('-q', '--quiet', action='store_false', dest='verbose',
    parser.add_option('-V', type='version_range', dest='vrange',
    parser.add_option('-v', '--verbose', action='store_true', dest='verbose',
    parser.add_option('-X', '--exclude', action='append',
        parser.error('--exclude option works with private directories '
    parser = optparse.OptionParser(usage, version='%prog 1.0',
        parser.print_usage()
                    pattern = compile_regexpr(None, None, pattern)
                    # pattern doesn't match installed Python versions
                pattern = pattern.rstrip('\n')
        patterns = []
        patterns.append((type_, vers, dname, pattern))
        patterns = [('re', versions, directory, i) for i in patterns]
# Permission is hereby granted, free of charge, to any person obtaining a copy
                pipe.next()
                pipe = py_compile(version, optimize, WORKERS)
            pipe.send(fn)
                pipe = STDINS[version]
        pkg_files = tuple(dpf.from_package(options.package))
    process = Popen(cmd, bufsize=1, shell=True,
     '       %prog -p PACKAGE'
            public_dir = PUBLIC_DIR_RE.match(fn)
            'public modules to skip')
            # pycentral's hook should clean it later
    pycompile -p foo /usr/share/foo # package's private files
    pycompile -p foo -V 2.6- /usr/share/foo # private files, Python >= 2.6
    pycompile -p python-mako # package's public files
                # `pycompile /usr/lib/` invoked, add missing worker
    pycompile -V 2.6 /usr/lib/foo/bar.py # python2.6 only
    pycompile -V 2.6 /usr/lib/python2.6/dist-packages # python2.6 only
Python versions that match given range.
    result = []
                result.append((type_, versions, dname, pattern))
        return []
    return patterns
    """Return patterns for files that shouldn't be bytecompiled."""
    """Return patterns for files that shouldn't be compiled in given dir."""
    return result
    rv = 0
        rv += 100
            rv = process.returncode
        # skip patterns that do not match requested directory
        # skip patterns that do not match requested versions
        # specific version requested, use it even if it's not in SUPPORTED
    # start Python interpreters that will handle byte compilation
                    stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)
    stdin = process.stdin
STDINS = {}
            STDINS[version] = coroutine
                STDINS[version] = pipe
        stdin.write(filename + '\n')
sys.path.insert(1, '/usr/share/python/')
            sys.stderr.write(child_output)
# The above copyright notice and this permission notice shall be included in
# THE SOFTWARE.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
"""TODO: move it to manpage
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
            try:
                type_, vrange, dname, pattern = line.split('|', 3)
    usage = '%prog [-V [X.Y][-][A.B]] DIR_OR_FILE [-X REGEXPR]\n' + \
#! /usr/bin/python
        valid_versions = set(compile_versions)  # all by default
                valid_versions = valid_versions - vers
        % (version, '' if (__debug__ or not optimize) else ' -O')
VERSION_RANGE examples: '2.5' (version 2.5 only), '2.5-' (version 2.5 or
        versions = debsorted(versions)[:1]
        versions = get_requested_versions(options.vrange, available=True)
                versions = get_requested_versions(vrange, available=True)
        versions = set(options.vrange[:1])
            versions = set(SUPPORTED)
        versions = set(versions)
        version = vrepr(version)
        # via -V option
# vim: et ts=4 sw=4
                vrange = parse_vrange(vrange)
    # wait for all processes to finish
    while True:
        with file(join(name, fn), 'r') as lines:
WORKERS = {}
    workers[version] = process  # keep the reference for .communicate()
                yield fn, set([getver(public_dir.group(1))])
                yield fn, valid_versions
