        
            
                    }
                }
            }
        }
        } 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
##--------------------------------------------------------------------##
	      }
		      }
#  02111-1307, USA.
                ($1 >= 0 && $1 <= 100) or die($usage);
#10. changed file format to avoid file/fn name repetition       2.40s
#11. changed file format to drop unnecessary end-line "."s      2.36s
	($1<2) or die("Can't read format with major version $1.\n");
#12. switched from hash CCs to array CCs                        1.61s
#13. only adding b[i] to a[i] if b[i] defined (was doing it if
#14. Stopped converting "." entries to undef and then back      1.16s
#15. Using foreach $i (x..y) instead of for ($i = 0...) in
#16. Finding count lengths by int((length-1)/3), not by
# 1. If $a2->[$i] is undefined, it defaults to 0 which is what we want; we turn
# 1. turned off warnings in add_hash_a_to_b()                   3.81 --> 3.48s
    1 while ($val =~ s/^(\d+)(\d{3})/$1,$2/);
    # 2ndary key, etc).
# 2. We don't add an undefined count or a ".", even though it's value is 0,
# 6. make line_to_CC() return a ref instead of a hash           3.01 --> 2.77s
        $a2->[$i] += $a1->[$i] if (defined $a1->[$i] && "." ne $a1->[$i]);
#    add_array_a_to_b()                                         1.11s
	      add_array_a_to_b($CC, $call_CCs{$curr_name,$curr_cname});
	      add_array_a_to_b($CC, $call_CCs{$curr_name,$curr_cname,$curr_line_num});
	      add_array_a_to_b($CC, $curr_cfn_CC);
            add_array_a_to_b($CC, $curr_fn_CC);
		add_array_a_to_b($CC, $curr_fn_CC);
                add_array_a_to_b($CC, $tmp);
                        add_array_a_to_b($src_file_CCs->{$.}, 
# Add each event count to the CC array.  '.' counts become undef, as do
# Add the two arrays;  any '.' entries are ignored.  Two tricky things:
        %all_ann_files = %user_ann_files;
        %all_ann_files = (%user_ann_files, %$threshold_files) 
    $all_ind_CCs{$curr_file} =
            $all_ind_CCs{$curr_file} = $curr_file_ind_CCs 
            $all_ind_CCs{$curr_file} = $curr_file_ind_CCs;
# all the threshold counts.
#  along with this program; if not, write to the Free Software
# Also returns a hash containing all the files that are involved in getting the
# and make lines too long, we compute exactly how wide each column needs to be
##--- and results printing.                                        ---##
annotate_ann_files($threshold_files);
            # Annotate chosen lines, tracking total counts of lines printed
                          annotated lines [8]
    # annotated lines above.
# Annotate selected files
@ Annotations may not be correct.
# Annotator for cachegrind/callgrind. 
                          are interested in [$default_threshold%]
# Argument and option handling
        # Argument handling -- annotation file checking and selection.
    # Assertion
                $auto_annotate = 0 if ($1 eq "no");
                $auto_annotate = 1 if ($1 eq "yes");
# Auto-annotating primes:
            # --auto=yes|no
    --auto=yes|no         annotate all source files containing functions
# Because the counts can get very big, and we don't want to waste screen space
#    because we don't want to make an $a2->[$i] that is undef become 0
            # blank, do nothing
# but we have to use @sort_order and @show_order below to handle the --sort and
# by finding the widest entry for each one.
		$call_CCs{$curr_name,$curr_cname} = [];
		$call_CCs{$curr_name,$curr_cname,$curr_line_num} = [];
		$call_counter{$curr_name,$curr_cname} = 0;
	      $call_counter{$curr_name,$curr_cname} += $curr_call_counter;
		$call_counter{$curr_name,$curr_cname,$curr_line_num} = 0;
	      $call_counter{$curr_name,$curr_cname,$curr_line_num} += $curr_call_counter;
	      $called_from_line->{$curr_file,$curr_line_num} = $tmp;
	  $called_funcs->{$curr_name} = $tmp2;
##---                                           callgrind_annotate ---##
           calling|both   the called functions or both [none]
	  $calling_funcs->{$curr_cname} = $tmp;
	# Can't read format with major version > 1
$cause_and_solution@@
        $cause_and_solution = <<END
@@ cause:    bug in the Valgrind's debug info reader that screws up with .h
@@ cause:    not sure, sorry
@@ cause:    '$src_file' has changed since information was gathered.
                $CC_col_widths->[$i] = max($CC_col_widths->[$i], $clength); 
    (@CC <= @events) or die("Line $.: too many event counts\n");
# CCs are arrays, the counts corresponding to @events, with 'undef'
	      $cfn_totals{$curr_cname} = $curr_cfn_CC;
    # Check for needed header entries
    # Check if summary line was present
#    checking for definedness ourselves.
    chomp $pwd;
            close(INPUTFILE);
    close(INPUTFILE);
    ($cmd ne "") or die("Line $.: missing command line\n");
    # column order (ie. first column event is primary sort key, 2nd column is
# Command line of profiled program.
#    commifying (halves the number of commify calls)            1.68s --> 1.47s
            # Commit result from previous function
       $compressed{$context,$index} = $realname;
                $context = $1;
            # --context=N
    --context=N           print N lines of context before and after
#  Copyright (C) 2002 Nicholas Nethercote
#  Copyright (C) 2003 Josef Weidendorfer
    # Correct inclusive totals
    # correspond to @CC positions.
	      $curr_call_counter = 0;
	  $curr_call_counter = $1;
	    $curr_cfile = "";
	  $curr_cfile = uncompressed_name("fl",$1);
	      $curr_cfn_CC = $cfn_totals{$curr_cname};
	      $curr_cfn_CC = [] unless (defined $curr_cfn_CC);
	  $curr_cfunc = uncompressed_name("fn",$1);
	    $curr_cname = "$curr_cfile:$curr_cfunc";
	    $curr_cname = "$curr_file:$curr_cfunc";
	  $curr_cobj = uncompressed_name("ob",$1);
    # Current directory, used to strip from file names if absolute
            $curr_file_ind_CCs = $all_ind_CCs{$curr_file};
                $curr_file_ind_CCs->{$curr_line_num} = $tmp;
	$curr_file_ind_CCs if (defined $curr_file);
            $curr_file_ind_CCs = {} unless (defined $curr_file_ind_CCs);
            $curr_file =~ s/^\Q$pwd\E//;
            $curr_file = uncompressed_name("fl",$1);
            $curr_file = uncompressed_name("fl",$2);
            $curr_fn_CC = $fn_totals{$curr_name};
            $curr_fn_CC = [] unless (defined $curr_fn_CC);
            $curr_fn = uncompressed_name("fn",$1);
            $curr_line_num = $1;
            $curr_name = "$curr_file:$curr_fn";
            $curr_obj = uncompressed_name("ob",$1);
    # @curr_totals has the same shape as @sort_order and @thresholds
            $curr_totals[$i] += $fn_CC->[$sort_order[$i]] 
	    $curr_totals[$i] = $summary_CC->[$sort_order[$i]] -
            (defined $curr_name) or die("Line $.: Unexpected fi/fe line\n");
            (defined $events{$show_event}) or 
            (defined $events{$sort_event}) or 
      (defined $input_file) or die($usage);
                (defined $user_ann_files{$src_file} ? "User" : "Auto");
        delete $threshold_files->{"???"};
            $did_annotations = 1;
                die("callgrind_annotate-$version\n");
                die("File $src_file not opened in any of: @include_dirs\n");
                die("--show event `$show_event' did not appear in input\n");
                die("--sort event `$sort_event' did not appear in input\n");
        die("sort_order length != thresholds length:\n",
                    die($usage);
                die($usage);
# Directories in which to look for annotation files.
    # Do as for --show, but if no --sort arg given, default to sorting by
# eg. (@events[$show_order[1]], @events[$show_order[2]]...) = @show_events.
#    either a[i] or b[i] was defined, but if b[i] was undefined
                    } else {
                } else {
            } else {
        } else {
      else {
     else {
    } else {
	  } else {
	  else {
	      else { $curr_line_num = 0; }
	else { $desc .= "$dline\n"; }
            } else {            # -h and --help fall under this case
            } elsif ($arg =~ /^--auto=(yes|no)$/) {
            } elsif ($arg =~ /^--context=([\d\.]+)$/) {
            } elsif ($arg =~ /^(-I|--include)=(.*)$/) {
            } elsif ($arg =~ /^--inclusive=(yes|no)$/) {
            } elsif ($arg =~ /^--show=(.*)$/) {
            } elsif ($arg =~ /^--sort=(.*)$/) {
            } elsif ($arg =~ /^--threshold=([\d\.]+)%?$/) {
            } elsif ($arg =~ /^--tree=(none|caller|calling|both)$/) {
      elsif (/^cmd:\s+(.*)$/)  { $cmd = $1; }
      elsif (/^creator:\s+(.*)$/)  { $creator = $1; }
      elsif (/^desc:\s+(.*)$/) {
      elsif (/^events:\s+(.*)$/) {
      elsif (/^part:\s+(.*)$/) { $part = $1;  }
      elsif (/^pid:\s+(.*)$/) { $pid = $1;  }
      elsif (/^positions:\s+(.*)$/) {
	} elsif (s/^calls=(\d+)//) {
	} elsif (s/^cfi=(.*)$//) {
	} elsif (s/^cfn=(.*)$//) {
        } elsif (s/^cob=(.*)$//) {
        } elsif (s/^(fi|fe)=(.*)$//) {
        } elsif (s/^fl=(.*)$//) {
        } elsif (s/^fn=(.*)$//) {
        } elsif (s/^jfi=(.*)$//) {
        } elsif (s/^jfn=(.*)$//) {
        } elsif (s/^(jump|jcnd)=//) {
        } elsif (s/^ob=(.*)$//) {
    } elsif ($src_file =~ /\.h$/) {
        } elsif (s/^\s*$//) {
        } elsif (s/^summary:\s+//) {
        } elsif (s/^totals:\s+//) {
      elsif (/^thread:\s+(.*)$/) { $thread = $1;  }
      elsif (/^version:\s*(\d+)/) {
##--- end                                           vg_annotate.in ---##
	$events = $1;
#   - events = A,B,C,D
# events count above the thresholds (ie. all the interesting ones).
        $events{$event} = $n;
            # Events header
# Events in input file, eg. (A,B,C,D)
	# events line is last in header
    # "events:" line.  Then initialise @show_order.
    ($events ne "") or die("Line $.: missing events line\n");
    @events = split(/\s+/, $events);
# Events to show, from command line, eg. (C,A,D)
    # Exhausted events, equal
# explaining possible causes.
            # Failed to open the file.  If chosen on the command line, die.
# File format is described in /docs/techdocs.html.
            # File header (distinguish between user- and auto-selected files).
        $filename =~ s/:.+$//;    # remove function name
# Files chosen for annotation on the command line.  
@@           files sometimes
                # Find length, accounting for commas that will be added
    # Find maximum width count for each column.  @CC_col_width positions
            # Finds interesting line ranges -- all lines with a CC, and all
    # Finish up handling final filename/fn_name counts
                               $fn_CC->[$sort_order[$i]]
    } @fn_fullnames;
    @fn_fullnames = sort {
    $fn_totals{"$curr_file:$curr_fn"} = $curr_fn_CC
            $fn_totals{$curr_name} = $curr_fn_CC;
            $fn_totals{$curr_name} = $curr_fn_CC if (defined $curr_name);
	$fn_totals{$name} = $cfn_totals{$name};
		      foreach my $called (keys %$tmp) {
	    foreach my $called (keys %$tmp2) {
	    foreach my $calling (keys %$tmp1) {
    foreach my $CC (@CCs) {
        foreach my $e (@sort_order) {
    foreach my $e (@thresholds) {
    foreach my $event (@events) {
    foreach my $fn_name (@fn_fullnames) {
        foreach my $f (@unfound_auto_annotate_files) {
        foreach (my $i = 0; $i < @$summary_CC; $i++) {
    foreach my $i (0 .. $n-1) {
        foreach my $i (0 .. scalar(@$CC)-1) {
    foreach my $i (0 .. (scalar @$CC)-1) {
                foreach my $i (0 .. scalar @sort_events - 1) {
        foreach my $i (0 .. scalar @sort_order - 1) {
        foreach my $i (0 .. scalar @thresholds - 1) {
            foreach my $include_dir (@include_dirs) {
        foreach my $include_dir (@include_dirs) {
    foreach my $include_dir (@include_dirs2) {
    foreach my $i (@show_order) {
    foreach my $i (@show_order) { 
    foreach my $i (@sort_order) {
                foreach my $line_num (@line_nums) {
      foreach my $name (keys %cfn_totals) {
        foreach my $show_event (@show_events) {
    foreach my $show_event (@show_events) {
        foreach my $sort_event (@sort_events) {
    foreach my $sort_event (@sort_events) {
    foreach my $src_file (keys %all_ann_files) {
    foreach $user_ann_file (@user_ann_files) {
    for my $arg (@ARGV) { 
            for (my $i = 0; $i < $n; $i++) {
# for @show_order.
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
                $full_file_name = ($include_dir eq "" 
            # full filename matches;  or, if auto-annotating, we have to
		$func_of_line{$curr_file,$curr_line_num} = $curr_name;
# function names aren't pushed over unnecessarily by huge summary figures).
@@           gather new information.
#  General Public License for more details.
# Generic description string.
            # Get file's CCs
# Global variables, main data structures
# handled this proportion of all the events thresholded.
	$has_addr = ($positions =~ /(addr|instr)/);
# hash(context, index) => realname for compressed traces
# hash( file:func => [ called file:func ])
# hash( file:func => [ calling file:func ])
# hash( file:func,cfile:cfunc => call CC[])
# hash( file:func,cfile:cfunc => call counter)
# hash( file:func,line => [called file:func ])
# hash( file:func,line => file:func
# hash (file:func => object name)
# hash(filename:fn_name => CC array)
# hash(filename => hash(line_num => CC array))
	$has_line = ($positions =~ /line/);
    # Header and counts for summary
    # Header for functions
    -h --help             show this message
                    $i++;
      if (/^$/) { ; }
        if (0 != $cmp) {
        if ($arg =~ /^-/) {
            if ($arg =~ /^--version$/) {
            # If arose from auto-annotation, print a little message.
    if ($auto_annotate) {
            if ($auto_annotate || defined $user_ann_files{$curr_file}) {
    # If auto-annotating, add interesting files (but not "???")
                if ($context < 0) {
    if ($creator ne "") { print " (creator: $creator)"; }
	    if ($curr_call_counter>0) {
	  if ($curr_cfile eq "") {
            # If curr_file is selected, add CC to curr_file list.  We look for
	      if (!defined $call_CCs{$curr_name,$curr_cname}) {
	      if (!defined $call_CCs{$curr_name,$curr_cname,$curr_line_num}) {
			if (defined $call_CCs{$func,$called,$.}) {
	      if (defined $call_counter{$calling,$fn_name}) {
	      if (defined $call_counter{$fn_name,$called}) {
            if (defined $CC->[$i]) {
                if (defined $curr_file);
	if (defined $curr_file && defined $curr_fn);
                if (defined $fn_CC->[$sort_order[$i]]);
	      if (defined $fn_CC->[$sort_order[$i]]);
      if (!defined $input_file) {
                    if (defined $line_nums[0] && $. == $line_nums[0]) {
		if (defined $obj_name{$called}) {
		if (defined $obj_name{$calling}) {
	if (defined $obj_name{$fn_name}) {
            if (!defined $src_file_CCs) {
	      if (!defined $tmp) {
		    if (defined $tmp) {
	  if (defined $tmp1) {
	  if (defined $tmp2) {
            if (defined $user_ann_files{$src_file}) {
    if ($did_annotations) {
	if ($dline =~ /^Option:/) {;}
	    if ($has_addr) {
	      if ($has_line) {
    if ($inclusive) {
	      if ($inclusive) {
	  if ($inclusive) {
    if ($input_file eq "") {
	  if ($input_file eq "") {
            if (@line_nums) {
    # If multiple threshold args weren't given via --sort, stick in the single
   if ($name =~ /^\((\d+)\)\s*(.*)$/) {
    # If no --show arg give, default to showing all events in the file.
    if (not defined $summary_CC) {
    if ((not defined $summary_CC) || is_zero($summary_CC)) {
        if (not $opened_file) {
    if (not @thresholds) {
                if (not $th_specified) {
# If on, automatically annotates all files that are involved in getting over
            if (open(INPUTFILE, "< $try_name")) {
      if ($part ne "") { $target .= ", part $part"; }
    if ($pid ne "") {
     if ($realname eq "") {
                if (-r $include_dir . $arg) {
        if (s/^(-?\d+|0x\w+)\s+//) {
	        if (s/^(\d+)\s+//) { $curr_line_num = $1; }
    if (@show_events) {
    # If --show option is used, check all specified events appeared in the
@@           If so, a warning will have already been issued about this.
    if (@sort_events) {
                    if ($sort_events[$i] =~ /.*:([\d\.]+)%?$/) {
            if ($src_file_CCs->{0}) {
            # If $src_file more recent than cachegrind.out, issue warning
                if ($src_line) {
    if ($src_more_recent_than_inputfile) {
            if ((stat $opened_file)[9] > (stat $input_file)[9]) {
	    if ($summary_CC->[$sort_order[$i]] >0) {
# If there is information about lines not in the file, issue a warning
            # If there was info on lines past the end of the file...
      if ($thread ne "") { $target .= ", thread $thread"; }
	if ($tree_caller && ($fn_name ne "???:???")) {
	if ($tree_caller || $tree_calling) { print " * "; }
	if ($tree_caller || $tree_calling) { print "\n"; }
	if ($tree_calling && ($fn_name ne "???:???")) {
    if (@unfound_auto_annotate_files) {
	    if ($verbose) { chomp; warn("    line: '$_'\n"); }
	if ($verbose) { chomp; warn("    line: '$_'\n"); }
    # If we did any annotating, print what proportion of events were covered by
          # ignore jump information
          # ignore jump information	
	  #ignore jump information
    -I --include=<dir>    add <dir> to list of directories to search for 
            # --include=A,B,C
                                  : "$include_dir + $src_file"); 
                $inclusive = 0 if ($1 eq "no");
                $inclusive = 1 if ($1 eq "yes");
	      # inclusive costs
# Inclusive statistics (with subroutine events)
# Inclusive totals for each function, for overall summary.
            # --inclusive=yes|no
    --inclusive=yes|no    add subroutine costs to functions calls [no]
                $inc =~ s|/$||;         # trim trailing '/'
# Individual CCs, organised by filename and line_num for easy annotation.
# Info on the profiled process.
@@ Information recorded about lines past the end of '$src_file'.
    # Initialise with minimum widths (from event names)
	    $input_file = $arg;
	  $input_file = (<cachegrind.out*>)[0];
      $input_file = (<callgrind.out*>)[0];
# Input file name, will be set in process_cmd_line
# Issue a warning that the source file is more recent than the input file. 
# Is this a line with all events zero?
	$isZero = 0 if ($CC->[$i] >0);
    # Iterate through sort events (eg. 3,2); return result if two are different
#    it just added 0)                                           1.48s
#     Josef.Weidendorfer@gmx.de
# key = basename (trimmed of any directory), value = full filename
                    last;
                last;
        last if $reached_all_thresholds;
                    last unless (defined $tmp);     # hack to detect EOF
#  License, or (at your option) any later version.
            # likely due to bugs in Valgrind's stabs debug info reader)
                       $line_nums[$i] + 2*$context >= $line_nums[$i+1]) {
            # lines within $context lines of a line with a CC.
    LOOP:
# "main()"
# Map from @show_events indices to @events indices, eg. (2,0,3).  Gives the
# Map from @sort_events indices to @events indices, eg. (3,2).  Same idea as
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# (Might help to think of it like a hash (0 => 2, 1 => 0, 2 => 3).)
# missing entries (implicitly).
#  modify it under the terms of the GNU General Public License as
    my ($a1, $a2) = @_;
    my %all_ann_files;
my %all_ind_CCs;
            my $ann_type = 
my $auto_annotate = 0;
my %call_CCs;
my %call_counter;
my $called_from_line;
my $called_funcs;
my $calling_funcs;
    my $cause_and_solution;
    my ($CC) = @_;
    my ($CC, $CC_col_widths) = @_;
    my ($CC_col_widths) = @_;
    my $CC_col_widths = [];
            my $CC_col_widths = compute_CC_col_widths(values %$src_file_CCs);
            my $CC = line_to_CC($_);
    my @CCs = @_;
    my @CC = (split /\s+/, $_[0]);
    my ($c, $d) = @_;
my %cfn_totals;
                my $clength = $length + int(($length - 1) / 3);
my $cmd = "";
        mycmp($fn_totals{$a}, $fn_totals{$b})
        my $cmp = $y <=> $x;        # reverse sort
        my $col_width   = $CC_col_widths->[$i];
my %compressed;
my $context = 8;
   my ($context, $name) = @_;
        my $count = (defined $CC->[$i] ? commify($CC->[$i]) : ".");
my $creator = "";
    my $curr_call_counter = 0;
    my $curr_cfile = "";
    my $curr_cfn_CC = [];
    my $curr_cfunc = "";
    my $curr_cname;
    my $curr_cobj = "";
    my $curr_file;
    my $curr_file_ind_CCs = {};     # hash(line_num => CC)
    my $curr_fn;
    my $curr_fn_CC = [];
    my $curr_line_num = 0;
    my $curr_name;
    my $curr_obj = "";
    my @curr_totals = ();
my $default_threshold = 99;
my $desc = "";
    my $did_annotations = 0;
	my $dline = $1;
        my $event       = $events[$i];
    my %events;
my @events;
my $events;
        my $event_width = length($event);
my $fancy = '-' x 80 . "\n";
        my $filename = $fn_name;
    my      $fn_CC_col_widths = compute_CC_col_widths(values %fn_totals);
        my $fn_CC = $fn_totals{$fn_name};
    my @fn_fullnames = keys   %fn_totals;
my %fn_totals;
        my $full_file_name = "";
		    my $func = $func_of_line{$src_file,$.};
my %func_of_line;
my $has_addr = 0;
my $has_line = 1;
                my $high = shift @pairs;
                my $inc = $2;
my @include_dirs = ("");
    my @include_dirs2 = @include_dirs;  # copy @include_dirs
    my $include_dir = shift(@include_dirs2);
my $inclusive = 0;
     my $index = $1;
my $input_file = "";
    my $is_on = ($auto_annotate ? "on" : "off");
    my $isZero = 1;
                my $length = length $CC->[$i];
    my $line;
            my @line_nums = sort {$a <=> $b} keys %$src_file_CCs;  
                my $low  = shift @pairs;
    my $n = 0;
            my $n = @line_nums;
    my $n = max(scalar @$a1, scalar @$a2);
my %obj_name;
        my $opened_file = "";
            my @pairs;
my $part = "";
        my $percent_printed_CC;
my $pid = "";
	my $positions = $1;
        my $pp_CC_col_widths = compute_CC_col_widths($percent_printed_CC);
    my $prev_line_num = 0;
    my $printed_totals_CC = [];
            my $prop = $curr_totals[$i] * 100;
    my $pwd = `pwd`;
        my $reached_all_thresholds = 1;
            my $readable = 0;
     my $realname = $2;
my @show_events;
my @show_order;
my $single_threshold  = $default_threshold;
my @sort_events;
my @sort_order;
        my $space = ' ' x ($CC_col_widths->[$i] - length($count));
        my $space       = ' ' x ($col_width - $event_width);
    my $src_file = $_[0];
            my $src_file_CCs = $all_ind_CCs{$src_file};
                my $src_line;
            my $src_more_recent_than_inputfile = 0;
    my ($src_more_recent_than_inputfile, $src_file, $excess_line_nums) = @_;
my $summary_CC;
    my $summary_CC_col_widths = compute_CC_col_widths($summary_CC);
    my $target = $cmd;
                        my $th = $1;
my $thread = "";
    my ($threshold_files) = @_; 
    my $threshold_files       = {};
my $threshold_files = print_summary_and_fn_totals();
my @thresholds;
                my $th_specified = 0;
	  my $tmp1 = $calling_funcs->{$fn_name};
	  my $tmp2 = $called_funcs->{$curr_name};
	  my $tmp2 = $called_funcs->{$fn_name};
	      my $tmp = $called_from_line->{$curr_file,$curr_line_num};
		    my $tmp  = $called_from_line->{$src_file,$.};
	  my $tmp = $calling_funcs->{$curr_cname};
                my $tmp = $curr_file_ind_CCs->{$curr_line_num};
                    my $tmp = <INPUTFILE>;
my $totals_CC;
my $tree_caller = 0;
my $tree_calling = 0;
            my $try_name = $include_dir . $src_file;
    my @unfound_auto_annotate_files;
my $usage = <<END
my %user_ann_files;
    my $user_ann_file = shift(@user_ann_files);
    my @user_ann_files = keys %user_ann_files;
    my ($val) = @_;
my $verbose = "1";
my $version = "3.7.0";
    my $warning = <<END
        my ($x, $y);
    my ($x, $y) = @_;
        $n++
	      next;
                next LOOP;
#     njn@valgrind.org
#    (not sure why higher;  maybe due to new '.' entries?)
#    [now add_array_a_to_b()]
# Number of lines to show around each annotated line.
            # Numeric, not lexicographic sort!
	    $obj_name{$curr_name} = $curr_obj;
#    off warnings to allow this.  This makes things about 10% faster than
                $opened_file    = $try_name;
    open(INPUTFILE, "< $input_file") || die "File $input_file not opened\n";
        # Option handling
  options for the user, with defaults in [ ], are:
# order in which we must traverse @events in order to show the @show_events, 
# Overview: the running example in the comments is for:
            $pairs[0] = 1 if ($pairs[0] < 1);
            # particular line (due to incomplete debug info).
            $percent_printed_CC->[$i] = 
# Performance improvements record, using cachegrind.out for cacheprof, doing no
# Positions used for cost lines; default: line numbers
	$prev_line_num = $curr_line_num;
            print("-- $ann_type-annotated source: $full_file_name\n");
    print("Auto-annotation:  $is_on\n");
                    print(" <bogus line $line_num>\n");
		print $call_counter{$calling,$fn_name} . "x)";
		print $call_counter{$fn_name,$called} . "x)";
			  print $call_counter{$func,$called,$.} . "x)\n";
			  print " => $called (";
		print" >   $called (";
	  # Print called functions
		print" < $calling (";
		print_CC($call_CCs{$calling,$fn_name}, $fn_CC_col_widths);
		print_CC($call_CCs{$fn_name,$called}, $fn_CC_col_widths);
			  print_CC($call_CCs{$func,$called,$.}, $CC_col_widths);
                        print_CC( [], $CC_col_widths);
        print_CC($fn_CC, $fn_CC_col_widths);
        print_CC($percent_printed_CC, $pp_CC_col_widths);
                print_CC($src_file_CCs->{0}, $CC_col_widths);
                        print_CC($src_file_CCs->{$.}, $CC_col_widths);
                    print_CC($src_file_CCs->{$line_num}, $CC_col_widths);
    print_CC($summary_CC, $summary_CC_col_widths);
                print(" <counts for unidentified lines in $src_file>\n\n");
    print($desc);
                                         $printed_totals_CC);
                        $printed_totals_CC->[$i] / $summary_CC->[$i] * 100);
            print_events($CC_col_widths);
    print_events($fn_CC_col_widths);
    print("Event sort order: @sort_events\n");
        print_events($pp_CC_col_widths);
    print("Events recorded:  @events\n");
    print("Events shown:     @show_events\n");
    print_events($summary_CC_col_widths);
            print("$fancy");
        print("$fancy");
        print($fancy);
    print($fancy);
    print(" file:function\n");
            print("  $f\n");
        print(" $fn_name");
	  # Print function callers
        # Print function results
    # Print functions, stopping when the threshold has been reached.
        print("                  $include_dir\n");
    print("Include dirs:     $include_dir\n");
                    print("-- line $high " . '-' x 40 . "\n");
                print("-- line $low " . '-' x 40 . "\n") if ($low != 1);
                # Print line number, unless EOF
                # Print line number, unless start of file
    # Print list of unfound auto-annotate selected files.
                print("\n");
            print("\n");
        print("\n");
    print "\n";
    print("\n");
		print "\n";
	print "\n";
            print("\n\n");
                print("  No information has been collected for $src_file\n\n");
		  print " [$obj_name{$called}]";
		  print " [$obj_name{$calling}]";
	  print " [$obj_name{$fn_name}]";
print_options();
# Print options used
# Print out the called functions
# Print out the callers of a function
# Print out the function totals sorted by these events, eg. (D,C).
        print(" percentage of events annotated\n\n");
    print "Profile data file '$input_file'";
    print("Profiled target:  $target\n");
    print(" PROGRAM TOTALS\n");
#	      print "Read ($curr_name => $curr_cname) $curr_call_counter\n";
      print "Reading data from '$input_file'...\n";
        print("$space$count ");
        print("$space$event ");
                    print(" $src_line");
# Prints summary and function totals (with separate column widths, so that
# Print summary and sorted function totals
            # Print summary of counts attributed to file but not to any
# Print the CC with each column's size dictated by $CC_col_widths.
        print("The following files chosen for auto-annotation could not be found:\n");
    print("Thresholds:       @thresholds\n");
        print("                  $user_ann_file\n");
    print("User annotated:   $user_ann_file\n");
    print($warning);
@@ Probable cause and solution:
process_cmd_line();
	      $prop = $prop / $summary_CC->[$sort_order[$i]];
#  published by the Free Software Foundation; either version 2 of the
        push(@$CC_col_widths, length($event));
        push(@curr_totals, 0);
                push(@include_dirs, "$inc/");
                push(@pairs, $line_nums[$i] - $context);   # lower marker
                push(@pairs, $line_nums[$i] + $context);   # upper marker
        push(@show_order, $events{$show_event});
        push(@sort_order, $events{$sort_event});
            push(@thresholds, 0);
                push(@unfound_auto_annotate_files, $src_file);
    $pwd .= '/';
            $reached_all_thresholds &&= ($prop >= $thresholds[$i]);
                    $readable = 1;
            $readable or die("File $arg not found in any of: @include_dirs\n");
    # Read body of input file.
    # Read "events:" line.  We make a temporary hash in which the Nth event's
    # Read header
# Reading of input file
read_input_file();
       $realname = $compressed{$context,$index};
            # remember everything -- we won't know until the end what's needed.
      # remove comments
# representing '.'.  This makes things fast (faster than using hashes for CCs)
    return 0;
    return \@CC;
    return $CC_col_widths;
            return $cmp;
    return $isZero;
   return $name;
     return $realname;
    return $threshold_files;
    return $val;
    return ($x > $y ? $x : $y);
      s/#.*$//;
    (scalar @sort_order == scalar @thresholds) or 
                s/^\+(\d+)/$prev_line_num+$1/e;
        s/^\-(\d+)/$prev_line_num-$1/e;
        s/^\+(\d+)/$prev_line_num+$1/e;
	        s/^\-(\d+)/$prev_line_num-$1/e;
    # separately).
            # Setup new one
    shift(@include_dirs2);       # remove "" entry, which is always the first
                        shift(@line_nums);
            shift(@line_nums) if (0 == $line_nums[0]);
            # Shift out 0 if it's in the line numbers (from unknown entries,
            # --show=A,B,C
    --show=A,B,C          only show figures for events A,B,C [all]
#   - --show=C,A,D
        @show_events = @events;
                @show_events = split(/,/, $1);
# --show options, which is a bit tricky.
#    (shrunk file by about 37%)
          # side effect needed: possibly add compression mapping
          # side effect needed: possibly add compression mapping 
                $single_threshold = $1;
@@ solution: none, sorry
@@ solution: Recompile program and rerun under "valgrind --cachesim=yes" to 
            # --sort=A,B,C
    --sort=A,B,C          sort columns by events A,B,C [event column order]
#   - --sort=D,C
        @sort_events = @events;
                        $sort_events[$i] =~ s/:.*//;
                @sort_events = split(/,/, $1);
    # Sort function names into order dictated by --sort option.
            "  @sort_order\n  @thresholds\n");
# source annotation (irrelevant ones removed):
                          source files
@ Source file '$src_file' is more recent than input file '$input_file'.
# specified).  We print out functions and do auto-annotations until we've
                s/^\*/$prev_line_num/e;
        s/^\*/$prev_line_num/e;
                sprintf("%.0f", 
                                  ? $src_file 
                                             $src_file, \@line_nums);
                $src_more_recent_than_inputfile = 1;
        s/#.*$//;   # remove comments
        # Stick filenames into a hash for quick 'n easy lookup throughout
        # Stop when we've reached all the thresholds
sub add_array_a_to_b ($$) 
sub annotate_ann_files($)
sub commify ($) {
sub compute_CC_col_widths (@) 
sub is_zero ($)
sub line_to_CC ($)
sub max ($$) 
sub mycmp ($$) 
sub print_CC ($$) 
sub print_events ($)
sub print_options ()
sub print_summary_and_fn_totals ()
sub process_cmd_line() 
sub read_input_file() 
sub uncompressed_name($$)
sub warning_on_nonexistent_lines ($$$)
sub warning_on_src_more_recent_than_inputfile ($)
            $summary_CC = line_to_CC($_);
	$summary_CC = $totals_CC;
	# suppress profile options in description output
      $target .= ")";
      $target .= " (PID $pid";
                        ($th >= 0 && $th <= 100) or die($usage);
                          that helped reach the event count threshold [no]
##--- The cache simulation framework: instrumentation, recording   ---##
#  The GNU General Public License is contained in the file COPYING.
    # the primary sort event, and 0% for the rest.
#  This file is based heavily on cg_annotate, part of Valgrind.
#  This file is part of Callgrind, a cache-simulator and call graph
#  This program is distributed in the hope that it will be useful, but
#  This program is free software; you can redistribute it and/or
    --threshold=<0--100>  percentage of counts (of primary sort event) we
    # threshold (either from --threshold if used, or the default otherwise) for
        $threshold_files->{$filename} = 1;
                    @thresholds = ();
        $thresholds[0] = $single_threshold;
                        $thresholds[$i] = 0;
                        $thresholds[$i] = $th;
# Thresholds, one for each sort event (or default to 1 if no sort events
            # --threshold=X (tolerates a trailing '%')
                        $th_specified = 1;
	  $$tmp2{$curr_cname} = 1;
	  $tmp2 = {} unless defined $tmp2;
	      $$tmp{$curr_cname} = 1;
	  $$tmp{$curr_name} = 1;
                $tmp = [] unless defined $tmp;
	      $tmp = {} unless defined $tmp;
	  $tmp = {} unless defined $tmp;
# Total counts for summary (an array reference).
	    $totals_CC = line_to_CC($_);
# Totals for each function, for overall summary.
#  tracer built on Valgrind.
    # Track if we did any annotations.
                $tree_caller  = 1 if ($1 eq "caller" || $1 eq "both");
                $tree_calling = 1 if ($1 eq "calling" || $1 eq "both");
            # --tree=none|caller|calling|both
    --tree=none|caller|   print for each function their callers,
          uncompressed_name("fl",$1);
          uncompressed_name("fn",$1);
#    unnecessarily.
    unshift(@include_dirs2, "") if (0 == @include_dirs2); 
    unshift(@user_ann_files, "") if (0 == @user_ann_files); 
        # Update the threshold counts
usage: callgrind_annotate [options] [callgrind-out-file [source-files...]]
# Usage message.
# Used in various places of output.
            $user_ann_files{$arg} = 1;
#                                                               user time
use strict;
#! /usr/bin/perl -w
    # value is N, which is useful for handling --show/--sort options below.
# Verbose mode
            # --version
# Version number
    --version             show version
    $^W = 0;
    $^W = 1;
                warning_on_nonexistent_lines($src_more_recent_than_inputfile,
                warning_on_src_more_recent_than_inputfile($src_file);
@@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@ WARNING @@
	warn("WARNING: header line $. malformed, ignoring\n");
            warn("WARNING: line $. malformed, ignoring\n");
        warn("WARNING: missing final summary line, no summary will be printed\n");
    # We suppress warnings about .h files
                while (($. < $high) && ($src_line = <INPUTFILE>)) {
                while ($i < $n-1 && 
    while (<INPUTFILE>) {
    while(<INPUTFILE>) {
                while ($. < $low-1) {
            while (@pairs) {
#  WITHOUT ANY WARRANTY; without even the implied warranty of
            # Work out the size of each column for printing
    # Work out the size of each column for printing (summary and functions
        $x = -1 unless defined $x;
        $x = $c->[$i];
        $y = -1 unless defined $y;
        $y = $d->[$i];
#  You should have received a copy of the GNU General Public License
