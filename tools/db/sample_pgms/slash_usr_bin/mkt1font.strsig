          );
         #
#-----------------------------------------------------------------------------#
###############
################
##################
#####################
######################
########################
#########################
###########################
###############################
	      [$1 . ($2 + $h) . " " . ($3 + $v) . $4]gme;
      $acc = "breve";
   $acc   = $def->{acc};
$accdepth = $chdp{macron};				# "depth" of macron
     \"accent\". A digraph consisting of, say, \"k\" and \"h\" will be
     accented characters, forcing mkt1font to define its own
$accents = "($subacc|$supacc|$underacc|underbar)";
$accheight = $chht{macron};				# height of macron
   $acc =~ s/^under//;
   $acdef = $1;
	    $acdef = "$begin\t$1 " . ($2 - $accdepth) . $3 . $end;
	    $acdef = "$begin\t" . ($1 - $accdepth) . $2 . $end;
	    $acdef = "$begin\t$1 " . (-$accdepth) . "rmoveto" . $end;
   $acdef = fixhints($nchar, $acc, $acdef, ($chwd{$char} + $kern), 0);
   $acdef = fixhints($nchar, $acc, $acdef, $h, 0);
      $acdef = fixhints($nchar, $acc, $acdef, $h, $underadp);
   $acdef = fixhints($nchar, $acc, $acdef, $h, $v);
   $acdef = fixhints($nchar, "underbar", $bdef, $h, 0);
      $acdef = join("\n", grep !/^\t.*[hv]stem$/, split(/\n/, $acdef)) . "\n";
   $acdef =~ s[^(\t-?\d+ )(-?\d+) (-?\d+)( 0 callsubr)$]
      $acdef = "\t$subrsnum 1 3 callothersubr\n\tpop\n\tcallsubr\n" . $acdef;
   $acname = $acc;
   # Adjustment for smaller, therefore lower, shrunken accent defs
     adjust the x and y coordinates of the dotaccent placed within a
	 $_ = <AFM>;
      $afmbanner =  "\nComment Based on $ofname; modified for $enc encoding";
      $afmbanner .= "\nComment by John Smiths's program mkt1font ";
      $afmbanner .= "\nComment Command line: $cmdline";
      $afmbanner .= "on $date";
      $afmbanner .= "(v. $version) " if $version;
      $afmhead = $_;
	 $afmhead .= $_;
      $afmhead =~ /^FontName (.*)$/m;
$afmhead =~ s/^(FontBBox -?\d+ )-?\d+ -?\d+ -?\d+$/$1$maxdp $maxrs $maxht/m;
      $afmhead =~ s/\n^Comment /$afmbanner$&/m;
      $afmhead =~ s/(\n^EncodingScheme ).*$/$1FontSpecific/m;
      $afmhead =~ s/(\n^FamilyName )(.*)$/$1$famname/m;
      $afmhead =~ s/(\n^FontName )(.*)$/$1$opt_n/m;
      $afmhead =~ s/(\n^FullName )(.*)$/$1$opt_n/m;
      $afmhead =~ s/\r//gm;				# Might be DOS file
$afmhead =~ s/^(StartCharMetrics )\d+$/$1$chmetricnum/m;
      $afmtail = $_;
	 $afmtail .= $_;
   $afmtail = $kstart . $knum . "\n" . $kdefs . $kend;
$afmtail =~ s/\nCC .*;$//gm;
$afmtail =~ s/\n(Start|End)Composites.*$//gm;
      $afmtail =~ s/[\r\cZ]//gm;			# Might be DOS file
#   along with this program; if not, write to the Free Software
     \"amacron breve\": requests for \"impossible\" characters are
        and $acc !~ /^$accents$/) {
	   and @foundit = grep / ; N $nchar ; /, @metrics_enc) {
        and !grep / ; N $acc ; /, @metrics_enc
        and $metrics_unenc !~ / ; N $acc ; /m
        and $metrics_unenc !~ / ; N $char ; /m) {
	      and $metrics_unenc =~ s/^C -1 ; WX \d+ ; N $nchar ; B .* ;( L .* ;)?\n//m) {
     A new character (such as \"amacron\" or \"kh\") may be freely
     \"A\") or consists of the word \".notdef\" (indicating that
     as \"amacron breve\" or \"kh underbar\"). There is no constraint
     as a request for a digraph formed from the \"character\" and the
  -a should refer to the AFM (Adobe Font Metrics) file for the input
   $astr .= "$chdp{$acc} $chrs{$char} $chht{$char} ;\n";
   $astr .= "$chls{$char} $chdp{$char} $chrs{$char} ";
   $astr = "C $num ; WX $chwd{$char} ; N $nchar ; B ";
   $astr = "C $num ; WX $chwd{$char} ; N $nchar ; B $chls{$char} ";
   $astr = "C $num ; WX " . $w . " ; N $nchar ; B $chls{$char} ";
   $astr .= (max($chht{$char}, $chht{$acc})) . " ;\n";
   $astr .= (min($chdp{$char}, $chdp{$acc})) . " $newrs ";
   $astr .= "$underbdp $chrs{$char} $chht{$char} ;\n";
   $astr .= "$v $chrs{$char} $chht{$char} ;\n";
   $astr .= "$v ;\n";
#   (at your option) any later version.
     available, as are \"under\" versions of all the normal
     a valid accent character, the program interprets the definition
   $bdef .= "$l hlineto\n\t$thk vlineto\n\tclosepath\n";
   $bdef = "\t$underbdp $thk hstem\n\t$v vmoveto\n\t-$thk vlineto\n\t";
	 ($begin, $line, $end) = ($`, $1, $');
     being.
   # Bloody Fontographer! We can't just say
  -b may optionally be specified to block the use of predefined
     breve to form the candrabindu accent.
# Build the characters
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
   # Calculate the current point reached at the end of the character
      $cb = $1;
      $cb = fixhints($nchar, "dotaccent", $cb, $h, $v);
     \"character\" names the character (e.g. \"comma\", \"eight\",
   $char  = $def->{char};
   $chdef = "";
	       $chdef .= $_;
	    $chdef = $_;
   $chdef = $1;
   ($chdef = $1) =~ s/-?\d+( hsbw\n)/$w$1/m;
      $chdef .= "$line\n";
      $chdefsnum = $1;
$chdefsnum = scalar(keys(%chstrings));
   @chdef = split(/\n/, $chdef);
	 $chdef =~ s/^(\t})($rend|$renp)$/$1 $2/m;
     $chdp{$char}, $chrs{$char}, $chht{$char}) = ($1, $2, $3, $4, $5, $6);
	       + $chls{$acc} * $shrink - ($v - $accdepth * $shrink) * $itadj);
$chmetricnum += grep /^C /, @metrics_enc;
$chmetricnum = split(/\n/, $metrics_unenc);
	    $chname = $1;
   ($chname) = /( ; N [a-zA-Z_][a-zA-Z0-9_.]* ; )/;
   ($chnum{$char}, $chwd{$char}, $chls{$char},
   $chstrings{$acc} =~ /^\/$acc {\n\t.+? .+?hsbw\n((.|\n)+?\t} $rend\n)/m;
   $chstrings{$char} =~ /^\/$char {\n(\t.+?hsbw\n(.|\n)*?)\tendchar\n\t} $rend\n/m;
         $chstrings{$chname} = $chdef;
      $chstrings{"dotaccent"} =~ /^\/dotaccent {\n\t.+? .+?hsbw\n((.|\n)+?\t} $rend\n)/m;
   $chstrings{$nchar} = $pstr;
$chstrings{$nchar} = $pstr;
$chstrings{uni0237} =~ /\A(.*?)(\t[-0-9 ]+?[rvh]moveto)(\n.+)(\n\t.*?(-?\d+) [rv]moveto)(.*?)(\n\tendchar.*?)\Z/ms;
$chstrings{uni0237} = $chstrings{j} . "\n";
   $chstrings{uni0237} = $one . $j1end . $four . $six . $seven
$chstrings{uni0237} =~s/\A\/j /\/uni0237 /m;
close AFM;
close DEF;
close DIS;
close OUTAFM;
close OUTDIS;
close PFB;
  -c may optionally give two comma-separated numerical values to
$cmdline = basename($0) . " " . join " ", @ARGV;
     consecutively, but the digraph \"kh\" can itself receive accents
#   Copyright (C) 1997 John D. Smith
	 # "correct" t1disasm output so t1asm will accept it as input
	 #"correct" t1disasm output so t1asm will accept it as input
# Create uni0237 (dotlessj)
   # creating new subroutines as necessary.
$date = "$months[$lt[4]] $lt[3], ${ \($lt[5] + 1900) }";
      $def = {};
      $def->{acc}   = $acc;
      $def->{char}  = $char;
     deferred until their constituents have had a chance to come into
     definition of \"a macron\" does not have to precede that of
   # definition. Place the horizontal offset in $hend{$char}, the
     definition they have in the input font.
      $def->{nchar} = $char . $acc;
      $def->{num}   = $num;
      $def->{qdef}  = $_;
   $def  = shift @defs;
	    delete $chstrings{$nchar2};
$description =
	    digraph($num, $char, $acc, $nchar);
	       $_ = <DIS>;
	    $_ = <DIS>;
$disbanner  = "% Based on $ofname; modified for $enc encoding\n";
$disbanner .= "% by John Smiths's program mkt1font ";
$disbanner .= "% Command line: $cmdline";
$disbanner .= "on $date\n";
$disbanner .= "(v. $version) " if $version;
$disfile1 = "mkt1font$$.dis";
$disfile2 = "$opt_n.dis";
	    $distail .= $_;
	 $distail = $_;
      do {
	    do {
	   && do {
      # do *not* use "$" to anchor the end of this line, because
   # Dropped accents
  -d should refer to a font definition file. This file (which could
# Eliminate composite character definitions
      else {
   else {
	 else {
   else { $acdef = fixhints($nchar, $acc, $acdef, $h, $underddp) }
      else { $acdef =~ s/\A/\t-$accdepth vmoveto\n/m }
   else { die "Bad definition: $_\n" }
      else { die "Bad definition (no such accent): $qdef\n" }
   else { die "Bad definition (no such character/accent): $char\n" }
      else { die "Bad definition (no such character): $qdef\n" }
   else { $it = 0 }
      else { $line =~ s/-?\d+/int($& * $shrink)/ge unless $line =~ /^dup / }
   else { $n1 = $num }
   else  { print OUTDIS }
   else { return $n2 }
   else { $v = $underddp + $chdp{$acc} }
   else { $V = $v - $chdp{$acc} - $vend{$char} }
      elsif (!($acc and $opt_b)
	 elsif ($acc =~ /^$supacc$/) {
	 elsif ($acc =~ /^$underacc$/) {
	 elsif ($acc =~ /^underbar$/) {
      elsif (!$acc) { warn "No such character - ignoring definition: $qdef\n" }
   elsif ($acdef =~ s/\A(?:\t(\d+) callsubr\n)((?:.|\n)*)\Z/$2/m) {
   elsif (/(^C -1 ; WX \d+ ; N ([a-zA-Z_][a-zA-Z0-9_.]*|\.notdef) ; B .* ;( L .* ;)?)\r?$/) {
   elsif ($chht{$char} > 1.15 * $xheight) {
	 elsif ($line =~ /\t(-?\d+) hmoveto$/) {
	 elsif ($line =~ /^\t(-?\d+)( vmoveto)$/) {
     empty); and \"accent\" optionally names an accent to be placed
($enc = basename($opt_d)) =~ s/\..*$//;
   # Encoded chars
     encoding and may be expressed in decimal, octal or hex;
	 $encoding .= "dup $i /$1 put\n";
$encoding = "/Encoding 256 array\n0 1 255 {1 index exch /.notdef put} for\n";
$encoding .= "readonly def\n";
# End of main program
   exit 1;
($famname = $opt_n) =~ s/^(.*)-.*?$/$1/;
file, as well as a DIS file containing a disassembled version of the
# File header
      # File tail
	      findend($char, $subrs[$1]);
   findend("j1", ($two . $three));
   # First adjust any Flex "0 callsubr" lines for horizontal and
# First build a list of definitions supplied by user
   # First deal with .notdef
         # First get rid of predefined afm entries and synonyms
	    fixkerns($char, $acc);
	 fixkerns($char, $acc);
     font.
for (@deflines) {
   foreach $line (@chdef) {
   foreach $line (split /\n/, $def) {
foreach (@metrics_enc) {			# Avoid duplicate entries
foreach (sort values %chstrings) { print OUTDIS }
foreach $subrdef (@subrs) { print OUTDIS $subrdef }
for $i (0 .. 255) {
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   $foundit =~ /^C (-?\d+) ; WX (\d+) ; N $char ; B (.+?) (.+?) (.+?) (.+?) ;/;
	 ($foundit = $&) =~ s/^C -1/C $num$1/m;
	 ($foundit = shift @foundit) =~ s/^C (\d+)/C $num/;
     found useful.
  -f should refer to the binary font file (PFB) for the input font.
   # Generalise the kerning info contained in the afm file by applying
   getcharinfo($acc) unless defined $chwd{$acc};
   getcharinfo($char) unless defined $chwd{$char};
      getcharinfo("dotaccent") unless defined $chwd{dotaccent};
getcharinfo("dotlessi");
getcharinfo("j");
getcharinfo("macron");
getopts('n:d:a:f:c:s:bh');
   # giving up.
#   GNU General Public License for more details.
      $h += $cbx;
   $H = $chwd{$char} + $chls{$acc} + $kern - $hend{$char};
	      $hend{$char} = $1;
	      $hend{$char} += $1;
	      $hend{$char} += ($1 + $2);
	      $hend{$char} += ($1 + $3 + $5);
	      $hend{$char} += ($2 + $4);
     Here \"number\" represents the character's position in the new
Hetherington's programs t1asm and t1disasm, which must be present on
   $H = $h - $hend{$char} - $chls{$char};
      $H = $h - $hend{$newchar} - $chls{$char};
   $h = round(0.1 * $chwd{$char} - $underbdp * $itadj);
   $h = round(($chwd{$char} - $chwd{$acc}) / 2 + $chls{$acc});
   $h = round(($chwd{$char} - $chwd{$acc}) / 2 + $chls{$acc} - $it);
      $h = round(($chwd{$char} - $chwd{$acc}) / 2 + $chls{$acc} - $v * $itadj);
      $h = round(($chwd{$char} - ($chwd{$acc} * $shrink)) / 2
      $h = round(($chwd{$char} - $chwd{dotaccent}) / 2 + $chls{dotaccent} - $it);
   if (/^2 index \/CharStrings (\d+) dict dup begin/) {
   if ($acc
   if ($acc =~ /^$accents$/) { $lchar = $rchar = $char }
      if (!($acc and $opt_b)
   if ($acc eq "candrabindu") {
   if ($acc eq "candrabindu") { die "Bad definition (no such accent): $qdef\n" }
   if ($acc eq "dot") { $acc = "period" }
	 if ($acc eq "overdot") {
   if ($acc eq "overdot") { $acc = "dotaccent" }
	 if ($acc =~ /^$subacc$/) {
   if ($acc =~ /^$supacc$/) {
   if ($acc =~ /^$supacc$/ and $opt_s) { $acdef = fixshrink($acc, $acdef) }
   #   if ($acc =~ /^$supacc$/) { $V -= $accdepth }
   if ($acc =~ /^$supacc$/) { $V = $underadp - $vend{$char} }
      if ($acdef =~ /^(.*moveto)$/m) {
      if ($afmhead =~ /\n^CapHeight (.*)$/m)          { $capheight = $1 }
      if ($afmhead =~ /\n^FontBBox -?\d+ (-?\d+) (-?\d+) (-?\d+)$/m) {
      if ($afmhead =~ /\n^ItalicAngle (.*)$/m)        { $italangle = $1 }
      if ($afmhead =~ /\n^XHeight (.*)$/m)            { $xheight = $1 }
if ($afmtail =~ /(\A(?:.|\n)*^StartKernPairs )\d+\n((?:.|\n)*)(^EndKernPairs(?:.|\n)*\Z)/m) {
	 if (/^\/([a-zA-Z_][a-zA-Z0-9_.]*|\.notdef|\.null) {$/) {
   if ($cb) {						# candrabindu
   if (/(^C (\d+) ; WX \d+ ; N ([a-zA-Z_][a-zA-Z0-9_.]*|\.notdef) ; B .* ;( L .* ;)?)\r?$/) {
   if ($char =~ /^[a-z]/ and $acc =~ /^$supacc$/) {
   if ($char eq "i") { $char = "dotlessi" }
   if ($char eq "j") { $char = "uni0237" }
      if ($char =~ /$supacc$/ and $char !~ /under$supacc$/) {
   if ($chht{$char} >= $accheight + $v2) {		# double accs
      if (/^dup (\d+) {$/) {
   if (/^\/Encoding /) {
      if (/^end/) {
   if (/^EndCharMetrics\r?$/) {
if ($five > 0) { $chstrings{uni0237} = $one . $two . $three . $seven }
      if (grep /^$acc$/, @nchars) {
      if (grep /^$char$/, @nchars) {
   if (!grep / ; N $char ; /, @metrics_enc
      # If it can't be built from sub-elements, issue a warning and move on
if ($kdefs) {
      if ($kdefs =~ /^(KPX (?:[a-eg-pr-z][a-zA-Z]*|q(?!uote).*?) $char)( -?\d+)$/m) {
      if ($kdefs =~ /^(KPX [a-zA-Z]+ )$char( -?\d+)$/m) {
   if ($kdefs =~ /^KPX $char $acc (-?\d+)$/m) { $kern = $1 };
      if ($kdefs =~ /^(KPX $char)(( (?:[a-pr-z][a-zA-Z]*|q(?!uote).*?) )-?\d+)$/m) {
      if ($kdefs =~ /^(KPX )$rchar(( [a-zA-Z]+ )-?\d+)$/m) {
   if ($line) {
      if ($line =~ /^C \d+ ; WX \d+ ; N ([a-zA-Z_][a-zA-Z0-9_.]*) ; /) {
      if ($line =~ /^\t(\d+) .*call(other)?subr$/) {
	 if ($line =~ /^\t(-?\d+) (-?\d+)( rmoveto)$/) {
   if ($metrics_all =~ /^.* ; N $char ; .*$/m) { $foundit = $& }
   if (($n1 - $n2) >= 0.5) { $n2++ }
   if ($nchar eq ".notdef") {
   if ($newrs > $maxrs) { $maxrs = $newrs }
   if (/^\/(.*?) ?{ ?noaccess def ?} ?executeonly def$/) {
   if (/^\/(.*?) ?{ ?noaccess put ?} ?executeonly def$/) {
   if ($num < 0) { $n1 = (0 - $num) }
   if ($num < 0) { return (0 - $n2) }
      if ($num > 255) { die "Bad definition (number out of range): $_\n" }
	 if ($old) {
if ($opt_c) { ($cbx, $cby) = $opt_c =~ /^(.*),(.*)$/ }	# candrabindu
if  ($opt_h or !($opt_n && $opt_d && $opt_a && $opt_f) or ($#ARGV >= 0)) {
if ($opt_n =~ /Bold/) { $thk = 72 } else { $thk = 52 }	# thickness and
if ($opt_n =~ /\s/) { die "Font name cannot contain whitespace\n" }
if ($opt_s) { $shrink = $opt_s / 1000 } else { $shrink = 1 }
   if (/^\s*(\d+|0[0-7]+|0x[0-9a-fA-F]+)\s+([a-zA-Z_][a-zA-Z0-9_.]*?|\.notdef)(?:\s+([a-zA-Z_][a-zA-Z0-9_.]*))?$/) {
   if (/^StartFontMetrics/) {
   if ($subrdef) {
   if ($subrdef = join("\n", grep /^\t.*[hv]stem$/, split(/\n/, $acdef))) {
   if (/^\/Subrs (\d+) array/) {
   if (/(\/Subrs )\d+( array)$/) {
     If the character named in the \"accent\" position is not in fact
   if ($v < $maxdp) { $maxdp = $v }
   if ($v > $maxht) { $maxht = $v }
   # If we can't handle $char/$acc yet, but believe we will be able
   # I have had to use to build TrueType and Macintosh versions of fonts)
   # implement (e.g.) underring by diving down low and then printing a
     in cases where a font designer does not share mkt1font's views
     indistinguishable from the letters \"k\" and \"h\" printed
     (In fact the equivalent ASCII file (PFA) is also acceptable for
     in PostScript fonts, \"underbar\" and \"underdot\" are also
     input, but the output font is always in PFB format.)
(\"input fonts\"). In order to do this it makes use of I. Lee
   # Instead we have to go through the following rigmarole:
     (introduced by \"\#\").
     is formed by overprinting a breve with a dotaccent. Finally,
$itadj  = sin($italangle * 3.14159 / 180) / cos($italangle * 3.14159 / 180);
# Italic adjustment: tan(angle)
   # it has imported: it sets the depth to the lowest point in the path,
   # it later turns out we were wrong, allow only five loops before
      # it may end with an invisible trailing space!
   # it to new accented chars. Do not kern lower-case chars bearing
#   it under the terms of the GNU General Public License as published by
	 $it = $v1 * $itadj;
      $it = ($v1 + $v2) * $itadj;
	 $it = $v2 * $itadj;
   $j1end = "\t$hend{j1} $vend{j1} rmoveto";
   $kdefs = join("\n", sort split /\n/, $kdefs);	# sort
   $kdefs .= "\n";
	 $kdefs =~ s[^(KPX (?:[a-eg-pr-z][a-zA-Z]*|q(?!uote).*?) $char)( -?\d+)$]
	 $kdefs =~ s[^(KPX [a-zA-Z]+ )$char( -?\d+)$]
	 $kdefs =~ s[^(KPX $char)(( (?:[a-pr-z][a-zA-Z]*|q(?!uote).*?) )-?\d+)$]
   $kdefs =~ s/((^KPX .*?)-?\d+$)\n\2.*$/$1/gm;		# remove duplicates
	 $kdefs =~ s[^(KPX )$rchar(( [a-zA-Z]+ )-?\d+)$]
	    $kdefs =~ s/\nKPX .*$nchar2 .*$//gm;
         $kdefs =~ s/\nKPX .*$nchar .*$//gm;
   $kdefs =~ s/^\s*\n//gm;				# and blank lines
   # Kerns etc.
   $knum = split(/\n/, $kdefs);
   ($kstart, $kdefs, $kend) = ($1, $2, $3);
      last;
	      last SWITCH;
      $lchar = $char;
      $l = $_ = <DIS>;
	 $l = $_ = <DIS>;
     like any other character: see next paragraph.
     like \"Utopia_French-BoldItalic\". The generated font files
   $line = $metrics_enc[$i];
     lines of character definitions, in the form
	 $line =~ s/^\t$snum/\t$subrsnum/;
	 $line =~ /^\t(\d+) callsubr$/
	 $line =~ /^\t-?\d+ (-?\d+) (-?\d+) 0 callsubr$/		# Flex
	 $line =~ /^\t(-?\d+) (-?\d+) (-?\d+) (-?\d+) (-?\d+) (-?\d+) rrcurveto$/
	 $line =~ /^\t(-?\d+) (-?\d+) (-?\d+) (-?\d+) hvcurveto$/
	 $line =~ /^\t(-?\d+) (-?\d+) (-?\d+) (-?\d+) vhcurveto$/
	 $line =~ /^\t(-?\d+) (-?\d+) r(line|move)to$/
	 $line =~ /^\t(-?\d+) h(line|move)to$/
	 $line =~ /^\t(-?\d+) v(line|move)to$/
   # Locate crucial definitions
   $l = round(0.8 * $chwd{$char});
@lt = localtime;
   # Make a new character consisting of two existing characters
	 ($maxdp, $maxrs, $maxht) = ($1, $2, $3);
            "May",       "June",     "July",     "August",
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      $metrics_enc[$2] = "$1\n";
   $metrics_enc[$num] = $astr;
	    $metrics_enc[$num] = $foundit;
	 $metrics_enc[$num] = $foundit;
      $metrics_unenc .= "$1\n";
$metrics_unenc .= "C -1 ; WX $chwd{j} ; N uni0237 ; B $chls{j} $chdp{j} $chrs{j} $chht{dotlessi} ;\n";
      $metrics_unenc .= $old unless $metrics_unenc =~ /$old/m;
   $metrics_unenc .= $old unless $metrics_unenc =~ /$old/m;
	    $metrics_unenc .= $old unless $metrics_unenc =~ /$old/m;
   $metrics_unenc =~ s/^C -1 .*$chname.*\n//gm if $chname;
	    $metrics_unenc =~ s/^C -1 ; WX \d+ ; N $nchar2 ; B .* ;( L .* ;)?\n//m;
	 $metrics_unenc =~ s/^C -1 ; WX \d+ ; N $nchar ; B .* ;( L .* ;)?\n//m;
#   Mkt1font: a program to generate accented Type 1 PostScript fonts
Mkt1font creates new Type 1 PostScript fonts based on existing fonts
@months = ( "January",   "February", "March",    "April",
   # Multiply all coordinates in a character definition by $shrink,
   my ($a, $b) = @_;
   my ($char, $acc) = @_;
   my ($char, $def) = @_;
   my $char = shift;
   my ($ch, $chdef) = @_;
   my (@chdef, $line, $snum, $subrdef);
   my $foundit;
   my ($lchar, $rchar);
   my $line;
   my $metrics_all = join("", @metrics_enc) . $metrics_unenc;
   my $n1, $n2;
   my ($nchar, $acc, $acdef, $h, $v) = @_;
   my ($num, $char, $acc, $nchar) = @_;
   my ($num, $char, $nchar) = @_;
   my ($num) = shift;
   my ($old, $acname, $astr, $h, $v, $H, $V, $chdef, $acdef, $begin, $line, $end, $pstr);
   my ($old, $astr, $h, $H, $V, $chdef, $acdef, $pstr);
   my ($old, $astr, $l, $h, $v, $H, $V, $bdef, $chdef, $acdef, $pstr);
   my ($old, $cb, $astr, $h, $v, $H, $V, $it, $chdef, $acdef, $pstr, $newchar);
   my ($old, $kern, $w, $newrs, $astr, $H, $V, $chdef, $acdef, $pstr);
   my $subrdef;
	            [$&\n$1$acc$2]gm
	            [$&\n$1$char$acc$2]gm
	   [$&\n$1$char$acc$2]gm
   $n2 = int($n1);
	    $nchar2 = $char . "dotaccent";
   $nchar = $def->{nchar};
      $nd = $1;
      $newchar = $char . $acc;
   $newrs = $chrs{$char} + $chwd{$acc} + $kern;
      next;
	    next;
   next if (/^\s*$/ || /^\#/);
   next if (/\/UniqueID .*$/);
      # Next look among existing unencoded chars (unless blocked by -b)
      # Now build the char
   # Now look for new char among existing encoded chars (unless blocked by -b)
      $np = $1;
  -n should name the font it is intended to generate. Avoid names
               \"number\"   \"character\"
               \"number\"   \"character\"   \"accent\"
      ($num, $char, $acc)  = ($1, $2, $3);
   $num   = $def->{num};
      $num = oct $num if $num =~ /^0/;
      $ofname = $1;
	 $old = $metrics_enc[$num];
      ($old = $metrics_enc[$num]) =~ s/^C $num/C -1/;
   ($old = $metrics_enc[$num]) =~ s/^C $num/C -1/;
	    ($old = $metrics_enc[$num]) =~ s/^C $num/C -1/;
	    $old =~ s/^C $num/C -1/;
	 $one = $1;
	 ($one, $three) = ($1, $3);
($one, $two, $three, $four, $five, $six, $seven) = ($1, $2, $3, $4, $5, $6, $7);
     on the character. In addition to the standard accents available
on the command line, as follows:
     on the ordering of definitions within a definition file. The
     on where accents should be placed.
open AFM, $opt_a or die "Cannot open $opt_a: $!\n";
open DEF, $opt_d or die "Cannot open $opt_d: $!\n";
open DIS, $disfile1;
open DIS, $disfile1 or die "Cannot open disassembled font file: $!\n";
open OUTAFM, ">$opt_n.afm";
open OUTDIS, ">$disfile2";
open PFB, $opt_f or die "Cannot open $opt_f: $!\n";
     \"overdot\" may be used as a synonym for \"dotaccent\".
# Packages and constants
$_ = <PFB>;
PFB file (including useful comments). Four options must be specified
   # place them in a numbered subroutine. Have the definition call
	 $prevnum = $1;
print OUTAFM $afmhead;
print OUTAFM $afmtail;
      print OUTAFM $line;
print OUTAFM $metrics_unenc;
      print OUTDIS "$1$subrsnum$2\n";
print OUTDIS $distail;
      print OUTDIS $encoding;
print OUTDIS "$nd\n2 index /CharStrings $chdefsnum dict dup begin\n";
   print STDERR $description;
   $pstr = "/$nchar {\n$chdef      % $nchar: start of $acc\n";
   $pstr = "/$nchar {\n$chdef      % $nchar: start of $acname\n";
      $pstr .= "      % $nchar: start of dotaccent\n\t$H $V rmoveto\n$cb";
      $pstr =~ s/\tendchar\n\t} $rend\n\Z//m;
   $pstr .= "\t$H $V rmoveto\n$acdef";
   $pstr .= "\t$H $V rmoveto\n$acdef\tendchar\n\t} $nd\n";
   push @deflines, $_;
      push @defs,   $def;
	    push @defs, $def;
      push @nchars, $def->{nchar};
   $qdef  = $def->{qdef};
      $rchar = $acc;
# Read AFM file
# Read and disassemble PFB file
# Read DEF file
   # remove them, adjust for horizontal and vertical offset, and
      ($rend = $nd) =~ s/\|/\\|/g;			# Regexp version
      ($renp = $np) =~ s/\|/\\|/g;			# Regexp version
   return $a > $b ? $a : $b;
   return $a > $b ? $b : $a;
   return $acdef;
   return $chdef;
   # Return greater of two values
   # Return lesser of two values
   # Return nearest integer value
   # ring at its normal height.
     ring) should be shrunk when they are used as subscript accents
   s/^(%!.*: ).*$/$1$opt_n\n$disbanner/;
   s /(\/BlueValues \[.*)(\] def)$/$1 $accheight $accheight$2/;
   # seems not to respect the depths for characters specified in afm files
	    "September", "October",  "November", "December"
# Set up constants
   s/(\/FamilyName \().*(\).*)$/$1$famname$2/;
   s/(\/FontBBox {-?\d+ )-?\d+ -?\d+ -?\d+/$1$maxdp $maxrs $maxht/m;
   s/(\/FontName \/).*?( .*)$/$1$opt_n$2/;
   s/(\/FullName \().*(\).*)$/$1$opt_n$2/;
     \"Slots\" for which no new definition is given retain the
  -s may optionally give the factor, expressed as a per-thousand
	 $snum = $1;
   s/\s*(\#.*)?$//;
           [-s shrink-factor] [-c candrabindu-adjustment] [-b]
	 # Store character definitions in %chstrings
   # Store character metric information
      # Store subroutine definitions in @subrs
$subacc = "(cedilla|ogonek|commaaccent)";
	    subacc($num, $char, $acc, $nchar);
sub digraph {
sub findend {
sub fixhints {
sub fixkerns {
sub fixshrink {
sub getcharinfo {
sub max {
sub min {
	       $subrdef .= $_;
	 $subrdef = $_;
	 $subrdef = fixshrink($ch, $subrdef);
      $subrdef = join("\n", grep /^\t.*[hv]stem$/, split(/\n/, $subrdef))
	 $subrdef =~ s/^(dup )$snum \{$/$1$subrsnum {\n      % $nchar: shrink $ch/m;
   $subrdef =~ s/^(\t)(-?\d+)( .*hstem)$/$1 . ($2 + $v) . $3/gme;
   $subrdef =~ s/^(\t)(-?\d+)( .*vstem)$/$1 . ($2 + $h) . $3/gme;
	 $subrdef =~ s/^(\t})($rend|$renp)$/$1 $2/m;
      $subrdef = $subrs[$1];
	 $subrdef = $subrs[$snum];
	 $subrnum = $1;
sub round {
      $subrsnum++;
	 $subrsnum++;
      $subrsnum = $1;
         $subrs[$subrnum] = $subrdef;
      $subrs[$subrsnum] = "dup $subrsnum {\n      % $nchar: hints for $acc\n";
	 $subrs[$subrsnum] = $subrdef;
      $subrs[$subrsnum] .= "$subrdef\n\treturn\n\t} $np\n";
   # Subscript accents
sub subacc {
sub supacc {
sub underacc {
sub underb {
     such as \"myfont\", as both mkt1font and other programs attempt
     (such as underdieresis, underring). Values of around 800 may be
$supacc = "(grave|acute|circumflex|tilde|macron|breve|dotaccent|overdot|dieresis|ring|hungarumlaut|caron|candrabindu)";
	    supacc($num, $char, $acc, $nchar);
   # Superscript accents
     superscript accents (\"underdieresis\", \"underring\", etc.).
   # superscript accents with capitals, quotes or a preceding "f".
      SWITCH: {
"Syntax: mkt1font -n fontname -d definition-file -a afm-file -f font-file
system "t1asm -b $disfile2 >$opt_n.pfb 2>/dev/null";
system "t1disasm $opt_f >$disfile1 2>/dev/null";
     The definition file may also contain blank lines and comments
   # The Fontographer hack below is necessary because Fontographer (which
#   the Free Software Foundation; either version 2 of the License, or
The -h option prints this help.
     The Indian accent \"candrabindu\" may also be specified: it
     the specified number's \"slot\" in the new encoding is to be
   # the subroutine.
the system. A successful run will generate an AFM file and a PFB
#   This program is distributed in the hope that it will be useful,
#   This program is free software; you can redistribute it and/or modify
# Tidy up kerns
     to draw conclusions from the name; better would be something
   # to later, send the definition to the back of the queue. In case
      undef $metrics_enc[$num];
	    underacc($num, $char, $acc, $nchar);
$underacc = "(underdot|under$supacc)";
$underadp = -230;				# depth of "under" accs
   # Underbar
$underbdp = -(82 + $thk);				# depth of underbar
	    underb($num, $char, $nchar);
$underddp = -213;				# depth of underdot
   # Unencoded chars
unless ($chdefsnum) { die "Cannot find size of CharStrings dict\n" }
   unless (defined $hend{$char}) { findend($char, $chstrings{$char}) }
      unless (defined $hend{$newchar}) { findend($newchar, $pstr) }
	 unless (++$def->{requeue} > 5) {
unless (/%!/) { die "File $opt_f is not a PostScript font\n" }
	   unless $kdefs =~ /^$one$acc /m;
	   unless $kdefs =~ /^$one$acc$three/m;
	   unless $kdefs =~ /^$one$char$acc /m;
	   unless $kdefs =~ /^$one$char$acc$three/m;
unless ($nd) { die "Cannot find \"noaccess def\" definition\n" }
unless ($np) { die "Cannot find \"noaccess put\" definition\n" }
	 unless ($prevnum == $num) {
unless ($subrsnum) { die "Cannot find size of Subrs array\n" }
unlink $disfile1;
      until eof(AFM);
	 until eof(DIS);
      until ($l !~ /^\/([a-zA-Z_][a-zA-Z0-9_.]*|\.notdef|\.null) {$/);
      until ($l !~ /^dup \d+ {$/);
      until $_ =~ /^StartCharMetrics \d+\r?$/;
	    until /^\t} ?$rend$/;
	    until /^\t} ?$renp$/;
     used in the \"character\" position of a further definition (such
use File::Basename;
     usefully be named, e.g., \"French.def\") should consist of
use Getopt::Std;
#!/usr/bin/perl
$v1 = $accheight - $xheight;		# vertical offset for double accents
$v2 = $capheight - $xheight;		# vertical offset for accented caps etc
     value, by which normally superscript accents (such as dieresis,
      $v += $cby;
   $v = $chht{$acc};
   $v -= $chht{$acc};
	      $vend{$char} += $1;
	      $vend{$char} += ($1 + $3);
	      $vend{$char} = $2;
	      $vend{$char} += $2;
	      $vend{$char} += ($2 + $4 + $6);
	      $vend{$char} += ($3 + $4);
$version = 0.25;
     versions. This may be useful to secure a consistent appearance
   # vertical offset in $vend{$char}.
   # vertical offset. Then collect the hints from the accent definition,
      $V += round($chdp{$acc} * (1 - $shrink) / $shrink);
      $v = round($underadp + ($chdp{$acc} - $accdepth) * $shrink);
   $v = $underbdp + $thk;
	 $v += $v1;					# double accents
      $v += ($v1 + $v2);				# on caps etc.
	 $v += $v2;					# accented caps etc.
   $V = -$vend{$char};
   $V = $v - $vend{$char};
      $V = $v - $vend{$newchar};
   $w = $chwd{$char} + $chwd{$acc} + $kern;
   # whether or not a mark was made there. So it is not possible to
while (<AFM>) {
while (<DEF>) {
while (@defs) {
while (<DIS>) {
while (<DIS>) {							# get header
     will also use this for their basename.
# Work through the list
# Write AFM file
# Write DIS and PFB files
#   You should have received a copy of the GNU General Public License
