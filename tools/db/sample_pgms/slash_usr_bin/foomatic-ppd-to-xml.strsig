$0 =~ m!/([^/]+)\s*$!;
	($addonlyrequesteddrivers ? ('addonlyrequesteddrivers' => 1) : ()),
			       '<autodetect>[\s\n\r]*<general>.*<\/general>');
	($basedir ? ('basedir' => $basedir) : ()),
                  base directory is given, the link set via the -l option 
	$basedir =~ s:/+$::;
 -b <directory> : Base directory for a relative link to the PPD. If the
 -c <comment>   : Add the given comment to the comment field of the XML
	    close FILE;
	close FILE;
		     "CMD:" . $db->{'dat'}{'general_cmd'} . ";" : "");
    $commentadded = 1;
	($comment && !$commentadded ? ('comment' => $comment) : ()),
 -C             : Suppress any default comments (max paper width, pages
                  current directory). With a base directory given the 
 -D             : Add only the driver requested by "-d" and "-r" to the
                  "-d" argument as the recommended driver (or the one to which
		  database.
	$db->{'dat'}{'comment'} =
	    $db->{'dat'}{'comment'} if !$parameters->{'nodefaultcomment'};
	#$db->{'dat'}{'comment'} .= "\n      <p>\n\n" . $dat->{'comment'};
	$db->{'dat'} = $d;
	$db->{'dat'} = $dat;
	$db->{'dat'}{'functionality'} = "A";
		    ($db->{'dat'}{'general_cmd'} ?
	$db->{'dat'}{'general_cmd'} = $dat->{'general_cmd'} if
	$db->{'dat'}{'general_des'} = $dat->{'general_des'} if
	$db->{'dat'}{'general_ieee'} = $dat->{'general_ieee'} if
		$db->{'dat'}{'general_ieee'} = "MFG:" .
	$db->{'dat'}{'general_mdl'} = $dat->{'general_mdl'} if
		$db->{'dat'}{'general_mdl'} = $product;
		    !$db->{'dat'}{'general_mfg'};
		    $db->{'dat'}{'general_mfg'} .
	$db->{'dat'}{'general_mfg'} = $dat->{'general_mfg'} if
		$db->{'dat'}{'general_mfg'} = $db->{'dat'}{'ppdmanufacturer'} if
	    $db->{'dat'}{'id'} =
		$db->{'dat'}{'id'} . ".xml";
	    $db->{'dat'}{'id'} . ".xml" or
	    $db->{'dat'}{'model'} =
					  $db->{'dat'}{'model'});
	    $db->{'dat'}{'model'} =~ s/^$db->{'dat'}{'make'}\s*//i;
		    $db->{'dat'}{'ppdmanufacturer'} &&
 -d <drivers>   : Comma-separated list of drivers with which the printer
	    defined($dat->{'general_cmd'}) &&
	    defined($dat->{'general_des'}) &&
	    defined($dat->{'general_ieee'}) && 
	    defined($dat->{'general_mdl'}) &&
	    defined($dat->{'general_mfg'}) &&
	    !defined($db->{'dat'}{'general_cmd'});
	    !defined($db->{'dat'}{'general_des'});
	    !defined($db->{'dat'}{'general_ieee'});
	    !defined($db->{'dat'}{'general_mdl'});
	    !defined($db->{'dat'}{'general_mfg'});
	delete($db->{'dat'});
    $dest =~ s/$regexp/$totransfer/s if $totransfer;
	    die "Cannot write file $db->{'dat'}{'id'}.xml!\n";
		die "Cannot write file $db->{'dat'}{'id'}.xml!\n";
		die ("Given PPD file not found, neither as $ppddlpath nor as $ppdfile!\n");
	    die ("Given PPD file $ppdfile not found!\n");
	    die ("PPD base directory $basedir does not exist!\n");
 <driver>       : Driver to which the PPD file should get assigned. This
                  driver list in the XML file, do not add drivers based on
			       '<driver>\S*<\/driver>');
			       '<drivers>.*<\/drivers>');
	(@driverslist ? ('drivers' => [@driverslist]) : ()),
			       '<\/drivers>[\s\n\r]*<comments>.*<\/comments>[\s\n\r]*<\/printer>');
                  driver than the driver from the PPD/the first one from the
    } else {
	} else {
    } elsif ($ppdlink && Foomatic::DB::member($ppddriver, @ppddrivers)) {
	$entryfound = 1;
	@existing = $db->find_printer("$dat->{'make'}|$dat->{'model'}", 4, 1);
    exit 1;
                  extension.
 -f <directory> : Directory where the resulting XML file to write to. The
                  file. Comments are in HTML.
		  files have to be supplied to different drivers, so with more
		     `find $libdir/db/source/printer -name "*.xml" -print0 | xargs -0 grep -l $ppddlpath`));
	Foomatic::DB::apply_driver_and_pdl_info($db->{'dat'}, $parameters);
		Foomatic::DB::clean_manufacturer_name(Foomatic::DB::clean_model_name($product))
		Foomatic::DB::generatepid($db->{'dat'}{'make'},
		     !Foomatic::DB::member($_, @existing);
		 !Foomatic::DB::member($_, @existing);
# Foomatic printer XML file generator to get XML files corresponding
    foreach my $entry (@existing) {
	foreach my $product (@{$dat->{ppdproduct}}) {
	foreach my $product (@{$db->{'dat'}{ppdproduct}}) {
foreach $ppdfile (@ARGV) {
    # from the first string. This is mainly for transfering XML
	    "      from the PPD file for this printer.<p>\n\n" .
getopts("d:r:p:lb:Dc:Cf:nxh");
	     grep {
		 grep {
help() if !@ARGV;
help() if $opt_h;
 -h             : show help information
    if ($basedir) {
	if (! -d $basedir) {
	if (!defined($parameters->{'drivers'})) {
	if (!defined($parameters->{'pdls'})) {
    if (!$entryfound) {
	if ($entry !~ /\.xml$/i) {
    if (!$nocheck) {
                  If not otherwise stated by the "-r" option, this is also
    if ($ppddlpath eq "") {
    if ($ppddriver) {
    if ($ppddriver && !Foomatic::DB::member($ppddriver, @driverslist)) {
    if ($ppddriver && !Foomatic::DB::member($ppddriver, @ppddrivers)) {
    if ($ppdfile =~ /^([^\:]+)\:(.*)$/) {
    if ($ppdlink && !$ppddriver) {
	    if (! -r $ppdfile) {
	if (! -r $ppdfile) {
	    if (scalar(@{$db->{'dat'}{ppdproduct}}) > 1) {
		if scalar(@{$db->{'dat'}{ppdproduct}}) > 1;
                  is optional. If not supplied, the first driver in the driver 
                  is relative to this directory (and not relative to the
 -l             : Add a link to the PPD file to the driver entry in the
			       '<lang>.*<\/lang>');
		  list supplied via the "-d" option is used. Note that the PPD
	       m:([^/]+)$:; $1;
		  makes the process vastly faster if you have PPD files for
	     } map {
		    ";MDL:" . $db->{'dat'}{'general_mdl'} . ";" .
	$mk = $dat->{'id'};
	$mk =~ s/^([^\-]+)\-.*$/$1/;
    # multi-line) without needing to rewrite the unaffected parts of
	       m:^(.*)\.xml$:; $1;
my $addonlyrequesteddrivers = $opt_D;
my $basedir = $opt_b;
my $commentadded = 0;
my $comment = $opt_c;
    my $dat = ppdtoperl($ppdfile, $parameters);
    my $db = Foomatic::DB->new();
	my $d = $db->get_printer($entry);
my $debug = 0;
my $destdir = $opt_f;
my @driverslist = ($drivers ? split(',', $drivers) : ());
my $drivers = $opt_d;
    my $entryfound = 0;
    my @existing = ();
	    my $f = ($destdir ? $destdir . "/" : ()) . 
my @newxmlentries = ();
my $nocheck = $opt_x;
my $nodefaultcomment = $opt_C;
my $nomod = $opt_n;
#my ($opt_h, $opt_d, $opt_p, $opt_A, $opt_P, $opt_w);
    my $parameters = {
my $pdls = $opt_p;
	    my @pids = $db->find_printer("$dat->{'make'}|$product", 4, 1);
    my $ppddlpath;
    my $ppddriver;
my @ppddrivers = ();
my $ppdlink = $opt_l;
my $progname = ($1 || $0);
my $rdriver = $opt_r;
	my $result;
    my ($src, $dest, $regexp) = @_;
    my $totransfer = $1;
	my $xml1 = $db->perltoxml('p');
	my $xml2 = $db->get_printer_xml($entry);
                  name of the file will be the printer ID with the ".xml"
 -n             : Do not write modified versions of existing XML files,
	next if $d->{'noxmlentry'};
	next if $nomod and $entry !~ /\.xml$/i;
	($nodefaultcomment && !$commentadded ? ('nodefaultcomment' => 1) : ()),
                  only create XML files for printers for which there is no
	open FILE, "> " . ($destdir ? $destdir . "/" : ()) . 
	    open FILE, "> " . $f or
    # out of the second string and replaces it by the piece copied
# packages).
	    $parameters->{'drivers'} = [$dat->{'driver'}];
	    $parameters->{'pdls'} = [split(',', $dat->{'general_cmd'})];
	$pdddlpath = "PPD/$mk/$ppd";    
                  PDLs, not even on the PDLs supplied by the "-p" option.
	($pdls ? ('pdls' => [split(',', $pdls)]) : ()),
                  (PDLs) which the printer supports. This will add all 
# -*- perl -*-
                  per minute, automatically generated XML, ...). Does not
		 } @pids);
                  Postscript, PCLXL, PCL6, PCL5e, PCL5c, PCL5, and PCL4.
	    $ppddlpath = $1 if $ppdfile =~ m:$basedir/(.*)$:;
	    $ppddlpath = $ppdfile;
	$ppddlpath = $ppdfile;
    $ppddlpath =~ s/\.gz$//i;
	$ppddriver = $1;
	$ppddriver = $driverslist[0];
	($ppddriver ? ('ppddriver' => $ppddriver) : ()),
	$ppdfile = $2;
	    $ppdfile = $basedir . "/" . $ppdfile;
                  <ppdfile> can also be given relative to this directory.
 <ppdfile>      : PPD file for which a printer XML file should be created
	$ppdlink = 0;
    $ppdlink = $opt_l;
	($ppdlink ? ('ppdlink' => 1) : ()),
 -p <pdls>      : Comma-separated list of known Page Description Languages
	$ppd = $ppdfile;
	$ppd =~ s:^.*/([^/]+):$1:;
	    print "  Adding PPD file to $db->{'dat'}{'id'}.xml ...\n";
	    print "  Creating new printer entry $db->{'dat'}{'id'}.xml ...\n";
		  printers which are for sure not yet in the Foomatic
	    print FILE $result;
	print FILE $result;
	print " for driver $ppddriver\n";
    print <<HELP;
	    print "  Modifying printer entry $db->{'dat'}{'id'}.xml ...\n";
	print "\n";
    print "PPD file $ppdfile";
$progname -h
$progname <options> [<driver>:]<ppdfile> [[<driver>:]<ppdfile> ...]
# Program name
	push(@driverslist, $ppddriver);
	    push(@existing,
	push(@existing,
	    push(@newxmlentries, $f);
	    push(@{$parameters->{'pdls'}}, split(',', $dat->{'general_cmd'}));
	push(@ppddrivers, $ppddriver);
	($rdriver ? ('recommendeddriver' => $rdriver) : ()),
 -r <driver>    : Recommended driver. Supply this option to specify another
	    $result = $db->perltoxml('p');
	$result = $xml2;
    return $dest;
    # sections from one XML file to another (strings can be
		  specified.
	     } split(/\n/s, 
    $src =~ m/($regexp)/s;
sub help {
sub transferregexp {
                  suitable drivers to the XML entry. Currently supported are:
                  suppress the comment supplied with "-c".
                  than one PPD drivers need to be specified here.
		  the first PPD file is assigned if the "-d" option is not
    # the first string, cuts the piece of the second matching $regexp
		  The option is not needed if for all PPDs drivers are
                  the recommended driver. Drivers already specified together
    # the XML file.
	    "      This database entry was automatically generated\n" .
    # This function copies the text fraction matching $regexp out of
# to manufacturer-supplied PostScript PPDs (or also PPDs from driver
    undef($dat);
    undef($db);
    unshift(@existing, @newxmlentries) if @newxmlentries;
		  used)..
use Data::Dumper;
use Foomatic::DB;
use Foomatic::Defaults;
use Getopt::Std;
#use strict;
#!/usr/bin/perl
	warn("WARNING: \"-l\" set and PPD file \"$ppdfile\" assigned to the driver \"$ppddriver\", to which another PPD file was assigned already. No links for this PPD file will get created!\n");
	warn("WARNING: \"-l\" set without assigning a driver to the PPD file \"$ppdfile\" and without supplying a driver via \"-d\". No links for this PPD file will get created!\n");
		  with PPDs do no need to get specified with this option again.
                  works. First driver is the one for which the PPD file is.
 -x             : Create XML files independent of whether there are already
	    $xml2 !~ /<autodetect>/;
	    $xml2 !~ /<autodetect>[\s\n\r]*<general>/s;
	    $xml2 !~ /<driver>/;
	    $xml2 !~ /<drivers>/;
	    $xml2 !~ /<lang>/;
	$xml2 =~ s/(<autodetect>)/$1\n    <general>\n    <\/general>/s if 
	$xml2 =~ s/(<\/driver>)/$1\n  <drivers>\n  <\/drivers>/s if 
	$xml2 =~ s/(<\/functionality>)/$1\n  <driver><\/driver>/s if 
	$xml2 =~ s/(<\/lang>)/$1\n  <autodetect>\n  <\/autodetect>/s if 
	$xml2 =~ s/(<\/(mechanism|url)>)/$1\n  <lang>\n  <\/lang>/s if 
	$xml2 = transferregexp($xml1, $xml2,
                  XML file.
                  XML files for the printers covered by the PPD or not. This
                  XML file yet.
