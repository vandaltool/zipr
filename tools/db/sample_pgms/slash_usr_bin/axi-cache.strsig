                #
            """
            )
        """
                # 1. Retrieve only one result, with default sorting.  Read its relevance as
                # 2. Set the cutoff as some percentage of the maximum relevance
                # 3. Set sort by the wanted value
                # 4. Perform the query
            # Access the Xapian index
# Activate support for the CJK tokenizer
        "again [query]: repeat the last search, possibly adding query terms"
        # Aggregated data source information
        # Aggregated plugin information
        # Aggregated value information
            # Aggregate info about values
            all_plugins_names.remove(plugin.filename)
        all_plugins_names = set((x for x in os.listdir(axi.PLUGINDIR) if x.endswith(".py")))
# along with this program; if not, write to the Free Software
        aptcache = apt.Cache(progress=AptSilentProgress())
            args = map(term_or_tag, args)
# (at your option) any later version.
# axi-cache - Query apt-xapian-index database
            blacklist = set(self.args)
            blacklist = set(self.args[:-1])
    BOOLWORDS = set(["and", "or", "not"])
                    break
                buf = buf.getvalue().replace("ENDDESC", "\n\n" + commands.getvalue()[:-1])
                buf = StringIO()
            "Build query from cached query info"
            # Build query parser
            # Build the enquire with the query
# but WITHOUT ANY WARRANTY; without even the implied warranty of
CACHEFILE = os.path.join(XDG_CACHE_HOME, "axi-cache.state")
    class AptSilentProgress(apt.progress.text.OpProgress) :
        class BasicFilter(xapian.ExpandDecider):
class Cmdline(object):
    class DB(object):
        class Parser(OptionParser):
    class SavedStateError(Exception):
        class TagFilter(xapian.ExpandDecider):
        class TermFilter(BasicFilter):
# coding: utf-8
                commands = StringIO()
    complete_depends = complete_show
    complete_madison = complete_show
    complete_policy = complete_show
    complete_rdepends = complete_show
    complete_rdetails = complete_show
    complete_showpkg = complete_show
    complete_showsrc = complete_show
            Compute suggestions for more terms
        # ConfigParser access wrappers with lots of extra ifs, needed because the
        # ConfigParser API has been designed to throw exceptions in the most stupid
            # Context-sensitive hints
            "Convert DB prefixes to user prefixes"
# Copyright (C) 2010  Enrico Zini <enrico@debian.org>
        count = int(args[0]) if args else 20
                count = matches.size()
            count = matches.size()
            cur_time = "last updated: " + cur_time
            cur_time = "not available: " + str(e)
            cur_timestamp = 0
            cur_timestamp = os.path.getmtime(axi.XAPIANDBSTAMP)
            cur_time = time.strftime("%c", time.localtime(cur_timestamp))
            # Data files used by the plugin
        db = DB()
DEBTAGS_VOCABULARY = "/var/lib/debtags/vocabulary"
        def build_query(self):
            def __call__(self, term):
    def clean_suggestions(self, eset):
    def complete_again(self):
    def complete_search(self):
    def complete_show(self):
            def describe_tag(tag):
    def do_again(self, args):
    def do_depends(self, args):
    def do_help(self, args):
    def do_info(self, args):
    def do_last(self, args):
    def do_madison(self, args):
    def do_more(self, args):
        def done(self):
    def do_policy(self, args):
    def do_rdepends(self, args):
    def do_rdetails(self, args):
    def do_search(self, args):
    def do_showpkg(self, args):
    def do_show(self, args):
    def do_showsrc(self, args):
            def error(self, msg):
        def fileinfo(fname):
    def format_help(self, out):
        def get_all_matches(self, first=None):
        def get_cache_last(self, key, default=None):
        def get_matches(self, first=None, count=20):
        def get_rdeps(self, name, pfx):
        def get_spelling_correction(self):
        def get_suggestions(self, count=10, filter=None):
        def __init__(self):
    def __init__(self):
            def __init__(self, cmdline, *args, **kwargs):
            def __init__(self, stemmer=None, exclude=None, prefix=None):
        def is_tag(self, t):
    def perform(self):
    def print_all_matches(self, matches_iter):
    def print_completions(self, matches):
            def print_help(self, fd=sys.stdout):
    def print_matches(self, matches):
    def readVocabulary():
        def save(self):
        def set_cache_last(self, key, val):
        def set_query_args(self, args, secondary=False):
        def set_query_string(self, q, secondary=False):
        def set_sort(self, key=None, cutoff=60):
    def tabcomplete_query_args(self):
            def term_or_tag(t):
        def unprefix(self, term):
        def unset_cache_last(self, key):
        def update(self, percent=None):
        def vocabulary(self):
                delta = datetime.timedelta(seconds=cur_timestamp-ts)
                delta = datetime.timedelta(seconds=ts-cur_timestamp)
        "depends pkgname[s]: run apt-cache depends pkgname[s]"
                deps = list(db.get_rdeps(name, pfx))
                    desc=desc,
                desc = describe_tag(tag)
            desc = doc.get("shortDesc", "(description unavailable)")
            desc = doc.get("shortDesc", "(unavailable)")
                    desc="(plugin disabled, description unavailable)",
                        description="Query the Apt Xapian index.ENDDESC")
        # Disabled plugins
            doc = plugin.obj.doc() or dict()
            elif first != 0:
        elif self.opts.tabcomplete == "plain" and not self.args:
            elif "Tag" in entry:
            elif term.startswith("XP"):
            elif term.startswith("XS"):
            elif ts == 0:
            elif ts <= cur_timestamp:
                else:
            else:
        else:
            enquire.set_query(xapian.Query(pfx+name))
            enquire = xapian.Enquire(self.db)
            est = matches.get_matches_estimated()
        except e:
                except Error, e:
        except Error, e:
    except ImportError:
except ImportError, e:
                except KeyError:
            except KeyError:
            except SavedStateError, e:
        except SavedStateError, e:
            exclude = self.args
            exclude = self.args[:-1]
        exclude = [x for x in exclude if x.lower() not in self.BOOLWORDS]
            # Expand from output of last query
        facets = dict()
                facets[entry["Facet"]] = entry
            facets, tags = self.db.vocabulary()
                    fd = facets[f]["Description"].split("\n", 1)[0].strip()
                fd.write(buf)
            f = getattr(self, "complete_" + self.cmd, None)
            f = getattr(self, "do_" + self.cmd, None)
                filter = self.BasicFilter()
            fin = open(DEBTAGS_VOCABULARY)
            first = 0
                first += 100
                first += 20
                first = int(self.db.get_cache_last("lastfirst", 0))
        first = int(self.db.get_cache_last("lastfirst", 0))
                first = int(self.get_cache_last("skip", 0))
            first = matches.get_firstitem()
        for entry in deb822.Deb822.iter_paragraphs(fin):
            for facet in ["interface", "role", "use", "works-with"]:
        for k, v in sorted(self.__class__.__dict__.iteritems()):
        for k, v in sources.iteritems():
        formatted
                for m in enquire.get_mset(first, first + 20):
                for m in matches:
        for m in matches_iter:
                for m in self.db.get_matches(first = first):
            for m in self.enquire.get_mset(0, 30):
        for name in args:
        #for name, info in sorted(plugins.iteritems(), key=lambda x:x[0]):
        for name, info in sorted(plugins.iteritems(), key=lambda x:x[0]):
        for name, val in sorted(values.iteritems(), key=lambda x:x[0]):
        for path, info in sources.iteritems():
            for pfx in ("XRD", "XRR", "XRS", "XRE", "XRP", "XRB", "XRC"):
            for pfx, tag in (
                for pkg in db.get_rdeps(name, pfx):
        for plugin in axi.indexer.Plugins():
        for plugin in sorted(all_plugins_names):
            for res in self.db.get_suggestions(count=20, filter=DB.TagFilter()):
        for r in eset:
            for s in plugin.info.get("sources", []):
        for s in self.clean_suggestions(self.db.get_suggestions(count=10, filter=DB.BasicFilter(stemmer=self.db.stem, exclude=exclude, prefix=prefix))):
            for term in self.db.db.allterms("XP" + (partial or "")):
                for term in self.db.db.allterms("XT" + facet + "::"):
            for term in self.db.db.allterms("XT" + self.args[0]):
            for term in sorted(terms):
        for usage, desc in [x for x in itemlist if "run apt-cache" in x[1]]:
        for usage, desc in [x for x in itemlist if "run apt-cache" not in x[1]]:
            for v in plugin.info.get("values", []):
                found = 0
                    found += 1
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    from ConfigParser import RawConfigParser
from cStringIO import StringIO
        from debian_bundle import deb822
        from debian import deb822
from optparse import OptionParser
                f, t = tag.split("::")
        # General info
            Generate Xapian matches for all query matches
            # Get results, optionally filtered
        Given an iterator of Xapian matches, print them all out nicely
# GNU General Public License for more details.
#    has a syntax for saved queries, recycle it)
    helponly = False
    helponly = True
        "help: show a summary of commands"
            if count != 0:
                if count == 0: break
            if cur_timestamp == 0:
                if desc is None:
            if "Facet" in entry:
            if filter is None:
            if first == 0:
            if first > 0:
            if first + count < est:
            if first is None:
            if f is None:
                if found < 20:
    if helponly: sys.exit(0)
                if "::" in t and self.is_tag(t):
            if key is None:
            if len(k) > maxpath: maxpath = len(k)
                if len(term) < 4: return False
            if len(usage) > maxusage:
            if len(v["desc"]) > maxdesc: maxdesc = len(v["desc"])
                if maxscore == None: maxscore = weight
                if name is None: continue
if __name__ == "__main__":
                if name not in values:
                if not deps: continue
if not helponly:
            if not k.startswith("do_"): continue
                if not os.path.exists(XDG_CACHE_HOME):
            if not secondary:
            if not self.cache.has_option("last", "query"):
            if not self.cache.has_section("last"):
        if not self.opts.tabcomplete:
                    if not t.startswith(self.prefix):
        if opts.tags and opts.all:
            if os.path.exists(CACHEFILE):
            if os.path.exists(fname):
                    if partial is not None and not pkg.startswith(partial): continue
                if path not in sources:
            if pkg is not None and pkg.candidate:
                    if pkg not in blacklist:
                if pkg not in blacklist:
            if plugins:
                if sc:
            if secondary:
            if self.cache.has_option("last", key):
            if self.dirty:
            if self.facets is None:
        if self.opts.all:
        if self.opts.last:
        if self.opts.sort:
        if self.opts.tabcomplete is not None:
        if self.opts.tabcomplete == "partial":
        if self.opts.tabcomplete == "partial" and len(self.args) == 1:
        if self.opts.tabcomplete == "partial" and self.args:
        if self.opts.tags:
                if self.prefix is not None:
                if self.stem(term) in self.exclude: return False
            if sort is not None:
            if s.startswith("tag:"):
            if term.startswith("XT"):
                if term.startswith("XT") or term.startswith("XS"): return True
                # If we don't sort by relevance, we need to specify a cutoff in order to
    import apt
import axi
        import axi.indexer
        import datetime
    import math
import os, os.path
    import re
import sys
        import time
    import xapian
            index_loc = "not available: " + str(e)
            index_loc = open(axi.XAPIANINDEX).read().split(" ", 1)[1].strip()
            index_loc = "pointing to " + index_loc
        "info: print information about the apt-xapian-index environment"
        itemlist = []
            itemlist.append([usage, desc])
# it under the terms of the GNU General Public License as published by
        "last [count]: show the last results again"
            # Last update status / whether an update is due
            line = self.name + " " + v.__doc__
        "madison pkgname[s]: run apt-cache madison pkgname[s]"
                matches = self.enquire.get_mset(first, 100)
            matches = self.enquire.get_mset(first, count)
        maxdesc = 0
        #maxname = max((len(x) for x in plugins.iterkeys()))
        maxname = max((len(x) for x in plugins.iterkeys()))
        maxname = max((len(x) for x in values.iterkeys()))
        maxpath = 0
            maxscore = None
        maxusage = 0
                maxusage = len(usage)
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        "more [count]: show more terms from the last search"
            name = m.document.get_data()
            name = os.path.splitext(plugin)[0]
        # { name: { path=path, desc=desc, status=status } }
                name = v.get("name", None)
                # Normalise the score in the interval [0, 1]
                # Note: ept-cache implements an adaptive cutoff as follows:
            #notmuch->query_parser->add_valuerangeprocessor (notmuch->value_range_processor);
            #notmuch->value_range_processor = new Xapian::NumberValueRangeProcessor (NOTMUCH_VALUE_TIMESTAMP);
            # Only show this when being verbose
                OptionParser.__init__(self, *args, **kwargs)
                OptionParser.print_help(self, buf)
        (opts, args) = self.parser.parse_args()
os.environ["XAPIAN_CJK_NGRAM"] = "1"
        os.execvp("/usr/bin/apt-cache", ["apt-cache", "depends"] + args)
        os.execvp("/usr/bin/apt-cache", ["apt-cache", "madison"] + args)
        os.execvp("/usr/bin/apt-cache", ["apt-cache", "policy"] + args)
        os.execvp("/usr/bin/apt-cache", ["apt-cache", "show"] + args)
        os.execvp("/usr/bin/apt-cache", ["apt-cache", "showpkg"] + args)
        os.execvp("/usr/bin/apt-cache", ["apt-cache", "showsrc"] + args)
                    os.makedirs(XDG_CACHE_HOME, mode=0700)
            partial = None
            partial = self.args[-1]
        pass
            pass
        # { pathname: { desc=shortdesc, plugins=[plugin names] } }
                    path=os.path.join(axi.PLUGINDIR, plugin),
                    path=os.path.join(axi.PLUGINDIR, plugin.filename),
                path = s.get("path", "(unknown)")
        # Per-plugin info
                pkg = aptcache[name]
                    pkg = m.document.get_data()
                pkg = None
                pkg = term.term[2:]
        # places one could possibly conceive
        # Plugin information
        plugins = dict()
            plugins[name] = dict(
            plugins[plugin.name] = dict(
            plugins = val.get("plugins", [])
        "policy pkgname[s]: run apt-cache policy pkgname[s]"
            # Prefix expand
            prefix = None
            prefix = self.args[-1] if self.args else None
        print "Data sources:"
                    print "Did you mean:", sc, "?"
        print "Documentation of available prefixes:", fileinfo(axi.XAPIANDBPREFIXES)
        print "Documentation of available values:", fileinfo(axi.XAPIANDBVALUES)
        print "Documentation of index contents:", fileinfo(axi.XAPIANDBDOC)
        print "Index location: %s (%s)" % (axi.XAPIANINDEX, index_loc)
        #    print "    ", info["desc"]
            print "%i results found." % est
                    print "%i%% %s" % (int(score * 100), tag)
                    print "%i%% %s -- %s" % (int(score * 100), tag, desc)
                print "%i%% %s - %s" % (m.percent, name, pkg.candidate.summary)
                print "%i%% %s - (unknown by apt)" % (m.percent, name)
        print "Main data directory:", axi.XAPIANDBPATH
                print "More tags:", " ".join([x[4:] for x in stags])
                print "More terms:", " ".join(sugg)
            print name
            print " ", name.ljust(maxname), "%4d" % int(val["val"]), provider
            print " ", name.ljust(maxname), info["status"]
                print name, tag, " ".join(deps)
                print "No more results to show"
        print >>out, "  apt-cache front-ends:"
        print >>out, "Commands:"
        print >>out, "  search commands:"
            print >>out, "    %-*.*s  %s" % (maxusage, maxusage, usage, desc)
            print " ", path.ljust(maxpath), info["desc"].ljust(maxdesc), provider
                        print pkg
                    print pkg
                    print " ", pkg
        print "Plugin directory:", axi.PLUGINDIR
        #print "Plugins:"
        print "Plugin status:"
            # print "Query:", self.query
                print "Results %i-%i:" % (first + 1, first + count)
            print "Reverse Depends:"
                print s
                print s[4:]
                print "`%s again' will restart the search" % self.name
        #    print "  %s:" % info["path"]
                print "`%s more' will give more results" % self.name
        print " ", "Source".ljust(maxpath), "Description".ljust(maxdesc), "Used by"
            #print >>sys.stderr, "Cannot read %s: %s. Please install `debtags' t" % (DEBTAGS_VOCABULARY, str(e))
                    print >>sys.stderr, e
                    print >>sys.stderr, "ignoring %s which seems to be corrupted" % CACHEFILE
                print >>sys.stderr, "Invalid command: `%s'.\n" % self.cmd
            print >>sys.stderr, "%s: maybe you need to run '%s search' first?" % (self.name, str(e))
    print >>sys.stderr, "%s: only help functions are implemented, for the sake of help2man" % str(e)
                print term
                    print term.term[2:]
                print term.term[2:]
        print "Update timestamp: %s (%s)" % (axi.XAPIANDBSTAMP, cur_time)
        print " ", "Value".ljust(maxname), "Code", "Provided by"
        print "Values:"
            provider = ", ".join(info.get("plugins", []))
                provider = ", ".join(plugins)
                provider = "update-apt-xapian-index"
            qargs, partial = self.tabcomplete_query_args()
        qargs, partial = self.tabcomplete_query_args()
            q = self.get_cache_last("query")
            queryargs = queryargs[:-1]
            queryargs = self.args
            queryargs = self.args[:-1]
        "Quiet progress so we don't get cache loading messages from Apt"
                raise SavedStateError("no saved query")
        "rdepends pkgname[s]: run apt-cache rdepends pkgname[s]"
        "rdetails pkgname[s]: show details of reverse relationships for the given packages"
            # Read state from previous runs
                # remove poor results from the output
        # Remove trailing boolean terms
        res = []
            res.append(self.db.unprefix(r.term))
        #res.sort()
                return
                return 0
            return 0
        return 0
                return 1
            return 1
            "Return all the rdeps of type @pfx for package @name"
            Return a Xapian ESet
            Return a Xapian mset with the next page of results.
            return default
            return f()
        return facets, tags
                        return False
                return fname
                return fname + " (available from next reindex)"
            return f(self.args)
            return matches
                    return None
            return None, None
                return "pkg:" + term[2:]
        return queryargs, partial
        return res
                return "sec:" + term[2:]
                return self.cache.get("last", key)
            return self.db.term_exists("XT" + t)
            return self.enquire.get_eset(count, rset, filter)
            return self.facets, self.tags
            return self.qp.get_corrected_query_string()
                    return "%s: %s" % (fd, td)
                    return t
                    return "tag:" + t
                return "tag:" + term[2:]
            return term
                return term[0].islower()
                return term.startswith("XT")
                reverse = sort[0] == '-' or sort[-1] == '-'
                rset.add_document(m.docid)
            rset = xapian.RSet()
#  - save NAME  save the query to be recalled later with @NAME (or if notmuch
            "Save the state so we find it next time"
                score = float(weight) / maxscore
                sc = self.db.get_spelling_correction()
        "search [terms]: start a new search"
            secondary = self.get_cache_last("secondary query", None)
                secondary = self.qp.parse_query(secondary,
        self.args = args
                self.cache.add_section("last")
            self.cache = RawConfigParser()
                    self.cache.read(CACHEFILE)
            self.cache.remove_option("last", key)
            self.cache.set("last", key, val)
                self.cache.write(open(CACHEFILE, "w"))
        self.cmd = "help" if not self.args else self.args.pop(0)
                self.cmdline = cmdline
                self.cmdline.format_help(commands)
                self.db.build_query()
            self.db.build_query()
        self.db.build_query()
        self.db = DB()
            self.db.save()
        self.db.set_query_args(args)
        self.db.set_query_args(args, secondary=True)
            self.db.set_query_args(qargs)
        self.db.set_query_args(qargs, secondary=True)
            self.db.set_sort(None)
            self.db.set_sort(self.opts.sort)
            self.db = xapian.Database(axi.XAPIANINDEX)
                self.dirty = False
            self.dirty = False
            self.dirty = True
                self.do_help(self.args)
                #self.enquire.set_cutoff(int(self.get_cache_last("cutoff", 60)))
            self.enquire.set_query(self.query)
                self.enquire.set_sort_by_value(values[sort], reverse)
            self.enquire = xapian.Enquire(self.db)
                self.exclude = set([self.stem(x) for x in exclude]) if exclude else set()
            self.facets = None
                self.facets, self.tags = readVocabulary()
        self.name = "axi-cache"
        self.opts = opts
        self.parser.add_option("--all", action="store_true", help="disable pagination and always show all results. Note that search results are normally sorted by relevance, so you may find meaningless results at the end of the output")
        self.parser.add_option("--last", action="store_true", help="use 'show --last' to limit tab completion to only the packages from the last search results")
        self.parser.add_option("-s", "--sort", help="sort by the given value, as listed in %s. Add a '-' to reverse sort order" % axi.XAPIANDBVALUES)
        self.parser.add_option("--tabcomplete", action="store", metavar="TYPE", help="suggest words for tab completion of the current command line (type is 'plain' or 'partial')")
        self.parser.add_option("--tags", action="store_true", help="show matching tags, rather than packages")
            self.parser.error("--tags conflicts with --all")
        self.parser = Parser(self, usage="usage: %prog [options] command [args]",
        self.parser.print_help()
                self.prefix = prefix
            self.print_all_matches((m for m in matches))
            self.print_all_matches(self.db.get_all_matches())
        self.print_completions(self.db.get_matches())
        self.print_completions(self.db.get_matches(first = 0))
                self.print_help(sys.stderr)
            self.print_matches(self.db.get_matches())
        self.print_matches(self.db.get_matches(count=count))
        self.print_matches(self.db.get_matches(first = 0))
        self.print_matches(self.db.get_matches(first=first, count=count))
            self.qp.add_boolean_prefix("sec", "XS")
            self.qp.add_boolean_prefix("tag", "XT")
            self.qp.add_prefix("pkg", "XP")
            self.qp.set_database(self.db)
            self.qp.set_default_op(xapian.Query.OP_AND)
            self.qp.set_stemmer(self.stem)
            self.qp.set_stemming_strategy(xapian.QueryParser.STEM_SOME)
            self.qp = xapian.QueryParser()
            self.query = self.qp.parse_query(q,
                self.query = xapian.Query(xapian.Query.OP_AND, self.query, secondary)
                self.set_cache_last("cutoff", str(cutoff))
            self.set_cache_last("lastfirst", first)
                self.set_cache_last("query", q)
                self.set_cache_last("secondary query", q)
            self.set_cache_last("skip", first + count)
                self.set_cache_last("sort", key)
            self.set_query_string(" ".join(args), secondary=secondary)
                self.stem = stemmer if stemmer else lambda x:x
            self.stem = xapian.Stem("english")
            self.tags = None
                self.unset_cache_last("cutoff")
            self.unset_cache_last("lastfirst")
                self.unset_cache_last("secondary query")
            self.unset_cache_last("skip")
                self.unset_cache_last("sort")
            "Set sorting method (default is by relevance)"
            "Set the query in the cache"
# Setup configuration
            # Show a preset list of tags
        "show pkgname[s]: run apt-cache show pkgname[s]"
        "showpkg pkgname[s]: run apt-cache showpkg pkgname[s]"
        "showsrc pkgname[s]: run apt-cache showsrc pkgname[s]"
            # Simple prefix search
                    # Skip leading uppercase chars
                # Sort by the requested value
            sort = self.get_cache_last("sort")
                sort = sort.strip('-')
        # Source files information
        sources = dict()
                    sources[path] = dict(desc=s.get("desc", "(unknown)"), plugins=[])
                sources[path].setdefault("plugins", []).append(plugin.name)
                stags = self.clean_suggestions(self.db.get_suggestions(count=7, filter=DB.TagFilter()))
                    status="disabled",
                status = "enabled, needs indexing (%s newer than index)" % str(delta)
                status = "enabled, not indexed"
                status = "enabled, up to date"
                status = "enabled, up to date (%s older than index)" % str(delta)
                    status=status,
                # Still in 2010 Cmdline is not an object. Oh dear.
                sugg = self.clean_suggestions(self.db.get_suggestions(count=7, filter=DB.TermFilter(stemmer=self.db.stem, exclude=self.args)))
                super(DB.BasicFilter, self).__init__()
                sys.exit(2)
    sys.exit(ui.perform())
                sys.stderr.write("%s: error: %s\n\n" % (self.get_prog_name(), msg))
        tags = dict()
                tag = self.db.unprefix(res.term)[4:]
                tags[entry["Tag"]] = entry
                    td = tags[tag]["Description"].split("\n", 1)[0].strip()
            # terms
            terms = set()
            terms.update((str(term) for term in self.db.db.synonym_keys(self.args[0])))
            terms.update((term.term for term in self.db.db.allterms(self.args[0])))
# the Free Software Foundation; either version 2 of the License, or
                #    the maximum relevance.
# This program is distributed in the hope that it will be useful,
# This program is free software; you can redistribute it and/or modify
            # TODO: check if the data from the plugin is present in the index
                # TODO: didn't this use to work?
                try:
            try:
        try:
    try:
            ts = plugin.info["timestamp"]
                        t = t[1:]
                    t = term
    ui = Cmdline()
            usage, desc = line.split(": ", 1)
            # Use the first 30 results as the key ones to use to compute relevant
#!/usr/bin/python
        # Value information
        # { valuename: { val=num, desc=shortdesc, plugins=[plugin names] } }
                values, descs = axi.readValueDB()
        values, descs = axi.readValueDB()
        values = dict(((a, dict(val=b, desc=descs[a], plugins=[])) for a, b in values.iteritems()))
                    values[name] = dict(val=None, desc=v.get("desc", "(unknown"), plugins=[])
                values[name].setdefault("plugins", []).append(plugin.name)
VERSION="0.44"
                        version="%prog "+ VERSION,
                weight = math.log(res.weight)
        while queryargs and queryargs[-1].lower() in self.BOOLWORDS:
                    while t and t[0].isupper():
            while True:
                    xapian.QueryParser.FLAG_AUTO_SYNONYMS)
                    xapian.QueryParser.FLAG_BOOLEAN |
                    xapian.QueryParser.FLAG_BOOLEAN_ANY_CASE |
                    xapian.QueryParser.FLAG_LOVEHATE |
                    xapian.QueryParser.FLAG_PURE_NOT |
                    xapian.QueryParser.FLAG_SPELLING_CORRECTION |
                    xapian.QueryParser.FLAG_WILDCARD |
XDG_CACHE_HOME = os.environ.get("XDG_CACHE_HOME", os.path.expanduser("~/.cache"))
#XDG_CONFIG_HOME = os.environ.get("XDG_CONFIG_HOME", os.expanduser("~/.config"))
                    ("XRB", "bre"),
                    ("XRC", "con")):
                    ("XRD", "dep"),
                    ("XRE", "enh"),
                    ("XRP", "pre"),
                    ("XRR", "rec"),
                    ("XRS", "sug"),
                    yield m
                    yield m.document.get_data()
# You should have received a copy of the GNU General Public License
