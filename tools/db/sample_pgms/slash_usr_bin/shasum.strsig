   -a, --algorithm   1 (default), 224, 256, 384, 512, 512224, 512256
$alg = 1 unless defined $alg;
		$alg = 1 unless defined $alg;
			$alg = 1 unless defined $alg;
		$alg = defined $sum ? $len2alg{length($sum)} : undef;
 algorithm explicitly using the -a option, e.g.
		and $checkfile = 'standard input'
@ARGV = ("-") unless @ARGV;
	'b|binary' => \$binary, 'c|check' => \$check,
   -b, --binary      read in binary mode
		($binary, $portable, $text) =
		$bslash = s/^\\//;
	## but functionally equivalent Digest::SHA::PurePerl instead.
   -c, --check       read SHA sums from the FILEs and check them
	$checkfile eq '-' and open(FH, '< -')
	close(FH);
	## Collect options from command line
	## Copyright (C) 2003-2011 Mark Shelor, All Rights Reserved
Copyright (c) 2003-2011 Mark Shelor <mshelor@cpan.org>.
			/^([\da-fA-F]+)[ \t]([ *?])([^\0]*)/;
	## Deal with help requests and incorrect uses
	## default to binary mode when reading files, unless
	## Default to SHA-1 unless overriden by command line option
	die "Unable to find $MOD_PREFER or $MOD_SECOND\n" if $@;
			$digest = "\\$digest";
	$digest->hexdigest;
digests.  The user simply feeds data to the script through files or
	## Display version information if requested
		else {
			else { $rsp .= "FAILED\n"; $err = 1; $match_errs++ }
	else { $STATUS = 1 }
	elsif ($digest = sumfile($file)) {
	elsif (! $status) {
END_OF_POD
		$err = 1;
			$err = 1; $read_errs++;
    eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
eval { Getopt::Long::Configure ("bundling") };
	eval "require $module";
eval "require $module";
	exit(0);
		exit($err);
	exit($err);
exit($STATUS)
	## explicitly overriden by command line "--text" or
			$file =~ s/\\/\\\\/g; $file =~ s/\n/\\n/g;
			$fmt_errs++;
		$fname =~ s/\r$// unless -e $fname;
		$fname = unescape($fname) if defined $fname && $bslash;
for $file (@ARGV) {
				"formatted SHA$alg checksum line\n") if $warn;
 ` ' for text, `?' for portable), and name for each FILE.
GetOptions(
grep { $_ == $alg } (1, 224, 256, 384, 512, 512224, 512256)
=head1 AUTHOR
=head1 DESCRIPTION
=head1 NAME
=head1 SEE ALSO
=head1 SYNOPSIS
   -h, --help        display this help and exit
	'h|help' => \$help, 'v|version' => \$version,
if ($@) {
	if ($check) { $STATUS = 1 unless verify($file) }
	if ($err) {
		if ($file =~ /[\n\\]/) {
		if (grep { ! defined $_ } ($alg, $sum, $modesym, $fname)) {
	if $help;
if ($isDOSish) { $binary = 1 unless $text || $portable }
			if (lc($sum) eq $digest) { $rsp .= "OK\n" }
	if $running_under_some_shell;
	if scalar(grep { defined $_ } ($binary, $portable, $text)) > 1;
	if $status && !$check;
if ($version) {
	if $warn && !$check;
	if ($@) { warn "shasum: $file: $!\n"; return }
	## Include an "-a" option for algorithm selection, and a
 input should be a former output of this program.  The default mode is to
inputs such as the NIST test vector "abc":
I<sha224sum>, I<sha256sum>, I<sha384sum>, and I<sha512sum> programs,
I<shasum> is implemented using the Perl module L<Digest::SHA> or
L<Digest::SHA::PurePerl>.
$len2alg{56} = 512224 if $alg == 512224;
$len2alg{64} = 512256 if $alg == 512256;
	## %len2alg: maps hex digest length to SHA algorithm
	local *FH;
			map { $_ eq $modesym } ('*', '?', ' ');
		($match_errs>1?'s':'') . " did NOT match\n") if $match_errs;
	$module = $MOD_SECOND;
	$msg = "" unless defined $msg;
my ($alg, $binary, $check, $text, $status, $warn, $help, $version);
	my ($bslash, $sum, $fname, $rsp, $digest);
	my $checkfile = shift;
	my $digest = eval { $module->new($alg)->addfile($file, $mode) };
	my ($err, $fmt_errs, $read_errs, $match_errs) = (0, 0, 0, 0);
	my($err, $msg) = @_;
my($file, $digest);
	my $file = shift;
my $isDOSish = ($^O =~ /^(MSWin\d\d|os2|dos|mint|cygwin)$/);
my %len2alg = (40 => 1, 56 => 224, 64 => 256, 96 => 384, 128 => 512);
	my $mode = $portable ? 'p' : ($binary ? 'b' : '');
my $modesym = $binary ? '*' : ($portable ? '?' : ' ');
my $MOD_PREFER = "Digest::SHA";
my $MOD_SECOND = "Digest::SHA::PurePerl";
my $module = $MOD_PREFER;
	my ($num_lines, $num_files) = (0, 0);
my $POD = <<'END_OF_POD';
my ($portable);
my $STATUS = 0;
	my($USAGE) = $POD =~ /SYNOPSIS\n\n(.+)\n=head1 DESCRIPTION\n/sm;
my $VERSION = "5.61";
			next;
		next if /^#/; s/\n$//; s/^[ \t]+//; $num_lines++;
		or die "shasum: $checkfile: $!\n";
Or, if you want to use SHA-256 instead of the default SHA-1, simply say:
	or sysopen(FH, $checkfile, O_RDONLY)
) or usage(1, "");
	or usage(1, "shasum: Unrecognized algorithm\n");
	perl -e "print qq(abc)" | shasum
	perl -e "print qq(abc)" | shasum -a 256
#!perl -w
	## "-p" option for portable digest computation.
	## "--portable" options.
	'p|portable' => \$portable
   -p, --portable    read files in portable mode
 print a line with checksum, a character indicating type (`*' for binary,
		print "$digest $modesym", "$file\n";
 Print or check SHA checksums.
		print $rsp unless $status;
	print $USAGE;
	print "$VERSION\n";
                         produces same digest on Windows/Unix/Mac
		($read_errs>1?'s':'') . " could not be read\n") if $read_errs;
	## Read from STDIN (-) if no files listed on command line
 Report shasum bugs to mshelor@cpan.org
	return $_;
	return($err == 0);
	return if /\\/;
			$rsp .= "FAILED open or read\n";
		$rsp = "$fname: "; $num_files++;
Running I<shasum> is often the quickest way to compute SHA message
	s/\\\\/\0/g;
	s/\0/\\/g;
		's are':' is') . " improperly formatted\n") if $fmt_errs;
select((select(STDERR), $| = 1)[0]);
select((select(STDOUT), $| = 1)[0]);
			"SHA$alg checksum lines found\n");
   shasum -a 512224 -c checksumfile
	## shasum: filter for computing SHA digests (ref. sha1sum/md5sum)
shasum - Print or Check SHA Checksums
	## shasum SYNOPSIS adapted from GNU Coreutils sha1sum.
	$_ = shift;
Since I<shasum> mimics the behavior of the combined GNU I<sha1sum>,
	s/\\n/\n/g;
   -s, --status      don't output anything, status code shows success
	's|status' => \$status, 'w|warn' => \$warn,
standard input, and then collects the results from standard output.
sub sumfile {
sub unescape {
sub usage {
sub verify {
	## sumfile($file): computes SHA digest of $file
		($sum, $modesym, $fname) =
	## Sync stdout and stderr by forcing a flush after every write
The following command shows how easy it is to compute digests for typical
 The following two options are useful only when verifying checksums:
 The sums are computed as described in FIPS-180-4.  When checking, the
	## Try to figure out if the OS is DOS-like.  If it is,
	## Try to use Digest::SHA.  If not installed, use the slower
   -t, --text        read in text mode (default)
	't|text' => \$text, 'a|algorithm=i' => \$alg,
	## unescape: convert backslashed filename to plain filename
		unless ($digest = sumfile($fname)) {
	unless ($num_files) {
usage(0)
usage(1, "shasum: Ambiguous file mode\n")
usage(1, "shasum: --status option used only when verifying checksums\n")
usage(1, "shasum: --warn option used only when verifying checksums\n")
	$USAGE =~ s/^ //gm;
 Usage: shasum [OPTION]... [FILE]...
use Fcntl;
use Getopt::Long;
use strict;
#!/usr/bin/perl
	## verify: confirm the digest values in a checksum file
	## Verify or compute SHA checksums of requested files
	## Version: 5.61
   -v, --version     output version information and exit
		warn($msg . "Type shasum -h for help\n");
			warn("shasum: $checkfile: $.: improperly " .
		warn("shasum: $checkfile: no properly formatted " .
		warn("shasum: WARNING: $fmt_errs line" . ($fmt_errs>1?
		warn("shasum: WARNING: $match_errs computed checksum" .
		warn("shasum: WARNING: $read_errs listed file" .
	## Wed Mar  9 05:26:36 MST 2011
 When verifying SHA-512/224 or SHA-512/256 checksums, indicate the
	while (<FH>) {
 With no FILE, or when FILE is -, read standard input.
   -w, --warn        warn about improperly formatted checksum lines
you can install this script as a convenient drop-in replacement.
