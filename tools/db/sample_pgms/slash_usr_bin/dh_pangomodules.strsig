            }
        }
# 'abs_path' from Cwd resolves symlinks, and we don't want that to happen
        addsubstvar($package, "misc:Depends", $pango_modver_dep);
and on the command line.
    # append the remaining command line arguments (either modules or
B<dh_pangomodules> is a debhelper program that handles correctly
B<dh_pangomodules> [S<I<debhelper options>>] [S<I<directory or module>> ...]
                chomp;
        chomp;
            close FIND;
    close QUERY;
    complex_doit("printf '%s\\n' '# automatically generated by dh_pangomodules, do not edit' >>$module_file");
            complex_doit("printf '%s\\n' '$_' >>$module_file");
dependency on the Module API version of pango is added to
development files.
dh_pangomodules - create a Pango Module file for all Pango modules
    # directories to scan for *.so modules)
    doit("chmod", 644, "$module_file");
    doit("chown", "0:0", "$module_file");
        doit("install", "-d", "$tmp/$module_files_d");
    doit("rm", "-f", "$module_file");
Do not generate any dependencies in ${misc:Depends}.
        } else {
} else {
        } elsif (-f $path or -l $path) {
        error("can't strip $absolute_tmp from output.");
            error("$path has unknown file type.");
              "find '$path' -name '*.so' \\( -type f -or -type l \\) |")
    foreach (@module_search_locations) {
    foreach my $dir (split(/:/, $modules_path)) {
foreach my $package (@{$dh{DOPACKAGES}}) {
generating Pango Module files with modules that it finds in the
=head1 AUTHOR
=head1 DESCRIPTION
=head1 NAME
=head1 OPTIONS
=head1 SEE ALSO
=head1 SYNOPSIS
    if (0 == @modules) {
    if (! $dh{K_FLAG}) {
        if (-d $path) {
    if (! -d "$tmp/$module_files_d") {
if ($ENV{PANGO_QUERYMODULES}) {
        if (! -e $path) {
        if (m#^\Q$absolute_tmp/\E#) {
            # if path is a directory (or symlink to a directory), search for
            # if path is a file or symlink, simply add it to the list
    if ($path =~ m#^/#) {
=item B<-k>
        # it's necessary to make the path absolute to strip the build-time
L<debhelper>
    # locations to search for modules
Loic Minier <lool@dooz.org>
${misc:Depends}.
    my $absolute_tmp = make_absolute_path($tmp);
    my $cwd = getcwd;
    my $do_query = join ' ', $querymodules, @modules;
my $module_files_d = 'usr/lib/i386-linux-gnu/pango/1.6.0/module-files.d';
    my $module_file = "$tmp/$module_files_d/$package.modules";
    my @modules = ();
    my @module_search_locations;
my $modules_path = 'usr/lib/i386-linux-gnu/pango/1.6.0/modules';
my $pango_modver_dep = 'pango1.0-multiarch-modver-1.6.0';
        my $path = make_absolute_path($_);
    my $path = shift;
my $querymodules;
    my $tmp = tmpdir($package);
            next;
        next;
        next if /^$/;
        next if m/^#/;
            open(FIND,
    open(QUERY, "$do_query |")
        or die "Can't query modules: $!";
              or die "Can't run find: $!";
# (otherwise it's harder to remove the prefix of the generated output)
<package>.modules file is installed into the corresponding package and a
    # Pango binary version
# Pango Module API version virtual Provide
Pango Modules Path, in directories you pass on the command line,
# pango-querymodules helper (generates a Pango Module File on its stdout with
pango-querymodules.  When any module is found, the generated
        # prefix later on
                push @modules, $_;
    push @module_search_locations, @ARGV if @ARGV;
        push @module_search_locations, "$tmp/$dir"
            push @modules, $path;
    $querymodules = $ENV{PANGO_QUERYMODULES};
    $querymodules = '/usr/bin/pango-querymodules';
# relative directory to store the generated Pango Module File
# relative Pango Modules Path (separated by ":")
    return "$cwd/$path";
        return $path;
    # since there's at least one module, generate a dependency on the
            # *.so files or symlinks
# *.so passed on its command-line)
    # split the path
            s#^\Q$absolute_tmp/\E#/#;
        # strip build-time prefix from output
sub make_absolute_path {
This command scans the specified packages for Pango modules thanks to
This program relies on Debhelper, but is shipped with the Pango
use Cwd;
use Debian::Debhelper::Dh_Lib;
use strict;
#!/usr/bin/perl -w
            verbose_print("skipping $path.");
        warning("couldn't find any Pango Modules for package $package.");
            while (<FIND>) {
    while (<QUERY>) {
