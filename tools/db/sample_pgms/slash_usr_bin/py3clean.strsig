 2010 Piotr O
# all copies or substantial portions of the Software.
arowski <piotr@debian.org>
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                     'cleaning directory or a package)')
            continue
# copies of the Software, and to permit persons to whom the Software is
# Copyright 
    counter = 0
                    counter += 1
        d = destroyer(magic_tag)
        d = destroyer()  # remove everything
        default=False, help='be quiet')
def destroyer(magic_tag=None):  # ;-)
        def find_files_to_remove(pyfile):
def get_files(items):
def get_magic_tag_to_remove(version):
def get_package_files(package_name):
def main():
    def myremove(fname):
        directory = dirname(fname)
            directory = "%s/__pycache__/" % dirname(pyfile)
            d.send(filename)
    elif args:
        elif isdir(item):
    elif magic_tag is False:
        else:
    else:
Examples:
            except:
    except GeneratorExit:
                except (IOError, OSError) as e:
            exit(0)
        exit(1)
        exit(2)
        exit(4)
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            for filename in find_files_to_remove(pyfile):
        for filename in get_files(args):
        for filename in get_package_files(options.package):
            for filename in ("%sc" % pyfile, "%so" % pyfile):
                for fn in files:
            for fn in glob1(directory, '*'):
            for fn in glob1(directory, "*.%s.py[co]" % magic_tag):
                #for fn in glob1(root, '*.py'):
    for item in items:
    for line in stdout.split('\n'):
            for root, dirs, files in walk(item):
    for v, t in map_.items():
from debpython.tools import get_magic_tags_map
from debpython.version import SUPPORTED, getver, vrepr
from glob import glob1
from os import environ, remove, rmdir, walk
from os.path import dirname, exists, isdir, isfile, join
from subprocess import Popen, PIPE
# furnished to do so, subject to the following conditions:
        help='specify Debian package name to clean')
        help='specify Python version to clean')
        help='turn verbose more one')
        if directory.endswith('__pycache__'):
                if exists(filename):
        if False, removes python3.1's .pyc files only,
                    if fn.endswith('.py'):
        if isfile(item) and item.endswith('.py'):
        if line.endswith('.py'):
    if magic_tag is None:
if __name__ == '__main__':
    if options.package:
    if options.package and args:
    if options.verbose or environ.get('PYCLEAN_DEBUG') == '1':
    if options.version:
        if options.version.endswith('3.1'):  # 3.1, -3.1
    if process.returncode != 0:
        if t == tag:
    if version != (3, 1) and version not in map_:
        if v == version:
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
import logging
import optparse
import sys
# initialize script
# in the Software without restriction, including without limitation the rights
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        log.debug('args: %s', args)
        log.debug('argv: %s', sys.argv)
                    log.debug(e)
    log.debug('magic tags to remove: %s', tag)
        log.debug('options: %s', options)
        log.error('cannot get content of %s', package_name)
                    log.error('cannot remove %s', filename)
        log.error('magic tag for %s not recognized', vrepr(version))
logging.basicConfig(format='%(levelname).1s: %(module)s:%(lineno)d: '
        log.info('cleaning directories: %s', args)
        log.info('cleaning package %s', options.package)
            log.info('magic tag(s) used by python%s. Nothing to remove.',
        log.info("removed files: %s", counter)
log = logging.getLogger(__name__)
        log.setLevel(logging.DEBUG)
        log.setLevel(logging.WARNING)
            magic_tag = False
            magic_tag = get_magic_tag_to_remove(getver(options.version))
    main()
    map_ = get_magic_tags_map(set(SUPPORTED).union(set([version])))
                           '%(message)s')
                    myremove(filename)
    next(d)  # initialize coroutine
# of this software and associated documentation files (the "Software"), to deal
    (options, args) = parser.parse_args()
        otherwise removes given magic tag from __pycache__ directory
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    :param magic_tag: if None, removes __pycache__ directories,
    parser.add_option('-p', '--package',
    parser.add_option('-q', '--quiet', action='store_false', dest='verbose',
    parser.add_option('-V', dest='version',
    parser.add_option('-v', '--verbose', action='store_true', dest='verbose',
        parser.error('only one action is allowed at the same time ('
    parser = optparse.OptionParser(usage, version='%prog 0.3')
        parser.print_usage()
                pass
# Permission is hereby granted, free of charge, to any person obtaining a copy
    process = Popen("/usr/bin/dpkg -L %s" % package_name,\
    py3clean -p python3-mako # all .py[co] files and __pycache__ directories from the package
    py3clean /usr/lib/python3.1/dist-packages # python3.1
    py3clean /usr/lib/python3/ # all Python 3.X
    py3clean -V 3.3 /usr/lib/foo/bar.py # bar/__pycache__/bar.cpython-33.py[co]
    py3clean -V 3.3 /usr/lib/python3/ # python 3.3 only
            pyfile = (yield)
        # remove 3.1's .pyc files only
        # remove all files in __pycache__ directory
            # remove "classic" .pyc files as well
    """Remove every .py[co] file associated to received .py file.
        remove(fname)
        # remove __pycache__ directory if it's empty
        # remove .pyc files for no longer needed magic tags
    """Returns magic tag or True if all of them should be removed."""
    return tag
                rmdir(directory)
                    shell=True, stdout=PIPE)
    # skip shared tags
    stdout, stderr = process.communicate()
    stdout = str(stdout, 'utf-8')
sys.path.insert(1, '/usr/share/python3/')
    tag = map_[version]
# The above copyright notice and this permission notice shall be included in
# THE SOFTWARE.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
"""TODO: move it to manpage
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                try:
            try:
    try:
    :type magic_tag: None or False or str"""
    usage = '%prog [-V VERSION] [-p PACKAGE | DIR_OR_FILE]'
#! /usr/bin/python3
# vim: et ts=4 sw=4
                    vrepr(v))
        while True:
                    yield filename
            yield item
                yield join(directory, fn)
                        yield join(root, fn)
                #    yield join(root, fn)
            yield line
