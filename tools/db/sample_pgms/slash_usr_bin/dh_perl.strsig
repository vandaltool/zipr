		# add perlapi-<ver> for XS modules
		addsubstvar($package, "perl:Depends",
		addsubstvar($package, "perl:Depends", $perl, $version)
a dependency on the correct base package. This is only necessary for some
all. B<perl-base> is Essential, so its dependency can be left out, unless a
and will use this information to generate a dependency on B<perl> or
B<dh_perl> also cleans up empty directories that MakeMaker can generate when
B<dh_perl> is a debhelper program that is responsible for generating
B<dh_perl> [S<I<debhelper options>>] [B<-d>] [S<I<library dirs> ...>]
B<perlapi>. The dependency will be substituted into your package's F<control>
Brendan O'Dea <bod@debian.org>
By default, scripts and architecture independent modules don't depend
	# Check also for alternate locations given on the command line
# Cleaning the paths given on the command line
		close F;
Debian policy, version 3.8.3
# dependency types
		$deps |= PM_MODULE if /\.pm$/;
			$deps |= PROGRAM;
		$deps |= XS_MODULE if /\.so$/;
dh_perl - calculates Perl dependencies and cleans up after MakeMaker
				"$dir");
directories by default.
directories, you can make B<dh_perl> check those directories by passing their
	}, @dirs if @dirs;
			doit("rmdir", "--ignore-fail-on-non-empty", "--parents",
		# essential
file wherever you place the token B<${perl:Depends}>.
	# find scripts
	find sub {
foreach (@ARGV) {
	foreach my $dir ("$tmp/usr/share/perl5", "$tmp/usr/lib/perl5") {
foreach my $package (@{$dh{DOPACKAGES}}) {
full B<perl> package. If so, you can pass the -d option to make B<dh_perl> generate
=head1 AUTHOR
=head1 CONFORMS TO
=head1 DESCRIPTION
=head1 NAME
=head1 OPTIONS
=head1 SEE ALSO
=head1 SYNOPSIS
		if (-d $dir) {
	if ($deps) {
			if $deps & XS_MODULE;
		if ($deps & XS_MODULE or $dh{V_FLAG_SET}) {
# If -d is given, then the dependency is on perl-base rather than perl.
		if (read F, local $_, 32 and m%^#!\s*(/usr/bin/perl|/usr/bin/env\s+perl)\s%) {
If your package installs Perl modules in non-standard
In some specific cases you may want to depend on B<perl-base> rather than the
installing Perl modules.
=item B<-d>
=item B<-V>
=item I<library dirs>
L<debhelper(7)>
		local *F;
	# Look for perl modules and check where they are installed
	# MakeMaker always makes lib and share dirs, but typically
	my $deps = 0;
	my @dirs = grep -d, map "$tmp/$_", $vendorlib, $vendorarch, @ARGV;
my $perl = 'perl';
	my $tmp=tmpdir($package);
my $vendorarch = substr $Config{vendorarch}, 1;
my $vendorlib = substr $Config{vendorlib}, 1;
		my $version="";
my $version;
names on the command line. It will only check the F<vendorlib> and F<vendorarch>
		# no need to depend on an un-versioned perl-base -- it's
Note that this flag may cause no dependency on B<perl-base> to be generated at
on any specific version of B<perl>. The B<-V> option causes the current
	# only one directory is installed into.
packages that are included in the base system.
			"perlapi-" . ($Config{debian_abi} || $Config{version}))
$perl .= '-base' if $dh{D_FLAG};
Perl policy, version 1.20
		return if $File::Find::dir=~/\/usr\/share\/doc\//;
		return unless -f;
		return unless -f and (-x or /\.pl$/);
		return unless open F, $_;
	s#^/##;
	s#/$##;
the B<${perl:Depends}> substitutions and adding them to substvars files.
The program will look at Perl scripts and modules in your package,
This program is a part of debhelper.
	}, $tmp;
			unless $perl eq 'perl-base' && ! length($version);
				unless $version;
use Config;
use constant PM_MODULE => 2;
use constant PROGRAM   => 1;
use constant XS_MODULE => 4;
use Debian::Debhelper::Dh_Lib;
use File::Find;
use strict;
#!/usr/bin/perl -w
			($version) = `dpkg -s $perl` =~ /^Version:\s*(\S+)/m
versioned dependency is needed.
version of the B<perl> (or B<perl-base> with B<-d>) package to be specified.
			$version = ">= $version";
