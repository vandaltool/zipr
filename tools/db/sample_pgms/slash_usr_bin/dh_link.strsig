acted on, not just the first.
an equal number of source and destination files specified.
a path as possible. It will also create any subdirectories it needs to to put
		# are recreated policy conformant.
B<dh_link> accepts a list of pairs of source and destination files. The source
B<dh_link> also scans the package build tree for existing symlinks which do not
B<dh_link> is a debhelper program that creates symlinks in package build
B<dh_link> [S<I<debhelper options>>] [B<-A>] [B<-X>I<item>] [S<I<source destination> ...>]
B<dh_link> will generate symlinks that comply with Debian policy - absolute
being corrected to comply with Debian policy.
Be sure you B<do> specify the full filename to both the source and
			# Build up the new src.
conform to Debian policy, and corrects them (v4 or later).
Create a file named I<destination> as a link to a file named I<source>. Do
Create any links specified by command line parameters in ALL packages
destination files are the symlinks that will be created. There B<must> be
destination files (unlike you would do if you were using something like
		$dest=~s:^/::;
dh_link - create symlinks in package build directories
 dh_link usr/share/man/man1/foo.1 usr/share/man/man1/bar.1
 dh_link var/lib/foo usr/lib/foo \
directories.
		# directory, it should be relative. If it's between
				$dir=~s/^\Q$tmp\E//;
	# doesn't, $#links will be _odd_ (not even, -- it's zero-based).
			doit("install","-d",$basedir);
		doit("ln","-sf", $src, "$tmp/$dest");
		doit("rm", "-f", "$tmp/$dest");
			# Do nothing
				# Do nothing
				else {
			else {
		else {
		elsif ($entry eq '..') {
		error("$file lists a link without a destination.");
			error("link destination $tmp/$dest is a directory");
		error("parameters list a link without a destination.");
Exclude symlinks that contain I<item> anywhere in their filename from
		    	# Figure out how much of a path $src and $dest
files are the already existing files that will be symlinked from. The
			for (1..$#dest_dirs - $x) {
	foreach $entry (@pathname) {
	foreach $entry (@respath) {
foreach my $package (@{$dh{DOPACKAGES}}) {
			for ($x=0; $x < @src_dirs && $src_dirs[$x] eq $dest_dirs[$x]; $x++) {}
			for ($x .. $#src_dirs) {
=head1 AUTHOR
=head1 DESCRIPTION
=head1 EXAMPLES
=head1 FILES
=head1 NAME
=head1 OPTIONS
=head1 SEE ALSO
=head1 SYNOPSIS
	if (! compat(3) && -e $tmp) {
	if (! defined $result) {
		if (-d "$tmp/$dest" && ! -l "$tmp/$dest") {
		if (! -e $basedir) {
		if ($entry eq '.' || $entry eq '') {
	if ($file) {
	if (int($#links/2) eq $#links/2) {
	if (($package eq $dh{FIRSTPACKAGE} || $dh{PARAMS_ALL}) && @ARGV) {
			if ($#respath == -1) {
		if (@src_dirs > 0 && $src_dirs[0] eq $dest_dirs[0]) {
		if ($src eq $dest) {
				if ($target=~/^\//) {
			if ($x > $#src_dirs && ! length $src) {
=item B<-A>, B<--all>
=item B<-X>I<item>, B<--exclude=>I<item>
=item debian/I<package>.links
=item I<source destination> ...
Joey Hess <joeyh@debian.org>
L<debhelper(7)>
		@links=filearray($file);
Lists pairs of source and destination files to be symlinked. Each pair
L<ln(1)>).
Make F<bar.1> be a symlink to F<foo.1>
Make F</usr/lib/foo/> be a link to F</var/lib/foo/>, and F<bar.1> be a symlink to
	# Make sure it has pairs of symlinks and destinations. If it
			# Make sure it's properly absolute.
		# Make sure the directory the link will be in exists.
		my $basedir=dirname("$tmp/$dest");
		my @dest_dirs=split(m:/+:,$dest);
		my $dest=pop @links;
				my $dir=$File::Find::dir;
	my $entry;
	my $file=pkgfile($package,"links");
	my @links;
	my @pathname = split(m:/+:,$start);
	my @respath;
	my $result;
		my @src_dirs=split(m:/+:,$src);
		my $src=expand_path(pop @links);
	my $start = @_ ? shift : '.';
				my $target = readlink($_);
	my $tmp=tmpdir($package);
			my $x;
			next;
(Or in all packages if B<-A> is specified.)
		# Policy says that if the link is all within one toplevel
				pop @respath;
		push @links, @ARGV;
				push @links, "$dir/$_";
					push @links, "$dir/$target";
					push @links, $target;
			push @respath, $entry;
# resolve symbolic links.
		$result .= '/' . $entry;
		$result="/"; # special case
				return if excludefile($_);
	return $result;
				return unless -l;
	# Same test as above, including arguments this time.
		# Scan for existing links and add them to @links, so they
			# share in common.
should be put on its own line, with the source and destination separated by
			$src="";
				$src.="../";
		$src=~s:^/::;
			$src=~s:/$::;
				$src.="."; # special case
			$src="/$src";
				$src.=$src_dirs[$_]."/";
			sub {
sub expand_path {
the F<foo.1>
the symlinks in.
# This expand_path expands all path "." and ".." components, but doesn't
this in the package build directory of the first package acted on.
This program is a part of debhelper.
			$tmp);
		# top level directories, leave it absolute.
use Debian::Debhelper::Dh_Lib;
use File::Find;
use strict;
#!/usr/bin/perl -w
   usr/share/man/man1/foo.1 usr/share/man/man1/bar.1
	# v4 or later and only if there is a temp dir already
			warning("skipping link from $src to self");
when policy says they should be absolute, and relative links with as short
	while (@links) {
whitespace.
