          $_ = "'$_'";
        ;
        }
#-------------------------------------------------------------------
###########################################################
    [2007/09/29 v1.4 Perl-free version of PerlTeX specific to $jobname.tex]
    \advance\plmac@macro@invocation@num by 1\relax
    alarm 0;
    alarm 1;
                 "Alternatively, you can selectively enable Perl features",
# and version 1.3c or later is part of all distributions of LaTeX
        autoflush PIPE 1;
    autoflush PIPE 1;
available.  These behave just like LaTeX's C<\newcommand> and
    awaitexists($toflag);
    awaitexists($toperl);
[B<-->[B<no>]B<safe>]
beautifully typeset documents but has a macro language that is
[B<--help>]
[B<--latex>=I<program>]
[B<--makesty>]
B<pdflatex> instead of ordinary B<latex>.
B<perltex> accepts the following command-line options:
B<perltex> executes the code from a C<\perlnewcommand> or
B<perltex> honors the following environment variables:
B<perltex>'s safety mechansisms with B<--nosafe>:
B<perltex>'s sandbox defaults to what L<Opcode> calls ``C<:browse>''.
B<perltex> with the B<--makesty> option.
[B<--permit>=I<feature>]
# By Scott Pakin <scott+pt@pakin.org>                     #
C<--latex>), including, for instance, the name of the F<.tex> file to
C<--latex=pdflatex> would typeset the given document using
Clearly, Perl's programmability could complement LaTeX's typesetting
    close DONEFLAG;
    close FROMFLAG;
    close FROMPERL;
    close LOGFILE;
        close PIPE;
    close PIPE;
        close STYFILE;
        close TOPERL;
compile.
# Copyright (C) 2009 Scott Pakin <scott+pt@pakin.org>
C<\perlnewcommand> and C<\perlrenewcommand> macros will be made
C<\perlrenewcommand> macro within a protected environment that
C<\renewcommand> except that the macro body contains Perl code instead
C<time> command:
defaults to ``C<latex>''.  The C<PERLTEX> environment variable
defined ($latexpid = fork) || die "fork: $!\n";
    delete_files($fromflag);
    delete_files($toflag, $toperl, $doneflag);
            delete_files($toperl, $fromperl, $toflag,
delete_files($toperl, $fromperl, $toflag, $fromflag, $doneflag, $pipe);
    die "exec('@latexcmdline'): $!\n";
        die "${progname}: Internal error -- unexpected operation tag \"$optag\"\n";
difficult to program.  In particular, support for complex string
Display basic usage information.
document includes a C<\usepackage{perltex}> in its preamble, then
document's C<\usepackage{perltex}> line with C<\usepackage{noperltex}>
document suitable for distribution to people who do not have PerlTeX
$doneflag = $jobname . ".dfpl";
        else {
    else {
    elsif ($optag eq "RUN") {
    elsif ($optag eq "USE") {
Enable or disable sandboxing.  With the default of B<--safe>,
enables finer-grained control over the B<perltex> sandbox.  See
    \endgroup
        $entirefile = <TOPERL>;
    exec {$latexcmdline[0]} @latexcmdline;
            exit 0;
    exit 0;
        exit 1;
external programs.  Specifying B<--nosafe> gives the LaTeX document
file generated by F<noperltex.sty> for each PerlTeX macro invocation
``flag'' file whose existence indicates that F<jobname.ffpl> has been
``flag'' file whose existence indicates that F<jobname.frpl> contains
``flag'' file whose existence indicates that F<jobname.topl> contains
foreach (1 .. 20) {
        foreach my $e (0 .. $#macroexpansions) {
    foreach my $filename (@_) {
      foreach (@otherstuff) {
for ($firstcmd=0; $firstcmd<=$#latexcmdline; $firstcmd++) {
                         $fromflag, $doneflag, $pipe);
$fromflag = $jobname . ".ffpl";
$fromperl = $jobname . ".frpl";
\gdef\plmac@show@placeholder#1#2\@empty{%
Generate a LaTeX style file called F<noperltex.sty>.  Replacing the
# generated with the docstrip utility.
GetOptions("help"       => sub {pod2usage(-verbose => 1)},
Getopt::Long::Configure("require_order", "pass_through");
    \global\plmac@macro@invocation@num=\plmac@macro@invocation@num
has no typesetting capabilities whatsoever.
=head1 AUTHOR
=head1 DESCRIPTION
=head1 ENVIRONMENT
=head1 EXAMPLES
=head1 FILES
=head1 NAME
=head1 NOTES
=head1 OPTIONS
=head1 SEE ALSO
=head1 SYNOPSIS
            @helpstring =
        $helpstring =~ s/\.  /.\\space\\space /g;
#    http://www.latex-project.org/lppl.txt
I<carte blanche> to execute any arbitrary Perl code, including that
    if ($@) {
    if (defined $latexpid) {
    if (defined $styfile) {
if (defined $styfile) {
        if (defined $warningmsg) {
If LaTeX gives a ``C<trapped by operation mask>'' error and you trust
if (!$latexpid) {
        if ($msg =~ /\btrapped by\b/) {
    if (open (PIPE, ">$pipe")) {
    if ($optag eq "DEF") {
    if ($optag eq "USE") {
if ($runsafely) {
    if (substr ($option, 0, 1) ne "\\") {
if (!$usepipe || !eval {mkfifo($pipe, 0600)}) {
        if (waitpid($latexpid, &WNOHANG)==-1) {
  \ifx#1U\relax
[I<latex options>]
information sent from LaTeX to Perl
information sent from Perl to LaTeX
In its simplest form, B<perltex> is run just like B<latex>:
    \input{noperltex-\the\plmac@macro@invocation@num.tex}%
installed.  The disadvantage is that F<noperltex.sty> is specific to
=item B<-->[B<no>]B<safe>
=item B<--help>
=item B<--latex>=I<program>
=item B<--makesty>
=item B<--permit>=I<feature>
=item F<jobname.dfpl>
=item F<jobname.ffpl>
=item F<jobname.frpl>
=item F<jobname.lgpl>
=item F<jobname.tfpl>
=item F<jobname.topl>
=item F<noperltex-#.tex>
=item PERLTEX
        $jobname = basename $option, ".tex" ;
        kill (9, $latexpid);
    last;
latex(1), pdflatex(1), perl(1), Safe(3pm), Opcode(3pm)
@latexcmdline = @ARGV;
    $latexcmdline[$firstcmd];
$latexcmdline[$firstcmd] =
        $latexcmdline[$firstcmd] = "\\input $option";
$latexprog = $ENV{"PERLTEX"} || "latex";
           "latex=s"    => \$latexprog,
LaTeX -- through the underlying TeX typesetting system -- produces
\let\noperltex@PackageError=\PackageError
\let\PackageError=\noperltex@PackageError
# license or (at your option) any later version.  The latest
        local $SIG{__WARN__} =
        local $/ = undef;
$logfile = $jobname . ".lgpl";
log file written by Perl; helpful for debugging Perl macros
L<Opcode> for more information.
L</OPTIONS>) overrides that.
macro definitions or macro invocations necessitates rerunning
    $macroname = "latex_" . $macroname;
            $macroname, $otherstuff[0];
    $macroname =~ s/^[^A-Za-z]+//;
    $macroname =~ s/\W/_/g;
           "makesty"    => sub {$styfile = "noperltex.sty"},
manipulation is largely lacking.  Perl is a popular general-purpose
        map {chomp; $_} split "$separator\n", $entirefile;
        $msg =~ s/at \(eval \d+\) line \d+\W+//;
        $msg =~ s/\s+/ /;
my $doneflag;
    my $entirefile;
my $firstcmd = 0;
my $fromflag;
my $fromperl;
        my @helpstring;
        my $helpstring = join ("\\MessageBreak\n", @helpstring);
my $jobname = "texput";
my @latexcmdline;
my $latexpid;
my $latexprog;
my $logfile;
my @macroexpansions;
        my $msg = $@;
    my ($optag, $macroname, @otherstuff) =
    my $option = $latexcmdline[$firstcmd];
    my $perlcode;
my @permittedops;
my $pipe;
my $pipestring = "\%\%\%\%\% Generated by $progname\n\\endinput\n";
my $progname = basename $0;
    my $result;
my $runsafely = 1;
my $sandbox_eval;
my $sandbox = new Safe;
my $separator = "";
my $styfile;
my $toflag;
my $toperl;
my $usepipe = 1;
        my $warningmsg;
\\NeedsTeXFormat{LaTeX2e}[1999/12/01]
\newcount\plmac@macro@invocation@num
    next if substr($option, 0, 1) eq "-";
of LaTeX code.
# of the LaTeX Project Public License, either version 1.3c of this
    open (DONEFLAG, ">$doneflag") || die "open($doneflag): $!\n";
    open (FROMFLAG, ">$fromflag") || die "open($fromflag): $!\n";
    open (FROMPERL, ">$fromperl") || die "open($fromperl): $!\n";
open (LOGFILE, ">$logfile") || die "open(\"$logfile\"): $!\n";
    open (STYFILE, ">$styfile") || die "open(\"$styfile\"): $!\n";
        open (TOPERL, "<$toperl") || die "open($toperl): $!\n";
                 "option to allow arbitrary Perl code to execute.",
option, which can be specified more than once on the command line,
               "out in your document and re-run perltex.");
overrides this default, and the B<--latex> command-line option (see
passed to B<latex> (or whatever program was specified with
        $perlcode =
Perl code (e.g., because you wrote it yourself), you can disable
        $perlcode = $otherstuff[0];
        $perlcode = sprintf "%s (%s);\n", $macroname, join(", ", @otherstuff);
# perltex.dtx  (with options: `perltex')
perltex - enable LaTeX macros to be defined in terms of Perl code
    perltex --latex=pdflatex myfile.tex
    perltex myfile.tex
    perltex --nosafe myfile.tex
    perltex --permit=:browse --permit=:filesys_open
permissions (C<:browse>) plus the ability to open files and invoke the
Permit particular Perl operations to be performed.  The B<--permit>
           "permit=s"   => \@permittedops) || pod2usage(2);
    @permittedops=(":browse") if $#permittedops==-1;
      --permit=time myfile.tex
$pipe = $jobname . ".pipe";
           "pipe!"      => \$usepipe,
    '\plmac@doneflag', $doneflag,
    '\plmac@fromfile', $fromperl,
    '\plmac@fromflag', $fromflag,
    '\plmac@pipe', $pipe,
    '\plmac@tag', $separator,
    '\plmac@tofile', $toperl,
    '\plmac@toflag', $toflag,
# Prepare a LaTeX run for two-way communication with Perl #
                printf STYFILE "\\begin{filecontents}{noperltex-%d.tex}\n", 1+$e;
            printf STYFILE "%% Invocation #%d\n", 1+$e;
    print LOGFILE $perlcode, "\n";
    print LOGFILE $result, "\n\n";
            print LOGFILE "# ===> $warningmsg\n\n";
    print LOGFILE "%" x 30, " LATEX RESULT ", "%" x 30, "\n";
    print LOGFILE "#" x 31, " PERL CODE ", "#" x 32, "\n";
        print PIPE $pipestring;
    print PIPE $pipestring;
            print STYFILE "\\end{filecontents}\n";
        print STYFILE "\\endinput\n";
            print STYFILE $macroexpansions[$e], "\\endinput\n";
            print STYFILE "\n";
        print STYFILE <<"STYFILEHEADER1";
        print STYFILE <<'STYFILEHEADER2';
produces the same output but does not require PerlTeX, making the
programming language whose forte is string manipulation.  However, it
prohibits ``unsafe'' operations such as accessing files or executing
\\ProvidesPackage{noperltex}
push @latexcmdline, "" if $#latexcmdline==-1;
    push @macroexpansions, $result if defined $styfile && $optag eq "USE";
\renewcommand{\PackageError}[3]{}
\RequirePackage{filecontents}
\RequirePackage{perltex}
    $result .= '\endinput';
        $result .= "{$helpstring}";
    $result = "" if !$result || $optag eq "RUN";
        $result = "\\PackageError{perltex}{$msg}";
        $result = $sandbox_eval->($perlcode);
    return eval $_[0];
           "safe!"      => \$runsafely,
    $sandbox_eval = sub {$sandbox->reval($_[0])};
    $sandbox_eval = \&top_level_eval;
    $sandbox->permit_only (@permittedops);
Scott Pakin, I<scott+pt@pakin.org>
    $separator .= chr(ord("A") + rand(26));
          s/\'/\\\'/g;
          s/\\/\\\\/g;
$SIG{"ALRM"} = sub {
$SIG{"PIPE"} = "IGNORE";
            sleep 0;
        sleep 0;
Specify a program to use instead of B<latex>.  For example,
Specify the filename of the LaTeX compiler.  The LaTeX compiler
    sprintf '\makeatletter' . '\def%s{%s}' x 7 . '\makeatother%s',
            sprintf "sub %s {%s}\n",
strengths.  B<perltex> is the tool that enables a symbiosis between
STYFILEHEADER1
STYFILEHEADER2
sub awaitexists ($)
            sub {chomp ($warningmsg=$_[0]); return 0};
sub delete_files (@)
sub top_level_eval ($)
           "synctext=s" => \$pipestring,
    sysopen PIPE, $pipe, O_WRONLY|O_CREAT, 0755;
    syswrite FROMPERL, $result;
the document that produced it.  Any changes to the document's PerlTeX
The following command gives documents only B<perltex>'s default
the F<.tex> file you're trying to compile not to execute malicious
# The original source files were:
                 "the Perl code you tried to execute attempted to perform an",
                ("The preceding error message comes from Perl.  Apparently,",
              ("The preceding error message comes from Perl.  Apparently,",
               "there's a bug in your Perl code.  You'll need to sort that",
These options are then followed by whatever options are normally
the two systems.  All a user needs to do is compile a LaTeX document
# This file may be distributed and/or modified under the conditions
# This is a generated file.
# This is file `perltex.pl',
$toflag = $jobname . ".tfpl";
$toperl = $jobname . ".topl";
To use B<pdflatex> instead of regular B<latex>, use the B<--latex>
                 "trust the Perl code, however; malicious Perl code can do a",
    undef $_;
            undef $latexpid;
    undef $latexpid;
            unlink $filename;
        unlink $filename;
                 "`unsafe' operation.  If you trust the Perl code (e.g., if",
unshift @latexcmdline, $latexprog;
use Fcntl;
use File::Basename;
use Getopt::Long;
use IO::Handle;
use Opcode;
    $usepipe = 0;
use Pod::Usage;
use POSIX;
use Safe;
use strict;
use warnings;
using B<perltex> instead of B<latex>.  (B<perltex> is actually a
                 "using perltex's --permit option.  Don't do this if you don't",
#! /usr/bin/env perl
valid data
# version 2006/05/20 or later.
# version of this license is in:
            $warningmsg =~ s/at \(eval \d+\) line \d+\W+//;
which can harm the user's files.  See L<Safe> for more information.
while (1) {
While compiling F<jobname.tex>, B<perltex> makes use of the following
    while (!-e $_[0]) {
        while (-e $filename) {
                 "world of harm to your computer system.");
wrapper for B<latex>, so no B<latex> functionality is lost.)  If the
                 "you wrote it) then you can invoke perltex with the --nosafe",
